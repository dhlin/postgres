<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/datetime.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/datetime.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L262">abbrevcache</a></li>
<li><a href="#L258">datecache</a></li>
<li><a href="#L105">datetktbl</a></li>
<li><a href="#L75">day_tab</a></li>
<li><a href="#L84">days</a></li>
<li><a href="#L260">deltacache</a></li>
<li><a href="#L187">deltatktbl</a></li>
<li><a href="#L81">months</a></li>
<li><a href="#L181">szdatetktbl</a></li>
<li><a href="#L252">szdeltatktbl</a></li>
<li><a href="#L254">zoneabbrevtbl</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L4502">AddISO8601IntPart</a></li>
<li><a href="#L4512">AddPostgresIntPart</a></li>
<li><a href="#L4535">AddVerboseIntPart</a></li>
<li><a href="#L633">AdjustDays</a></li>
<li><a href="#L569">AdjustFractDays</a></li>
<li><a href="#L537">AdjustFractMicroseconds</a></li>
<li><a href="#L601">AdjustFractYears</a></li>
<li><a href="#L618">AdjustMicroseconds</a></li>
<li><a href="#L649">AdjustMonths</a></li>
<li><a href="#L661">AdjustYears</a></li>
<li><a href="#L448">AppendSeconds</a></li>
<li><a href="#L511">AppendTimestampSeconds</a></li>
<li><a href="#L4768">CheckDateTokenTable</a></li>
<li><a href="#L4800">CheckDateTokenTables</a></li>
<li><a href="#L3329">ClearPgItmIn</a></li>
<li><a href="#L4862">ConvertTimeZoneAbbrevs</a></li>
<li><a href="#L4081">DateTimeParseError</a></li>
<li><a href="#L2387">DecodeDate</a></li>
<li><a href="#L978">DecodeDateTime</a></li>
<li><a href="#L3818">DecodeISO8601Interval</a></li>
<li><a href="#L3353">DecodeInterval</a></li>
<li><a href="#L2716">DecodeNumber</a></li>
<li><a href="#L2901">DecodeNumberField</a></li>
<li><a href="#L3137">DecodeSpecial</a></li>
<li><a href="#L2661">DecodeTime</a></li>
<li><a href="#L2579">DecodeTimeCommon</a></li>
<li><a href="#L2690">DecodeTimeForInterval</a></li>
<li><a href="#L1864">DecodeTimeOnly</a></li>
<li><a href="#L2996">DecodeTimezone</a></li>
<li><a href="#L3080">DecodeTimezoneAbbrev</a></li>
<li><a href="#L3262">DecodeTimezoneAbbrevPrefix</a></li>
<li><a href="#L3179">DecodeTimezoneName</a></li>
<li><a href="#L3234">DecodeTimezoneNameToTz</a></li>
<li><a href="#L4036">DecodeUnits</a></li>
<li><a href="#L1746">DetermineTimeZoneAbbrevOffset</a></li>
<li><a href="#L1821">DetermineTimeZoneAbbrevOffsetInternal</a></li>
<li><a href="#L1784">DetermineTimeZoneAbbrevOffsetTS</a></li>
<li><a href="#L1585">DetermineTimeZoneOffset</a></li>
<li><a href="#L1607">DetermineTimeZoneOffsetInternal</a></li>
<li><a href="#L4216">EncodeDateOnly</a></li>
<li><a href="#L4331">EncodeDateTime</a></li>
<li><a href="#L4574">EncodeInterval</a></li>
<li><a href="#L4301">EncodeTimeOnly</a></li>
<li><a href="#L4178">EncodeTimezone</a></li>
<li><a href="#L4959">FetchDynamicTimeZone</a></li>
<li><a href="#L366">GetCurrentDateTime</a></li>
<li><a href="#L387">GetCurrentTimeUsec</a></li>
<li><a href="#L3791">ISO8601IntegerWidth</a></li>
<li><a href="#L4946">InstallTimeZoneAbbrevs</a></li>
<li><a href="#L754">ParseDateTime</a></li>
<li><a href="#L680">ParseFraction</a></li>
<li><a href="#L709">ParseFractionalSecond</a></li>
<li><a href="#L3749">ParseISO8601Number</a></li>
<li><a href="#L4829">TemporalSimplify</a></li>
<li><a href="#L2497">ValidateDate</a></li>
<li><a href="#L286">date2j</a></li>
<li><a href="#L4142">datebsearch</a></li>
<li><a href="#L522">int64_multiply_add</a></li>
<li><a href="#L311">j2date</a></li>
<li><a href="#L344">j2day</a></li>
<li><a href="#L4990">pg_timezone_abbrevs</a></li>
<li><a href="#L5111">pg_timezone_names</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L768">APPEND_CHAR</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * datetime.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for date/time types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/datetime.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/string.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/scansup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/date.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datetime.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/tzparser.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2716" title="utils/adt/datetime.c:2716">DecodeNumber</a>(<span class="Type">int</span> flen, <span class="Type">char</span> *str, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> haveTextMonth,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> fmask, <span class="Type">int</span> *tmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> pg_tm *tm, fsec_t *fsec, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *is2digits);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2901" title="utils/adt/datetime.c:2901">DecodeNumberField</a>(<span class="Type">int</span> len, <span class="Type">char</span> *str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> fmask, <span class="Type">int</span> *tmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm *tm, fsec_t *fsec, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *is2digits);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2579" title="utils/adt/datetime.c:2579">DecodeTimeCommon</a>(<span class="Type">char</span> *str, <span class="Type">int</span> fmask, <span class="Type">int</span> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *tmask, <span class="Type">struct</span> pg_itm *itm);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2661" title="utils/adt/datetime.c:2661">DecodeTime</a>(<span class="Type">char</span> *str, <span class="Type">int</span> fmask, <span class="Type">int</span> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *tmask, <span class="Type">struct</span> pg_tm *tm, fsec_t *fsec);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2690" title="utils/adt/datetime.c:2690">DecodeTimeForInterval</a>(<span class="Type">char</span> *str, <span class="Type">int</span> fmask, <span class="Type">int</span> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *tmask, <span class="Type">struct</span> pg_itm_in *itm_in);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> datetkn *<a href="#L4142" title="utils/adt/datetime.c:4142">datebsearch</a>(<span class="Type">const</span> <span class="Type">char</span> *key, <span class="Type">const</span> datetkn *base, <span class="Type">int</span> nel);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2387" title="utils/adt/datetime.c:2387">DecodeDate</a>(<span class="Type">char</span> *str, <span class="Type">int</span> fmask, <span class="Type">int</span> *tmask, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *is2digits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> pg_tm *tm);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L448" title="utils/adt/datetime.c:448">AppendSeconds</a>(<span class="Type">char</span> *cp, <span class="Type">int</span> sec, fsec_t fsec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> precision, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fillzeros);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L522" title="utils/adt/datetime.c:522">int64_multiply_add</a>(int64 val, int64 multiplier, int64 *sum);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L537" title="utils/adt/datetime.c:537">AdjustFractMicroseconds</a>(<span class="Type">double</span> frac, int64 scale,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_itm_in *itm_in);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L569" title="utils/adt/datetime.c:569">AdjustFractDays</a>(<span class="Type">double</span> frac, <span class="Type">int</span> scale,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_itm_in *itm_in);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L601" title="utils/adt/datetime.c:601">AdjustFractYears</a>(<span class="Type">double</span> frac, <span class="Type">int</span> scale,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> pg_itm_in *itm_in);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L618" title="utils/adt/datetime.c:618">AdjustMicroseconds</a>(int64 val, <span class="Type">double</span> fval, int64 scale,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> pg_itm_in *itm_in);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L633" title="utils/adt/datetime.c:633">AdjustDays</a>(int64 val, <span class="Type">int</span> scale,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> pg_itm_in *itm_in);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L649" title="utils/adt/datetime.c:649">AdjustMonths</a>(int64 val, <span class="Type">struct</span> pg_itm_in *itm_in);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L661" title="utils/adt/datetime.c:661">AdjustYears</a>(int64 val, <span class="Type">int</span> scale,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_itm_in *itm_in);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1607" title="utils/adt/datetime.c:1607">DetermineTimeZoneOffsetInternal</a>(<span class="Type">struct</span> pg_tm *tm, pg_tz *tzp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_time_t *tp);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1821" title="utils/adt/datetime.c:1821">DetermineTimeZoneAbbrevOffsetInternal</a>(pg_time_t t,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *abbr, pg_tz *tzp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *offset, <span class="Type">int</span> *isdst);<br/></li>
<li><span class="Type">static</span> pg_tz *<a href="#L4959" title="utils/adt/datetime.c:4959">FetchDynamicTimeZone</a>(TimeZoneAbbrevTable *tbl, <span class="Type">const</span> datetkn *tp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DateTimeErrorExtra *extra);<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L75">&#x200c;</a><span class="Type">const</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">day_tab</span>[<span class="Constant">2</span>][<span class="Constant">13</span>] =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">31</span>, <span class="Constant">28</span>, <span class="Constant">31</span>, <span class="Constant">30</span>, <span class="Constant">31</span>, <span class="Constant">30</span>, <span class="Constant">31</span>, <span class="Constant">31</span>, <span class="Constant">30</span>, <span class="Constant">31</span>, <span class="Constant">30</span>, <span class="Constant">31</span>, <span class="Constant">0</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">31</span>, <span class="Constant">29</span>, <span class="Constant">31</span>, <span class="Constant">30</span>, <span class="Constant">31</span>, <span class="Constant">30</span>, <span class="Constant">31</span>, <span class="Constant">31</span>, <span class="Constant">30</span>, <span class="Constant">31</span>, <span class="Constant">30</span>, <span class="Constant">31</span>, <span class="Constant">0</span>}<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L81">&#x200c;</a><span class="Type">const</span> <span class="Type">char</span> *<span class="Type">const</span> <span class="linkable">months</span>[] = {<span class="Constant">&quot;Jan&quot;</span>, <span class="Constant">&quot;Feb&quot;</span>, <span class="Constant">&quot;Mar&quot;</span>, <span class="Constant">&quot;Apr&quot;</span>, <span class="Constant">&quot;May&quot;</span>, <span class="Constant">&quot;Jun&quot;</span>,<br/></li>
<li><span class="Constant">&quot;Jul&quot;</span>, <span class="Constant">&quot;Aug&quot;</span>, <span class="Constant">&quot;Sep&quot;</span>, <span class="Constant">&quot;Oct&quot;</span>, <span class="Constant">&quot;Nov&quot;</span>, <span class="Constant">&quot;Dec&quot;</span>, <span class="Constant">NULL</span>};<br/></li>
<li><br/></li>
<li><a id="L84">&#x200c;</a><span class="Type">const</span> <span class="Type">char</span> *<span class="Type">const</span> <span class="linkable">days</span>[] = {<span class="Constant">&quot;Sunday&quot;</span>, <span class="Constant">&quot;Monday&quot;</span>, <span class="Constant">&quot;Tuesday&quot;</span>, <span class="Constant">&quot;Wednesday&quot;</span>,<br/></li>
<li><span class="Constant">&quot;Thursday&quot;</span>, <span class="Constant">&quot;Friday&quot;</span>, <span class="Constant">&quot;Saturday&quot;</span>, <span class="Constant">NULL</span>};<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; PRIVATE ROUTINES&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L105" title="utils/adt/datetime.c:105">datetktbl</a> holds date/time keywords.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this table must be strictly alphabetically ordered to allow an<br/></li>
<li></span><span class="Comment"> * O(ln(N)) search algorithm to be used.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The token field must be NUL-terminated; we truncate entries to TOKMAXLEN<br/></li>
<li></span><span class="Comment"> * characters to fit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The static table contains no TZ, DTZ, or DYNTZ entries; rather those<br/></li>
<li></span><span class="Comment"> * are loaded from configuration files and stored in <a href="#L254" title="utils/adt/datetime.c:254">zoneabbrevtbl</a>, whose<br/></li>
<li></span><span class="Comment"> * abbrevs[] field has the same format as the static <a href="#L105" title="utils/adt/datetime.c:105">datetktbl</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L105">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> datetkn <span class="linkable">datetktbl</span>[] = {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* token, type, value */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;+infinity&quot;</span>, RESERV, DTK_LATE},&nbsp; &nbsp; <span class="Comment">/* same as &quot;infinity&quot; */<br/></li>
<li></span>&nbsp; &nbsp; {EARLY, RESERV, DTK_EARLY}, <span class="Comment">/* &quot;-infinity&quot; reserved for &quot;early time&quot; */<br/></li>
<li></span>&nbsp; &nbsp; {DA_D, ADBC, AD},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;ad&quot; for years &gt; 0 */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;allballs&quot;</span>, RESERV, DTK_ZULU}, <span class="Comment">/* 00:00:00 */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;am&quot;</span>, AMPM, AM},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;apr&quot;</span>, MONTH, <span class="Constant">4</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;april&quot;</span>, MONTH, <span class="Constant">4</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;at&quot;</span>, IGNORE_DTF, <span class="Constant">0</span>},&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;at&quot; (throwaway) */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;aug&quot;</span>, MONTH, <span class="Constant">8</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;august&quot;</span>, MONTH, <span class="Constant">8</span>},<br/></li>
<li>&nbsp; &nbsp; {DB_C, ADBC, BC},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;bc&quot; for years &lt;= 0 */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;d&quot;</span>, UNITS, DTK_DAY},&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;day of month&quot; for ISO input */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;dec&quot;</span>, MONTH, <span class="Constant">12</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;december&quot;</span>, MONTH, <span class="Constant">12</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;dow&quot;</span>, UNITS, DTK_DOW},&nbsp; &nbsp; <span class="Comment">/* day of week */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;doy&quot;</span>, UNITS, DTK_DOY},&nbsp; &nbsp; <span class="Comment">/* day of year */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;dst&quot;</span>, DTZMOD, SECS_PER_HOUR},<br/></li>
<li>&nbsp; &nbsp; {EPOCH, RESERV, DTK_EPOCH}, <span class="Comment">/* &quot;epoch&quot; reserved for system epoch time */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;feb&quot;</span>, MONTH, <span class="Constant">2</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;february&quot;</span>, MONTH, <span class="Constant">2</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;fri&quot;</span>, DOW, <span class="Constant">5</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;friday&quot;</span>, DOW, <span class="Constant">5</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;h&quot;</span>, UNITS, DTK_HOUR},&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;hour&quot; */<br/></li>
<li></span>&nbsp; &nbsp; {LATE, RESERV, DTK_LATE},&nbsp; &nbsp; <span class="Comment">/* &quot;infinity&quot; reserved for &quot;late time&quot; */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;isodow&quot;</span>, UNITS, DTK_ISODOW},&nbsp; &nbsp; <span class="Comment">/* ISO day of week, Sunday == 7 */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;isoyear&quot;</span>, UNITS, DTK_ISOYEAR},&nbsp; &nbsp; <span class="Comment">/* year in terms of the ISO week date */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;j&quot;</span>, UNITS, DTK_JULIAN},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;jan&quot;</span>, MONTH, <span class="Constant">1</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;january&quot;</span>, MONTH, <span class="Constant">1</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;jd&quot;</span>, UNITS, DTK_JULIAN},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;jul&quot;</span>, MONTH, <span class="Constant">7</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;julian&quot;</span>, UNITS, DTK_JULIAN},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;july&quot;</span>, MONTH, <span class="Constant">7</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;jun&quot;</span>, MONTH, <span class="Constant">6</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;june&quot;</span>, MONTH, <span class="Constant">6</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;m&quot;</span>, UNITS, DTK_MONTH},&nbsp; &nbsp; <span class="Comment">/* &quot;month&quot; for ISO input */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;mar&quot;</span>, MONTH, <span class="Constant">3</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;march&quot;</span>, MONTH, <span class="Constant">3</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;may&quot;</span>, MONTH, <span class="Constant">5</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;mm&quot;</span>, UNITS, DTK_MINUTE},&nbsp; &nbsp; <span class="Comment">/* &quot;minute&quot; for ISO input */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;mon&quot;</span>, DOW, <span class="Constant">1</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;monday&quot;</span>, DOW, <span class="Constant">1</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;nov&quot;</span>, MONTH, <span class="Constant">11</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;november&quot;</span>, MONTH, <span class="Constant">11</span>},<br/></li>
<li>&nbsp; &nbsp; {NOW, RESERV, DTK_NOW},&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current transaction time */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;oct&quot;</span>, MONTH, <span class="Constant">10</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;october&quot;</span>, MONTH, <span class="Constant">10</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;on&quot;</span>, IGNORE_DTF, <span class="Constant">0</span>},&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;on&quot; (throwaway) */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;pm&quot;</span>, AMPM, PM},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;s&quot;</span>, UNITS, DTK_SECOND},&nbsp; &nbsp; <span class="Comment">/* &quot;seconds&quot; for ISO input */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;sat&quot;</span>, DOW, <span class="Constant">6</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;saturday&quot;</span>, DOW, <span class="Constant">6</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;sep&quot;</span>, MONTH, <span class="Constant">9</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;sept&quot;</span>, MONTH, <span class="Constant">9</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;september&quot;</span>, MONTH, <span class="Constant">9</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;sun&quot;</span>, DOW, <span class="Constant">0</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;sunday&quot;</span>, DOW, <span class="Constant">0</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;t&quot;</span>, ISOTIME, DTK_TIME},&nbsp; &nbsp; <span class="Comment">/* Filler for ISO time fields */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;thu&quot;</span>, DOW, <span class="Constant">4</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;thur&quot;</span>, DOW, <span class="Constant">4</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;thurs&quot;</span>, DOW, <span class="Constant">4</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;thursday&quot;</span>, DOW, <span class="Constant">4</span>},<br/></li>
<li>&nbsp; &nbsp; {TODAY, RESERV, DTK_TODAY}, <span class="Comment">/* midnight */<br/></li>
<li></span>&nbsp; &nbsp; {TOMORROW, RESERV, DTK_TOMORROW},&nbsp; &nbsp; <span class="Comment">/* tomorrow midnight */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;tue&quot;</span>, DOW, <span class="Constant">2</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;tues&quot;</span>, DOW, <span class="Constant">2</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;tuesday&quot;</span>, DOW, <span class="Constant">2</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;wed&quot;</span>, DOW, <span class="Constant">3</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;wednesday&quot;</span>, DOW, <span class="Constant">3</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;weds&quot;</span>, DOW, <span class="Constant">3</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;y&quot;</span>, UNITS, DTK_YEAR},&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;year&quot; for ISO input */<br/></li>
<li></span>&nbsp; &nbsp; {YESTERDAY, RESERV, DTK_YESTERDAY}&nbsp; &nbsp; <span class="Comment">/* yesterday midnight */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><a id="L181">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <span class="Type">int</span> <span class="linkable">szdatetktbl</span> = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span> <a href="#L105" title="utils/adt/datetime.c:105">datetktbl</a> / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span> <a href="#L105" title="utils/adt/datetime.c:105">datetktbl</a>[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L187" title="utils/adt/datetime.c:187">deltatktbl</a>: same format as <a href="#L105" title="utils/adt/datetime.c:105">datetktbl</a>, but holds keywords used to represent<br/></li>
<li></span><span class="Comment"> * time units (eg, for intervals, and for EXTRACT).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L187">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> datetkn <span class="linkable">deltatktbl</span>[] = {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* token, type, value */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;@&quot;</span>, IGNORE_DTF, <span class="Constant">0</span>},&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* postgres relative prefix */<br/></li>
<li></span>&nbsp; &nbsp; {DAGO, AGO, <span class="Constant">0</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;ago&quot; indicates negative time offset */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;c&quot;</span>, UNITS, DTK_CENTURY},&nbsp; &nbsp; <span class="Comment">/* &quot;century&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;cent&quot;</span>, UNITS, DTK_CENTURY},&nbsp; &nbsp; <span class="Comment">/* &quot;century&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;centuries&quot;</span>, UNITS, DTK_CENTURY},&nbsp; &nbsp; <span class="Comment">/* &quot;centuries&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {DCENTURY, UNITS, DTK_CENTURY}, <span class="Comment">/* &quot;century&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;d&quot;</span>, UNITS, DTK_DAY},&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;day&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {DDAY, UNITS, DTK_DAY},&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;day&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;<a href="#L84" title="utils/adt/datetime.c:84">days</a>&quot;</span>, UNITS, DTK_DAY},&nbsp; &nbsp; <span class="Comment">/* &quot;<a href="#L84" title="utils/adt/datetime.c:84">days</a>&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;dec&quot;</span>, UNITS, DTK_DECADE}, <span class="Comment">/* &quot;decade&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {DDECADE, UNITS, DTK_DECADE},&nbsp; &nbsp; <span class="Comment">/* &quot;decade&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;decades&quot;</span>, UNITS, DTK_DECADE}, <span class="Comment">/* &quot;decades&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;decs&quot;</span>, UNITS, DTK_DECADE},&nbsp; &nbsp; <span class="Comment">/* &quot;decades&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;h&quot;</span>, UNITS, DTK_HOUR},&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;hour&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {DHOUR, UNITS, DTK_HOUR},&nbsp; &nbsp; <span class="Comment">/* &quot;hour&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;hours&quot;</span>, UNITS, DTK_HOUR}, <span class="Comment">/* &quot;hours&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;hr&quot;</span>, UNITS, DTK_HOUR},&nbsp; &nbsp; <span class="Comment">/* &quot;hour&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;hrs&quot;</span>, UNITS, DTK_HOUR},&nbsp; &nbsp; <span class="Comment">/* &quot;hours&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;m&quot;</span>, UNITS, DTK_MINUTE},&nbsp; &nbsp; <span class="Comment">/* &quot;minute&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;microsecon&quot;</span>, UNITS, DTK_MICROSEC},&nbsp; &nbsp; <span class="Comment">/* &quot;microsecond&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;mil&quot;</span>, UNITS, DTK_MILLENNIUM}, <span class="Comment">/* &quot;millennium&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;millennia&quot;</span>, UNITS, DTK_MILLENNIUM},&nbsp; &nbsp; <span class="Comment">/* &quot;millennia&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {DMILLENNIUM, UNITS, DTK_MILLENNIUM},&nbsp; &nbsp; <span class="Comment">/* &quot;millennium&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;millisecon&quot;</span>, UNITS, DTK_MILLISEC},&nbsp; &nbsp; <span class="Comment">/* relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;mils&quot;</span>, UNITS, DTK_MILLENNIUM},&nbsp; &nbsp; <span class="Comment">/* &quot;millennia&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;min&quot;</span>, UNITS, DTK_MINUTE}, <span class="Comment">/* &quot;minute&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;mins&quot;</span>, UNITS, DTK_MINUTE},&nbsp; &nbsp; <span class="Comment">/* &quot;minutes&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {DMINUTE, UNITS, DTK_MINUTE},&nbsp; &nbsp; <span class="Comment">/* &quot;minute&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;minutes&quot;</span>, UNITS, DTK_MINUTE}, <span class="Comment">/* &quot;minutes&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;mon&quot;</span>, UNITS, DTK_MONTH},&nbsp; &nbsp; <span class="Comment">/* &quot;<a href="#L81" title="utils/adt/datetime.c:81">months</a>&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;mons&quot;</span>, UNITS, DTK_MONTH}, <span class="Comment">/* &quot;<a href="#L81" title="utils/adt/datetime.c:81">months</a>&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {DMONTH, UNITS, DTK_MONTH}, <span class="Comment">/* &quot;month&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;<a href="#L81" title="utils/adt/datetime.c:81">months</a>&quot;</span>, UNITS, DTK_MONTH},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;ms&quot;</span>, UNITS, DTK_MILLISEC},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;msec&quot;</span>, UNITS, DTK_MILLISEC},<br/></li>
<li>&nbsp; &nbsp; {DMILLISEC, UNITS, DTK_MILLISEC},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;mseconds&quot;</span>, UNITS, DTK_MILLISEC},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;msecs&quot;</span>, UNITS, DTK_MILLISEC},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;qtr&quot;</span>, UNITS, DTK_QUARTER},&nbsp; &nbsp; <span class="Comment">/* &quot;quarter&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {DQUARTER, UNITS, DTK_QUARTER}, <span class="Comment">/* &quot;quarter&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;s&quot;</span>, UNITS, DTK_SECOND},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;sec&quot;</span>, UNITS, DTK_SECOND},<br/></li>
<li>&nbsp; &nbsp; {DSECOND, UNITS, DTK_SECOND},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;seconds&quot;</span>, UNITS, DTK_SECOND},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;secs&quot;</span>, UNITS, DTK_SECOND},<br/></li>
<li>&nbsp; &nbsp; {DTIMEZONE, UNITS, DTK_TZ}, <span class="Comment">/* &quot;timezone&quot; time offset */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;timezone_h&quot;</span>, UNITS, DTK_TZ_HOUR}, <span class="Comment">/* timezone hour units */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;timezone_m&quot;</span>, UNITS, DTK_TZ_MINUTE},&nbsp; &nbsp; <span class="Comment">/* timezone minutes units */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;us&quot;</span>, UNITS, DTK_MICROSEC},&nbsp; &nbsp; <span class="Comment">/* &quot;microsecond&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;usec&quot;</span>, UNITS, DTK_MICROSEC},&nbsp; &nbsp; <span class="Comment">/* &quot;microsecond&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {DMICROSEC, UNITS, DTK_MICROSEC},&nbsp; &nbsp; <span class="Comment">/* &quot;microsecond&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;useconds&quot;</span>, UNITS, DTK_MICROSEC},&nbsp; &nbsp; <span class="Comment">/* &quot;microseconds&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;usecs&quot;</span>, UNITS, DTK_MICROSEC}, <span class="Comment">/* &quot;microseconds&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;w&quot;</span>, UNITS, DTK_WEEK},&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;week&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {DWEEK, UNITS, DTK_WEEK},&nbsp; &nbsp; <span class="Comment">/* &quot;week&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;weeks&quot;</span>, UNITS, DTK_WEEK}, <span class="Comment">/* &quot;weeks&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;y&quot;</span>, UNITS, DTK_YEAR},&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;year&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {DYEAR, UNITS, DTK_YEAR},&nbsp; &nbsp; <span class="Comment">/* &quot;year&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;years&quot;</span>, UNITS, DTK_YEAR}, <span class="Comment">/* &quot;years&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;yr&quot;</span>, UNITS, DTK_YEAR},&nbsp; &nbsp; <span class="Comment">/* &quot;year&quot; relative */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;yrs&quot;</span>, UNITS, DTK_YEAR}&nbsp; &nbsp; <span class="Comment">/* &quot;years&quot; relative */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><a id="L252">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <span class="Type">int</span> <span class="linkable">szdeltatktbl</span> = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span> <a href="#L187" title="utils/adt/datetime.c:187">deltatktbl</a> / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span> <a href="#L187" title="utils/adt/datetime.c:187">deltatktbl</a>[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li><a id="L254">&#x200c;</a><span class="Type">static</span> TimeZoneAbbrevTable *<span class="linkable">zoneabbrevtbl</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Caches of recent lookup results in the above tables */<br/></li>
<li></span><br/></li>
<li><a id="L258">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> datetkn *<span class="linkable">datecache</span>[MAXDATEFIELDS] = {<span class="Constant">NULL</span>};<br/></li>
<li><br/></li>
<li><a id="L260">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> datetkn *<span class="linkable">deltacache</span>[MAXDATEFIELDS] = {<span class="Constant">NULL</span>};<br/></li>
<li><br/></li>
<li><a id="L262">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> datetkn *<span class="linkable">abbrevcache</span>[MAXDATEFIELDS] = {<span class="Constant">NULL</span>};<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Calendar time to Julian date conversions.<br/></li>
<li></span><span class="Comment"> * Julian date is commonly used in astronomical applications,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; since it is numerically accurate and computationally simple.<br/></li>
<li></span><span class="Comment"> * The algorithms here will accurately convert between Julian day<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; and calendar date for all non-negative Julian <a href="#L84" title="utils/adt/datetime.c:84">days</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (i.e. from Nov 24, -4713 on).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Rewritten to eliminate overflow problems. This <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> allows the<br/></li>
<li></span><span class="Comment"> * routines to work correctly for all Julian day counts from<br/></li>
<li></span><span class="Comment"> * 0 to 2147483647&nbsp; &nbsp; (Nov 24, -4713 to Jun 3, 5874898) assuming<br/></li>
<li></span><span class="Comment"> * a 32-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integer. Longer types should also work to the limits<br/></li>
<li></span><span class="Comment"> * of their precision.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Actually, <a href="#L286" title="utils/adt/datetime.c:286">date2j</a>() will work sanely, in the sense of producing<br/></li>
<li></span><span class="Comment"> * valid negative Julian dates, significantly <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> Nov 24, -4713.<br/></li>
<li></span><span class="Comment"> * We rely on it to do so back to Nov 1, -4713; see IS_VALID_JULIAN()<br/></li>
<li></span><span class="Comment"> * and associated commentary in timestamp.h.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">int<br/></li>
<li><a id="L286">&#x200c;</a></span><span class="linkable">date2j</span>(<span class="Type">int</span> year, <span class="Type">int</span> month, <span class="Type">int</span> day)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; julian;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; century;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (month &gt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; month += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; year += <span class="Constant">4800</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; month += <span class="Constant">13</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; year += <span class="Constant">4799</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; century = year / <span class="Constant">100</span>;<br/></li>
<li>&nbsp; &nbsp; julian = year * <span class="Constant">365</span> - <span class="Constant">32167</span>;<br/></li>
<li>&nbsp; &nbsp; julian += year / <span class="Constant">4</span> - century + century / <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; julian += <span class="Constant">7834</span> * month / <span class="Constant">256</span> + day;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> julian;<br/></li>
<li>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L286" title="utils/adt/datetime.c:286">date2j</a>() */<br/></li>
<li></span><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L311">&#x200c;</a></span><span class="linkable">j2date</span>(<span class="Type">int</span> jd, <span class="Type">int</span> *year, <span class="Type">int</span> *month, <span class="Type">int</span> *day)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> julian;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> quad;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; julian = jd;<br/></li>
<li>&nbsp; &nbsp; julian += <span class="Constant">32044</span>;<br/></li>
<li>&nbsp; &nbsp; quad = julian / <span class="Constant">146097</span>;<br/></li>
<li>&nbsp; &nbsp; extra = (julian - quad * <span class="Constant">146097</span>) * <span class="Constant">4</span> + <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; julian += <span class="Constant">60</span> + quad * <span class="Constant">3</span> + extra / <span class="Constant">146097</span>;<br/></li>
<li>&nbsp; &nbsp; quad = julian / <span class="Constant">1461</span>;<br/></li>
<li>&nbsp; &nbsp; julian -= quad * <span class="Constant">1461</span>;<br/></li>
<li>&nbsp; &nbsp; y = julian * <span class="Constant">4</span> / <span class="Constant">1461</span>;<br/></li>
<li>&nbsp; &nbsp; julian = ((y != <span class="Constant">0</span>) ? ((julian + <span class="Constant">305</span>) % <span class="Constant">365</span>) : ((julian + <span class="Constant">306</span>) % <span class="Constant">366</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; + <span class="Constant">123</span>;<br/></li>
<li>&nbsp; &nbsp; y += quad * <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; *year = y - <span class="Constant">4800</span>;<br/></li>
<li>&nbsp; &nbsp; quad = julian * <span class="Constant">2141</span> / <span class="Constant">65536</span>;<br/></li>
<li>&nbsp; &nbsp; *day = julian - <span class="Constant">7834</span> * quad / <span class="Constant">256</span>;<br/></li>
<li>&nbsp; &nbsp; *month = (quad + <span class="Constant">10</span>) % MONTHS_PER_YEAR + <span class="Constant">1</span>;<br/></li>
<li>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L311" title="utils/adt/datetime.c:311">j2date</a>() */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L344" title="utils/adt/datetime.c:344">j2day</a> - convert Julian date to day-of-week (0..6 == Sun..Sat)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: various places use the locution <a href="#L344" title="utils/adt/datetime.c:344">j2day</a>(date - 1) to produce a<br/></li>
<li></span><span class="Comment"> * result according to the convention 0..6 = Mon..Sun.&nbsp; This is a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of<br/></li>
<li></span><span class="Comment"> * a crock, but will work as long as the computation here is just a modulo.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L344">&#x200c;</a></span><span class="linkable">j2day</span>(<span class="Type">int</span> date)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; date += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; date %= <span class="Constant">7</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cope if division truncates towards zero, as it probably does */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (date &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; date += <span class="Constant">7</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> date;<br/></li>
<li>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L344" title="utils/adt/datetime.c:344">j2day</a>() */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L366" title="utils/adt/datetime.c:366">GetCurrentDateTime</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Get the transaction start time (&quot;<a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>()&quot;) broken down as a struct pg_tm,<br/></li>
<li></span><span class="Comment"> * converted according to the session timezone setting.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is just a convenience wrapper for <a href="#L387" title="utils/adt/datetime.c:387">GetCurrentTimeUsec</a>, to cover the<br/></li>
<li></span><span class="Comment"> * case where caller doesn't need either fractional seconds or tz offset.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L366">&#x200c;</a></span><span class="linkable">GetCurrentDateTime</span>(<span class="Type">struct</span> pg_tm *tm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L387" title="utils/adt/datetime.c:387">GetCurrentTimeUsec</a>(tm, &amp;fsec, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L387" title="utils/adt/datetime.c:387">GetCurrentTimeUsec</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Get the transaction start time (&quot;<a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>()&quot;) broken down as a struct pg_tm,<br/></li>
<li></span><span class="Comment"> * including fractional seconds and timezone offset.&nbsp; The time is converted<br/></li>
<li></span><span class="Comment"> * according to the session timezone setting.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callers may pass tzp = NULL if they don't need the offset, but this does<br/></li>
<li></span><span class="Comment"> * not affect the conversion behavior (unlike <a href="timestamp.c.html#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>()).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Internally, we cache the result, since this could be called many times<br/></li>
<li></span><span class="Comment"> * in a transaction, within which <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>() doesn't change.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L387">&#x200c;</a></span><span class="linkable">GetCurrentTimeUsec</span>(<span class="Type">struct</span> pg_tm *tm, fsec_t *fsec, <span class="Type">int</span> *tzp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz cur_ts = <a href="../../access/transam/xact.c.html#L867" title="access/transam/xact.c:867">GetCurrentTransactionStartTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The cache key must include both current time and current timezone.&nbsp; By<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * representing the timezone by just a pointer, we're assuming that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * distinct timezone settings could never have the same pointer value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is true by virtue of the hashtable used inside pg_tzset();<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * however, it might need another look if we ever allow entries in that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> to be recycled.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">static</span> TimestampTz cache_ts = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> pg_tz *cache_timezone = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">struct</span> pg_tm cache_tm;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> fsec_t cache_fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; cache_tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cur_ts != cache_ts || session_timezone != cache_timezone)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure cache is marked invalid in case of error after partial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * update within <a href="timestamp.c.html#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cache_timezone = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Perform the computation, storing results into cache.&nbsp; We do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * really expect <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error here, since current time surely ought to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * within <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, but check just for sanity's sake.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="timestamp.c.html#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(cur_ts, &amp;cache_tz, &amp;cache_tm, &amp;cache_fsec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, session_timezone) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, so mark the cache valid. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cache_ts = cur_ts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache_timezone = session_timezone;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *tm = cache_tm;<br/></li>
<li>&nbsp; &nbsp; *fsec = cache_fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tzp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *tzp = cache_tz;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Append seconds and fractional seconds (if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) at *cp.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * precision is the max number of fraction digits, fillzeros says to<br/></li>
<li></span><span class="Comment"> * pad to two integral-seconds digits.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a pointer to the new end of string.&nbsp; No NUL terminator is put<br/></li>
<li></span><span class="Comment"> * there; callers are responsible for NUL terminating str themselves.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sign is stripped from the input sec and fsec <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L448">&#x200c;</a><span class="linkable">AppendSeconds</span>(<span class="Type">char</span> *cp, <span class="Type">int</span> sec, fsec_t fsec, <span class="Type">int</span> precision, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fillzeros)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(precision &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fillzeros)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(cp, abs(sec), <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="numutils.c.html#L1309" title="utils/adt/numutils.c:1309">pg_ultostr</a>(cp, abs(sec));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fsec_t is just an int32 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fsec != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; value = abs(fsec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *end = &amp;cp[precision + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; gotnonzero = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *cp++ = <span class="Constant">'.'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Append the fractional seconds part.&nbsp; Note that we don't want <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * trailing zeros here, so since we're building the number in reverse<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> appending zeros until we've output a non-zero digit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (precision--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; oldval = value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; remainder;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value /= <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remainder = oldval - value * <span class="Constant">10</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check if we got a non-zero */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remainder)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gotnonzero = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gotnonzero)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp[precision] = <span class="Constant">'0'</span> + remainder;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end = &amp;cp[precision];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we still have a non-zero value then precision must have not been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enough to <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> the number.&nbsp; We punt the problem to <a href="numutils.c.html#L1309" title="utils/adt/numutils.c:1309">pg_ultostr</a>(),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which will generate a correct answer in the minimum valid width.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="numutils.c.html#L1309" title="utils/adt/numutils.c:1309">pg_ultostr</a>(cp, abs(fsec));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> end;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cp;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Variant of above that's specialized to timestamp case.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a pointer to the new end of string.&nbsp; No NUL terminator is put<br/></li>
<li></span><span class="Comment"> * there; callers are responsible for NUL terminating str themselves.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L511">&#x200c;</a><span class="linkable">AppendTimestampSeconds</span>(<span class="Type">char</span> *cp, <span class="Type">struct</span> pg_tm *tm, fsec_t fsec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L448" title="utils/adt/datetime.c:448">AppendSeconds</a>(cp, tm-&gt;tm_sec, fsec, MAX_TIMESTAMP_PRECISION, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add val * multiplier to *sum.<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false on overflow.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L522">&#x200c;</a></span><span class="linkable">int64_multiply_add</span>(int64 val, int64 multiplier, int64 *sum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; product;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_mul_s64_overflow(val, multiplier, &amp;product) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_add_s64_overflow(*sum, product, sum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Multiply frac by scale (to produce microseconds) and add to itm_in-&gt;tm_usec.<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if itm_in overflows.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L537">&#x200c;</a></span><span class="linkable">AdjustFractMicroseconds</span>(<span class="Type">double</span> frac, int64 scale,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_itm_in *itm_in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; usec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fast path for common case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (frac == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We assume the input frac has abs value less than 1, so overflow of frac<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or usec is not an issue for interesting <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of scale.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; frac *= scale;<br/></li>
<li>&nbsp; &nbsp; usec = (int64) frac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Round off <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fractional microsecond */<br/></li>
<li></span>&nbsp; &nbsp; frac -= usec;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (frac &gt; <span class="Constant">0.5</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; usec++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frac &lt; -<span class="Constant">0.5</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; usec--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> !pg_add_s64_overflow(itm_in-&gt;tm_usec, usec, &amp;itm_in-&gt;tm_usec);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Multiply frac by scale (to produce <a href="#L84" title="utils/adt/datetime.c:84">days</a>).&nbsp; Add the integral part of the<br/></li>
<li></span><span class="Comment"> * result to itm_in-&gt;tm_mday, the fractional part to itm_in-&gt;tm_usec.<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if itm_in overflows.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L569">&#x200c;</a></span><span class="linkable">AdjustFractDays</span>(<span class="Type">double</span> frac, <span class="Type">int</span> scale,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_itm_in *itm_in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra_days;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fast path for common case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (frac == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We assume the input frac has abs value less than 1, so overflow of frac<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or extra_days is not an issue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; frac *= scale;<br/></li>
<li>&nbsp; &nbsp; extra_days = (<span class="Type">int</span>) frac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... but this could overflow, if tm_mday is already nonzero */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s32_overflow(itm_in-&gt;tm_mday, extra_days, &amp;itm_in-&gt;tm_mday))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fractional day */<br/></li>
<li></span>&nbsp; &nbsp; frac -= extra_days;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L537" title="utils/adt/datetime.c:537">AdjustFractMicroseconds</a>(frac, USECS_PER_DAY, itm_in);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Multiply frac by scale (to produce years), then further scale up to <a href="#L81" title="utils/adt/datetime.c:81">months</a>.<br/></li>
<li></span><span class="Comment"> * Add the integral part of the result to itm_in-&gt;tm_mon, discarding <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * fractional part.<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if itm_in overflows.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L601">&#x200c;</a></span><span class="linkable">AdjustFractYears</span>(<span class="Type">double</span> frac, <span class="Type">int</span> scale,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> pg_itm_in *itm_in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As above, we assume abs(frac) &lt; 1, so this can't overflow for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interesting value of scale.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra_months = (<span class="Type">int</span>) rint(frac * scale * MONTHS_PER_YEAR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> !pg_add_s32_overflow(itm_in-&gt;tm_mon, extra_months, &amp;itm_in-&gt;tm_mon);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add (val + fval) * scale to itm_in-&gt;tm_usec.<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if itm_in overflows.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L618">&#x200c;</a></span><span class="linkable">AdjustMicroseconds</span>(int64 val, <span class="Type">double</span> fval, int64 scale,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> pg_itm_in *itm_in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle the integer part */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L522" title="utils/adt/datetime.c:522">int64_multiply_add</a>(val, scale, &amp;itm_in-&gt;tm_usec))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle the float part */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L537" title="utils/adt/datetime.c:537">AdjustFractMicroseconds</a>(fval, scale, itm_in);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Multiply val by scale (to produce <a href="#L84" title="utils/adt/datetime.c:84">days</a>) and add to itm_in-&gt;tm_mday.<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if itm_in overflows.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L633">&#x200c;</a></span><span class="linkable">AdjustDays</span>(int64 val, <span class="Type">int</span> scale, <span class="Type">struct</span> pg_itm_in *itm_in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="utils/adt/datetime.c:84">days</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (val &lt; <span class="Constant">INT_MIN</span> || val &gt; <span class="Constant">INT_MAX</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> !pg_mul_s32_overflow((int32) val, scale, &amp;<a href="#L84" title="utils/adt/datetime.c:84">days</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !pg_add_s32_overflow(itm_in-&gt;tm_mday, <a href="#L84" title="utils/adt/datetime.c:84">days</a>, &amp;itm_in-&gt;tm_mday);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add val to itm_in-&gt;tm_mon (no need for scale here, as val is always<br/></li>
<li></span><span class="Comment"> * in <a href="#L81" title="utils/adt/datetime.c:81">months</a> already).<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if itm_in overflows.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L649">&#x200c;</a></span><span class="linkable">AdjustMonths</span>(int64 val, <span class="Type">struct</span> pg_itm_in *itm_in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (val &lt; <span class="Constant">INT_MIN</span> || val &gt; <span class="Constant">INT_MAX</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> !pg_add_s32_overflow(itm_in-&gt;tm_mon, (int32) val, &amp;itm_in-&gt;tm_mon);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Multiply val by scale (to produce years) and add to itm_in-&gt;tm_year.<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if itm_in overflows.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L661">&#x200c;</a></span><span class="linkable">AdjustYears</span>(int64 val, <span class="Type">int</span> scale,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_itm_in *itm_in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; years;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (val &lt; <span class="Constant">INT_MIN</span> || val &gt; <span class="Constant">INT_MAX</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> !pg_mul_s32_overflow((int32) val, scale, &amp;years) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !pg_add_s32_overflow(itm_in-&gt;tm_year, years, &amp;itm_in-&gt;tm_year);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parse the fractional part of a number (decimal point and optional digits,<br/></li>
<li></span><span class="Comment"> * followed by end of string).&nbsp; Returns the fractional value into *frac.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 0 if successful, DTERR code if bogus input detected.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L680">&#x200c;</a></span><span class="linkable">ParseFraction</span>(<span class="Type">char</span> *cp, <span class="Type">double</span> *frac)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Caller should always pass the start of the fraction part */<br/></li>
<li></span>&nbsp; &nbsp; Assert(*cp == <span class="Constant">'.'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We want to allow just &quot;.&quot; with no digits, but some versions of strtod<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will report EINVAL for that, so special-case it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cp[<span class="Constant">1</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *frac = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *frac = strtod(cp, &amp;cp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> failure */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp != <span class="Special">'\0'</span> || errno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch a fractional-second value with suitable error checking.<br/></li>
<li></span><span class="Comment"> * Same as <a href="#L680" title="utils/adt/datetime.c:680">ParseFraction</a> except we convert the result to integer microseconds.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L709">&#x200c;</a></span><span class="linkable">ParseFractionalSecond</span>(<span class="Type">char</span> *cp, fsec_t *fsec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; frac;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dterr = <a href="#L680" title="utils/adt/datetime.c:680">ParseFraction</a>(cp, &amp;frac);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; *fsec = rint(frac * <span class="Constant">1000000</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L754" title="utils/adt/datetime.c:754">ParseDateTime</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Break string into tokens based on a date/time context.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Returns 0 if successful, DTERR code if bogus input detected.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * timestr - the input string<br/></li>
<li></span><span class="Comment"> * workbuf - workspace for field string storage. This must be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; larger than the largest legal input for this datetime type --<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; some additional space will be needed to NUL terminate fields.<br/></li>
<li></span><span class="Comment"> * buflen - the size of workbuf<br/></li>
<li></span><span class="Comment"> * field[] - pointers to field strings are returned in this array<br/></li>
<li></span><span class="Comment"> * ftype[] - field type indicators are returned in this array<br/></li>
<li></span><span class="Comment"> * maxfields - dimensions of the above two arrays<br/></li>
<li></span><span class="Comment"> * *numfields - set to the actual number of fields detected<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The fields extracted from the input are stored as separate,<br/></li>
<li></span><span class="Comment"> * null-terminated strings in the workspace at workbuf. Any text is<br/></li>
<li></span><span class="Comment"> * converted to <a href="oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> case.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Several field types are assigned:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; DTK_NUMBER - digits and (possibly) a decimal point<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; DTK_DATE - digits and two delimiters, or digits and text<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; DTK_TIME - digits, colon delimiters, and possibly a decimal point<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; DTK_STRING - text (no digits or punctuation)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; DTK_SPECIAL - leading &quot;+&quot; or &quot;-&quot; followed by text<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; DTK_TZ - leading &quot;+&quot; or &quot;-&quot; followed by digits (also eats ':', '.', '-')<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that some field types can hold unexpected items:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; DTK_NUMBER can hold date fields (yy.ddd)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; DTK_STRING can hold <a href="#L81" title="utils/adt/datetime.c:81">months</a> (January) and time zones (PST)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; DTK_DATE can hold time zone names (America/New_York, GMT-8)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L754">&#x200c;</a></span><span class="linkable">ParseDateTime</span>(<span class="Type">const</span> <span class="Type">char</span> *timestr, <span class="Type">char</span> *workbuf, <span class="Type">size_t</span> buflen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> **field, <span class="Type">int</span> *ftype, <span class="Type">int</span> maxfields, <span class="Type">int</span> *numfields)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nf = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *cp = timestr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *bufp = workbuf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *bufend = workbuf + buflen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the character pointed-to by &quot;bufptr&quot; to &quot;newchar&quot;, and increment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;bufptr&quot;. &quot;end&quot; gives the end of the buffer -- we return an error if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there is no space left to append a character to the buffer. Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;bufptr&quot; is evaluated twice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li><a id="L768">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">APPEND_CHAR</span>(bufptr, end, newchar)&nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (((bufptr) + </span><span class="Constant">1</span><span class="PreProc">) &gt;= (end))&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="PreProc"> DTERR_BAD_FORMAT;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; *(bufptr)++ = newchar;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* outer loop through fields */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (*cp != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore spaces between fields */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Record start of current field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nf &gt;= maxfields)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; field[nf] = bufp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* leading digit? then date or time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L768" title="utils/adt/datetime.c:768">APPEND_CHAR</a>(bufp, bufend, *cp++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L768" title="utils/adt/datetime.c:768">APPEND_CHAR</a>(bufp, bufend, *cp++);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* time field? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp == <span class="Constant">':'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[nf] = DTK_TIME;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L768" title="utils/adt/datetime.c:768">APPEND_CHAR</a>(bufp, bufend, *cp++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (*cp == <span class="Constant">':'</span>) || (*cp == <span class="Constant">'.'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L768" title="utils/adt/datetime.c:768">APPEND_CHAR</a>(bufp, bufend, *cp++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* date field? allow embedded text month */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*cp == <span class="Constant">'-'</span> || *cp == <span class="Constant">'/'</span> || *cp == <span class="Constant">'.'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* save delimiting character to use later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; delim = *cp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L768" title="utils/adt/datetime.c:768">APPEND_CHAR</a>(bufp, bufend, *cp++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* second field is all digits? then no embedded text month */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[nf] = ((delim == <span class="Constant">'.'</span>) ? DTK_NUMBER : DTK_DATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L768" title="utils/adt/datetime.c:768">APPEND_CHAR</a>(bufp, bufend, *cp++);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * insist that the delimiters match to get a three-field<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * date.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp == delim)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[nf] = DTK_DATE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L768" title="utils/adt/datetime.c:768">APPEND_CHAR</a>(bufp, bufend, *cp++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp) || *cp == delim)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L768" title="utils/adt/datetime.c:768">APPEND_CHAR</a>(bufp, bufend, *cp++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[nf] = DTK_DATE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (isalnum((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp) || *cp == delim)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L768" title="utils/adt/datetime.c:768">APPEND_CHAR</a>(bufp, bufend, pg_tolower((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp++));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise, number only and will determine year, month, day, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * concatenated fields later...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[nf] = DTK_NUMBER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Leading decimal point? Then fractional seconds... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*cp == <span class="Constant">'.'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L768" title="utils/adt/datetime.c:768">APPEND_CHAR</a>(bufp, bufend, *cp++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L768" title="utils/adt/datetime.c:768">APPEND_CHAR</a>(bufp, bufend, *cp++);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[nf] = DTK_NUMBER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * text? then date string, month, day of week, special, or timezone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (isalpha((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_date;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[nf] = DTK_STRING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L768" title="utils/adt/datetime.c:768">APPEND_CHAR</a>(bufp, bufend, pg_tolower((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp++));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (isalpha((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L768" title="utils/adt/datetime.c:768">APPEND_CHAR</a>(bufp, bufend, pg_tolower((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp++));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Dates can have embedded '-', '/', or '.' separators.&nbsp; It could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * also be a timezone name containing embedded '/', '+', '-', '<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>',<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or ':' (but '<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>' or ':' can't be the first punctuation). If the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> character is a digit or '+', we need to check whether what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we have so far is a recognized non-timezone keyword --- if so,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't believe that this is the start of a timezone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_date = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp == <span class="Constant">'-'</span> || *cp == <span class="Constant">'/'</span> || *cp == <span class="Constant">'.'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_date = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*cp == <span class="Constant">'+'</span> || isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *bufp = <span class="Special">'\0'</span>;&nbsp; &nbsp; <span class="Comment">/* null-terminate current field value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we need search only the core token table, not TZ names */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4142" title="utils/adt/datetime.c:4142">datebsearch</a>(field[nf], <a href="#L105" title="utils/adt/datetime.c:105">datetktbl</a>, <a href="#L181" title="utils/adt/datetime.c:181">szdatetktbl</a>) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_date = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_date)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[nf] = DTK_DATE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L768" title="utils/adt/datetime.c:768">APPEND_CHAR</a>(bufp, bufend, pg_tolower((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp++));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (*cp == <span class="Constant">'+'</span> || *cp == <span class="Constant">'-'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *cp == <span class="Constant">'/'</span> || *cp == <span class="Constant">'<a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *cp == <span class="Constant">'.'</span> || *cp == <span class="Constant">':'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isalnum((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sign? then special or <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> timezone */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*cp == <span class="Constant">'+'</span> || *cp == <span class="Constant">'-'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L768" title="utils/adt/datetime.c:768">APPEND_CHAR</a>(bufp, bufend, *cp++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* soak up leading whitespace */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> timezone? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* note that &quot;DTK_TZ&quot; could also be a signed float or yyyy-mm */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[nf] = DTK_TZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L768" title="utils/adt/datetime.c:768">APPEND_CHAR</a>(bufp, bufend, *cp++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *cp == <span class="Constant">':'</span> || *cp == <span class="Constant">'.'</span> || *cp == <span class="Constant">'-'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L768" title="utils/adt/datetime.c:768">APPEND_CHAR</a>(bufp, bufend, *cp++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* special? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (isalpha((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[nf] = DTK_SPECIAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L768" title="utils/adt/datetime.c:768">APPEND_CHAR</a>(bufp, bufend, pg_tolower((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp++));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (isalpha((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L768" title="utils/adt/datetime.c:768">APPEND_CHAR</a>(bufp, bufend, pg_tolower((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp++));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise something wrong... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore other punctuation but use as delimiter */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ispunct((<span class="Type">unsigned</span> <span class="Type">char</span>) *cp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise, something is not right... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* force in a delimiter after each field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *bufp++ = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nf++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *numfields = nf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L978" title="utils/adt/datetime.c:978">DecodeDateTime</a>()<br/></li>
<li></span><span class="Comment"> * Interpret previously parsed fields for general date and time.<br/></li>
<li></span><span class="Comment"> * Return 0 if full date, 1 if only time, and negative DTERR code if problems.<br/></li>
<li></span><span class="Comment"> * (Currently, all callers treat 1 as an error return too.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs are field[] and ftype[] arrays, of length nf.<br/></li>
<li></span><span class="Comment"> * Other arguments are outputs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; External format(s):<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;&lt;weekday&gt; &lt;month&gt;-&lt;day&gt;-&lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt;&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;Fri Feb-7-1997 15:23:27&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;Feb-7-1997 15:23:27&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;2-7-1997 15:23:27&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;1997-2-7 15:23:27&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;1997.038 15:23:27&quot;&nbsp; &nbsp; &nbsp; &nbsp; (day of year 1-366)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Also supports input in <a href="../../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a> time:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;970207 152327&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;97038 152327&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;20011225T040506.789-07&quot;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Use the system-provided <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to get the current time zone<br/></li>
<li></span><span class="Comment"> * if not specified in the input string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the date is outside the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of pg_time_t (in practice that could only<br/></li>
<li></span><span class="Comment"> * happen if pg_time_t is just 32 bits), then assume UTC time zone - thomas<br/></li>
<li></span><span class="Comment"> * 1997-05-27<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L978">&#x200c;</a></span><span class="linkable">DecodeDateTime</span>(<span class="Type">char</span> **field, <span class="Type">int</span> *ftype, <span class="Type">int</span> nf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *dtype, <span class="Type">struct</span> pg_tm *tm, fsec_t *fsec, <span class="Type">int</span> *tzp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DateTimeErrorExtra *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fmask = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptype = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;prefix type&quot; for ISO and Julian formats */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mer = HR24;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; haveTextMonth = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isjulian = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is2digits = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; bc = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pg_tz&nbsp; &nbsp; &nbsp;&nbsp; *namedTz = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pg_tz&nbsp; &nbsp; &nbsp;&nbsp; *abbrevTz = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pg_tz&nbsp; &nbsp; &nbsp;&nbsp; *valtz;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *abbrev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm cur_tm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We'll insist on at least all of the date fields, but <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remaining fields in case they are not set later...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *dtype = DTK_DATE;<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_hour = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_min = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_sec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; *fsec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't know daylight savings time status apriori */<br/></li>
<li></span>&nbsp; &nbsp; tm-&gt;tm_isdst = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tzp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *tzp = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nf; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (ftype[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DATE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Integral julian day with attached time zone? All other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * forms with JD will be separated into distinct fields, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * handle just this case here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptype == DTK_JULIAN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jday;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jday = strtoint(field[i], &amp;cp, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ERANGE</span> || jday &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L311" title="utils/adt/datetime.c:311">j2date</a>(jday, &amp;tm-&gt;tm_year, &amp;tm-&gt;tm_mon, &amp;tm-&gt;tm_mday);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isjulian = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the time zone from the end of the string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2996" title="utils/adt/datetime.c:2996">DecodeTimezone</a>(cp, tzp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_DATE_M | DTK_TIME_M | DTK_M(TZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptype = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Already have a date? Then this might be a time zone name<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with embedded punctuation (e.g. &quot;America/New_York&quot;) or a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * run-together time with trailing time zone (e.g. hhmmss-zz).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * - thomas 2001-12-25<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We consider it a time zone if we already have month &amp; day.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is to allow the form &quot;mmm dd hhmmss tz year&quot;, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we've historically accepted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ptype != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((fmask &amp; (DTK_M(MONTH) | DTK_M(DAY))) ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (DTK_M(MONTH) | DTK_M(DAY))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No time zone accepted? Then quit... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *field[i]) || ptype != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Allow a preceding &quot;t&quot; field, but no other units.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptype != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sanity check; should not fail this test */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptype != DTK_TIME)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptype = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Starts with a digit but we already have a time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * field? Then we are in trouble with a date and time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((fmask &amp; DTK_TIME_M) == DTK_TIME_M)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cp = strchr(field[i], <span class="Constant">'-'</span>)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the time zone from the end of the string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2996" title="utils/adt/datetime.c:2996">DecodeTimezone</a>(cp, tzp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Then read the rest of the field as a concatenated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2901" title="utils/adt/datetime.c:2901">DecodeNumberField</a>(strlen(field[i]), field[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tmask, tm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec, &amp;is2digits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * modify tmask after returning from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2901" title="utils/adt/datetime.c:2901">DecodeNumberField</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask |= DTK_M(TZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; namedTz = pg_tzset(field[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!namedTz)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra-&gt;dtee_timezone = field[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_TIMEZONE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we'll apply the zone setting below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(TZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2387" title="utils/adt/datetime.c:2387">DecodeDate</a>(field[i], fmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tmask, &amp;is2digits, tm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TIME:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This might be an ISO time following a &quot;t&quot; field.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptype != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sanity check; should not fail this test */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptype != DTK_TIME)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptype = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2661" title="utils/adt/datetime.c:2661">DecodeTime</a>(field[i], fmask, INTERVAL_FULL_RANGE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tmask, tm, fsec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for time overflow */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="date.c.html#L1427" title="utils/adt/date.c:1427">time_overflows</a>(tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *fsec))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TZ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2996" title="utils/adt/datetime.c:2996">DecodeTimezone</a>(field[i], &amp;tz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tzp = tz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(TZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_NUMBER:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Deal with cases where previous field labeled this one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptype != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = strtoint(field[i], &amp;cp, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ERANGE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp != <span class="Constant">'.'</span> &amp;&amp; *cp != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (ptype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_JULIAN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* previous field was a label for &quot;julian date&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (value &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_DATE_M;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L311" title="utils/adt/datetime.c:311">j2date</a>(value, &amp;tm-&gt;tm_year, &amp;tm-&gt;tm_mon, &amp;tm-&gt;tm_mday);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isjulian = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fractional Julian Day? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp == <span class="Constant">'.'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L680" title="utils/adt/datetime.c:680">ParseFraction</a>(cp, &amp;time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; time *= USECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="timestamp.c.html#L1874" title="utils/adt/timestamp.c:1874">dt2time</a>(time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tm-&gt;tm_hour, &amp;tm-&gt;tm_min,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tm-&gt;tm_sec, fsec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask |= DTK_TIME_M;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TIME:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* previous field was &quot;t&quot; for ISO time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2901" title="utils/adt/datetime.c:2901">DecodeNumberField</a>(strlen(field[i]), field[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fmask | DTK_DATE_M),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tmask, tm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec, &amp;is2digits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tmask != DTK_TIME_M)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptype = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *dtype = DTK_DATE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flen = strlen(field[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = strchr(field[i], <span class="Constant">'.'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Embedded decimal and no date yet? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cp != <span class="Constant">NULL</span> &amp;&amp; !(fmask &amp; DTK_DATE_M))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2387" title="utils/adt/datetime.c:2387">DecodeDate</a>(field[i], fmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tmask, &amp;is2digits, tm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* embedded decimal and several digits <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cp != <span class="Constant">NULL</span> &amp;&amp; flen - strlen(cp) &gt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Interpret as a concatenated date or time Set the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * type field to allow decoding other fields later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Example: 20011223 or 040506<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2901" title="utils/adt/datetime.c:2901">DecodeNumberField</a>(flen, field[i], fmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tmask, tm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec, &amp;is2digits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Is this a YMD or HMS specification, or a year number?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * YMD and HMS are required to be six digits or more, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if it is 5 digits, it is a year.&nbsp; If it is six or more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * digits, we assume it is YMD or HMS unless no date and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no time <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> have been specified.&nbsp; This forces 6+<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * digit years to be at the end of the string, or to use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the ISO date specification.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (flen &gt;= <span class="Constant">6</span> &amp;&amp; (!(fmask &amp; DTK_DATE_M) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !(fmask &amp; DTK_TIME_M)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2901" title="utils/adt/datetime.c:2901">DecodeNumberField</a>(flen, field[i], fmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tmask, tm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec, &amp;is2digits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise it is a single date/time field... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2716" title="utils/adt/datetime.c:2716">DecodeNumber</a>(flen, field[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; haveTextMonth, fmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tmask, tm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fsec, &amp;is2digits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_STRING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_SPECIAL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* timezone abbrevs take precedence over built-in tokens */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L3080" title="utils/adt/datetime.c:3080">DecodeTimezoneAbbrev</a>(i, field[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;type, &amp;val, &amp;valtz, extra);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (type == UNKNOWN_FIELD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = <a href="#L3137" title="utils/adt/datetime.c:3137">DecodeSpecial</a>(i, field[i], &amp;val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (type == IGNORE_DTF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RESERV:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_NOW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = (DTK_DATE_M | DTK_TIME_M | DTK_M(TZ));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *dtype = DTK_DATE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L387" title="utils/adt/datetime.c:387">GetCurrentTimeUsec</a>(tm, fsec, tzp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_YESTERDAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_DATE_M;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *dtype = DTK_DATE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L366" title="utils/adt/datetime.c:366">GetCurrentDateTime</a>(&amp;cur_tm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L311" title="utils/adt/datetime.c:311">j2date</a>(<a href="#L286" title="utils/adt/datetime.c:286">date2j</a>(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tm-&gt;tm_year, &amp;tm-&gt;tm_mon, &amp;tm-&gt;tm_mday);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TODAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_DATE_M;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *dtype = DTK_DATE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L366" title="utils/adt/datetime.c:366">GetCurrentDateTime</a>(&amp;cur_tm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = cur_tm.tm_year;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = cur_tm.tm_mon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = cur_tm.tm_mday;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TOMORROW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_DATE_M;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *dtype = DTK_DATE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L366" title="utils/adt/datetime.c:366">GetCurrentDateTime</a>(&amp;cur_tm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L311" title="utils/adt/datetime.c:311">j2date</a>(<a href="#L286" title="utils/adt/datetime.c:286">date2j</a>(cur_tm.tm_year, cur_tm.tm_mon, cur_tm.tm_mday) + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tm-&gt;tm_year, &amp;tm-&gt;tm_mon, &amp;tm-&gt;tm_mday);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_ZULU:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = (DTK_TIME_M | DTK_M(TZ));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *dtype = DTK_DATE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tzp = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_EPOCH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_LATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_EARLY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = (DTK_DATE_M | DTK_TIME_M | DTK_M(TZ));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *dtype = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caller ignores tm for these dtype codes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized RESERV datetime token: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MONTH:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already have a (<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>) month? then see if we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * substitute...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((fmask &amp; DTK_M(MONTH)) &amp;&amp; !haveTextMonth &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !(fmask &amp; DTK_M(DAY)) &amp;&amp; tm-&gt;tm_mon &gt;= <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon &lt;= <span class="Constant">31</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = tm-&gt;tm_mon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(DAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haveTextMonth = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTZMOD:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * daylight savings time modifier (solves &quot;MET DST&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * syntax)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask |= DTK_M(DTZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_isdst = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tzp -= val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTZ:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set mask for TZ here _or_ check for DTZ later when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * getting default timezone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask |= DTK_M(TZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_isdst = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tzp = -val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TZ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_isdst = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tzp = -val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DYNTZ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask |= DTK_M(TZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we'll determine the actual offset later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abbrevTz = valtz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abbrev = field[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mer = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ADBC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bc = (val == BC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DOW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_wday = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> UNITS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reject consecutive unhandled units */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptype != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptype = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ISOTIME:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is a filler field &quot;t&quot; indicating that the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * field is time. Try to verify that this is sensible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No preceding date? Then quit... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((fmask &amp; DTK_DATE_M) != DTK_DATE_M)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reject consecutive unhandled units */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptype != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptype = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> UNKNOWN_FIELD:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before giving up and declaring error, check to see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if it is an all-alpha timezone name.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; namedTz = pg_tzset(field[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!namedTz)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we'll apply the zone setting below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(TZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tmask &amp; fmask)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fmask |= tmask;<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end loop over fields */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reject if prefix type appeared and was never handled */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ptype != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do additional checking for normal date specs (but not &quot;infinity&quot; etc) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*dtype == DTK_DATE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do final checking/adjustment of Y/M/D fields */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2497" title="utils/adt/datetime.c:2497">ValidateDate</a>(fmask, isjulian, is2digits, bc, tm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* handle AM/PM */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mer != HR24 &amp;&amp; tm-&gt;tm_hour &gt; HOURS_PER_DAY / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mer == AM &amp;&amp; tm-&gt;tm_hour == HOURS_PER_DAY / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (mer == PM &amp;&amp; tm-&gt;tm_hour != HOURS_PER_DAY / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour += HOURS_PER_DAY / <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for incomplete input */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((fmask &amp; DTK_DATE_M) != DTK_DATE_M)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((fmask &amp; DTK_TIME_M) == DTK_TIME_M)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we had a full timezone spec, compute the offset (we could not do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, because we need the date to resolve DST status).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (namedTz != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* daylight savings time modifier disallowed with full TZ */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fmask &amp; DTK_M(DTZMOD))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tzp = <a href="#L1585" title="utils/adt/datetime.c:1585">DetermineTimeZoneOffset</a>(tm, namedTz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Likewise, if we had a dynamic timezone abbreviation, resolve it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (abbrevTz != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* daylight savings time modifier disallowed with dynamic TZ */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fmask &amp; DTK_M(DTZMOD))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tzp = <a href="#L1746" title="utils/adt/datetime.c:1746">DetermineTimeZoneAbbrevOffset</a>(tm, abbrev, abbrevTz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* timezone not specified? then use session timezone */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzp != <span class="Constant">NULL</span> &amp;&amp; !(fmask &amp; DTK_M(TZ)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * daylight savings time modifier but no standard timezone? then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fmask &amp; DTK_M(DTZMOD))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tzp = <a href="#L1585" title="utils/adt/datetime.c:1585">DetermineTimeZoneOffset</a>(tm, session_timezone);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1585" title="utils/adt/datetime.c:1585">DetermineTimeZoneOffset</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given a struct pg_tm in which tm_year, tm_mon, tm_mday, tm_hour, tm_min,<br/></li>
<li></span><span class="Comment"> * and tm_sec fields are set, and a zic-style time zone definition, determine<br/></li>
<li></span><span class="Comment"> * the applicable GMT offset and daylight-savings status at that time.<br/></li>
<li></span><span class="Comment"> * Set the struct pg_tm's tm_isdst field accordingly, and return the GMT<br/></li>
<li></span><span class="Comment"> * offset as the function result.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: if the date is out of the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> we can deal with, we return zero<br/></li>
<li></span><span class="Comment"> * as the GMT offset and set tm_isdst = 0.&nbsp; We don't throw an error here,<br/></li>
<li></span><span class="Comment"> * though probably some higher-level code will.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1585">&#x200c;</a></span><span class="linkable">DetermineTimeZoneOffset</span>(<span class="Type">struct</span> pg_tm *tm, pg_tz *tzp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_time_t&nbsp; &nbsp; t;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1607" title="utils/adt/datetime.c:1607">DetermineTimeZoneOffsetInternal</a>(tm, tzp, &amp;t);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1607" title="utils/adt/datetime.c:1607">DetermineTimeZoneOffsetInternal</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, but also return the actual UTC time imputed to the date/time<br/></li>
<li></span><span class="Comment"> * into *tp.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In event of an out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> date, we punt by returning zero into *tp.<br/></li>
<li></span><span class="Comment"> * This is okay for the immediate callers but is a good reason for not<br/></li>
<li></span><span class="Comment"> * exposing this worker function globally.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: it might seem that we should use mktime() for this, but bitter<br/></li>
<li></span><span class="Comment"> * experience teaches otherwise.&nbsp; This code is much faster than most versions<br/></li>
<li></span><span class="Comment"> * of mktime(), anyway.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1607">&#x200c;</a></span><span class="linkable">DetermineTimeZoneOffsetInternal</span>(<span class="Type">struct</span> pg_tm *tm, pg_tz *tzp, pg_time_t *tp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; date,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sec;<br/></li>
<li>&nbsp; &nbsp; pg_time_t&nbsp; &nbsp; day,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mytime,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevtime,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boundary,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; beforetime,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aftertime;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span> <span class="Type">int</span>&nbsp; &nbsp; before_gmtoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; after_gmtoff;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; before_isdst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; after_isdst;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, generate the pg_time_t value corresponding to the given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * y/m/d/h/m/s taken as GMT time.&nbsp; If this overflows, punt and decide the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timezone is GMT.&nbsp; (For a valid Julian date, integer overflow should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * impossible with 64-<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> pg_time_t, but let's check for safety.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IS_VALID_JULIAN(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> overflow;<br/></li>
<li>&nbsp; &nbsp; date = <a href="#L286" title="utils/adt/datetime.c:286">date2j</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday) - UNIX_EPOCH_JDATE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; day = ((pg_time_t) date) * SECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (day / SECS_PER_DAY != date)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> overflow;<br/></li>
<li>&nbsp; &nbsp; sec = tm-&gt;tm_sec + (tm-&gt;tm_min + tm-&gt;tm_hour * MINS_PER_HOUR) * SECS_PER_MINUTE;<br/></li>
<li>&nbsp; &nbsp; mytime = day + sec;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* since sec &gt;= 0, overflow could only be from +day to -mytime */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mytime &lt; <span class="Constant">0</span> &amp;&amp; day &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> overflow;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find the DST time boundary just <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> or following the target time. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume that all zones have GMT offsets less than 24 hours, and that DST<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * boundaries can't be closer together than 48 hours, so backing up 24<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hours and finding the &quot;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>&quot; boundary will work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; prevtime = mytime - SECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mytime &lt; <span class="Constant">0</span> &amp;&amp; prevtime &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> overflow;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = pg_next_dst_boundary(&amp;prevtime,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;before_gmtoff, &amp;before_isdst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;boundary,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;after_gmtoff, &amp;after_isdst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tzp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> overflow;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* failure? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Non-DST zone, life is simple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_isdst = before_isdst;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *tp = mytime - before_gmtoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -(<span class="Type">int</span>) before_gmtoff;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Form the candidate pg_time_t <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> with local-time adjustment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; beforetime = mytime - before_gmtoff;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((before_gmtoff &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mytime &lt; <span class="Constant">0</span> &amp;&amp; beforetime &gt; <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (before_gmtoff &lt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mytime &gt; <span class="Constant">0</span> &amp;&amp; beforetime &lt; <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> overflow;<br/></li>
<li>&nbsp; &nbsp; aftertime = mytime - after_gmtoff;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((after_gmtoff &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mytime &lt; <span class="Constant">0</span> &amp;&amp; aftertime &gt; <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (after_gmtoff &lt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mytime &gt; <span class="Constant">0</span> &amp;&amp; aftertime &lt; <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> overflow;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If both <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> or both after the boundary time, we know what to do. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * boundary time itself is considered to be after the transition, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * means we can <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> aftertime == boundary in the second case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (beforetime &lt; boundary &amp;&amp; aftertime &lt; boundary)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_isdst = before_isdst;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *tp = beforetime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -(<span class="Type">int</span>) before_gmtoff;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (beforetime &gt; boundary &amp;&amp; aftertime &gt;= boundary)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_isdst = after_isdst;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *tp = aftertime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -(<span class="Type">int</span>) after_gmtoff;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's an invalid or ambiguous time due to timezone transition.&nbsp; In a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * spring-forward transition, prefer the &quot;<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>&quot; interpretation; in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fall-back transition, prefer &quot;after&quot;.&nbsp; (We used to define and implement<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this test as &quot;prefer the standard-time interpretation&quot;, but that rule<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * does not <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> to resolve the behavior when both times are reported as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * standard time; which does happen, eg Europe/Moscow in Oct 2014.&nbsp; Also,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in some zones such as Europe/Dublin, there is widespread confusion<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about which time offset is &quot;standard&quot; time, so it's fortunate that our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * behavior doesn't depend on that.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (beforetime &gt; aftertime)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_isdst = before_isdst;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *tp = beforetime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -(<span class="Type">int</span>) before_gmtoff;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_isdst = after_isdst;<br/></li>
<li>&nbsp; &nbsp; *tp = aftertime;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -(<span class="Type">int</span>) after_gmtoff;<br/></li>
<li><br/></li>
<li><span class="Statement">overflow</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Given date is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, so assume UTC */<br/></li>
<li></span>&nbsp; &nbsp; tm-&gt;tm_isdst = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; *tp = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1746" title="utils/adt/datetime.c:1746">DetermineTimeZoneAbbrevOffset</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Determine the GMT offset and DST flag to be attributed to a dynamic<br/></li>
<li></span><span class="Comment"> * time zone abbreviation, that is one whose meaning has changed over time.<br/></li>
<li></span><span class="Comment"> * *tm contains the local time at which the meaning should be determined,<br/></li>
<li></span><span class="Comment"> * and tm-&gt;tm_isdst receives the DST flag.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This differs from the behavior of <a href="#L1585" title="utils/adt/datetime.c:1585">DetermineTimeZoneOffset</a>() in that a<br/></li>
<li></span><span class="Comment"> * standard-time or daylight-time abbreviation forces use of the corresponding<br/></li>
<li></span><span class="Comment"> * GMT offset even when the zone was then in DS or standard time respectively.<br/></li>
<li></span><span class="Comment"> * (However, that happens only if we can match the given abbreviation to some<br/></li>
<li></span><span class="Comment"> * abbreviation that appears in the IANA timezone data.&nbsp; Otherwise, we fall<br/></li>
<li></span><span class="Comment"> * back to doing <a href="#L1585" title="utils/adt/datetime.c:1585">DetermineTimeZoneOffset</a>().)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1746">&#x200c;</a></span><span class="linkable">DetermineTimeZoneAbbrevOffset</span>(<span class="Type">struct</span> pg_tm *tm, <span class="Type">const</span> <span class="Type">char</span> *abbr, pg_tz *tzp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_time_t&nbsp; &nbsp; t;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zone_offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abbr_offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abbr_isdst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute the UTC time we want to probe at.&nbsp; (In event of overflow, we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * probe at the epoch, which is a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> random but probably doesn't matter.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; zone_offset = <a href="#L1607" title="utils/adt/datetime.c:1607">DetermineTimeZoneOffsetInternal</a>(tm, tzp, &amp;t);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to match the abbreviation to something in the zone definition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1821" title="utils/adt/datetime.c:1821">DetermineTimeZoneAbbrevOffsetInternal</a>(t, abbr, tzp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;abbr_offset, &amp;abbr_isdst))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Success, so use the abbrev-specific answers. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_isdst = abbr_isdst;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> abbr_offset;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No match, so use the answers we already got from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1607" title="utils/adt/datetime.c:1607">DetermineTimeZoneOffsetInternal</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> zone_offset;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1784" title="utils/adt/datetime.c:1784">DetermineTimeZoneAbbrevOffsetTS</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above but the probe time is specified as a TimestampTz (hence, UTC time),<br/></li>
<li></span><span class="Comment"> * and DST status is returned into *isdst rather than into tm-&gt;tm_isdst.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1784">&#x200c;</a></span><span class="linkable">DetermineTimeZoneAbbrevOffsetTS</span>(TimestampTz ts, <span class="Type">const</span> <span class="Type">char</span> *abbr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_tz *tzp, <span class="Type">int</span> *isdst)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_time_t&nbsp; &nbsp; t = <a href="timestamp.c.html#L1833" title="utils/adt/timestamp.c:1833">timestamptz_to_time_t</a>(ts);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zone_offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abbr_offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tm;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the abbrev matches anything in the zone data, this is pretty easy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1821" title="utils/adt/datetime.c:1821">DetermineTimeZoneAbbrevOffsetInternal</a>(t, abbr, tzp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;abbr_offset, isdst))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> abbr_offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Else, break down the timestamp so we can use <a href="#L1585" title="utils/adt/datetime.c:1585">DetermineTimeZoneOffset</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="timestamp.c.html#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(ts, &amp;tz, &amp;tm, &amp;fsec, <span class="Constant">NULL</span>, tzp) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; zone_offset = <a href="#L1585" title="utils/adt/datetime.c:1585">DetermineTimeZoneOffset</a>(&amp;tm, tzp);<br/></li>
<li>&nbsp; &nbsp; *isdst = tm.tm_isdst;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> zone_offset;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1821" title="utils/adt/datetime.c:1821">DetermineTimeZoneAbbrevOffsetInternal</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Workhorse for above two <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>: work from a pg_time_t probe instant.<br/></li>
<li></span><span class="Comment"> * On success, return GMT offset and DST status into *offset and *isdst.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1821">&#x200c;</a></span><span class="linkable">DetermineTimeZoneAbbrevOffsetInternal</span>(pg_time_t t, <span class="Type">const</span> <span class="Type">char</span> *abbr, pg_tz *tzp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *offset, <span class="Type">int</span> *isdst)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; upabbr[TZ_STRLEN_MAX + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span> <span class="Type">int</span>&nbsp; &nbsp; gmtoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need to force the abbrev to <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> case */<br/></li>
<li></span>&nbsp; &nbsp; strlcpy(upabbr, abbr, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(upabbr));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (p = (<span class="Type">unsigned</span> <span class="Type">char</span> *) upabbr; *p; p++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *p = pg_toupper(*p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up the abbrev's meaning at this time in this zone */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pg_interpret_timezone_abbrev(upabbr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;t,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;gmtoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isdst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tzp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Change sign to agree with <a href="#L1585" title="utils/adt/datetime.c:1585">DetermineTimeZoneOffset</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *offset = (<span class="Type">int</span>) -gmtoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L1864" title="utils/adt/datetime.c:1864">DecodeTimeOnly</a>()<br/></li>
<li></span><span class="Comment"> * Interpret parsed string as time fields only.<br/></li>
<li></span><span class="Comment"> * Returns 0 if successful, DTERR code if bogus input detected.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs are field[] and ftype[] arrays, of length nf.<br/></li>
<li></span><span class="Comment"> * Other arguments are outputs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that support for time zone is here for<br/></li>
<li></span><span class="Comment"> * SQL TIME WITH TIME ZONE, but it reveals<br/></li>
<li></span><span class="Comment"> * bogosity with SQL date/time standards, since<br/></li>
<li></span><span class="Comment"> * we must infer a time zone from current time.<br/></li>
<li></span><span class="Comment"> * - thomas 2000-03-10<br/></li>
<li></span><span class="Comment"> * Allow specifying date to get a better time zone,<br/></li>
<li></span><span class="Comment"> * if time zones are allowed. - thomas 2001-12-26<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1864">&#x200c;</a></span><span class="linkable">DecodeTimeOnly</span>(<span class="Type">char</span> **field, <span class="Type">int</span> *ftype, <span class="Type">int</span> nf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *dtype, <span class="Type">struct</span> pg_tm *tm, fsec_t *fsec, <span class="Type">int</span> *tzp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DateTimeErrorExtra *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fmask = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptype = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;prefix type&quot; for ISO and Julian formats */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isjulian = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is2digits = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; bc = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mer = HR24;<br/></li>
<li>&nbsp; &nbsp; pg_tz&nbsp; &nbsp; &nbsp;&nbsp; *namedTz = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pg_tz&nbsp; &nbsp; &nbsp;&nbsp; *abbrevTz = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *abbrev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pg_tz&nbsp; &nbsp; &nbsp;&nbsp; *valtz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *dtype = DTK_TIME;<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_hour = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_min = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_sec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; *fsec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't know daylight savings time status apriori */<br/></li>
<li></span>&nbsp; &nbsp; tm-&gt;tm_isdst = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tzp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *tzp = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nf; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (ftype[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DATE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Time zone not allowed? Then should not <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> dates or time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * zones no matter what else!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Under limited circumstances, we will <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a date... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == <span class="Constant">0</span> &amp;&amp; nf &gt;= <span class="Constant">2</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ftype[nf - <span class="Constant">1</span>] == DTK_DATE || ftype[<span class="Constant">1</span>] == DTK_TIME))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2387" title="utils/adt/datetime.c:2387">DecodeDate</a>(field[i], fmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tmask, &amp;is2digits, tm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise, this is a time and/or time zone */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *field[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Starts with a digit but we already have a time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * field? Then we are in trouble with time already...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((fmask &amp; DTK_TIME_M) == DTK_TIME_M)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Should not get here and fail. Sanity check only...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cp = strchr(field[i], <span class="Constant">'-'</span>)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the time zone from the end of the string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2996" title="utils/adt/datetime.c:2996">DecodeTimezone</a>(cp, tzp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Then read the rest of the field as a concatenated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2901" title="utils/adt/datetime.c:2901">DecodeNumberField</a>(strlen(field[i]), field[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fmask | DTK_DATE_M),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tmask, tm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec, &amp;is2digits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[i] = dterr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask |= DTK_M(TZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; namedTz = pg_tzset(field[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!namedTz)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra-&gt;dtee_timezone = field[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_TIMEZONE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we'll apply the zone setting below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[i] = DTK_TZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(TZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TIME:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2661" title="utils/adt/datetime.c:2661">DecodeTime</a>(field[i], (fmask | DTK_DATE_M),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INTERVAL_FULL_RANGE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tmask, tm, fsec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TZ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2996" title="utils/adt/datetime.c:2996">DecodeTimezone</a>(field[i], &amp;tz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tzp = tz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(TZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_NUMBER:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Deal with cases where previous field labeled this one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptype != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = strtoint(field[i], &amp;cp, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ERANGE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp != <span class="Constant">'.'</span> &amp;&amp; *cp != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (ptype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_JULIAN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* previous field was a label for &quot;julian date&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (value &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_DATE_M;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L311" title="utils/adt/datetime.c:311">j2date</a>(value, &amp;tm-&gt;tm_year, &amp;tm-&gt;tm_mon, &amp;tm-&gt;tm_mday);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isjulian = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp == <span class="Constant">'.'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L680" title="utils/adt/datetime.c:680">ParseFraction</a>(cp, &amp;time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; time *= USECS_PER_DAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="timestamp.c.html#L1874" title="utils/adt/timestamp.c:1874">dt2time</a>(time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tm-&gt;tm_hour, &amp;tm-&gt;tm_min,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tm-&gt;tm_sec, fsec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask |= DTK_TIME_M;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TIME:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* previous field was &quot;t&quot; for ISO time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2901" title="utils/adt/datetime.c:2901">DecodeNumberField</a>(strlen(field[i]), field[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fmask | DTK_DATE_M),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tmask, tm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec, &amp;is2digits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[i] = dterr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tmask != DTK_TIME_M)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptype = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *dtype = DTK_DATE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flen = strlen(field[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = strchr(field[i], <span class="Constant">'.'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Embedded decimal? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Under limited circumstances, we will <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * date...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == <span class="Constant">0</span> &amp;&amp; nf &gt;= <span class="Constant">2</span> &amp;&amp; ftype[nf - <span class="Constant">1</span>] == DTK_DATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2387" title="utils/adt/datetime.c:2387">DecodeDate</a>(field[i], fmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tmask, &amp;is2digits, tm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* embedded decimal and several digits <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (flen - strlen(cp) &gt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Interpret as a concatenated date or time Set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the type field to allow decoding other fields<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later. Example: 20011223 or 040506<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2901" title="utils/adt/datetime.c:2901">DecodeNumberField</a>(flen, field[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fmask | DTK_DATE_M),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tmask, tm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec, &amp;is2digits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[i] = dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (flen &gt; <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2901" title="utils/adt/datetime.c:2901">DecodeNumberField</a>(flen, field[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fmask | DTK_DATE_M),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tmask, tm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec, &amp;is2digits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[i] = dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise it is a single date/time field... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2716" title="utils/adt/datetime.c:2716">DecodeNumber</a>(flen, field[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (fmask | DTK_DATE_M),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tmask, tm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fsec, &amp;is2digits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_STRING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_SPECIAL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* timezone abbrevs take precedence over built-in tokens */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L3080" title="utils/adt/datetime.c:3080">DecodeTimezoneAbbrev</a>(i, field[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;type, &amp;val, &amp;valtz, extra);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (type == UNKNOWN_FIELD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = <a href="#L3137" title="utils/adt/datetime.c:3137">DecodeSpecial</a>(i, field[i], &amp;val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (type == IGNORE_DTF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RESERV:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_NOW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_TIME_M;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *dtype = DTK_TIME;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L387" title="utils/adt/datetime.c:387">GetCurrentTimeUsec</a>(tm, fsec, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_ZULU:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = (DTK_TIME_M | DTK_M(TZ));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *dtype = DTK_TIME;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_isdst = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTZMOD:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * daylight savings time modifier (solves &quot;MET DST&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * syntax)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask |= DTK_M(DTZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_isdst = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tzp -= val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTZ:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set mask for TZ here _or_ check for DTZ later when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * getting default timezone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask |= DTK_M(TZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_isdst = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tzp = -val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[i] = DTK_TZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TZ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_isdst = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tzp = -val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[i] = DTK_TZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DYNTZ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask |= DTK_M(TZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we'll determine the actual offset later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abbrevTz = valtz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; abbrev = field[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[i] = DTK_TZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mer = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ADBC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bc = (val == BC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> UNITS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reject consecutive unhandled units */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptype != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptype = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ISOTIME:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reject consecutive unhandled units */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptype != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptype = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> UNKNOWN_FIELD:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before giving up and declaring error, check to see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if it is an all-alpha timezone name.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; namedTz = pg_tzset(field[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!namedTz)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we'll apply the zone setting below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(TZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tmask &amp; fmask)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fmask |= tmask;<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end loop over fields */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reject if prefix type appeared and was never handled */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ptype != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do final checking/adjustment of Y/M/D fields */<br/></li>
<li></span>&nbsp; &nbsp; dterr = <a href="#L2497" title="utils/adt/datetime.c:2497">ValidateDate</a>(fmask, isjulian, is2digits, bc, tm);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* handle AM/PM */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mer != HR24 &amp;&amp; tm-&gt;tm_hour &gt; HOURS_PER_DAY / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mer == AM &amp;&amp; tm-&gt;tm_hour == HOURS_PER_DAY / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (mer == PM &amp;&amp; tm-&gt;tm_hour != HOURS_PER_DAY / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour += HOURS_PER_DAY / <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for time overflow */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="date.c.html#L1427" title="utils/adt/date.c:1427">time_overflows</a>(tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec, *fsec))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((fmask &amp; DTK_TIME_M) != DTK_TIME_M)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we had a full timezone spec, compute the offset (we could not do it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, because we may need the date to resolve DST status).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (namedTz != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span> <span class="Type">int</span>&nbsp; &nbsp; gmtoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* daylight savings time modifier disallowed with full TZ */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fmask &amp; DTK_M(DTZMOD))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if non-DST zone, we do not need to know the date */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_get_timezone_offset(namedTz, &amp;gmtoff))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tzp = -(<span class="Type">int</span>) gmtoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* a date has to be specified */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((fmask &amp; DTK_DATE_M) != DTK_DATE_M)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tzp = <a href="#L1585" title="utils/adt/datetime.c:1585">DetermineTimeZoneOffset</a>(tm, namedTz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise, if we had a dynamic timezone abbreviation, resolve it <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (abbrevTz != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tmp = &amp;tt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * daylight savings time modifier but no standard timezone? then error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fmask &amp; DTK_M(DTZMOD))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((fmask &amp; DTK_DATE_M) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L366" title="utils/adt/datetime.c:366">GetCurrentDateTime</a>(tmp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* a date has to be specified */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((fmask &amp; DTK_DATE_M) != DTK_DATE_M)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp-&gt;tm_year = tm-&gt;tm_year;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp-&gt;tm_mon = tm-&gt;tm_mon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp-&gt;tm_mday = tm-&gt;tm_mday;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp-&gt;tm_hour = tm-&gt;tm_hour;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp-&gt;tm_min = tm-&gt;tm_min;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp-&gt;tm_sec = tm-&gt;tm_sec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *tzp = <a href="#L1746" title="utils/adt/datetime.c:1746">DetermineTimeZoneAbbrevOffset</a>(tmp, abbrev, abbrevTz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_isdst = tmp-&gt;tm_isdst;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* timezone not specified? then use session timezone */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tzp != <span class="Constant">NULL</span> &amp;&amp; !(fmask &amp; DTK_M(TZ)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tmp = &amp;tt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * daylight savings time modifier but no standard timezone? then error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fmask &amp; DTK_M(DTZMOD))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((fmask &amp; DTK_DATE_M) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L366" title="utils/adt/datetime.c:366">GetCurrentDateTime</a>(tmp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* a date has to be specified */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((fmask &amp; DTK_DATE_M) != DTK_DATE_M)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp-&gt;tm_year = tm-&gt;tm_year;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp-&gt;tm_mon = tm-&gt;tm_mon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp-&gt;tm_mday = tm-&gt;tm_mday;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp-&gt;tm_hour = tm-&gt;tm_hour;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp-&gt;tm_min = tm-&gt;tm_min;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp-&gt;tm_sec = tm-&gt;tm_sec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *tzp = <a href="#L1585" title="utils/adt/datetime.c:1585">DetermineTimeZoneOffset</a>(tmp, session_timezone);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_isdst = tmp-&gt;tm_isdst;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2387" title="utils/adt/datetime.c:2387">DecodeDate</a>()<br/></li>
<li></span><span class="Comment"> * Decode date string which includes delimiters.<br/></li>
<li></span><span class="Comment"> * Return 0 if okay, a DTERR code if not.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; str: field to be parsed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; fmask: bitmask for field types already seen<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *tmask: receives bitmask for fields found here<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *is2digits: set to true if we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> 2-digit year<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *tm: field <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are stored into appropriate members of this struct<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2387">&#x200c;</a></span><span class="linkable">DecodeDate</span>(<span class="Type">char</span> *str, <span class="Type">int</span> fmask, <span class="Type">int</span> *tmask, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *is2digits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> pg_tm *tm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nf = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; haveTextMonth = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dmask = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *field[MAXDATEFIELDS];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *tmask = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> this string... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (*str != <span class="Special">'\0'</span> &amp;&amp; nf &lt; MAXDATEFIELDS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> field separators */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*str != <span class="Special">'\0'</span> &amp;&amp; !isalnum((<span class="Type">unsigned</span> <span class="Type">char</span>) *str))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*str == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;&nbsp; &nbsp; <span class="Comment">/* end of string after separator */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; field[nf] = str;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *str))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *str))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (isalpha((<span class="Type">unsigned</span> <span class="Type">char</span>) *str))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (isalpha((<span class="Type">unsigned</span> <span class="Type">char</span>) *str))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Just get rid of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-digit, non-alpha characters... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*str != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nf++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* look first for text fields, since that will be unambiguous month */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nf; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isalpha((<span class="Type">unsigned</span> <span class="Type">char</span>) *field[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = <a href="#L3137" title="utils/adt/datetime.c:3137">DecodeSpecial</a>(i, field[i], &amp;val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (type == IGNORE_DTF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dmask = DTK_M(type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MONTH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haveTextMonth = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fmask &amp; dmask)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fmask |= dmask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tmask |= dmask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark this field as being completed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; field[i] = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> pick up remaining <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> fields */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nf; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (field[i] == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((len = strlen(field[i])) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2716" title="utils/adt/datetime.c:2716">DecodeNumber</a>(len, field[i], haveTextMonth, fmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;dmask, tm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;fsec, is2digits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fmask &amp; dmask)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fmask |= dmask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *tmask |= dmask;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((fmask &amp; ~(DTK_M(DOY) | DTK_M(TZ))) != DTK_DATE_M)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* validation of the field <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> must wait until <a href="#L2497" title="utils/adt/datetime.c:2497">ValidateDate</a>() */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2497" title="utils/adt/datetime.c:2497">ValidateDate</a>()<br/></li>
<li></span><span class="Comment"> * Check valid year/month/day <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, handle BC and DOY cases<br/></li>
<li></span><span class="Comment"> * Return 0 if okay, a DTERR code if not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2497">&#x200c;</a></span><span class="linkable">ValidateDate</span>(<span class="Type">int</span> fmask, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isjulian, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is2digits, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> bc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> pg_tm *tm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fmask &amp; DTK_M(YEAR))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isjulian)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tm_year is correct and should not be touched */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (bc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there is no year zero in AD/BC notation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_year &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* internally, we represent 1 BC as year zero, 2 BC as -1, etc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = -(tm-&gt;tm_year - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (is2digits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* process 1 or 2-digit input as 1970-2069 AD, allow '0' and '00' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_year &lt; <span class="Constant">0</span>)&nbsp; &nbsp; <span class="Comment">/* just paranoia */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_year &lt; <span class="Constant">70</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year += <span class="Constant">2000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (tm-&gt;tm_year &lt; <span class="Constant">100</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year += <span class="Constant">1900</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there is no year zero in AD/BC notation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_year &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that we have correct year, decode DOY */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fmask &amp; DTK_M(DOY))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L311" title="utils/adt/datetime.c:311">j2date</a>(<a href="#L286" title="utils/adt/datetime.c:286">date2j</a>(tm-&gt;tm_year, <span class="Constant">1</span>, <span class="Constant">1</span>) + tm-&gt;tm_yday - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tm-&gt;tm_year, &amp;tm-&gt;tm_mon, &amp;tm-&gt;tm_mday);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for valid month */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fmask &amp; DTK_M(MONTH))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_mon &lt; <span class="Constant">1</span> || tm-&gt;tm_mon &gt; MONTHS_PER_YEAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_MD_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* minimal check for valid day */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fmask &amp; DTK_M(DAY))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_mday &lt; <span class="Constant">1</span> || tm-&gt;tm_mday &gt; <span class="Constant">31</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_MD_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((fmask &amp; DTK_DATE_M) == DTK_DATE_M)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for valid day of month, <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that we know for sure the month<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and year.&nbsp; Note we don't use MD_FIELD_OVERFLOW here, since it seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unlikely that &quot;Feb 29&quot; is a YMD-order error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_mday &gt; <a href="#L75" title="utils/adt/datetime.c:75">day_tab</a>[isleap(tm-&gt;tm_year)][tm-&gt;tm_mon - <span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2579" title="utils/adt/datetime.c:2579">DecodeTimeCommon</a>()<br/></li>
<li></span><span class="Comment"> * Decode time string which includes delimiters.<br/></li>
<li></span><span class="Comment"> * Return 0 if okay, a DTERR code if not.<br/></li>
<li></span><span class="Comment"> * tmask and itm are output parameters.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This code is shared between the timestamp and interval cases.<br/></li>
<li></span><span class="Comment"> * We return a struct pg_itm (of which only the tm_usec, tm_sec, tm_min,<br/></li>
<li></span><span class="Comment"> * and tm_hour fields are used) and let the wrapper <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> below<br/></li>
<li></span><span class="Comment"> * convert and <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-check as necessary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2579">&#x200c;</a></span><span class="linkable">DecodeTimeCommon</span>(<span class="Type">char</span> *str, <span class="Type">int</span> fmask, <span class="Type">int</span> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *tmask, <span class="Type">struct</span> pg_itm *itm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *tmask = DTK_TIME_M;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; itm-&gt;tm_hour = strtoi64(str, &amp;cp, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ERANGE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*cp != <span class="Constant">':'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; itm-&gt;tm_min = strtoint(cp + <span class="Constant">1</span>, &amp;cp, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ERANGE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*cp == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itm-&gt;tm_sec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's a MINUTE TO SECOND interval, take 2 fields as being mm:ss */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> == (INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (itm-&gt;tm_hour &gt; <span class="Constant">INT_MAX</span> || itm-&gt;tm_hour &lt; <span class="Constant">INT_MIN</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itm-&gt;tm_sec = itm-&gt;tm_min;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itm-&gt;tm_min = (<span class="Type">int</span>) itm-&gt;tm_hour;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itm-&gt;tm_hour = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*cp == <span class="Constant">'.'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* always assume mm:ss.sss is MINUTE TO SECOND */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L709" title="utils/adt/datetime.c:709">ParseFractionalSecond</a>(cp, &amp;fsec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (itm-&gt;tm_hour &gt; <span class="Constant">INT_MAX</span> || itm-&gt;tm_hour &lt; <span class="Constant">INT_MIN</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itm-&gt;tm_sec = itm-&gt;tm_min;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itm-&gt;tm_min = (<span class="Type">int</span>) itm-&gt;tm_hour;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itm-&gt;tm_hour = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*cp == <span class="Constant">':'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itm-&gt;tm_sec = strtoint(cp + <span class="Constant">1</span>, &amp;cp, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ERANGE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp == <span class="Constant">'.'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L709" title="utils/adt/datetime.c:709">ParseFractionalSecond</a>(cp, &amp;fsec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*cp != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do a sanity check; but caller must check the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of tm_hour */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (itm-&gt;tm_hour &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itm-&gt;tm_min &lt; <span class="Constant">0</span> || itm-&gt;tm_min &gt; MINS_PER_HOUR - <span class="Constant">1</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itm-&gt;tm_sec &lt; <span class="Constant">0</span> || itm-&gt;tm_sec &gt; SECS_PER_MINUTE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fsec &lt; <span class="Constant">0</span> || fsec &gt; USECS_PER_SEC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itm-&gt;tm_usec = (<span class="Type">int</span>) fsec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2661" title="utils/adt/datetime.c:2661">DecodeTime</a>()<br/></li>
<li></span><span class="Comment"> * Decode time string which includes delimiters.<br/></li>
<li></span><span class="Comment"> * Return 0 if okay, a DTERR code if not.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This version is used for timestamps.&nbsp; The results are returned into<br/></li>
<li></span><span class="Comment"> * the tm_hour/tm_min/tm_sec fields of *tm, and microseconds into *fsec.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2661">&#x200c;</a></span><span class="linkable">DecodeTime</span>(<span class="Type">char</span> *str, <span class="Type">int</span> fmask, <span class="Type">int</span> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *tmask, <span class="Type">struct</span> pg_tm *tm, fsec_t *fsec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_itm itm;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dterr = <a href="#L2579" title="utils/adt/datetime.c:2579">DecodeTimeCommon</a>(str, fmask, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tmask, &amp;itm);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (itm.tm_hour &gt; <span class="Constant">INT_MAX</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_hour = (<span class="Type">int</span>) itm.tm_hour;<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_min = itm.tm_min;<br/></li>
<li>&nbsp; &nbsp; tm-&gt;tm_sec = itm.tm_sec;<br/></li>
<li>&nbsp; &nbsp; *fsec = itm.tm_usec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2690" title="utils/adt/datetime.c:2690">DecodeTimeForInterval</a>()<br/></li>
<li></span><span class="Comment"> * Decode time string which includes delimiters.<br/></li>
<li></span><span class="Comment"> * Return 0 if okay, a DTERR code if not.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This version is used for intervals.&nbsp; The results are returned into<br/></li>
<li></span><span class="Comment"> * itm_in-&gt;tm_usec.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2690">&#x200c;</a></span><span class="linkable">DecodeTimeForInterval</span>(<span class="Type">char</span> *str, <span class="Type">int</span> fmask, <span class="Type">int</span> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *tmask, <span class="Type">struct</span> pg_itm_in *itm_in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_itm itm;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dterr = <a href="#L2579" title="utils/adt/datetime.c:2579">DecodeTimeCommon</a>(str, fmask, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tmask, &amp;itm);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itm_in-&gt;tm_usec = itm.tm_usec;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L522" title="utils/adt/datetime.c:522">int64_multiply_add</a>(itm.tm_hour, USECS_PER_HOUR, &amp;itm_in-&gt;tm_usec) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L522" title="utils/adt/datetime.c:522">int64_multiply_add</a>(itm.tm_min, USECS_PER_MINUTE, &amp;itm_in-&gt;tm_usec) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L522" title="utils/adt/datetime.c:522">int64_multiply_add</a>(itm.tm_sec, USECS_PER_SEC, &amp;itm_in-&gt;tm_usec))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2716" title="utils/adt/datetime.c:2716">DecodeNumber</a>()<br/></li>
<li></span><span class="Comment"> * Interpret plain <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> field as a date value in context.<br/></li>
<li></span><span class="Comment"> * Return 0 if okay, a DTERR code if not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2716">&#x200c;</a></span><span class="linkable">DecodeNumber</span>(<span class="Type">int</span> flen, <span class="Type">char</span> *str, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> haveTextMonth, <span class="Type">int</span> fmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *tmask, <span class="Type">struct</span> pg_tm *tm, fsec_t *fsec, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *is2digits)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *tmask = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; val = strtoint(str, &amp;cp, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ERANGE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cp == str)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*cp == <span class="Constant">'.'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * More than two digits <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> decimal point? Then could be a date or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a run-together time: 2001.360 20011225 040506.789<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cp - str &gt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2901" title="utils/adt/datetime.c:2901">DecodeNumberField</a>(flen, str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fmask | DTK_DATE_M),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask, tm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec, is2digits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L709" title="utils/adt/datetime.c:709">ParseFractionalSecond</a>(cp, fsec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*cp != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Special case for day of year */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flen == <span class="Constant">3</span> &amp;&amp; (fmask &amp; DTK_DATE_M) == DTK_M(YEAR) &amp;&amp; val &gt;= <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val &lt;= <span class="Constant">366</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *tmask = (DTK_M(DOY) | DTK_M(MONTH) | DTK_M(DAY));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_yday = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tm_mon and tm_mday can't actually be set yet ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Switch based on what we have so far */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (fmask &amp; DTK_DATE_M)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">0</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Nothing so far; make a decision about what we think the input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is.&nbsp; There used to be lots of heuristics here, but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consensus <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> is to be paranoid.&nbsp; It *must* be either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * YYYY-MM-DD (with a more-than-two-digit year field), or the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * field order defined by <a href="../init/globals.c.html#L123" title="utils/init/globals.c:123">DateOrder</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flen &gt;= <span class="Constant">3</span> || <a href="../init/globals.c.html#L123" title="utils/init/globals.c:123">DateOrder</a> == DATEORDER_YMD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tmask = DTK_M(YEAR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../init/globals.c.html#L123" title="utils/init/globals.c:123">DateOrder</a> == DATEORDER_DMY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tmask = DTK_M(DAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tmask = DTK_M(MONTH);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> (DTK_M(YEAR)):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be at second field of YY-MM-DD */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tmask = DTK_M(MONTH);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> (DTK_M(MONTH)):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (haveTextMonth)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are at the first <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> field of a date that included a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * textual month name.&nbsp; We want to support the variants<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * MON-DD-YYYY, DD-MON-YYYY, and YYYY-MON-DD as unambiguous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inputs.&nbsp; We will also <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> MON-DD-YY or DD-MON-YY in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either DMY or MDY modes, as well as YY-MON-DD in YMD mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flen &gt;= <span class="Constant">3</span> || <a href="../init/globals.c.html#L123" title="utils/init/globals.c:123">DateOrder</a> == DATEORDER_YMD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tmask = DTK_M(YEAR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tmask = DTK_M(DAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be at second field of MM-DD-YY */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tmask = DTK_M(DAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> (DTK_M(YEAR) | DTK_M(MONTH)):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (haveTextMonth)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need to <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> DD-MON-YYYY even in YMD mode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flen &gt;= <span class="Constant">3</span> &amp;&amp; *is2digits)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Guess that first <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> field is day was wrong */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tmask = DTK_M(DAY);&nbsp; &nbsp; <span class="Comment">/* YEAR is already set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = tm-&gt;tm_year;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *is2digits = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tmask = DTK_M(DAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be at third field of YY-MM-DD */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tmask = DTK_M(DAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> (DTK_M(DAY)):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be at second field of DD-MM-YY */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tmask = DTK_M(MONTH);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> (DTK_M(MONTH) | DTK_M(DAY)):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be at third field of DD-MM-YY or MM-DD-YY */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tmask = DTK_M(YEAR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY)):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we have all the date, so it must be a time field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2901" title="utils/adt/datetime.c:2901">DecodeNumberField</a>(flen, str, fmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask, tm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec, is2digits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Anything else is bogus input */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When processing a year field, mark it for adjustment if it's only one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or two digits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*tmask == DTK_M(YEAR))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *is2digits = (flen &lt;= <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2901" title="utils/adt/datetime.c:2901">DecodeNumberField</a>()<br/></li>
<li></span><span class="Comment"> * Interpret <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> string as a concatenated date or time field.<br/></li>
<li></span><span class="Comment"> * Return a DTK token (&gt;= 0) if successful, a DTERR code (&lt; 0) if not.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Use the context of previously decoded fields to <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> with<br/></li>
<li></span><span class="Comment"> * the interpretation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2901">&#x200c;</a></span><span class="linkable">DecodeNumberField</span>(<span class="Type">int</span> len, <span class="Type">char</span> *str, <span class="Type">int</span> fmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *tmask, <span class="Type">struct</span> pg_tm *tm, fsec_t *fsec, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *is2digits)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Have a decimal point? Then this is a date or something with a seconds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * field...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((cp = strchr(str, <span class="Constant">'.'</span>)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Can we use <a href="#L709" title="utils/adt/datetime.c:709">ParseFractionalSecond</a> here?&nbsp; Not clear whether trailing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * junk should be rejected ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cp[<span class="Constant">1</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* avoid assuming that strtod will <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> &quot;.&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *fsec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; frac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frac = strtod(cp, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *fsec = rint(frac * <span class="Constant">1000000</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now truncate off the fraction for further processing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *cp = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = strlen(str);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No decimal point and no complete date yet? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((fmask &amp; DTK_DATE_M) != DTK_DATE_M)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len &gt;= <span class="Constant">6</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tmask = DTK_DATE_M;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Start from end and consider first 2 as Day, <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> 2 as Month,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and the rest as Year.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mday = atoi(str + (len - <span class="Constant">2</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(str + (len - <span class="Constant">2</span>)) = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_mon = atoi(str + (len - <span class="Constant">4</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(str + (len - <span class="Constant">4</span>)) = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_year = atoi(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((len - <span class="Constant">4</span>) == <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *is2digits = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTK_DATE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not all time fields are specified? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((fmask &amp; DTK_TIME_M) != DTK_TIME_M)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* hhmmss */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len == <span class="Constant">6</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tmask = DTK_TIME_M;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec = atoi(str + <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(str + <span class="Constant">4</span>) = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min = atoi(str + <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(str + <span class="Constant">2</span>) = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour = atoi(str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTK_TIME;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* hhmm? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (len == <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tmask = DTK_TIME_M;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_sec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_min = atoi(str + <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(str + <span class="Constant">2</span>) = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_hour = atoi(str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTK_TIME;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L2996" title="utils/adt/datetime.c:2996">DecodeTimezone</a>()<br/></li>
<li></span><span class="Comment"> * Interpret string as a <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> timezone.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return 0 if okay (and set *tzp), a DTERR code if not okay.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2996">&#x200c;</a></span><span class="linkable">DecodeTimezone</span>(<span class="Type">const</span> <span class="Type">char</span> *str, <span class="Type">int</span> *tzp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* leading character must be &quot;+&quot; or &quot;-&quot; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*str != <span class="Constant">'+'</span> &amp;&amp; *str != <span class="Constant">'-'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; hr = strtoint(str + <span class="Constant">1</span>, &amp;cp, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ERANGE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_TZDISP_OVERFLOW;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* explicit delimiter? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*cp == <span class="Constant">':'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; min = strtoint(cp + <span class="Constant">1</span>, &amp;cp, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ERANGE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_TZDISP_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp == <span class="Constant">':'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sec = strtoint(cp + <span class="Constant">1</span>, &amp;cp, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ERANGE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_TZDISP_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* otherwise, might have run things together... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*cp == <span class="Special">'\0'</span> &amp;&amp; strlen(str) &gt; <span class="Constant">3</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; min = hr % <span class="Constant">100</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hr = hr / <span class="Constant">100</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we could, but don't, support a run-together hhmmss format */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; min = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="geo_spgist.c.html#L107" title="utils/adt/geo_spgist.c:107">Range</a>-check the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>; see notes in datatype/timestamp.h */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hr &lt; <span class="Constant">0</span> || hr &gt; MAX_TZDISP_HOUR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_TZDISP_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (min &lt; <span class="Constant">0</span> || min &gt;= MINS_PER_HOUR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_TZDISP_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sec &lt; <span class="Constant">0</span> || sec &gt;= SECS_PER_MINUTE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_TZDISP_OVERFLOW;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tz = (hr * MINS_PER_HOUR + min) * SECS_PER_MINUTE + sec;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*str == <span class="Constant">'-'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tz = -tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *tzp = -tz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*cp != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3080" title="utils/adt/datetime.c:3080">DecodeTimezoneAbbrev</a>()<br/></li>
<li></span><span class="Comment"> * Interpret string as a timezone abbreviation, if possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Sets *ftype to an abbreviation type (TZ, DTZ, or DYNTZ), or UNKNOWN_FIELD if<br/></li>
<li></span><span class="Comment"> * string is not <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> known abbreviation.&nbsp; On success, set *offset and *tz to<br/></li>
<li></span><span class="Comment"> * represent the UTC offset (for TZ or DTZ) or underlying zone (for DYNTZ).<br/></li>
<li></span><span class="Comment"> * Note that full timezone names (such as America/New_York) are not handled<br/></li>
<li></span><span class="Comment"> * here, mostly for historical reasons.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The function result is 0 or a DTERR code; in the latter case, *extra<br/></li>
<li></span><span class="Comment"> * is filled as needed.&nbsp; Note that unknown-abbreviation is not considered<br/></li>
<li></span><span class="Comment"> * an error case.&nbsp; Also note that many callers assume that the DTERR code<br/></li>
<li></span><span class="Comment"> * is one that <a href="#L4081" title="utils/adt/datetime.c:4081">DateTimeParseError</a> does not require &quot;str&quot; or &quot;datatype&quot;<br/></li>
<li></span><span class="Comment"> * strings for.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given string must be lowercased already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Implement a cache lookup since it is likely that dates<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; will be related in format.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3080">&#x200c;</a></span><span class="linkable">DecodeTimezoneAbbrev</span>(<span class="Type">int</span> field, <span class="Type">const</span> <span class="Type">char</span> *lowtoken,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *ftype, <span class="Type">int</span> *offset, pg_tz **tz,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DateTimeErrorExtra *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> datetkn *tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="#L262" title="utils/adt/datetime.c:262">abbrevcache</a>[field];<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use strncmp so that we match truncated tokens */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tp == <span class="Constant">NULL</span> || strncmp(lowtoken, tp-&gt;token, TOKMAXLEN) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L254" title="utils/adt/datetime.c:254">zoneabbrevtbl</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tp = <a href="#L4142" title="utils/adt/datetime.c:4142">datebsearch</a>(lowtoken, <a href="#L254" title="utils/adt/datetime.c:254">zoneabbrevtbl</a>-&gt;abbrevs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L254" title="utils/adt/datetime.c:254">zoneabbrevtbl</a>-&gt;numabbrevs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ftype = UNKNOWN_FIELD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *tz = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L262" title="utils/adt/datetime.c:262">abbrevcache</a>[field] = tp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ftype = tp-&gt;type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tp-&gt;type == DYNTZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tz = <a href="#L4959" title="utils/adt/datetime.c:4959">FetchDynamicTimeZone</a>(<a href="#L254" title="utils/adt/datetime.c:254">zoneabbrevtbl</a>, tp, extra);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*tz == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_ZONE_ABBREV;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *offset = tp-&gt;value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tz = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3137" title="utils/adt/datetime.c:3137">DecodeSpecial</a>()<br/></li>
<li></span><span class="Comment"> * Decode text string using lookup table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Recognizes the keywords listed in <a href="#L105" title="utils/adt/datetime.c:105">datetktbl</a>.<br/></li>
<li></span><span class="Comment"> * Note: at one time this would also recognize timezone abbreviations,<br/></li>
<li></span><span class="Comment"> * but no more; use <a href="#L3080" title="utils/adt/datetime.c:3080">DecodeTimezoneAbbrev</a> for that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given string must be lowercased already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Implement a cache lookup since it is likely that dates<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; will be related in format.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3137">&#x200c;</a></span><span class="linkable">DecodeSpecial</span>(<span class="Type">int</span> field, <span class="Type">const</span> <span class="Type">char</span> *lowtoken, <span class="Type">int</span> *val)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> datetkn *tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="#L258" title="utils/adt/datetime.c:258">datecache</a>[field];<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use strncmp so that we match truncated tokens */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tp == <span class="Constant">NULL</span> || strncmp(lowtoken, tp-&gt;token, TOKMAXLEN) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tp = <a href="#L4142" title="utils/adt/datetime.c:4142">datebsearch</a>(lowtoken, <a href="#L105" title="utils/adt/datetime.c:105">datetktbl</a>, <a href="#L181" title="utils/adt/datetime.c:181">szdatetktbl</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; type = UNKNOWN_FIELD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *val = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L258" title="utils/adt/datetime.c:258">datecache</a>[field] = tp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; type = tp-&gt;type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *val = tp-&gt;value;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> type;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3179" title="utils/adt/datetime.c:3179">DecodeTimezoneName</a>()<br/></li>
<li></span><span class="Comment"> * Interpret string as a timezone abbreviation or name.<br/></li>
<li></span><span class="Comment"> * Throw error if the name is not recognized.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The return value indicates what kind of zone identifier it is:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; TZNAME_FIXED_OFFSET: fixed offset from UTC<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; TZNAME_DYNTZ: dynamic timezone abbreviation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; TZNAME_ZONE: full tzdb zone name<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For TZNAME_FIXED_OFFSET, *offset receives the UTC offset (in seconds,<br/></li>
<li></span><span class="Comment"> * with ISO sign convention: positive is east of Greenwich).<br/></li>
<li></span><span class="Comment"> * For the other two cases, *tz receives the timezone struct representing<br/></li>
<li></span><span class="Comment"> * the zone name or the abbreviation's underlying zone.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3179">&#x200c;</a></span><span class="linkable">DecodeTimezoneName</span>(<span class="Type">const</span> <span class="Type">char</span> *tzname, <span class="Type">int</span> *offset, pg_tz **tz)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lowzone;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type;<br/></li>
<li>&nbsp; &nbsp; DateTimeErrorExtra extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First we look in the timezone abbreviation table (to handle cases like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;EST&quot;), and if that fails, we look in the timezone database (to handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases like &quot;America/New_York&quot;).&nbsp; This matches the order in which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timestamp input checks the cases; it's important because the timezone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database unwisely uses a few zone names that are identical to offset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * abbreviations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L3080" title="utils/adt/datetime.c:3080">DecodeTimezoneAbbrev</a> requires lowercase input */<br/></li>
<li></span>&nbsp; &nbsp; lowzone = <a href="../../parser/scansup.c.html#L37" title="parser/scansup.c:37">downcase_truncate_identifier</a>(tzname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strlen(tzname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dterr = <a href="#L3080" title="utils/adt/datetime.c:3080">DecodeTimezoneAbbrev</a>(<span class="Constant">0</span>, lowzone, &amp;type, offset, tz, &amp;extra);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4081" title="utils/adt/datetime.c:4081">DateTimeParseError</a>(dterr, &amp;extra, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type == TZ || type == DTZ)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fixed-offset abbreviation, return the offset */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TZNAME_FIXED_OFFSET;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (type == DYNTZ)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dynamic-offset abbreviation, return its referenced timezone */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TZNAME_DYNTZ;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try it as a full zone name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *tz = pg_tzset(tzname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*tz == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;time zone </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not recognized&quot;</span>, tzname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TZNAME_ZONE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3234" title="utils/adt/datetime.c:3234">DecodeTimezoneNameToTz</a>()<br/></li>
<li></span><span class="Comment"> * Interpret string as a timezone abbreviation or name.<br/></li>
<li></span><span class="Comment"> * Throw error if the name is not recognized.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a simple wrapper for <a href="#L3179" title="utils/adt/datetime.c:3179">DecodeTimezoneName</a> that produces a pg_tz *<br/></li>
<li></span><span class="Comment"> * result in all cases.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>pg_tz *<br/></li>
<li><a id="L3234">&#x200c;</a><span class="linkable">DecodeTimezoneNameToTz</span>(<span class="Type">const</span> <span class="Type">char</span> *tzname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_tz&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3179" title="utils/adt/datetime.c:3179">DecodeTimezoneName</a>(tzname, &amp;offset, &amp;result) == TZNAME_FIXED_OFFSET)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fixed-offset abbreviation, get a pg_tz descriptor for that */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = pg_tzset_offset(-offset);&nbsp; &nbsp; <span class="Comment">/* flip to POSIX sign convention */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3262" title="utils/adt/datetime.c:3262">DecodeTimezoneAbbrevPrefix</a>()<br/></li>
<li></span><span class="Comment"> * Interpret prefix of string as a timezone abbreviation, if possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This has roughly the same functionality as <a href="#L3080" title="utils/adt/datetime.c:3080">DecodeTimezoneAbbrev</a>(),<br/></li>
<li></span><span class="Comment"> * but the API is adapted to the needs of formatting.c.&nbsp; Notably,<br/></li>
<li></span><span class="Comment"> * we will match the <a href="../../regex/rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a> possible prefix of the given string<br/></li>
<li></span><span class="Comment"> * rather than insisting on a complete match, and downcasing is applied<br/></li>
<li></span><span class="Comment"> * here rather than in the caller.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the length of the timezone abbreviation, or -1 if not recognized.<br/></li>
<li></span><span class="Comment"> * On success, sets *offset to the GMT offset for the abbreviation if it<br/></li>
<li></span><span class="Comment"> * is a fixed-offset abbreviation, or sets *tz to the pg_tz struct for<br/></li>
<li></span><span class="Comment"> * a dynamic abbreviation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3262">&#x200c;</a></span><span class="linkable">DecodeTimezoneAbbrevPrefix</span>(<span class="Type">const</span> <span class="Type">char</span> *str, <span class="Type">int</span> *offset, pg_tz **tz)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; lowtoken[TOKMAXLEN + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *offset = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* avoid uninitialized <a href="../../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> on failure */<br/></li>
<li></span>&nbsp; &nbsp; *tz = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L254" title="utils/adt/datetime.c:254">zoneabbrevtbl</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no abbrevs known, so fail immediately */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Downcase as much of the string as we could need */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (len = <span class="Constant">0</span>; len &lt; TOKMAXLEN; len++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*str == <span class="Special">'\0'</span> || !isalpha((<span class="Type">unsigned</span> <span class="Type">char</span>) *str))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lowtoken[len] = pg_tolower((<span class="Type">unsigned</span> <span class="Type">char</span>) *str++);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; lowtoken[len] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We could avoid doing repeated binary searches if we cared to duplicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L4142" title="utils/adt/datetime.c:4142">datebsearch</a> here, but it's not clear that such an optimization would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worth the trouble.&nbsp; In common cases there's probably not anything after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the zone abbrev anyway.&nbsp; So just search with successively truncated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> datetkn *tp = <a href="#L4142" title="utils/adt/datetime.c:4142">datebsearch</a>(lowtoken, <a href="#L254" title="utils/adt/datetime.c:254">zoneabbrevtbl</a>-&gt;abbrevs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L254" title="utils/adt/datetime.c:254">zoneabbrevtbl</a>-&gt;numabbrevs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tp-&gt;type == DYNTZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DateTimeErrorExtra extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_tz&nbsp; &nbsp; &nbsp;&nbsp; *tzp = <a href="#L4959" title="utils/adt/datetime.c:4959">FetchDynamicTimeZone</a>(<a href="#L254" title="utils/adt/datetime.c:254">zoneabbrevtbl</a>, tp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;extra);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzp != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Caller must resolve the abbrev's current meaning */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tz = tzp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fixed-offset zone abbrev, so it's easy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *offset = tp-&gt;value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lowtoken[--len] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Did not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a match */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3329" title="utils/adt/datetime.c:3329">ClearPgItmIn</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Zero out a pg_itm_in<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L3329">&#x200c;</a></span><span class="linkable">ClearPgItmIn</span>(<span class="Type">struct</span> pg_itm_in *itm_in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; itm_in-&gt;tm_usec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; itm_in-&gt;tm_mday = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; itm_in-&gt;tm_mon = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; itm_in-&gt;tm_year = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3353" title="utils/adt/datetime.c:3353">DecodeInterval</a>()<br/></li>
<li></span><span class="Comment"> * Interpret previously parsed fields for general time interval.<br/></li>
<li></span><span class="Comment"> * Returns 0 if successful, DTERR code if bogus input detected.<br/></li>
<li></span><span class="Comment"> * dtype and itm_in are output parameters.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Allow &quot;date&quot; field DTK_DATE since this could be just<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; an unsigned floating point number. - thomas 1997-11-16<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Allow ISO-style time span, with implicit units on number of <a href="#L84" title="utils/adt/datetime.c:84">days</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; preceding an hh:mm:ss field. - thomas 1998-04-30<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * itm_in remains undefined for infinite interval <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for which dtype alone<br/></li>
<li></span><span class="Comment"> * suffices.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3353">&#x200c;</a></span><span class="linkable">DecodeInterval</span>(<span class="Type">char</span> **field, <span class="Type">int</span> *ftype, <span class="Type">int</span> nf, <span class="Type">int</span> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *dtype, <span class="Type">struct</span> pg_itm_in *itm_in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; force_negative = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_before = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; parsing_unit_val = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fmask = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; fval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *dtype = DTK_DELTA;<br/></li>
<li>&nbsp; &nbsp; type = IGNORE_DTF;<br/></li>
<li>&nbsp; &nbsp; <a href="#L3329" title="utils/adt/datetime.c:3329">ClearPgItmIn</a>(itm_in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The SQL standard defines the interval literal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; '-1 1:00:00'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to mean &quot;negative 1 <a href="#L84" title="utils/adt/datetime.c:84">days</a> and negative 1 hours&quot;, while Postgres<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * traditionally treats this as meaning &quot;negative 1 <a href="#L84" title="utils/adt/datetime.c:84">days</a> and positive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 1 hours&quot;.&nbsp; In SQL_STANDARD intervalstyle, we apply the leading sign<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to all fields if there are no other explicit signs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We leave the signs alone if there are additional explicit signs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This protects us against misinterpreting postgres-style <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> output,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since the postgres-style output code has always put an explicit sign on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all fields following a negative field.&nbsp; But note that SQL-spec output<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is ambiguous and can be misinterpreted on load!&nbsp; &nbsp; (So it's best practice<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> in postgres style, not SQL style.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L124" title="utils/init/globals.c:124">IntervalStyle</a> == INTSTYLE_SQL_STANDARD &amp;&amp; nf &gt; <span class="Constant">0</span> &amp;&amp; *field[<span class="Constant">0</span>] == <span class="Constant">'-'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; force_negative = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for additional explicit signs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; nf; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*field[i] == <span class="Constant">'-'</span> || *field[i] == <span class="Constant">'+'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; force_negative = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read through list backwards to pick up units <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = nf - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (ftype[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TIME:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L2690" title="utils/adt/datetime.c:2690">DecodeTimeForInterval</a>(field[i], fmask, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tmask, itm_in);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (force_negative &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itm_in-&gt;tm_usec &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itm_in-&gt;tm_usec = -itm_in-&gt;tm_usec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = DTK_DAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsing_unit_val = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_TZ:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Timezone means a token with a leading sign character and at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * least one digit; there could be ':', '.', '-' embedded in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(*field[i] == <span class="Constant">'-'</span> || *field[i] == <span class="Constant">'+'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for signed hh:mm or hh:mm:ss.&nbsp; If so, process exactly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * like DTK_TIME case above, plus handling the sign.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strchr(field[i] + <span class="Constant">1</span>, <span class="Constant">':'</span>) != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2690" title="utils/adt/datetime.c:2690">DecodeTimeForInterval</a>(field[i] + <span class="Constant">1</span>, fmask, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tmask, itm_in) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*field[i] == <span class="Constant">'-'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* flip the sign on time field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (itm_in-&gt;tm_usec == PG_INT64_MIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itm_in-&gt;tm_usec = -itm_in-&gt;tm_usec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (force_negative &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itm_in-&gt;tm_usec &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itm_in-&gt;tm_usec = -itm_in-&gt;tm_usec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> type to be a day, if units are not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * specified. This handles the case of '1 +02:03' since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are reading right to left.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = DTK_DAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsing_unit_val = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, fall through to DTK_NUMBER case, which can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * handle signed float numbers and signed year-month <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_NUMBER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (type == IGNORE_DTF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* use typmod to decide what rightmost field is */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(YEAR):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = DTK_YEAR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(MONTH):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(YEAR) | INTERVAL_MASK(MONTH):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = DTK_MONTH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(DAY):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = DTK_DAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(HOUR):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = DTK_HOUR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(MINUTE):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = DTK_MINUTE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(SECOND):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVAL_MASK(DAY) | INTERVAL_MASK(HOUR) | INTERVAL_MASK(MINUTE) | INTERVAL_MASK(SECOND):<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = DTK_SECOND;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = DTK_SECOND;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = strtoi64(field[i], &amp;cp, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ERANGE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp == <span class="Constant">'-'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SQL &quot;years-<a href="#L81" title="utils/adt/datetime.c:81">months</a>&quot; syntax */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val2 = strtoint(cp + <span class="Constant">1</span>, &amp;cp, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ERANGE</span> || val2 &lt; <span class="Constant">0</span> || val2 &gt;= MONTHS_PER_YEAR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*cp != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = DTK_MONTH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*field[i] == <span class="Constant">'-'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val2 = -val2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_mul_s64_overflow(val, MONTHS_PER_YEAR, &amp;val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_add_s64_overflow(val, val2, &amp;val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fval = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*cp == <span class="Constant">'.'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L680" title="utils/adt/datetime.c:680">ParseFraction</a>(cp, &amp;fval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*field[i] == <span class="Constant">'-'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fval = -fval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*cp == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fval = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* DTK_M(type); */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (force_negative)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* val and fval should be of same sign, but test anyway */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (val &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = -val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fval &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fval = -fval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MICROSEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L618" title="utils/adt/datetime.c:618">AdjustMicroseconds</a>(val, fval, <span class="Constant">1</span>, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(MICROSECOND);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLISEC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L618" title="utils/adt/datetime.c:618">AdjustMicroseconds</a>(val, fval, <span class="Constant">1000</span>, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(MILLISECOND);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_SECOND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L618" title="utils/adt/datetime.c:618">AdjustMicroseconds</a>(val, fval, USECS_PER_SEC, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subseconds were specified, consider this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * microsecond and millisecond input as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fval == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(SECOND);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_ALL_SECS_M;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MINUTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L618" title="utils/adt/datetime.c:618">AdjustMicroseconds</a>(val, fval, USECS_PER_MINUTE, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(MINUTE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_HOUR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L618" title="utils/adt/datetime.c:618">AdjustMicroseconds</a>(val, fval, USECS_PER_HOUR, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(HOUR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = DTK_DAY; <span class="Comment">/* set for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DAY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L633" title="utils/adt/datetime.c:633">AdjustDays</a>(val, <span class="Constant">1</span>, itm_in) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L537" title="utils/adt/datetime.c:537">AdjustFractMicroseconds</a>(fval, USECS_PER_DAY, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(DAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_WEEK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L633" title="utils/adt/datetime.c:633">AdjustDays</a>(val, <span class="Constant">7</span>, itm_in) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L569" title="utils/adt/datetime.c:569">AdjustFractDays</a>(fval, <span class="Constant">7</span>, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(WEEK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MONTH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L649" title="utils/adt/datetime.c:649">AdjustMonths</a>(val, itm_in) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L569" title="utils/adt/datetime.c:569">AdjustFractDays</a>(fval, DAYS_PER_MONTH, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(MONTH);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_YEAR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L661" title="utils/adt/datetime.c:661">AdjustYears</a>(val, <span class="Constant">1</span>, itm_in) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L601" title="utils/adt/datetime.c:601">AdjustFractYears</a>(fval, <span class="Constant">1</span>, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(YEAR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_DECADE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L661" title="utils/adt/datetime.c:661">AdjustYears</a>(val, <span class="Constant">10</span>, itm_in) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L601" title="utils/adt/datetime.c:601">AdjustFractYears</a>(fval, <span class="Constant">10</span>, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(DECADE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_CENTURY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L661" title="utils/adt/datetime.c:661">AdjustYears</a>(val, <span class="Constant">100</span>, itm_in) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L601" title="utils/adt/datetime.c:601">AdjustFractYears</a>(fval, <span class="Constant">100</span>, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(CENTURY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_MILLENNIUM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L661" title="utils/adt/datetime.c:661">AdjustYears</a>(val, <span class="Constant">1000</span>, itm_in) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L601" title="utils/adt/datetime.c:601">AdjustFractYears</a>(fval, <span class="Constant">1000</span>, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = DTK_M(MILLENNIUM);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsing_unit_val = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_STRING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTK_SPECIAL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reject consecutive unhandled units */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsing_unit_val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = <a href="#L4036" title="utils/adt/datetime.c:4036">DecodeUnits</a>(i, field[i], &amp;uval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (type == UNKNOWN_FIELD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = <a href="#L3137" title="utils/adt/datetime.c:3137">DecodeSpecial</a>(i, field[i], &amp;uval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (type == IGNORE_DTF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* DTK_M(type); */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> UNITS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = uval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsing_unit_val = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AGO:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;ago&quot; is only allowed to appear at the end of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interval.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i != nf - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_before = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type = uval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RESERV:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmask = (DTK_DATE_M | DTK_TIME_M);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only reserved words corresponding to infinite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * intervals are accepted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (uval != DTK_LATE &amp;&amp; uval != DTK_EARLY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Infinity cannot be followed by anything else. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could allow &quot;ago&quot; to reverse the sign of infinity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but using signed infinity is more intuitive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i != nf - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *dtype = uval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tmask &amp; fmask)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fmask |= tmask;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ensure that at least one time field has been found */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fmask == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reject if unit appeared and was never handled */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parsing_unit_val)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* finally, AGO negates everything */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_before)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (itm_in-&gt;tm_usec == PG_INT64_MIN ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itm_in-&gt;tm_mday == <span class="Constant">INT_MIN</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itm_in-&gt;tm_mon == <span class="Constant">INT_MIN</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itm_in-&gt;tm_year == <span class="Constant">INT_MIN</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itm_in-&gt;tm_usec = -itm_in-&gt;tm_usec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itm_in-&gt;tm_mday = -itm_in-&gt;tm_mday;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itm_in-&gt;tm_mon = -itm_in-&gt;tm_mon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itm_in-&gt;tm_year = -itm_in-&gt;tm_year;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to avoid duplicated code in <a href="#L3818" title="utils/adt/datetime.c:3818">DecodeISO8601Interval</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Parse a decimal value and break it into integer and fractional parts.<br/></li>
<li></span><span class="Comment"> * Set *endptr to end+1 of the parsed substring.<br/></li>
<li></span><span class="Comment"> * Returns 0 or DTERR code.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L3749">&#x200c;</a></span><span class="linkable">ParseISO8601Number</span>(<span class="Type">char</span> *str, <span class="Type">char</span> **endptr, int64 *ipart, <span class="Type">double</span> *fpart)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Historically this has accepted anything that strtod() would take,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * notably including &quot;e&quot; notation, so continue doing that.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slightly annoying because the precision of double is less than that of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * int64, so we would lose accuracy for inputs larger than 2^53 or so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, historically we rejected inputs outside the int32 <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * making that concern moot.&nbsp; What we do <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> is reject abs(val) above<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 1.0e15 (a round number a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> less than 2^50), so that <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> accepted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value will have an exact integer part, and thereby a fraction part with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * abs(*fpart) less than 1.&nbsp; In the absence of field complaints it doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seem worth working harder.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(isdigit((<span class="Type">unsigned</span> <span class="Type">char</span>) *str) || *str == <span class="Constant">'-'</span> || *str == <span class="Constant">'.'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; val = strtod(str, endptr);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* did we not see anything that looks like a double? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*endptr == str || errno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* watch out for overflow, including infinities; reject NaN too */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(val) || val &lt; -<span class="Constant">1.0e15</span> || val &gt; <span class="Constant">1.0e15</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* be very sure we truncate towards zero (cf <a href="float.c.html#L1421" title="utils/adt/float.c:1421">dtrunc</a>()) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (val &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ipart = (int64) floor(val);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *ipart = (int64) -floor(-val);<br/></li>
<li>&nbsp; &nbsp; *fpart = val - *ipart;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Callers expect this to hold */<br/></li>
<li></span>&nbsp; &nbsp; Assert(*fpart &gt; -<span class="Constant">1.0</span> &amp;&amp; *fpart &lt; <span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine number of integral digits in a valid ISO 8601 number field<br/></li>
<li></span><span class="Comment"> * (we should ignore sign and <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fraction part)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L3791">&#x200c;</a></span><span class="linkable">ISO8601IntegerWidth</span>(<span class="Type">char</span> *fieldstart)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We might have had a leading '-' */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*fieldstart == <span class="Constant">'-'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fieldstart++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> strspn(fieldstart, <span class="Constant">&quot;0123456789&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L3818" title="utils/adt/datetime.c:3818">DecodeISO8601Interval</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Decode an ISO 8601 time interval of the &quot;format with designators&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (section 4.4.3.2) or &quot;alternative format&quot; (section 4.4.3.3)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Examples:&nbsp; P1D&nbsp; &nbsp; for 1 day<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PT1H for 1 hour<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; P2Y6M7DT1H30M for 2 years, 6 <a href="#L81" title="utils/adt/datetime.c:81">months</a>, 7 <a href="#L84" title="utils/adt/datetime.c:84">days</a> 1 hour 30 min<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; P0002-06-07T01:30:00 the same value in alternative format<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 0 if successful, DTERR code if bogus input detected.<br/></li>
<li></span><span class="Comment"> * Note: error code should be DTERR_BAD_FORMAT if input doesn't look like<br/></li>
<li></span><span class="Comment"> * ISO8601, otherwise this could cause unexpected error messages.<br/></li>
<li></span><span class="Comment"> * dtype and itm_in are output parameters.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; A couple exceptions from the spec:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; - a week field ('W') may coexist with other units<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; - allows decimals in fields other than the least significant unit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3818">&#x200c;</a></span><span class="linkable">DecodeISO8601Interval</span>(<span class="Type">char</span> *str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *dtype, <span class="Type">struct</span> pg_itm_in *itm_in)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; datepart = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; havefield = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *dtype = DTK_DELTA;<br/></li>
<li>&nbsp; &nbsp; <a href="#L3329" title="utils/adt/datetime.c:3329">ClearPgItmIn</a>(itm_in);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strlen(str) &lt; <span class="Constant">2</span> || str[<span class="Constant">0</span>] != <span class="Constant">'P'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; str++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (*str)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *fieldstart;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; fval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; unit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*str == <span class="Constant">'T'</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* T indicates the beginning of the time part */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datepart = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; havefield = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fieldstart = str;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L3749" title="utils/adt/datetime.c:3749">ParseISO8601Number</a>(str, &amp;str, &amp;val, &amp;fval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we could step off the end of the string here.&nbsp; Code below<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * *must* exit the loop if unit == '\0'.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; unit = *str++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (datepart)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (unit)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> T: Y M W D */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'Y'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L661" title="utils/adt/datetime.c:661">AdjustYears</a>(val, <span class="Constant">1</span>, itm_in) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L601" title="utils/adt/datetime.c:601">AdjustFractYears</a>(fval, <span class="Constant">1</span>, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'M'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L649" title="utils/adt/datetime.c:649">AdjustMonths</a>(val, itm_in) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L569" title="utils/adt/datetime.c:569">AdjustFractDays</a>(fval, DAYS_PER_MONTH, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'W'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L633" title="utils/adt/datetime.c:633">AdjustDays</a>(val, <span class="Constant">7</span>, itm_in) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L569" title="utils/adt/datetime.c:569">AdjustFractDays</a>(fval, <span class="Constant">7</span>, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'D'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L633" title="utils/adt/datetime.c:633">AdjustDays</a>(val, <span class="Constant">1</span>, itm_in) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L537" title="utils/adt/datetime.c:537">AdjustFractMicroseconds</a>(fval, USECS_PER_DAY, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'T'</span>:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ISO 8601 4.4.3.3 Alternative Format / Basic */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Special">'\0'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3791" title="utils/adt/datetime.c:3791">ISO8601IntegerWidth</a>(fieldstart) == <span class="Constant">8</span> &amp;&amp; !havefield)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L661" title="utils/adt/datetime.c:661">AdjustYears</a>(val / <span class="Constant">10000</span>, <span class="Constant">1</span>, itm_in) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L649" title="utils/adt/datetime.c:649">AdjustMonths</a>((val / <span class="Constant">100</span>) % <span class="Constant">100</span>, itm_in) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L633" title="utils/adt/datetime.c:633">AdjustDays</a>(val % <span class="Constant">100</span>, <span class="Constant">1</span>, itm_in) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L537" title="utils/adt/datetime.c:537">AdjustFractMicroseconds</a>(fval, USECS_PER_DAY, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unit == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datepart = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; havefield = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Else fall through to extended alternative format */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'-'</span>:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ISO 8601 4.4.3.3 Alternative Format,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Extended */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (havefield)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L661" title="utils/adt/datetime.c:661">AdjustYears</a>(val, <span class="Constant">1</span>, itm_in) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L601" title="utils/adt/datetime.c:601">AdjustFractYears</a>(fval, <span class="Constant">1</span>, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unit == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unit == <span class="Constant">'T'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datepart = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; havefield = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L3749" title="utils/adt/datetime.c:3749">ParseISO8601Number</a>(str, &amp;str, &amp;val, &amp;fval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L649" title="utils/adt/datetime.c:649">AdjustMonths</a>(val, itm_in) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L569" title="utils/adt/datetime.c:569">AdjustFractDays</a>(fval, DAYS_PER_MONTH, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*str == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*str == <span class="Constant">'T'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datepart = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; havefield = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*str != <span class="Constant">'-'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L3749" title="utils/adt/datetime.c:3749">ParseISO8601Number</a>(str, &amp;str, &amp;val, &amp;fval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L633" title="utils/adt/datetime.c:633">AdjustDays</a>(val, <span class="Constant">1</span>, itm_in) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L537" title="utils/adt/datetime.c:537">AdjustFractMicroseconds</a>(fval, USECS_PER_DAY, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*str == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*str == <span class="Constant">'T'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datepart = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; havefield = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not a valid date unit suffix */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (unit)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* after T: H M S */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'H'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L618" title="utils/adt/datetime.c:618">AdjustMicroseconds</a>(val, fval, USECS_PER_HOUR, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'M'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L618" title="utils/adt/datetime.c:618">AdjustMicroseconds</a>(val, fval, USECS_PER_MINUTE, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'S'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L618" title="utils/adt/datetime.c:618">AdjustMicroseconds</a>(val, fval, USECS_PER_SEC, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Special">'\0'</span>:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ISO 8601 4.4.3.3 Alternative Format */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3791" title="utils/adt/datetime.c:3791">ISO8601IntegerWidth</a>(fieldstart) == <span class="Constant">6</span> &amp;&amp; !havefield)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L618" title="utils/adt/datetime.c:618">AdjustMicroseconds</a>(val / <span class="Constant">10000</span>, <span class="Constant">0</span>, USECS_PER_HOUR, itm_in) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L618" title="utils/adt/datetime.c:618">AdjustMicroseconds</a>((val / <span class="Constant">100</span>) % <span class="Constant">100</span>, <span class="Constant">0</span>, USECS_PER_MINUTE, itm_in) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L618" title="utils/adt/datetime.c:618">AdjustMicroseconds</a>(val % <span class="Constant">100</span>, <span class="Constant">0</span>, USECS_PER_SEC, itm_in) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L537" title="utils/adt/datetime.c:537">AdjustFractMicroseconds</a>(fval, <span class="Constant">1</span>, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Else fall through to extended alternative format */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">':'</span>:&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ISO 8601 4.4.3.3 Alternative Format,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Extended */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (havefield)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L618" title="utils/adt/datetime.c:618">AdjustMicroseconds</a>(val, fval, USECS_PER_HOUR, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unit == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L3749" title="utils/adt/datetime.c:3749">ParseISO8601Number</a>(str, &amp;str, &amp;val, &amp;fval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L618" title="utils/adt/datetime.c:618">AdjustMicroseconds</a>(val, fval, USECS_PER_MINUTE, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*str == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*str != <span class="Constant">':'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="#L3749" title="utils/adt/datetime.c:3749">ParseISO8601Number</a>(str, &amp;str, &amp;val, &amp;fval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L618" title="utils/adt/datetime.c:618">AdjustMicroseconds</a>(val, fval, USECS_PER_SEC, itm_in))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_FIELD_OVERFLOW;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*str == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not a valid time unit suffix */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> DTERR_BAD_FORMAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; havefield = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L4036" title="utils/adt/datetime.c:4036">DecodeUnits</a>()<br/></li>
<li></span><span class="Comment"> * Decode text string using lookup table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine recognizes keywords associated with time interval units.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given string must be lowercased already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Implement a cache lookup since it is likely that dates<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; will be related in format.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L4036">&#x200c;</a></span><span class="linkable">DecodeUnits</span>(<span class="Type">int</span> field, <span class="Type">const</span> <span class="Type">char</span> *lowtoken, <span class="Type">int</span> *val)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> datetkn *tp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="#L260" title="utils/adt/datetime.c:260">deltacache</a>[field];<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use strncmp so that we match truncated tokens */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tp == <span class="Constant">NULL</span> || strncmp(lowtoken, tp-&gt;token, TOKMAXLEN) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tp = <a href="#L4142" title="utils/adt/datetime.c:4142">datebsearch</a>(lowtoken, <a href="#L187" title="utils/adt/datetime.c:187">deltatktbl</a>, <a href="#L252" title="utils/adt/datetime.c:252">szdeltatktbl</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; type = UNKNOWN_FIELD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *val = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L260" title="utils/adt/datetime.c:260">deltacache</a>[field] = tp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; type = tp-&gt;type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *val = tp-&gt;value;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> type;<br/></li>
<li>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L4036" title="utils/adt/datetime.c:4036">DecodeUnits</a>() */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report an error detected by one of the datetime input processing routines.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * dterr is the error code, and *extra contains <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> auxiliary info we need<br/></li>
<li></span><span class="Comment"> * for the error report.&nbsp; extra can be NULL if not needed for the particular<br/></li>
<li></span><span class="Comment"> * dterr value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * str is the original input string, and datatype is the name of the datatype<br/></li>
<li></span><span class="Comment"> * we were trying to <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a>.&nbsp; (For some DTERR codes, these are not used and<br/></li>
<li></span><span class="Comment"> * can be NULL.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If escontext points to an ErrorSaveContext node, that is filled instead<br/></li>
<li></span><span class="Comment"> * of throwing an error.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: it might seem useless to distinguish DTERR_INTERVAL_OVERFLOW and<br/></li>
<li></span><span class="Comment"> * DTERR_TZDISP_OVERFLOW from DTERR_FIELD_OVERFLOW, but SQL99 mandates three<br/></li>
<li></span><span class="Comment"> * separate SQLSTATE codes, so ...<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4081">&#x200c;</a></span><span class="linkable">DateTimeParseError</span>(<span class="Type">int</span> dterr, DateTimeErrorExtra *extra,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *str, <span class="Type">const</span> <span class="Type">char</span> *datatype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *escontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (dterr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTERR_FIELD_OVERFLOW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errsave(escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_FIELD_OVERFLOW),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;date/time field value out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTERR_MD_FIELD_OVERFLOW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &lt;nanny&gt;same as above, but add hint about <a href="../init/globals.c.html#L122" title="utils/init/globals.c:122">DateStyle</a>&lt;/nanny&gt; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errsave(escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATETIME_FIELD_OVERFLOW),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;date/time field value out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Perhaps you need a different </span><span class="Special">\&quot;</span><span class="Constant">datestyle</span><span class="Special">\&quot;</span><span class="Constant"> setting.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTERR_INTERVAL_OVERFLOW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errsave(escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERVAL_FIELD_OVERFLOW),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;interval field value out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTERR_TZDISP_OVERFLOW:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errsave(escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;time zone displacement out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTERR_BAD_TIMEZONE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errsave(escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;time zone </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not recognized&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra-&gt;dtee_timezone)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTERR_BAD_ZONE_ABBREV:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errsave(escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONFIG_FILE_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;time zone </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not recognized&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra-&gt;dtee_timezone),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;This time zone name appears in the configuration file for time zone abbreviation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; extra-&gt;dtee_abbrev)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTERR_BAD_FORMAT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errsave(escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_DATETIME_FORMAT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid input syntax for type </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datatype, str)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L4142" title="utils/adt/datetime.c:4142">datebsearch</a>()<br/></li>
<li></span><span class="Comment"> * Binary search -- from Knuth (6.2.1) Algorithm B.&nbsp; Special case like this<br/></li>
<li></span><span class="Comment"> * is WAY faster than the generic bsearch().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> datetkn *<br/></li>
<li><a id="L4142">&#x200c;</a><span class="linkable">datebsearch</span>(<span class="Type">const</span> <span class="Type">char</span> *key, <span class="Type">const</span> datetkn *base, <span class="Type">int</span> nel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nel &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> datetkn *last = base + nel - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *position;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (last &gt;= base)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; position = base + ((last - base) &gt;&gt; <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* precheck the first character for a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of extra speed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">int</span>) key[<span class="Constant">0</span>] - (<span class="Type">int</span>) position-&gt;token[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* use strncmp so that we match truncated tokens */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = strncmp(key, position-&gt;token, TOKMAXLEN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> position;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last = position - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base = position + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L4178" title="utils/adt/datetime.c:4178">EncodeTimezone</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Copies representation of a <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> timezone offset to str.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a pointer to the new end of string.&nbsp; No NUL terminator is put<br/></li>
<li></span><span class="Comment"> * there; callers are responsible for NUL terminating str themselves.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L4178">&#x200c;</a><span class="linkable">EncodeTimezone</span>(<span class="Type">char</span> *str, <span class="Type">int</span> tz, <span class="Type">int</span> style)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hour,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sec = abs(tz);<br/></li>
<li>&nbsp; &nbsp; min = sec / SECS_PER_MINUTE;<br/></li>
<li>&nbsp; &nbsp; sec -= min * SECS_PER_MINUTE;<br/></li>
<li>&nbsp; &nbsp; hour = min / MINS_PER_HOUR;<br/></li>
<li>&nbsp; &nbsp; min -= hour * MINS_PER_HOUR;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* TZ is negated compared to sign we wish to display ... */<br/></li>
<li></span>&nbsp; &nbsp; *str++ = (tz &lt;= <span class="Constant">0</span> ? <span class="Constant">'+'</span> : <span class="Constant">'-'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sec != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, hour, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">':'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, min, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">':'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, sec, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (min != <span class="Constant">0</span> || style == USE_XSD_DATES)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, hour, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">':'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, min, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, hour, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> str;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L4216" title="utils/adt/datetime.c:4216">EncodeDateOnly</a>()<br/></li>
<li></span><span class="Comment"> * Encode date as local time.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4216">&#x200c;</a></span><span class="linkable">EncodeDateOnly</span>(<span class="Type">struct</span> pg_tm *tm, <span class="Type">int</span> style, <span class="Type">char</span> *str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(tm-&gt;tm_mon &gt;= <span class="Constant">1</span> &amp;&amp; tm-&gt;tm_mon &lt;= MONTHS_PER_YEAR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (style)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> USE_ISO_DATES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> USE_XSD_DATES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* compatible with ISO date formats */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (tm-&gt;tm_year &gt; <span class="Constant">0</span>) ? tm-&gt;tm_year : -(tm-&gt;tm_year - <span class="Constant">1</span>), <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">'-'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mon, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">'-'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mday, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> USE_SQL_DATES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* compatible with Oracle/Ingres date formats */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L123" title="utils/init/globals.c:123">DateOrder</a> == DATEORDER_DMY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mday, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">'/'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mon, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mon, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">'/'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mday, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">'/'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (tm-&gt;tm_year &gt; <span class="Constant">0</span>) ? tm-&gt;tm_year : -(tm-&gt;tm_year - <span class="Constant">1</span>), <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> USE_GERMAN_DATES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* German-style date format */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mday, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">'.'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mon, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">'.'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (tm-&gt;tm_year &gt; <span class="Constant">0</span>) ? tm-&gt;tm_year : -(tm-&gt;tm_year - <span class="Constant">1</span>), <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> USE_POSTGRES_DATES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* traditional date-only style for Postgres */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L123" title="utils/init/globals.c:123">DateOrder</a> == DATEORDER_DMY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mday, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">'-'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mon, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mon, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">'-'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mday, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">'-'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (tm-&gt;tm_year &gt; <span class="Constant">0</span>) ? tm-&gt;tm_year : -(tm-&gt;tm_year - <span class="Constant">1</span>), <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_year &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(str, <span class="Constant">&quot; BC&quot;</span>, <span class="Constant">3</span>);&nbsp; &nbsp; <span class="Comment">/* Don't copy NUL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; str += <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *str = <span class="Special">'\0'</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L4301" title="utils/adt/datetime.c:4301">EncodeTimeOnly</a>()<br/></li>
<li></span><span class="Comment"> * Encode time fields only.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tm and fsec are the value to encode, print_tz determines whether to include<br/></li>
<li></span><span class="Comment"> * a time zone (the difference between time and timetz types), tz is the<br/></li>
<li></span><span class="Comment"> * <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> time zone offset, style is the date style, str is where to write the<br/></li>
<li></span><span class="Comment"> * output.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4301">&#x200c;</a></span><span class="linkable">EncodeTimeOnly</span>(<span class="Type">struct</span> pg_tm *tm, fsec_t fsec, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> print_tz, <span class="Type">int</span> tz, <span class="Type">int</span> style, <span class="Type">char</span> *str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_hour, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; *str++ = <span class="Constant">':'</span>;<br/></li>
<li>&nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_min, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; *str++ = <span class="Constant">':'</span>;<br/></li>
<li>&nbsp; &nbsp; str = <a href="#L448" title="utils/adt/datetime.c:448">AppendSeconds</a>(str, tm-&gt;tm_sec, fsec, MAX_TIME_PRECISION, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (print_tz)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str = <a href="#L4178" title="utils/adt/datetime.c:4178">EncodeTimezone</a>(str, tz, style);<br/></li>
<li>&nbsp; &nbsp; *str = <span class="Special">'\0'</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L4331" title="utils/adt/datetime.c:4331">EncodeDateTime</a>()<br/></li>
<li></span><span class="Comment"> * Encode date and time interpreted as local time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tm and fsec are the value to encode, print_tz determines whether to include<br/></li>
<li></span><span class="Comment"> * a time zone (the difference between timestamp and timestamptz types), tz is<br/></li>
<li></span><span class="Comment"> * the <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> time zone offset, tzn is the textual time zone, which if<br/></li>
<li></span><span class="Comment"> * specified will be used instead of tz by some styles, style is the date<br/></li>
<li></span><span class="Comment"> * style, str is where to write the output.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Supported date styles:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Postgres - day mon hh:mm:ss yyyy tz<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; SQL - mm/dd/yyyy hh:mm:ss.ss tz<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; ISO - yyyy-mm-dd hh:mm:ss+/-tz<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; German - dd.mm.yyyy hh:mm:ss tz<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; XSD - yyyy-mm-ddThh:mm:ss.ss+/-tz<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4331">&#x200c;</a></span><span class="linkable">EncodeDateTime</span>(<span class="Type">struct</span> pg_tm *tm, fsec_t fsec, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> print_tz, <span class="Type">int</span> tz, <span class="Type">const</span> <span class="Type">char</span> *tzn, <span class="Type">int</span> style, <span class="Type">char</span> *str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; day;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(tm-&gt;tm_mon &gt;= <span class="Constant">1</span> &amp;&amp; tm-&gt;tm_mon &lt;= MONTHS_PER_YEAR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Negative tm_isdst means we have no valid time zone translation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_isdst &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; print_tz = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (style)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> USE_ISO_DATES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> USE_XSD_DATES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compatible with ISO-8601 date formats */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (tm-&gt;tm_year &gt; <span class="Constant">0</span>) ? tm-&gt;tm_year : -(tm-&gt;tm_year - <span class="Constant">1</span>), <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">'-'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mon, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">'-'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mday, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = (style == USE_ISO_DATES) ? <span class="Constant">' '</span> : <span class="Constant">'T'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_hour, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">':'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_min, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">':'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="#L511" title="utils/adt/datetime.c:511">AppendTimestampSeconds</a>(str, tm, fsec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (print_tz)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="#L4178" title="utils/adt/datetime.c:4178">EncodeTimezone</a>(str, tz, style);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> USE_SQL_DATES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compatible with Oracle/Ingres date formats */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L123" title="utils/init/globals.c:123">DateOrder</a> == DATEORDER_DMY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mday, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">'/'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mon, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mon, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">'/'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mday, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">'/'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (tm-&gt;tm_year &gt; <span class="Constant">0</span>) ? tm-&gt;tm_year : -(tm-&gt;tm_year - <span class="Constant">1</span>), <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">' '</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_hour, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">':'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_min, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">':'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="#L511" title="utils/adt/datetime.c:511">AppendTimestampSeconds</a>(str, tm, fsec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: the uses of %.*s in this function would be risky if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * timezone names ever contain non-ASCII characters, since we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not being careful to do encoding-aware clipping.&nbsp; However, all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TZ abbreviations in the IANA database are plain ASCII.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (print_tz)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(str, <span class="Constant">&quot; </span><span class="Special">%.*s</span><span class="Constant">&quot;</span>, MAXTZLEN, tzn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str += strlen(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="#L4178" title="utils/adt/datetime.c:4178">EncodeTimezone</a>(str, tz, style);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> USE_GERMAN_DATES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* German variant on European style */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mday, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">'.'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mon, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">'.'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (tm-&gt;tm_year &gt; <span class="Constant">0</span>) ? tm-&gt;tm_year : -(tm-&gt;tm_year - <span class="Constant">1</span>), <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">' '</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_hour, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">':'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_min, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">':'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="#L511" title="utils/adt/datetime.c:511">AppendTimestampSeconds</a>(str, tm, fsec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (print_tz)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(str, <span class="Constant">&quot; </span><span class="Special">%.*s</span><span class="Constant">&quot;</span>, MAXTZLEN, tzn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str += strlen(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="#L4178" title="utils/adt/datetime.c:4178">EncodeTimezone</a>(str, tz, style);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> USE_POSTGRES_DATES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Backward-compatible with traditional Postgres abstime dates */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; day = <a href="#L286" title="utils/adt/datetime.c:286">date2j</a>(tm-&gt;tm_year, tm-&gt;tm_mon, tm-&gt;tm_mday);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tm-&gt;tm_wday = <a href="#L344" title="utils/adt/datetime.c:344">j2day</a>(day);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(str, <a href="#L84" title="utils/adt/datetime.c:84">days</a>[tm-&gt;tm_wday], <span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str += <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">' '</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../init/globals.c.html#L123" title="utils/init/globals.c:123">DateOrder</a> == DATEORDER_DMY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mday, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">' '</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(str, <a href="#L81" title="utils/adt/datetime.c:81">months</a>[tm-&gt;tm_mon - <span class="Constant">1</span>], <span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str += <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(str, <a href="#L81" title="utils/adt/datetime.c:81">months</a>[tm-&gt;tm_mon - <span class="Constant">1</span>], <span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str += <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">' '</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_mday, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">' '</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_hour, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">':'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str, tm-&gt;tm_min, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">':'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="#L511" title="utils/adt/datetime.c:511">AppendTimestampSeconds</a>(str, tm, fsec);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">' '</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="numutils.c.html#L1269" title="utils/adt/numutils.c:1269">pg_ultostr_zeropad</a>(str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (tm-&gt;tm_year &gt; <span class="Constant">0</span>) ? tm-&gt;tm_year : -(tm-&gt;tm_year - <span class="Constant">1</span>), <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (print_tz)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(str, <span class="Constant">&quot; </span><span class="Special">%.*s</span><span class="Constant">&quot;</span>, MAXTZLEN, tzn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str += strlen(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have a time zone, but no string version. Use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> form, but be sure to include a leading space to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * avoid formatting something which would be rejected by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the date/time parser later. - thomas 2001-10-19<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *str++ = <span class="Constant">' '</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = <a href="#L4178" title="utils/adt/datetime.c:4178">EncodeTimezone</a>(str, tz, style);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tm-&gt;tm_year &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(str, <span class="Constant">&quot; BC&quot;</span>, <span class="Constant">3</span>);&nbsp; &nbsp; <span class="Comment">/* Don't copy NUL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; str += <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *str = <span class="Special">'\0'</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to avoid duplicated code in <a href="#L4574" title="utils/adt/datetime.c:4574">EncodeInterval</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Append an ISO-8601-style interval field, but only if value isn't zero */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L4502">&#x200c;</a><span class="linkable">AddISO8601IntPart</span>(<span class="Type">char</span> *cp, int64 value, <span class="Type">char</span> units)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (value == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cp;<br/></li>
<li>&nbsp; &nbsp; sprintf(cp, <span class="Constant">&quot;</span><span class="Special">%lld%c</span><span class="Constant">&quot;</span>, (<span class="Type">long</span> <span class="Type">long</span>) value, units);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cp + strlen(cp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Append a postgres-style interval field, but only if value isn't zero */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L4512">&#x200c;</a><span class="linkable">AddPostgresIntPart</span>(<span class="Type">char</span> *cp, int64 value, <span class="Type">const</span> <span class="Type">char</span> *units,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *is_zero, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *is_before)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (value == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cp;<br/></li>
<li>&nbsp; &nbsp; sprintf(cp, <span class="Constant">&quot;</span><span class="Special">%s%s%lld</span><span class="Constant"> </span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (!*is_zero) ? <span class="Constant">&quot; &quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*is_before &amp;&amp; value &gt; <span class="Constant">0</span>) ? <span class="Constant">&quot;+&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; units,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (value != <span class="Constant">1</span>) ? <span class="Constant">&quot;s&quot;</span> : <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Each nonzero field sets is_before for (only) the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one.&nbsp; This is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tad bizarre but it's how it worked <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *is_before = (value &lt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; *is_zero = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cp + strlen(cp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Append a verbose-style interval field, but only if value isn't zero */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L4535">&#x200c;</a><span class="linkable">AddVerboseIntPart</span>(<span class="Type">char</span> *cp, int64 value, <span class="Type">const</span> <span class="Type">char</span> *units,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *is_zero, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *is_before)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (value == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cp;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* first nonzero value sets is_before */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*is_zero)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *is_before = (value &lt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; value = i64abs(value);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*is_before)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; value = -value;<br/></li>
<li>&nbsp; &nbsp; sprintf(cp, <span class="Constant">&quot; </span><span class="Special">%lld</span><span class="Constant"> </span><span class="Special">%s%s</span><span class="Constant">&quot;</span>, (<span class="Type">long</span> <span class="Type">long</span>) value, units, (value == <span class="Constant">1</span>) ? <span class="Constant">&quot;&quot;</span> : <span class="Constant">&quot;s&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; *is_zero = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cp + strlen(cp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L4574" title="utils/adt/datetime.c:4574">EncodeInterval</a>()<br/></li>
<li></span><span class="Comment"> * Interpret time structure as a delta time and convert to string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Support &quot;traditional Postgres&quot; and ISO-8601 styles.<br/></li>
<li></span><span class="Comment"> * Actually, afaik ISO does not address time interval formatting,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; but this looks similar to the spec for absolute date/time.<br/></li>
<li></span><span class="Comment"> * - thomas 1998-04-30<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Actually, afaik, ISO 8601 does specify formats for &quot;time<br/></li>
<li></span><span class="Comment"> * intervals...[of the]...format with time-unit designators&quot;, which<br/></li>
<li></span><span class="Comment"> * are pretty ugly.&nbsp; The format looks something like<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; P1Y1M1DT1H1M1.12345S<br/></li>
<li></span><span class="Comment"> * but useful for exchanging data with computers instead of humans.<br/></li>
<li></span><span class="Comment"> * - ron 2003-07-14<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * And ISO's SQL 2008 standard specifies standards for<br/></li>
<li></span><span class="Comment"> * &quot;year-month literal&quot;s (that look like '2-3') and<br/></li>
<li></span><span class="Comment"> * &quot;day-time literal&quot;s (that look like ('4 5:6:7')<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4574">&#x200c;</a></span><span class="linkable">EncodeInterval</span>(<span class="Type">struct</span> pg_itm *itm, <span class="Type">int</span> style, <span class="Type">char</span> *str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cp = str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; year = itm-&gt;tm_year;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mon = itm-&gt;tm_mon;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; mday = itm-&gt;tm_mday;&nbsp; &nbsp; <span class="Comment">/* tm_mday could be INT_MIN */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; hour = itm-&gt;tm_hour;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min = itm-&gt;tm_min;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sec = itm-&gt;tm_sec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec = itm-&gt;tm_usec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_before = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_zero = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The sign of year and month are guaranteed to match, since they are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stored internally as &quot;month&quot;. But we'll need to check for is_before and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is_zero when determining the signs of day and hour/minute/seconds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (style)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SQL Standard interval format */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTSTYLE_SQL_STANDARD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_negative = year &lt; <span class="Constant">0</span> || mon &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mday &lt; <span class="Constant">0</span> || hour &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min &lt; <span class="Constant">0</span> || sec &lt; <span class="Constant">0</span> || fsec &lt; <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_positive = year &gt; <span class="Constant">0</span> || mon &gt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mday &gt; <span class="Constant">0</span> || hour &gt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min &gt; <span class="Constant">0</span> || sec &gt; <span class="Constant">0</span> || fsec &gt; <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_year_month = year != <span class="Constant">0</span> || mon != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_day_time = mday != <span class="Constant">0</span> || hour != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min != <span class="Constant">0</span> || sec != <span class="Constant">0</span> || fsec != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_day = mday != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sql_standard_value = !(has_negative &amp;&amp; has_positive) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !(has_year_month &amp;&amp; has_day_time);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SQL Standard wants only 1 &quot;&lt;sign&gt;&quot; preceding the whole<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interval ... but can't do that if mixed signs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (has_negative &amp;&amp; sql_standard_value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = <span class="Constant">'-'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; year = -year;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mon = -mon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mday = -mday;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hour = -hour;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min = -min;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sec = -sec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec = -fsec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!has_negative &amp;&amp; !has_positive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(cp, <span class="Constant">&quot;0&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!sql_standard_value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For non sql-standard interval <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, force outputting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the signs to avoid ambiguities with intervals with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mixed sign components.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; year_sign = (year &lt; <span class="Constant">0</span> || mon &lt; <span class="Constant">0</span>) ? <span class="Constant">'-'</span> : <span class="Constant">'+'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; day_sign = (mday &lt; <span class="Constant">0</span>) ? <span class="Constant">'-'</span> : <span class="Constant">'+'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; sec_sign = (hour &lt; <span class="Constant">0</span> || min &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sec &lt; <span class="Constant">0</span> || fsec &lt; <span class="Constant">0</span>) ? <span class="Constant">'-'</span> : <span class="Constant">'+'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(cp, <span class="Constant">&quot;</span><span class="Special">%c%d</span><span class="Constant">-</span><span class="Special">%d</span><span class="Constant"> </span><span class="Special">%c%lld</span><span class="Constant"> </span><span class="Special">%c%lld</span><span class="Constant">:</span><span class="Special">%02d</span><span class="Constant">:&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; year_sign, abs(year), abs(mon),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; day_sign, (<span class="Type">long</span> <span class="Type">long</span>) i64abs(mday),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sec_sign, (<span class="Type">long</span> <span class="Type">long</span>) i64abs(hour), abs(min));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp += strlen(cp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="#L448" title="utils/adt/datetime.c:448">AppendSeconds</a>(cp, sec, fsec, MAX_INTERVAL_PRECISION, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (has_year_month)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(cp, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">-</span><span class="Special">%d</span><span class="Constant">&quot;</span>, year, mon);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (has_day)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(cp, <span class="Constant">&quot;</span><span class="Special">%lld</span><span class="Constant"> </span><span class="Special">%lld</span><span class="Constant">:</span><span class="Special">%02d</span><span class="Constant">:&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) mday, (<span class="Type">long</span> <span class="Type">long</span>) hour, min);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp += strlen(cp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="#L448" title="utils/adt/datetime.c:448">AppendSeconds</a>(cp, sec, fsec, MAX_INTERVAL_PRECISION, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(cp, <span class="Constant">&quot;</span><span class="Special">%lld</span><span class="Constant">:</span><span class="Special">%02d</span><span class="Constant">:&quot;</span>, (<span class="Type">long</span> <span class="Type">long</span>) hour, min);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp += strlen(cp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="#L448" title="utils/adt/datetime.c:448">AppendSeconds</a>(cp, sec, fsec, MAX_INTERVAL_PRECISION, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ISO 8601 &quot;time-intervals by duration only&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTSTYLE_ISO_8601:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* special-case zero to avoid printing nothing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (year == <span class="Constant">0</span> &amp;&amp; mon == <span class="Constant">0</span> &amp;&amp; mday == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hour == <span class="Constant">0</span> &amp;&amp; min == <span class="Constant">0</span> &amp;&amp; sec == <span class="Constant">0</span> &amp;&amp; fsec == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(cp, <span class="Constant">&quot;PT0S&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = <span class="Constant">'P'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="#L4502" title="utils/adt/datetime.c:4502">AddISO8601IntPart</a>(cp, year, <span class="Constant">'Y'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="#L4502" title="utils/adt/datetime.c:4502">AddISO8601IntPart</a>(cp, mon, <span class="Constant">'M'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="#L4502" title="utils/adt/datetime.c:4502">AddISO8601IntPart</a>(cp, mday, <span class="Constant">'D'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hour != <span class="Constant">0</span> || min != <span class="Constant">0</span> || sec != <span class="Constant">0</span> || fsec != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = <span class="Constant">'T'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="#L4502" title="utils/adt/datetime.c:4502">AddISO8601IntPart</a>(cp, hour, <span class="Constant">'H'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="#L4502" title="utils/adt/datetime.c:4502">AddISO8601IntPart</a>(cp, min, <span class="Constant">'M'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sec != <span class="Constant">0</span> || fsec != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sec &lt; <span class="Constant">0</span> || fsec &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = <span class="Constant">'-'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="#L448" title="utils/adt/datetime.c:448">AppendSeconds</a>(cp, sec, fsec, MAX_INTERVAL_PRECISION, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = <span class="Constant">'S'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compatible with postgresql &lt; 8.4 when <a href="../init/globals.c.html#L122" title="utils/init/globals.c:122">DateStyle</a> = 'iso' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTSTYLE_POSTGRES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="#L4512" title="utils/adt/datetime.c:4512">AddPostgresIntPart</a>(cp, year, <span class="Constant">&quot;year&quot;</span>, &amp;is_zero, &amp;is_before);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ideally we should spell out &quot;month&quot; like we do for &quot;year&quot; and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;day&quot;.&nbsp; However, for backward compatibility, we can't easily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fix this.&nbsp; bjm 2011-05-24<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="#L4512" title="utils/adt/datetime.c:4512">AddPostgresIntPart</a>(cp, mon, <span class="Constant">&quot;mon&quot;</span>, &amp;is_zero, &amp;is_before);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="#L4512" title="utils/adt/datetime.c:4512">AddPostgresIntPart</a>(cp, mday, <span class="Constant">&quot;day&quot;</span>, &amp;is_zero, &amp;is_before);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_zero || hour != <span class="Constant">0</span> || min != <span class="Constant">0</span> || sec != <span class="Constant">0</span> || fsec != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; minus = (hour &lt; <span class="Constant">0</span> || min &lt; <span class="Constant">0</span> || sec &lt; <span class="Constant">0</span> || fsec &lt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(cp, <span class="Constant">&quot;</span><span class="Special">%s%s%02lld</span><span class="Constant">:</span><span class="Special">%02d</span><span class="Constant">:&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_zero ? <span class="Constant">&quot;&quot;</span> : <span class="Constant">&quot; &quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (minus ? <span class="Constant">&quot;-&quot;</span> : (is_before ? <span class="Constant">&quot;+&quot;</span> : <span class="Constant">&quot;&quot;</span>)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) i64abs(hour), abs(min));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp += strlen(cp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="#L448" title="utils/adt/datetime.c:448">AppendSeconds</a>(cp, sec, fsec, MAX_INTERVAL_PRECISION, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compatible with postgresql &lt; 8.4 when <a href="../init/globals.c.html#L122" title="utils/init/globals.c:122">DateStyle</a> != 'iso' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTSTYLE_POSTGRES_VERBOSE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcpy(cp, <span class="Constant">&quot;@&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="#L4535" title="utils/adt/datetime.c:4535">AddVerboseIntPart</a>(cp, year, <span class="Constant">&quot;year&quot;</span>, &amp;is_zero, &amp;is_before);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="#L4535" title="utils/adt/datetime.c:4535">AddVerboseIntPart</a>(cp, mon, <span class="Constant">&quot;mon&quot;</span>, &amp;is_zero, &amp;is_before);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="#L4535" title="utils/adt/datetime.c:4535">AddVerboseIntPart</a>(cp, mday, <span class="Constant">&quot;day&quot;</span>, &amp;is_zero, &amp;is_before);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="#L4535" title="utils/adt/datetime.c:4535">AddVerboseIntPart</a>(cp, hour, <span class="Constant">&quot;hour&quot;</span>, &amp;is_zero, &amp;is_before);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="#L4535" title="utils/adt/datetime.c:4535">AddVerboseIntPart</a>(cp, min, <span class="Constant">&quot;min&quot;</span>, &amp;is_zero, &amp;is_before);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sec != <span class="Constant">0</span> || fsec != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = <span class="Constant">' '</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sec &lt; <span class="Constant">0</span> || (sec == <span class="Constant">0</span> &amp;&amp; fsec &lt; <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_zero)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_before = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!is_before)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = <span class="Constant">'-'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (is_before)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *cp++ = <span class="Constant">'-'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cp = <a href="#L448" title="utils/adt/datetime.c:448">AppendSeconds</a>(cp, sec, fsec, MAX_INTERVAL_PRECISION, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We output &quot;ago&quot;, not negatives, so use abs(). */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sprintf(cp, <span class="Constant">&quot; sec</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (abs(sec) != <span class="Constant">1</span> || fsec != <span class="Constant">0</span>) ? <span class="Constant">&quot;s&quot;</span> : <span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_zero = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* identically zero? then put in a unitless zero... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_zero)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcat(cp, <span class="Constant">&quot; 0&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_before)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcat(cp, <span class="Constant">&quot; ago&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We've been burnt by stupid errors in the ordering of the datetkn tables<br/></li>
<li></span><span class="Comment"> * once too often.&nbsp; Arrange to check them during postmaster start.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4768">&#x200c;</a></span><span class="linkable">CheckDateTokenTable</span>(<span class="Type">const</span> <span class="Type">char</span> *tablename, <span class="Type">const</span> datetkn *base, <span class="Type">int</span> nel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ok = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nel; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for token strings that don't fit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strlen(base[i].token) &gt; TOKMAXLEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* %.*s is safe since all our tokens are ASCII */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;token too long in </span><span class="Special">%s</span><span class="Constant"> table: </span><span class="Special">\&quot;%.*s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tablename,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TOKMAXLEN + <span class="Constant">1</span>, base[i].token);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ok = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't risk applying strcmp */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for out of order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(base[i - <span class="Constant">1</span>].token, base[i].token) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;ordering error in </span><span class="Special">%s</span><span class="Constant"> table: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> &gt;= </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tablename,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; base[i - <span class="Constant">1</span>].token,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; base[i].token);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ok = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ok;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4800">&#x200c;</a></span><span class="linkable">CheckDateTokenTables</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ok = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(UNIX_EPOCH_JDATE == <a href="#L286" title="utils/adt/datetime.c:286">date2j</a>(<span class="Constant">1970</span>, <span class="Constant">1</span>, <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; Assert(POSTGRES_EPOCH_JDATE == <a href="#L286" title="utils/adt/datetime.c:286">date2j</a>(<span class="Constant">2000</span>, <span class="Constant">1</span>, <span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ok &amp;= <a href="#L4768" title="utils/adt/datetime.c:4768">CheckDateTokenTable</a>(<span class="Constant">&quot;<a href="#L105" title="utils/adt/datetime.c:105">datetktbl</a>&quot;</span>, <a href="#L105" title="utils/adt/datetime.c:105">datetktbl</a>, <a href="#L181" title="utils/adt/datetime.c:181">szdatetktbl</a>);<br/></li>
<li>&nbsp; &nbsp; ok &amp;= <a href="#L4768" title="utils/adt/datetime.c:4768">CheckDateTokenTable</a>(<span class="Constant">&quot;<a href="#L187" title="utils/adt/datetime.c:187">deltatktbl</a>&quot;</span>, <a href="#L187" title="utils/adt/datetime.c:187">deltatktbl</a>, <a href="#L252" title="utils/adt/datetime.c:252">szdeltatktbl</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ok;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Common code for temporal prosupport <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>: simplify, if possible,<br/></li>
<li></span><span class="Comment"> * a call to a temporal type's length-coercion function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Types time, timetz, timestamp and timestamptz each have a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of allowed<br/></li>
<li></span><span class="Comment"> * precisions.&nbsp; An unspecified precision is rigorously equivalent to the<br/></li>
<li></span><span class="Comment"> * highest specifiable precision.&nbsp; We can replace the function call with a<br/></li>
<li></span><span class="Comment"> * no-op RelabelType if it is coercing to the same or higher precision as the<br/></li>
<li></span><span class="Comment"> * input is known to have.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The input Node is always a FuncExpr, but to reduce the #include footprint<br/></li>
<li></span><span class="Comment"> * of datetime.h, we declare it as Node *.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: <a href="timestamp.c.html#L345" title="utils/adt/timestamp.c:345">timestamp_scale</a> throws an error when the typmod is out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, but<br/></li>
<li></span><span class="Comment"> * we can't get there from a cast: our typmodin will have caught it already.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Node *<br/></li>
<li><a id="L4829">&#x200c;</a><span class="linkable">TemporalSimplify</span>(int32 max_precis, Node *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FuncExpr&nbsp;&nbsp; *expr = castNode(FuncExpr, node);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *ret = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *typmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(list_length(expr-&gt;args) &gt;= <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typmod = (Node *) lsecond(expr-&gt;args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(typmod, Const) &amp;&amp; !((Const *) typmod)-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *source = (Node *) linitial(expr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; old_precis = <a href="../../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>(source);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; new_precis = DatumGetInt32(((Const *) typmod)-&gt;constvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_precis &lt; <span class="Constant">0</span> || new_precis == max_precis ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (old_precis &gt;= <span class="Constant">0</span> &amp;&amp; new_precis &gt;= old_precis))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="../../nodes/nodeFuncs.c.html#L684" title="nodes/nodeFuncs.c:684">relabel_to_typmod</a>(source, new_precis);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This function gets called during timezone config file load or reload<br/></li>
<li></span><span class="Comment"> * to create the final array of timezone tokens.&nbsp; The argument array<br/></li>
<li></span><span class="Comment"> * is already sorted in name order.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is a TimeZoneAbbrevTable (which must be a single <a href="../misc/guc.c.html#L640" title="utils/misc/guc.c:640">guc_malloc</a>'d<br/></li>
<li></span><span class="Comment"> * chunk) or NULL on alloc failure.&nbsp; No other error conditions are defined.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TimeZoneAbbrevTable *<br/></li>
<li><a id="L4862">&#x200c;</a><span class="linkable">ConvertTimeZoneAbbrevs</span>(<span class="Type">struct</span> tzEntry *abbrevs, <span class="Type">int</span> n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeZoneAbbrevTable *tbl;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; tbl_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Space for fixed fields and datetkn array */<br/></li>
<li></span>&nbsp; &nbsp; tbl_size = offsetof(TimeZoneAbbrevTable, abbrevs) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(datetkn);<br/></li>
<li>&nbsp; &nbsp; tbl_size = MAXALIGN(tbl_size);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Count up space for dynamic abbreviations */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; n; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> tzEntry *abbr = abbrevs + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (abbr-&gt;zone != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; dsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsize = offsetof(DynamicZoneAbbrev, zone) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strlen(abbr-&gt;zone) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbl_size += MAXALIGN(dsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Alloc the result ... */<br/></li>
<li></span>&nbsp; &nbsp; tbl = <a href="../misc/guc.c.html#L640" title="utils/misc/guc.c:640">guc_malloc</a>(LOG, tbl_size);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!tbl)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and fill it in */<br/></li>
<li></span>&nbsp; &nbsp; tbl-&gt;tblsize = tbl_size;<br/></li>
<li>&nbsp; &nbsp; tbl-&gt;numabbrevs = n;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* in this loop, tbl_size reprises the space calculation above */<br/></li>
<li></span>&nbsp; &nbsp; tbl_size = offsetof(TimeZoneAbbrevTable, abbrevs) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(datetkn);<br/></li>
<li>&nbsp; &nbsp; tbl_size = MAXALIGN(tbl_size);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; n; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> tzEntry *abbr = abbrevs + i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datetkn&nbsp; &nbsp; *dtoken = tbl-&gt;abbrevs + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* use strlcpy to truncate name if necessary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; strlcpy(dtoken-&gt;token, abbr-&gt;abbrev, TOKMAXLEN + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (abbr-&gt;zone != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allocate a DynamicZoneAbbrev for this abbreviation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DynamicZoneAbbrev *dtza;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; dsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dtza = (DynamicZoneAbbrev *) ((<span class="Type">char</span> *) tbl + tbl_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dtza-&gt;tz = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcpy(dtza-&gt;zone, abbr-&gt;zone);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dtoken-&gt;type = DYNTZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* value is offset from table start to DynamicZoneAbbrev */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dtoken-&gt;value = (int32) tbl_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsize = offsetof(DynamicZoneAbbrev, zone) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strlen(abbr-&gt;zone) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbl_size += MAXALIGN(dsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dtoken-&gt;type = abbr-&gt;is_dst ? DTZ : TZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dtoken-&gt;value = abbr-&gt;offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assert the two loops above agreed on size calculations */<br/></li>
<li></span>&nbsp; &nbsp; Assert(tbl-&gt;tblsize == tbl_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check the ordering, if testing */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L4768" title="utils/adt/datetime.c:4768">CheckDateTokenTable</a>(<span class="Constant">&quot;timezone abbreviations&quot;</span>, tbl-&gt;abbrevs, n));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tbl;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Install a TimeZoneAbbrevTable as the active table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller is responsible that the passed table doesn't go away while in use.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4946">&#x200c;</a></span><span class="linkable">InstallTimeZoneAbbrevs</span>(TimeZoneAbbrevTable *tbl)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L254" title="utils/adt/datetime.c:254">zoneabbrevtbl</a> = tbl;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reset <a href="#L262" title="utils/adt/datetime.c:262">abbrevcache</a>, which may contain pointers into old table */<br/></li>
<li></span>&nbsp; &nbsp; memset(<a href="#L262" title="utils/adt/datetime.c:262">abbrevcache</a>, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L262" title="utils/adt/datetime.c:262">abbrevcache</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper subroutine to locate pg_tz timezone for a dynamic abbreviation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On failure, returns NULL and fills *extra for a DTERR_BAD_ZONE_ABBREV error.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> pg_tz *<br/></li>
<li><a id="L4959">&#x200c;</a><span class="linkable">FetchDynamicTimeZone</span>(TimeZoneAbbrevTable *tbl, <span class="Type">const</span> datetkn *tp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DateTimeErrorExtra *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DynamicZoneAbbrev *dtza;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Just some sanity checks to prevent indexing off into nowhere */<br/></li>
<li></span>&nbsp; &nbsp; Assert(tp-&gt;type == DYNTZ);<br/></li>
<li>&nbsp; &nbsp; Assert(tp-&gt;value &gt; <span class="Constant">0</span> &amp;&amp; tp-&gt;value &lt; tbl-&gt;tblsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dtza = (DynamicZoneAbbrev *) ((<span class="Type">char</span> *) tbl + tp-&gt;value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up the underlying zone if we haven't already */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dtza-&gt;tz == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dtza-&gt;tz = pg_tzset(dtza-&gt;zone);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dtza-&gt;tz == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ooops, bogus zone name in config file entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra-&gt;dtee_timezone = dtza-&gt;zone;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extra-&gt;dtee_abbrev = tp-&gt;token;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> dtza-&gt;tz;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This set-returning function reads all the available time zone abbreviations<br/></li>
<li></span><span class="Comment"> * and returns a set of (abbrev, utc_offset, is_dst).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L4990">&#x200c;</a><span class="linkable">pg_timezone_abbrevs</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FuncCallContext *funcctx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *pindex;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">3</span>] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> datetkn *tp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buffer[TOKMAXLEN + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gmtoffset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_dst;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_itm_in itm_in;<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *resInterval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* stuff done only on the first call of the function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (SRF_IS_FIRSTCALL())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* create a function context for cross-call persistence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; funcctx = SRF_FIRSTCALL_INIT();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * switch to memory context appropriate for multiple function calls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocate memory for user context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pindex = (<span class="Type">int</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *pindex = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;user_fctx = (<span class="Type">void</span> *) pindex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../fmgr/funcapi.c.html#L276" title="utils/fmgr/funcapi.c:276">get_call_result_type</a>(fcinfo, <span class="Constant">NULL</span>, &amp;tupdesc) != TYPEFUNC_COMPOSITE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;return type must be a row type&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;tuple_desc = tupdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* stuff done on every call of the function */<br/></li>
<li></span>&nbsp; &nbsp; funcctx = SRF_PERCALL_SETUP();<br/></li>
<li>&nbsp; &nbsp; pindex = (<span class="Type">int</span> *) funcctx-&gt;user_fctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L254" title="utils/adt/datetime.c:254">zoneabbrevtbl</a> == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *pindex &gt;= <a href="#L254" title="utils/adt/datetime.c:254">zoneabbrevtbl</a>-&gt;numabbrevs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_DONE(funcctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="#L254" title="utils/adt/datetime.c:254">zoneabbrevtbl</a>-&gt;abbrevs + *pindex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (tp-&gt;type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TZ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gmtoffset = tp-&gt;value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_dst = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DTZ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gmtoffset = tp-&gt;value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_dst = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DYNTZ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Determine the current meaning of the abbrev */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_tz&nbsp; &nbsp; &nbsp;&nbsp; *tzp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DateTimeErrorExtra extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isdst;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tzp = <a href="#L4959" title="utils/adt/datetime.c:4959">FetchDynamicTimeZone</a>(<a href="#L254" title="utils/adt/datetime.c:254">zoneabbrevtbl</a>, tp, &amp;extra);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4081" title="utils/adt/datetime.c:4081">DateTimeParseError</a>(DTERR_BAD_ZONE_ABBREV, &amp;extra,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../../access/transam/xact.c.html#L867" title="access/transam/xact.c:867">GetCurrentTransactionStartTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gmtoffset = -<a href="#L1784" title="utils/adt/datetime.c:1784">DetermineTimeZoneAbbrevOffsetTS</a>(<a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tp-&gt;token,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tzp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isdst);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_dst = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) isdst;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized timezone type </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) tp-&gt;type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gmtoffset = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_dst = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Convert name to text, using upcasing conversion that is the inverse of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * what <a href="#L754" title="utils/adt/datetime.c:754">ParseDateTime</a>() uses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; strlcpy(buffer, tp-&gt;token, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buffer));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (p = (<span class="Type">unsigned</span> <span class="Type">char</span> *) buffer; *p; p++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *p = pg_toupper(*p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = CStringGetTextDatum(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert offset (in seconds) to an interval; can't overflow */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(&amp;itm_in, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> pg_itm_in));<br/></li>
<li>&nbsp; &nbsp; itm_in.tm_usec = (int64) gmtoffset * USECS_PER_SEC;<br/></li>
<li>&nbsp; &nbsp; resInterval = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="timestamp.c.html#L2115" title="utils/adt/timestamp.c:2115">itmin2interval</a>(&amp;itm_in, resInterval);<br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = IntervalPGetDatum(resInterval);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = BoolGetDatum(is_dst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (*pindex)++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(funcctx-&gt;tuple_desc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; result = HeapTupleGetDatum(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SRF_RETURN_NEXT(funcctx, result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This set-returning function reads all the available full time zones<br/></li>
<li></span><span class="Comment"> * and returns a set of (name, abbrev, utc_offset, is_dst).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L5111">&#x200c;</a><span class="linkable">pg_timezone_names</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ReturnSetInfo *rsinfo = (ReturnSetInfo *) fcinfo-&gt;resultinfo;<br/></li>
<li>&nbsp; &nbsp; pg_tzenum&nbsp; *tzenum;<br/></li>
<li>&nbsp; &nbsp; pg_tz&nbsp; &nbsp; &nbsp;&nbsp; *tz;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">4</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">4</span>] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tzoff;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm tm;<br/></li>
<li>&nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *tzn;<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *resInterval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_itm_in itm_in;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../fmgr/funcapi.c.html#L76" title="utils/fmgr/funcapi.c:76">InitMaterializedSRF</a>(fcinfo, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> timezone scanning code */<br/></li>
<li></span>&nbsp; &nbsp; tzenum = pg_tzenumerate_start();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* search for another zone to display */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tz = pg_tzenumerate_next(tzenum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tz)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Convert <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>() to local time in this zone */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="timestamp.c.html#L1901" title="utils/adt/timestamp.c:1901">timestamp2tm</a>(<a href="../../access/transam/xact.c.html#L867" title="access/transam/xact.c:867">GetCurrentTransactionStartTimestamp</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tzoff, &amp;tm, &amp;fsec, &amp;tzn, tz) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore if conversion fails */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * IANA's rather silly &quot;Factory&quot; time zone used to emit ridiculously<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * long &quot;abbreviations&quot; such as &quot;Local time zone must be set--see zic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * manual page&quot; or &quot;Local time zone must be set--use tzsetup&quot;.&nbsp; While<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * modern versions of tzdb emit the much saner &quot;-00&quot;, it seems some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * benighted packagers are hacking the IANA data so that it continues<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to produce these strings.&nbsp; To prevent producing a weirdly wide<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * abbrev column, reject ridiculously long abbreviations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tzn &amp;&amp; strlen(tzn) &gt; <span class="Constant">31</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = CStringGetTextDatum(pg_get_timezone_name(tz));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = CStringGetTextDatum(tzn ? tzn : <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Convert tzoff to an interval; can't overflow */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(&amp;itm_in, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> pg_itm_in));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itm_in.tm_usec = (int64) -tzoff * USECS_PER_SEC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resInterval = (Interval *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Interval));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="timestamp.c.html#L2115" title="utils/adt/timestamp.c:2115">itmin2interval</a>(&amp;itm_in, resInterval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = IntervalPGetDatum(resInterval);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">3</span>] = BoolGetDatum(tm.tm_isdst &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../sort/tuplestore.c.html#L750" title="utils/sort/tuplestore.c:750">tuplestore_putvalues</a>(rsinfo-&gt;setResult, rsinfo-&gt;setDesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_tzenumerate_end(tzenum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
