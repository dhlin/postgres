<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/expandedrecord.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/expandedrecord.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L38">ER_methods</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L927">DatumGetExpandedRecord</a></li>
<li><a href="#L764">ER_flatten_into</a></li>
<li><a href="#L652">ER_get_flat_size</a></li>
<li><a href="#L902">ER_mc_callback</a></li>
<li><a href="#L1402">build_dummy_expanded_header</a></li>
<li><a href="#L1494">check_domain_for_new_field</a></li>
<li><a href="#L1576">check_domain_for_new_tuple</a></li>
<li><a href="#L952">deconstruct_expanded_record</a></li>
<li><a href="#L1063">expanded_record_fetch_field</a></li>
<li><a href="#L824">expanded_record_fetch_tupdesc</a></li>
<li><a href="#L884">expanded_record_get_tuple</a></li>
<li><a href="#L1017">expanded_record_lookup_field</a></li>
<li><a href="#L1112">expanded_record_set_field_internal</a></li>
<li><a href="#L1249">expanded_record_set_fields</a></li>
<li><a href="#L440">expanded_record_set_tuple</a></li>
<li><a href="#L1379">get_short_term_cxt</a></li>
<li><a href="#L580">make_expanded_record_from_datum</a></li>
<li><a href="#L329">make_expanded_record_from_exprecord</a></li>
<li><a href="#L205">make_expanded_record_from_tupdesc</a></li>
<li><a href="#L69">make_expanded_record_from_typeid</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * expandedrecord.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Functions for manipulating composite expanded objects.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module supports &quot;expanded objects&quot; (cf. expandeddatum.h) that can<br/></li>
<li></span><span class="Comment"> * store <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of named composite types, domains over named composite types,<br/></li>
<li></span><span class="Comment"> * and record types (registered or anonymous).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/expandedrecord.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/detoast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heaptoast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/heap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/expandedrecord.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* &quot;Methods&quot; required for an expanded object */<br/></li>
<li></span><span class="Type">static</span> Size <a href="#L652" title="utils/adt/expandedrecord.c:652">ER_get_flat_size</a>(ExpandedObjectHeader *eohptr);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L764" title="utils/adt/expandedrecord.c:764">ER_flatten_into</a>(ExpandedObjectHeader *eohptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *result, Size allocated_size);<br/></li>
<li><br/></li>
<li><a id="L38">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> ExpandedObjectMethods <span class="linkable">ER_methods</span> =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L652" title="utils/adt/expandedrecord.c:652">ER_get_flat_size</a>,<br/></li>
<li>&nbsp; &nbsp; <a href="#L764" title="utils/adt/expandedrecord.c:764">ER_flatten_into</a><br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Other local <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L902" title="utils/adt/expandedrecord.c:902">ER_mc_callback</a>(<span class="Type">void</span> *arg);<br/></li>
<li><span class="Type">static</span> MemoryContext <a href="#L1379" title="utils/adt/expandedrecord.c:1379">get_short_term_cxt</a>(ExpandedRecordHeader *erh);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1402" title="utils/adt/expandedrecord.c:1402">build_dummy_expanded_header</a>(ExpandedRecordHeader *main_erh);<br/></li>
<li><span class="Type">static</span> pg_noinline <span class="Type">void</span> <a href="#L1494" title="utils/adt/expandedrecord.c:1494">check_domain_for_new_field</a>(ExpandedRecordHeader *erh,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> fnumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum newValue, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull);<br/></li>
<li><span class="Type">static</span> pg_noinline <span class="Type">void</span> <a href="#L1576" title="utils/adt/expandedrecord.c:1576">check_domain_for_new_tuple</a>(ExpandedRecordHeader *erh,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTuple tuple);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build an expanded record of the specified composite type<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * type_id can be RECORDOID, but only if a positive typmod is given.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The expanded record is initially &quot;empty&quot;, having a state logically<br/></li>
<li></span><span class="Comment"> * equivalent to a NULL composite value (not ROW(NULL, NULL, ...)).<br/></li>
<li></span><span class="Comment"> * Note that this might not be a valid state for a domain type;<br/></li>
<li></span><span class="Comment"> * if the caller needs to check that, call<br/></li>
<li></span><span class="Comment"> * <a href="#L440" title="utils/adt/expandedrecord.c:440">expanded_record_set_tuple</a>(erh, NULL, false, false).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The expanded object will be a child of parentcontext.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ExpandedRecordHeader *<br/></li>
<li><a id="L69">&#x200c;</a><span class="linkable">make_expanded_record_from_typeid</span>(Oid type_id, int32 typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MemoryContext parentcontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExpandedRecordHeader *erh;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; tupdesc_id;<br/></li>
<li>&nbsp; &nbsp; MemoryContext objcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *chunk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type_id != RECORDOID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Consult the typcache to see if it's a domain over composite, and in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case to get the tupdesc and tupdesc identifier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(type_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_TUPDESC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_DOMAIN_BASE_INFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;typtype == TYPTYPE_DOMAIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= ER_FLAG_IS_DOMAIN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(typentry-&gt;domainBaseType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_TUPDESC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;tupDesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;type </span><span class="Special">%s</span><span class="Constant"> is not composite&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(type_id))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc = typentry-&gt;tupDesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc_id = typentry-&gt;tupDesc_identifier;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For RECORD types, get the tupdesc and identifier from typcache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc = <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(type_id, typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc_id = <a href="../cache/typcache.c.html#L2045" title="utils/cache/typcache.c:2045">assign_record_type_identifier</a>(type_id, typmod);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate private context for expanded object.&nbsp; We use a regular-size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context, not a small one, to improve the odds that we can fit a tupdesc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into it without needing an extra malloc block.&nbsp; (This code path doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ever need to copy a tupdesc into the expanded record, but let's be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consistent with the other ways of making an expanded record.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; objcxt = AllocSetContextCreate(parentcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;expanded record&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we already know the number of fields in the tupdesc, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate the dvalues/dnulls arrays along with the record header.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is useless if we never need those arrays, but it costs almost nothing,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and it will save a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> cycle if we do need them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; erh = (ExpandedRecordHeader *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(objcxt, MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExpandedRecordHeader))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; + tupdesc-&gt;natts * (<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure all header fields are initialized to 0/null */<br/></li>
<li></span>&nbsp; &nbsp; memset(erh, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExpandedRecordHeader));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="expandeddatum.c.html#L48" title="utils/adt/expandeddatum.c:48">EOH_init_header</a>(&amp;erh-&gt;hdr, &amp;<a href="#L38" title="utils/adt/expandedrecord.c:38">ER_methods</a>, objcxt);<br/></li>
<li>&nbsp; &nbsp; erh-&gt;er_magic = ER_MAGIC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up dvalues/dnulls, with no valid contents as yet */<br/></li>
<li></span>&nbsp; &nbsp; chunk = (<span class="Type">char</span> *) erh + MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExpandedRecordHeader));<br/></li>
<li>&nbsp; &nbsp; erh-&gt;dvalues = (Datum *) chunk;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;dnulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) (chunk + tupdesc-&gt;natts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; erh-&gt;nfields = tupdesc-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill in composite-type identification info */<br/></li>
<li></span>&nbsp; &nbsp; erh-&gt;er_decltypeid = type_id;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;er_typeid = tupdesc-&gt;tdtypeid;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;er_typmod = tupdesc-&gt;tdtypmod;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;er_tupdesc_id = tupdesc_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; erh-&gt;flags = flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If what we got from the typcache is a refcounted tupdesc, we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * acquire our own refcount on it.&nbsp; We manage the refcount with a memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context callback rather than assuming that the <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * longer-lived than this expanded object.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tupdesc-&gt;tdrefcount &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Register callback to release the refcount */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_mcb.func = <a href="#L902" title="utils/adt/expandedrecord.c:902">ER_mc_callback</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_mcb.arg = (<span class="Type">void</span> *) erh;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L568" title="utils/mmgr/mcxt.c:568">MemoryContextRegisterResetCallback</a>(erh-&gt;hdr.eoh_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;erh-&gt;er_mcb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And save the pointer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_tupdesc = tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc-&gt;tdrefcount++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we called <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>, release the pin it took */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (type_id == RECORDOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReleaseTupleDesc(tupdesc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's not refcounted, just assume it will outlive the expanded<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * object.&nbsp; (This can happen for shared record types, for instance.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_tupdesc = tupdesc;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't set ER_FLAG_DVALUES_VALID or ER_FLAG_FVALUE_VALID, so the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record remains logically empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> erh;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build an expanded record of the rowtype defined by the tupdesc<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The tupdesc is copied if necessary (i.e., if we can't just bump its<br/></li>
<li></span><span class="Comment"> * reference count instead).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The expanded record is initially &quot;empty&quot;, having a state logically<br/></li>
<li></span><span class="Comment"> * equivalent to a NULL composite value (not ROW(NULL, NULL, ...)).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The expanded object will be a child of parentcontext.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ExpandedRecordHeader *<br/></li>
<li><a id="L205">&#x200c;</a><span class="linkable">make_expanded_record_from_tupdesc</span>(TupleDesc tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext parentcontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExpandedRecordHeader *erh;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; tupdesc_id;<br/></li>
<li>&nbsp; &nbsp; MemoryContext objcxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *chunk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tupdesc-&gt;tdtypeid != RECORDOID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a named composite type (not RECORD), we prefer to reference<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the typcache's copy of the tupdesc, which is guaranteed to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * refcounted (the given tupdesc might not be).&nbsp; In <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to consult the typcache to get the correct tupdesc identifier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that tdtypeid couldn't be a domain type, so we need not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consider that case here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(tupdesc-&gt;tdtypeid, TYPECACHE_TUPDESC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry-&gt;tupDesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;type </span><span class="Special">%s</span><span class="Constant"> is not composite&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(tupdesc-&gt;tdtypeid))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc = typentry-&gt;tupDesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc_id = typentry-&gt;tupDesc_identifier;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For RECORD types, get the appropriate unique identifier (possibly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * freshly assigned).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc_id = <a href="../cache/typcache.c.html#L2045" title="utils/cache/typcache.c:2045">assign_record_type_identifier</a>(tupdesc-&gt;tdtypeid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tupdesc-&gt;tdtypmod);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate private context for expanded object.&nbsp; We use a regular-size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context, not a small one, to improve the odds that we can fit a tupdesc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into it without needing an extra malloc block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; objcxt = AllocSetContextCreate(parentcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;expanded record&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we already know the number of fields in the tupdesc, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate the dvalues/dnulls arrays along with the record header.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is useless if we never need those arrays, but it costs almost nothing,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and it will save a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> cycle if we do need them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; erh = (ExpandedRecordHeader *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(objcxt, MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExpandedRecordHeader))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; + tupdesc-&gt;natts * (<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure all header fields are initialized to 0/null */<br/></li>
<li></span>&nbsp; &nbsp; memset(erh, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExpandedRecordHeader));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="expandeddatum.c.html#L48" title="utils/adt/expandeddatum.c:48">EOH_init_header</a>(&amp;erh-&gt;hdr, &amp;<a href="#L38" title="utils/adt/expandedrecord.c:38">ER_methods</a>, objcxt);<br/></li>
<li>&nbsp; &nbsp; erh-&gt;er_magic = ER_MAGIC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up dvalues/dnulls, with no valid contents as yet */<br/></li>
<li></span>&nbsp; &nbsp; chunk = (<span class="Type">char</span> *) erh + MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExpandedRecordHeader));<br/></li>
<li>&nbsp; &nbsp; erh-&gt;dvalues = (Datum *) chunk;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;dnulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) (chunk + tupdesc-&gt;natts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; erh-&gt;nfields = tupdesc-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill in composite-type identification info */<br/></li>
<li></span>&nbsp; &nbsp; erh-&gt;er_decltypeid = erh-&gt;er_typeid = tupdesc-&gt;tdtypeid;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;er_typmod = tupdesc-&gt;tdtypmod;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;er_tupdesc_id = tupdesc_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy tupdesc if needed, but we prefer to bump its refcount if possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We manage the refcount with a memory context callback rather than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assuming that the <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> is longer-lived than this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expanded object.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tupdesc-&gt;tdrefcount &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Register callback to release the refcount */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_mcb.func = <a href="#L902" title="utils/adt/expandedrecord.c:902">ER_mc_callback</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_mcb.arg = (<span class="Type">void</span> *) erh;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L568" title="utils/mmgr/mcxt.c:568">MemoryContextRegisterResetCallback</a>(erh-&gt;hdr.eoh_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;erh-&gt;er_mcb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And save the pointer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_tupdesc = tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc-&gt;tdrefcount++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Just copy it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(objcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_tupdesc = <a href="../../access/common/tupdesc.c.html#L133" title="access/common/tupdesc.c:133">CreateTupleDescCopy</a>(tupdesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;flags |= ER_FLAG_TUPDESC_ALLOCED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't set ER_FLAG_DVALUES_VALID or ER_FLAG_FVALUE_VALID, so the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record remains logically empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> erh;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build an expanded record of the same rowtype as the given expanded record<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is faster than either of the above routines because we can bypass<br/></li>
<li></span><span class="Comment"> * typcache lookup(s).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The expanded record is initially &quot;empty&quot; --- we do not copy whatever<br/></li>
<li></span><span class="Comment"> * tuple might be in the source expanded record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The expanded object will be a child of parentcontext.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ExpandedRecordHeader *<br/></li>
<li><a id="L329">&#x200c;</a><span class="linkable">make_expanded_record_from_exprecord</span>(ExpandedRecordHeader *olderh,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext parentcontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExpandedRecordHeader *erh;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc = expanded_record_get_tupdesc(olderh);<br/></li>
<li>&nbsp; &nbsp; MemoryContext objcxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *chunk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate private context for expanded object.&nbsp; We use a regular-size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context, not a small one, to improve the odds that we can fit a tupdesc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into it without needing an extra malloc block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; objcxt = AllocSetContextCreate(parentcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;expanded record&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we already know the number of fields in the tupdesc, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate the dvalues/dnulls arrays along with the record header.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is useless if we never need those arrays, but it costs almost nothing,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and it will save a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> cycle if we do need them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; erh = (ExpandedRecordHeader *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(objcxt, MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExpandedRecordHeader))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; + tupdesc-&gt;natts * (<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure all header fields are initialized to 0/null */<br/></li>
<li></span>&nbsp; &nbsp; memset(erh, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExpandedRecordHeader));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="expandeddatum.c.html#L48" title="utils/adt/expandeddatum.c:48">EOH_init_header</a>(&amp;erh-&gt;hdr, &amp;<a href="#L38" title="utils/adt/expandedrecord.c:38">ER_methods</a>, objcxt);<br/></li>
<li>&nbsp; &nbsp; erh-&gt;er_magic = ER_MAGIC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up dvalues/dnulls, with no valid contents as yet */<br/></li>
<li></span>&nbsp; &nbsp; chunk = (<span class="Type">char</span> *) erh + MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExpandedRecordHeader));<br/></li>
<li>&nbsp; &nbsp; erh-&gt;dvalues = (Datum *) chunk;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;dnulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) (chunk + tupdesc-&gt;natts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; erh-&gt;nfields = tupdesc-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill in composite-type identification info */<br/></li>
<li></span>&nbsp; &nbsp; erh-&gt;er_decltypeid = olderh-&gt;er_decltypeid;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;er_typeid = olderh-&gt;er_typeid;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;er_typmod = olderh-&gt;er_typmod;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;er_tupdesc_id = olderh-&gt;er_tupdesc_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The only flag <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> that transfers over is IS_DOMAIN */<br/></li>
<li></span>&nbsp; &nbsp; erh-&gt;flags = olderh-&gt;flags &amp; ER_FLAG_IS_DOMAIN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy tupdesc if needed, but we prefer to bump its refcount if possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We manage the refcount with a memory context callback rather than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assuming that the <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> is longer-lived than this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expanded object.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tupdesc-&gt;tdrefcount &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Register callback to release the refcount */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_mcb.func = <a href="#L902" title="utils/adt/expandedrecord.c:902">ER_mc_callback</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_mcb.arg = (<span class="Type">void</span> *) erh;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L568" title="utils/mmgr/mcxt.c:568">MemoryContextRegisterResetCallback</a>(erh-&gt;hdr.eoh_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;erh-&gt;er_mcb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And save the pointer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_tupdesc = tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc-&gt;tdrefcount++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (olderh-&gt;flags &amp; ER_FLAG_TUPDESC_ALLOCED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We need to make our own copy of the tupdesc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(objcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_tupdesc = <a href="../../access/common/tupdesc.c.html#L133" title="access/common/tupdesc.c:133">CreateTupleDescCopy</a>(tupdesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;flags |= ER_FLAG_TUPDESC_ALLOCED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Assume the tupdesc will outlive this expanded object, just like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're assuming it will outlive the source object.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_tupdesc = tupdesc;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't set ER_FLAG_DVALUES_VALID or ER_FLAG_FVALUE_VALID, so the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record remains logically empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> erh;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> given tuple as the value of the expanded record<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is caller's responsibility that the tuple matches the record's<br/></li>
<li></span><span class="Comment"> * previously-assigned rowtype.&nbsp; (However domain constraints, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>,<br/></li>
<li></span><span class="Comment"> * will be checked here.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The tuple is physically copied into the expanded record's local storage<br/></li>
<li></span><span class="Comment"> * if &quot;copy&quot; is true, otherwise it's caller's responsibility that the tuple<br/></li>
<li></span><span class="Comment"> * will live as long as the expanded record does.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Out-of-line field <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the tuple are automatically inlined if<br/></li>
<li></span><span class="Comment"> * &quot;expand_external&quot; is true, otherwise not.&nbsp; (The combination copy = false,<br/></li>
<li></span><span class="Comment"> * expand_external = true is not sensible and not supported.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Alternatively, tuple can be NULL, in which case we just set the expanded<br/></li>
<li></span><span class="Comment"> * record to be empty.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L440">&#x200c;</a></span><span class="linkable">expanded_record_set_tuple</span>(ExpandedRecordHeader *erh,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> copy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> expand_external)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldflags;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; oldtuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *oldfstartptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *oldfendptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newflags;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; newtuple;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't ever be trying to assign new data to a dummy header */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!(erh-&gt;flags &amp; ER_FLAG_IS_DUMMY));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Before performing the assignment, see if result will satisfy domain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (erh-&gt;flags &amp; ER_FLAG_IS_DOMAIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1576" title="utils/adt/expandedrecord.c:1576">check_domain_for_new_tuple</a>(erh, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we need to get rid of out-of-line field <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, do so, using the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * short-term context to avoid leaking whatever cruft the toast fetch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might generate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (expand_external &amp;&amp; tuple)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assert caller didn't ask for unsupported case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(copy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleHasExternal(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="#L1379" title="utils/adt/expandedrecord.c:1379">get_short_term_cxt</a>(erh));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../../access/heap/heaptoast.c.html#L350" title="access/heap/heaptoast.c:350">toast_flatten_tuple</a>(tuple, erh-&gt;er_tupdesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expand_external = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* need not clean up below */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize new flags, keeping only non-data status bits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldflags = erh-&gt;flags;<br/></li>
<li>&nbsp; &nbsp; newflags = oldflags &amp; ER_FLAGS_NON_DATA;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy tuple into local storage if needed.&nbsp; We must be sure this succeeds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we start to modify the expanded record's state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (copy &amp;&amp; tuple)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(erh-&gt;hdr.eoh_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newtuple = <a href="../../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newflags |= ER_FLAG_FVALUE_ALLOCED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> flush anything that detoasting might have leaked. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expand_external)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(erh-&gt;er_short_term_cxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newtuple = tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make copies of fields we're about to overwrite */<br/></li>
<li></span>&nbsp; &nbsp; oldtuple = erh-&gt;fvalue;<br/></li>
<li>&nbsp; &nbsp; oldfstartptr = erh-&gt;fstartptr;<br/></li>
<li>&nbsp; &nbsp; oldfendptr = erh-&gt;fendptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> safe to update the expanded record's state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newtuple)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Save flat representation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;fvalue = newtuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;fstartptr = (<span class="Type">char</span> *) newtuple-&gt;t_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;fendptr = ((<span class="Type">char</span> *) newtuple-&gt;t_data) + newtuple-&gt;t_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newflags |= ER_FLAG_FVALUE_VALID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember if we have <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> out-of-line field <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleHasExternal(newtuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newflags |= ER_FLAG_HAVE_EXTERNAL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;fvalue = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;fstartptr = erh-&gt;fendptr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; erh-&gt;flags = newflags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset flat-size info; we don't bother to make it valid <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; erh-&gt;flat_size = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now, release <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> storage belonging to old field <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; It's safe to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do this because ER_FLAG_DVALUES_VALID is no longer set in erh-&gt;flags;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * even if we fail partway through, the record is valid, and at worst<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we've failed to reclaim some space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (oldflags &amp; ER_FLAG_DVALUES_ALLOCED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc = erh-&gt;er_tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; erh-&gt;nfields; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!erh-&gt;dnulls[i] &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !(TupleDescAttr(tupdesc, i)-&gt;attbyval))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *oldValue = (<span class="Type">char</span> *) DatumGetPointer(erh-&gt;dvalues[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldValue &lt; oldfstartptr || oldValue &gt;= oldfendptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(oldValue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Likewise free the old tuple, if it was locally allocated */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (oldflags &amp; ER_FLAG_FVALUE_ALLOCED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(oldtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We won't make a new deconstructed representation until/unless needed */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L580" title="utils/adt/expandedrecord.c:580">make_expanded_record_from_datum</a>: build expanded record from composite Datum<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This combines the <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> of <a href="#L69" title="utils/adt/expandedrecord.c:69">make_expanded_record_from_typeid</a> and<br/></li>
<li></span><span class="Comment"> * <a href="#L440" title="utils/adt/expandedrecord.c:440">expanded_record_set_tuple</a>.&nbsp; However, we do not force a lookup of the<br/></li>
<li></span><span class="Comment"> * tupdesc immediately, reasoning that it might never be needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The expanded object will be a child of parentcontext.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: a composite datum cannot self-identify as being of a domain type,<br/></li>
<li></span><span class="Comment"> * so we need not consider domain cases here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L580">&#x200c;</a><span class="linkable">make_expanded_record_from_datum</span>(Datum recorddatum, MemoryContext parentcontext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExpandedRecordHeader *erh;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader tuphdr;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tmptup;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; newtuple;<br/></li>
<li>&nbsp; &nbsp; MemoryContext objcxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate private context for expanded object.&nbsp; We use a regular-size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context, not a small one, to improve the odds that we can fit a tupdesc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into it without needing an extra malloc block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; objcxt = AllocSetContextCreate(parentcontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;expanded record&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up expanded record header, initializing fields to 0/null */<br/></li>
<li></span>&nbsp; &nbsp; erh = (ExpandedRecordHeader *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(objcxt, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExpandedRecordHeader));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="expandeddatum.c.html#L48" title="utils/adt/expandeddatum.c:48">EOH_init_header</a>(&amp;erh-&gt;hdr, &amp;<a href="#L38" title="utils/adt/expandedrecord.c:38">ER_methods</a>, objcxt);<br/></li>
<li>&nbsp; &nbsp; erh-&gt;er_magic = ER_MAGIC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Detoast and copy source record into private context, as a HeapTuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (If we actually have to detoast the source, we'll leak some memory in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the caller's context, but it doesn't seem worth worrying about.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tuphdr = DatumGetHeapTupleHeader(recorddatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tmptup.t_len = HeapTupleHeaderGetDatumLength(tuphdr);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tmptup.t_self));<br/></li>
<li>&nbsp; &nbsp; tmptup.t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; tmptup.t_data = tuphdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(objcxt);<br/></li>
<li>&nbsp; &nbsp; newtuple = <a href="../../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(&amp;tmptup);<br/></li>
<li>&nbsp; &nbsp; erh-&gt;flags |= ER_FLAG_FVALUE_ALLOCED;<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill in composite-type identification info */<br/></li>
<li></span>&nbsp; &nbsp; erh-&gt;er_decltypeid = erh-&gt;er_typeid = HeapTupleHeaderGetTypeId(tuphdr);<br/></li>
<li>&nbsp; &nbsp; erh-&gt;er_typmod = HeapTupleHeaderGetTypMod(tuphdr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remember we have a flat representation */<br/></li>
<li></span>&nbsp; &nbsp; erh-&gt;fvalue = newtuple;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;fstartptr = (<span class="Type">char</span> *) newtuple-&gt;t_data;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;fendptr = ((<span class="Type">char</span> *) newtuple-&gt;t_data) + newtuple-&gt;t_len;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;flags |= ER_FLAG_FVALUE_VALID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't need to set ER_FLAG_HAVE_EXTERNAL */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!HeapTupleHeaderHasExternal(tuphdr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We won't look up the tupdesc till we have to, nor make a deconstructed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * representation.&nbsp; We don't have enough info to fill flat_size and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * friends, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* return a R/W pointer to the expanded record */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> EOHPGetRWDatum(&amp;erh-&gt;hdr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * get_flat_size method for expanded <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: call this in a reasonably short-lived memory context, in case of<br/></li>
<li></span><span class="Comment"> * memory leaks from activities such as detoasting.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Size<br/></li>
<li><a id="L652">&#x200c;</a><span class="linkable">ER_get_flat_size</span>(ExpandedObjectHeader *eohptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExpandedRecordHeader *erh = (ExpandedRecordHeader *) eohptr;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; data_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hoff;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasnull;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(erh-&gt;er_magic == ER_MAGIC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The flat representation has to be a valid composite datum.&nbsp; Make sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we have a registered, not anonymous, RECORD type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (erh-&gt;er_typeid == RECORDOID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_typmod &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc = expanded_record_get_tupdesc(erh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/typcache.c.html#L1953" title="utils/cache/typcache.c:1953">assign_record_type_typmod</a>(tupdesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_typmod = tupdesc-&gt;tdtypmod;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have a valid flattened value without out-of-line fields, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just use it as-is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (erh-&gt;flags &amp; ER_FLAG_FVALUE_VALID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(erh-&gt;flags &amp; ER_FLAG_HAVE_EXTERNAL))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> erh-&gt;fvalue-&gt;t_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we have a cached size value, believe that */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (erh-&gt;flat_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> erh-&gt;flat_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we haven't yet deconstructed the tuple, do that */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(erh-&gt;flags &amp; ER_FLAG_DVALUES_VALID))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L952" title="utils/adt/expandedrecord.c:952">deconstruct_expanded_record</a>(erh);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Tuple descriptor must be valid by <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; tupdesc = erh-&gt;er_tupdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Composite datums mustn't contain <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> out-of-line <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (erh-&gt;flags &amp; ER_FLAG_HAVE_EXTERNAL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; erh-&gt;nfields; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(tupdesc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!erh-&gt;dnulls[i] &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !attr-&gt;attbyval &amp;&amp; attr-&gt;attlen == -<span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARATT_IS_EXTERNAL(DatumGetPointer(erh-&gt;dvalues[i])))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1112" title="utils/adt/expandedrecord.c:1112">expanded_record_set_field_internal</a> can do the actual work<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of detoasting.&nbsp; It needn't recheck domain constraints.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1112" title="utils/adt/expandedrecord.c:1112">expanded_record_set_field_internal</a>(erh, i + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; erh-&gt;dvalues[i], <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> removed all external field <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, so we can clear the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * flag about them.&nbsp; This won't cause <a href="#L764" title="utils/adt/expandedrecord.c:764">ER_flatten_into</a>() to mistakenly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * take the fast path, since expanded_record_set_field() will have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cleared ER_FLAG_FVALUE_VALID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;flags &amp;= ~ER_FLAG_HAVE_EXTERNAL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Test if we currently have <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> null <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; hasnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; erh-&gt;nfields; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (erh-&gt;dnulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine total space needed */<br/></li>
<li></span>&nbsp; &nbsp; len = offsetof(HeapTupleHeaderData, t_bits);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hasnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len += BITMAPLEN(tupdesc-&gt;natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hoff = len = MAXALIGN(len); <span class="Comment">/* align user data safely */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; data_len = <a href="../../access/common/heaptuple.c.html#L215" title="access/common/heaptuple.c:215">heap_compute_data_size</a>(tupdesc, erh-&gt;dvalues, erh-&gt;dnulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len += data_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cache for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time */<br/></li>
<li></span>&nbsp; &nbsp; erh-&gt;flat_size = len;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;data_len = data_len;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;hoff = hoff;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;hasnull = hasnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> len;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * flatten_into method for expanded <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L764">&#x200c;</a></span><span class="linkable">ER_flatten_into</span>(ExpandedObjectHeader *eohptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *result, Size allocated_size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExpandedRecordHeader *erh = (ExpandedRecordHeader *) eohptr;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader tuphdr = (HeapTupleHeader) result;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(erh-&gt;er_magic == ER_MAGIC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Easy if we have a valid flattened value without out-of-line fields */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (erh-&gt;flags &amp; ER_FLAG_FVALUE_VALID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(erh-&gt;flags &amp; ER_FLAG_HAVE_EXTERNAL))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(allocated_size == erh-&gt;fvalue-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(tuphdr, erh-&gt;fvalue-&gt;t_data, allocated_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The original flattened value might not have datum header fields */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetDatumLength(tuphdr, allocated_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetTypeId(tuphdr, erh-&gt;er_typeid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetTypMod(tuphdr, erh-&gt;er_typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else allocation should match previous get_flat_size result */<br/></li>
<li></span>&nbsp; &nbsp; Assert(allocated_size == erh-&gt;flat_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We'll need the tuple descriptor */<br/></li>
<li></span>&nbsp; &nbsp; tupdesc = expanded_record_get_tupdesc(erh);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We must ensure that <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pad space is zero-filled */<br/></li>
<li></span>&nbsp; &nbsp; memset(tuphdr, <span class="Constant">0</span>, allocated_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up header fields of composite Datum */<br/></li>
<li></span>&nbsp; &nbsp; HeapTupleHeaderSetDatumLength(tuphdr, allocated_size);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetTypeId(tuphdr, erh-&gt;er_typeid);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetTypMod(tuphdr, erh-&gt;er_typmod);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We also make sure that t_ctid is invalid unless explicitly set */<br/></li>
<li></span>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tuphdr-&gt;t_ctid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetNatts(tuphdr, tupdesc-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; tuphdr-&gt;t_hoff = erh-&gt;hoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And fill the data area from dvalues/dnulls */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L400" title="access/common/heaptuple.c:400">heap_fill_tuple</a>(tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;dvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;dnulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">char</span> *) tuphdr + erh-&gt;hoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;data_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tuphdr-&gt;t_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (erh-&gt;hasnull ? tuphdr-&gt;t_bits : <span class="Constant">NULL</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Look up the tupdesc for the expanded record's actual type<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: code <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> to this module is allowed to just fetch<br/></li>
<li></span><span class="Comment"> * erh-&gt;er_tupdesc if ER_FLAG_DVALUES_VALID is set; otherwise it should call<br/></li>
<li></span><span class="Comment"> * expanded_record_get_tupdesc.&nbsp; This function is the out-of-line portion<br/></li>
<li></span><span class="Comment"> * of expanded_record_get_tupdesc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleDesc<br/></li>
<li><a id="L824">&#x200c;</a><span class="linkable">expanded_record_fetch_tupdesc</span>(ExpandedRecordHeader *erh)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Easy if we already have it (but caller should have checked already) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (erh-&gt;er_tupdesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> erh-&gt;er_tupdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lookup the composite type's tupdesc using the typcache */<br/></li>
<li></span>&nbsp; &nbsp; tupdesc = <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(erh-&gt;er_typeid, erh-&gt;er_typmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's a refcounted tupdesc rather than a statically allocated one, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * want to manage the refcount with a memory context callback rather than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assuming that the <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> is longer-lived than this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expanded object.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tupdesc-&gt;tdrefcount &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Register callback if we didn't already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (erh-&gt;er_mcb.arg == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_mcb.func = <a href="#L902" title="utils/adt/expandedrecord.c:902">ER_mc_callback</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_mcb.arg = (<span class="Type">void</span> *) erh;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L568" title="utils/mmgr/mcxt.c:568">MemoryContextRegisterResetCallback</a>(erh-&gt;hdr.eoh_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;erh-&gt;er_mcb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember our own pointer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_tupdesc = tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc-&gt;tdrefcount++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release the pin <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a> acquired */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ReleaseTupleDesc(tupdesc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Just remember the pointer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_tupdesc = tupdesc;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* In either case, fetch the process-global ID for this tupdesc */<br/></li>
<li></span>&nbsp; &nbsp; erh-&gt;er_tupdesc_id = <a href="../cache/typcache.c.html#L2045" title="utils/cache/typcache.c:2045">assign_record_type_identifier</a>(tupdesc-&gt;tdtypeid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tupdesc-&gt;tdtypmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tupdesc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get a HeapTuple representing the current value of the expanded record<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If valid, the originally stored tuple is returned, so caller must not<br/></li>
<li></span><span class="Comment"> * scribble on it.&nbsp; Otherwise, we return a HeapTuple created in the current<br/></li>
<li></span><span class="Comment"> * memory context.&nbsp; In either case, no attempt has been made to inline<br/></li>
<li></span><span class="Comment"> * out-of-line toasted <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, so the tuple isn't usable as a composite<br/></li>
<li></span><span class="Comment"> * datum.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns NULL if expanded record is empty.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L884">&#x200c;</a><span class="linkable">expanded_record_get_tuple</span>(ExpandedRecordHeader *erh)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Easy case if we still have original tuple */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (erh-&gt;flags &amp; ER_FLAG_FVALUE_VALID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> erh-&gt;fvalue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else just build a tuple from datums */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (erh-&gt;flags &amp; ER_FLAG_DVALUES_VALID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(erh-&gt;er_tupdesc, erh-&gt;dvalues, erh-&gt;dnulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Expanded record is empty */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Memory context reset callback for cleaning up external resources<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L902">&#x200c;</a></span><span class="linkable">ER_mc_callback</span>(<span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExpandedRecordHeader *erh = (ExpandedRecordHeader *) arg;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc = erh-&gt;er_tupdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release our privately-managed tupdesc refcount, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tupdesc)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_tupdesc = <span class="Constant">NULL</span>; <span class="Comment">/* just for luck */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tupdesc-&gt;tdrefcount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (--tupdesc-&gt;tdrefcount == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/tupdesc.c.html#L331" title="access/common/tupdesc.c:331">FreeTupleDesc</a>(tupdesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L927" title="utils/adt/expandedrecord.c:927">DatumGetExpandedRecord</a>: get a writable expanded record from an input argument<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caution: if the input is a read/write pointer, this returns the input<br/></li>
<li></span><span class="Comment"> * argument; so callers must be sure that their changes are &quot;safe&quot;, that is<br/></li>
<li></span><span class="Comment"> * they cannot leave the record in a corrupt state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ExpandedRecordHeader *<br/></li>
<li><a id="L927">&#x200c;</a><span class="linkable">DatumGetExpandedRecord</span>(Datum d)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it's a writable expanded record already, just return it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXTERNAL_EXPANDED_RW(DatumGetPointer(d)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExpandedRecordHeader *erh = (ExpandedRecordHeader *) <a href="expandeddatum.c.html#L29" title="utils/adt/expandeddatum.c:29">DatumGetEOHP</a>(d);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(erh-&gt;er_magic == ER_MAGIC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> erh;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else expand the hard way */<br/></li>
<li></span>&nbsp; &nbsp; d = <a href="#L580" title="utils/adt/expandedrecord.c:580">make_expanded_record_from_datum</a>(d, <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (ExpandedRecordHeader *) <a href="expandeddatum.c.html#L29" title="utils/adt/expandeddatum.c:29">DatumGetEOHP</a>(d);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create the Datum/isnull representation of an expanded record object<br/></li>
<li></span><span class="Comment"> * if we didn't do so already.&nbsp; After calling this, it's OK to read the<br/></li>
<li></span><span class="Comment"> * dvalues/dnulls arrays directly, rather than going through get_field.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that if the object is currently empty (&quot;null&quot;), this will change<br/></li>
<li></span><span class="Comment"> * it to represent a row of nulls.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L952">&#x200c;</a></span><span class="linkable">deconstruct_expanded_record</span>(ExpandedRecordHeader *erh)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *dvalues;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *dnulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nfields;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (erh-&gt;flags &amp; ER_FLAG_DVALUES_VALID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* already valid, nothing to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We'll need the tuple descriptor */<br/></li>
<li></span>&nbsp; &nbsp; tupdesc = expanded_record_get_tupdesc(erh);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate arrays in private context, if we don't have them already.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't expect to see a change in nfields here, so while we cope if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happens, we don't bother avoiding a leak of the old arrays (which might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not be separately <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d, anyway).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nfields = tupdesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (erh-&gt;dvalues == <span class="Constant">NULL</span> || erh-&gt;nfields != nfields)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *chunk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To save a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> cycle, we allocate both the Datum and isnull<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * arrays in one <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> chunk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; chunk = <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(erh-&gt;hdr.eoh_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nfields * (<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dvalues = (Datum *) chunk;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dnulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) (chunk + nfields * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;dvalues = dvalues;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;dnulls = dnulls;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;nfields = nfields;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dvalues = erh-&gt;dvalues;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dnulls = erh-&gt;dnulls;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (erh-&gt;flags &amp; ER_FLAG_FVALUE_VALID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Deconstruct tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(erh-&gt;fvalue, tupdesc, dvalues, dnulls);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If record was empty, instantiate it as a row of nulls */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memset(dvalues, <span class="Constant">0</span>, nfields * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(dnulls, <span class="Constant">true</span>, nfields * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the dvalues as valid */<br/></li>
<li></span>&nbsp; &nbsp; erh-&gt;flags |= ER_FLAG_DVALUES_VALID;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Look up a record field by name<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there is a field named &quot;fieldname&quot;, fill in the contents of finfo<br/></li>
<li></span><span class="Comment"> * and return &quot;true&quot;.&nbsp; Else return &quot;false&quot; without changing *finfo.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1017">&#x200c;</a></span><span class="linkable">expanded_record_lookup_field</span>(ExpandedRecordHeader *erh, <span class="Type">const</span> <span class="Type">char</span> *fieldname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExpandedRecordFieldInfo *finfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fno;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> FormData_pg_attribute *sysattr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tupdesc = expanded_record_get_tupdesc(erh);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First, check user-defined attributes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (fno = <span class="Constant">0</span>; fno &lt; tupdesc-&gt;natts; fno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attr = TupleDescAttr(tupdesc, fno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="name.c.html#L247" title="utils/adt/name.c:247">namestrcmp</a>(&amp;attr-&gt;attname, fieldname) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !attr-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;fnumber = attr-&gt;attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;ftypeid = attr-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;ftypmod = attr-&gt;atttypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;fcollation = attr-&gt;attcollation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* How about system attributes? */<br/></li>
<li></span>&nbsp; &nbsp; sysattr = <a href="../../catalog/heap.c.html#L252" title="catalog/heap.c:252">SystemAttributeByName</a>(fieldname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sysattr != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;fnumber = sysattr-&gt;attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;ftypeid = sysattr-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;ftypmod = sysattr-&gt;atttypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;fcollation = sysattr-&gt;attcollation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch value of record field<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * expanded_record_get_field is the frontend for this; it handles the<br/></li>
<li></span><span class="Comment"> * easy inline-able cases.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1063">&#x200c;</a><span class="linkable">expanded_record_fetch_field</span>(ExpandedRecordHeader *erh, <span class="Type">int</span> fnumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fnumber &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Empty record has null fields */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ExpandedRecordIsEmpty(erh))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure we have deconstructed form */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L952" title="utils/adt/expandedrecord.c:952">deconstruct_expanded_record</a>(erh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> field number reads as null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(fnumber &gt; erh-&gt;nfields))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isnull = erh-&gt;dnulls[fnumber - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> erh-&gt;dvalues[fnumber - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* System columns read as null if we haven't got flat tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (erh-&gt;fvalue == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../access/common/heaptuple.c.html#L723" title="access/common/heaptuple.c:723">heap_getsysattr</a> doesn't actually use tupdesc, so just pass null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../access/common/heaptuple.c.html#L723" title="access/common/heaptuple.c:723">heap_getsysattr</a>(erh-&gt;fvalue, fnumber, <span class="Constant">NULL</span>, isnull);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set value of record field<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the expanded record is of domain type, the assignment will be rejected<br/></li>
<li></span><span class="Comment"> * (without changing the record's state) if the domain's constraints would<br/></li>
<li></span><span class="Comment"> * be violated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If expand_external is true and newValue is an out-of-line value, we'll<br/></li>
<li></span><span class="Comment"> * forcibly detoast it so that the record does not depend on external storage.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Internal callers can pass check_constraints = false to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> application<br/></li>
<li></span><span class="Comment"> * of domain constraints.&nbsp; External callers should never do that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1112">&#x200c;</a></span><span class="linkable">expanded_record_set_field_internal</span>(ExpandedRecordHeader *erh, <span class="Type">int</span> fnumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum newValue, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> expand_external,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> check_constraints)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attr;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *dvalues;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *dnulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *oldValue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Shouldn't ever be trying to assign new data to a dummy header, except<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the case of an <a href="pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> call for field inlining.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!(erh-&gt;flags &amp; ER_FLAG_IS_DUMMY) || !check_constraints);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Before performing the assignment, see if result will satisfy domain */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((erh-&gt;flags &amp; ER_FLAG_IS_DOMAIN) &amp;&amp; check_constraints)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1494" title="utils/adt/expandedrecord.c:1494">check_domain_for_new_field</a>(erh, fnumber, newValue, isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we haven't yet deconstructed the tuple, do that */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(erh-&gt;flags &amp; ER_FLAG_DVALUES_VALID))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L952" title="utils/adt/expandedrecord.c:952">deconstruct_expanded_record</a>(erh);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Tuple descriptor must be valid by <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; tupdesc = erh-&gt;er_tupdesc;<br/></li>
<li>&nbsp; &nbsp; Assert(erh-&gt;nfields == tupdesc-&gt;natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Caller error if fnumber is system column or nonexistent column */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(fnumber &lt;= <span class="Constant">0</span> || fnumber &gt; erh-&gt;nfields))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot assign to field </span><span class="Special">%d</span><span class="Constant"> of expanded record&quot;</span>, fnumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy new field value into record's context, and deal with detoasting,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; attr = TupleDescAttr(tupdesc, fnumber - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isnull &amp;&amp; !attr-&gt;attbyval)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If requested, detoast <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> external value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expand_external)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attr-&gt;attlen == -<span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARATT_IS_EXTERNAL(DatumGetPointer(newValue)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Detoasting should be done in short-lived context. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="#L1379" title="utils/adt/expandedrecord.c:1379">get_short_term_cxt</a>(erh));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newValue = PointerGetDatum(<a href="../../access/common/detoast.c.html#L45" title="access/common/detoast.c:45">detoast_external_attr</a>((<span class="Type">struct</span> varlena *) DatumGetPointer(newValue)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expand_external = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* need not clean up below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy value into record's context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(erh-&gt;hdr.eoh_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newValue = <a href="datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(newValue, <span class="Constant">false</span>, attr-&gt;attlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> flush anything that detoasting might have leaked */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expand_external)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(erh-&gt;er_short_term_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember that we have field(s) that may need to be <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'d */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;flags |= ER_FLAG_DVALUES_ALLOCED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * While we're here, note whether it's an external toasted value,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because that could mean we need to inline it later.&nbsp; (Think not to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> this into the previous expand_external logic: <a href="datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a> could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by itself have made the value non-external.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attr-&gt;attlen == -<span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARATT_IS_EXTERNAL(DatumGetPointer(newValue)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;flags |= ER_FLAG_HAVE_EXTERNAL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're ready to make irreversible changes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dvalues = erh-&gt;dvalues;<br/></li>
<li>&nbsp; &nbsp; dnulls = erh-&gt;dnulls;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Flattened value will no longer represent record accurately */<br/></li>
<li></span>&nbsp; &nbsp; erh-&gt;flags &amp;= ~ER_FLAG_FVALUE_VALID;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And we don't know the flattened size either */<br/></li>
<li></span>&nbsp; &nbsp; erh-&gt;flat_size = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Grab old field value for <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'ing, if needed. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!attr-&gt;attbyval &amp;&amp; !dnulls[fnumber - <span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldValue = (<span class="Type">char</span> *) DatumGetPointer(dvalues[fnumber - <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldValue = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And finally we can insert the new field. */<br/></li>
<li></span>&nbsp; &nbsp; dvalues[fnumber - <span class="Constant">1</span>] = newValue;<br/></li>
<li>&nbsp; &nbsp; dnulls[fnumber - <span class="Constant">1</span>] = isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Free old field if needed; this keeps repeated field replacements from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bloating the record's storage.&nbsp; If the <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> somehow fails, it won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corrupt the record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're updating a dummy header, we can't risk <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'ing the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value, because most likely the expanded record's <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> header still has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a pointer to it.&nbsp; This won't result in <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sustained memory leak, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whatever we just allocated here is in the short-lived domain check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (oldValue &amp;&amp; !(erh-&gt;flags &amp; ER_FLAG_IS_DUMMY))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't try to <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> a part of the original flat record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldValue &lt; erh-&gt;fstartptr || oldValue &gt;= erh-&gt;fendptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(oldValue);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set all record field(s)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must ensure that the provided datums are of the right types<br/></li>
<li></span><span class="Comment"> * to match the record's previously assigned rowtype.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If expand_external is true, we'll forcibly detoast out-of-line field <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * so that the record does not depend on external storage.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike repeated application of expanded_record_set_field(), this does not<br/></li>
<li></span><span class="Comment"> * guarantee to leave the expanded record in a non-corrupt state in event<br/></li>
<li></span><span class="Comment"> * of an error.&nbsp; Typically it would only be used for initializing a new<br/></li>
<li></span><span class="Comment"> * expanded record.&nbsp; Also, because we expect this to be applied at most once<br/></li>
<li></span><span class="Comment"> * in the lifespan of an expanded record, we do not worry about <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cruft<br/></li>
<li></span><span class="Comment"> * that detoasting might leak.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1249">&#x200c;</a></span><span class="linkable">expanded_record_set_fields</span>(ExpandedRecordHeader *erh,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> Datum *newValues, <span class="Type">const</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> expand_external)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *dvalues;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *dnulls;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fnumber;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't ever be trying to assign new data to a dummy header */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!(erh-&gt;flags &amp; ER_FLAG_IS_DUMMY));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we haven't yet deconstructed the tuple, do that */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(erh-&gt;flags &amp; ER_FLAG_DVALUES_VALID))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L952" title="utils/adt/expandedrecord.c:952">deconstruct_expanded_record</a>(erh);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Tuple descriptor must be valid by <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; tupdesc = erh-&gt;er_tupdesc;<br/></li>
<li>&nbsp; &nbsp; Assert(erh-&gt;nfields == tupdesc-&gt;natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Flattened value will no longer represent record accurately */<br/></li>
<li></span>&nbsp; &nbsp; erh-&gt;flags &amp;= ~ER_FLAG_FVALUE_VALID;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And we don't know the flattened size either */<br/></li>
<li></span>&nbsp; &nbsp; erh-&gt;flat_size = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(erh-&gt;hdr.eoh_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dvalues = erh-&gt;dvalues;<br/></li>
<li>&nbsp; &nbsp; dnulls = erh-&gt;dnulls;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (fnumber = <span class="Constant">0</span>; fnumber &lt; erh-&gt;nfields; fnumber++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(tupdesc, fnumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; newValue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore dropped columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attr-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newValue = newValues[fnumber];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isnull = isnulls[fnumber];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!attr-&gt;attbyval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy new field value into record's context, and deal with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * detoasting, if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is it an external toasted value? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attr-&gt;attlen == -<span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARATT_IS_EXTERNAL(DatumGetPointer(newValue)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expand_external)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Detoast as requested while copying the value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newValue = PointerGetDatum(<a href="../../access/common/detoast.c.html#L45" title="access/common/detoast.c:45">detoast_external_attr</a>((<span class="Type">struct</span> varlena *) DatumGetPointer(newValue)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Just copy the value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newValue = <a href="datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(newValue, <span class="Constant">false</span>, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's still external, remember that */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXTERNAL(DatumGetPointer(newValue)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;flags |= ER_FLAG_HAVE_EXTERNAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not an external value, just copy it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newValue = <a href="datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(newValue, <span class="Constant">false</span>, attr-&gt;attlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember that we have field(s) that need to be <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'d */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;flags |= ER_FLAG_DVALUES_ALLOCED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Free old field value, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> (not likely, since really we ought<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to be inserting into an empty record).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(!dnulls[fnumber]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *oldValue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldValue = (<span class="Type">char</span> *) DatumGetPointer(dvalues[fnumber]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't try to <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> a part of the original flat record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldValue &lt; erh-&gt;fstartptr || oldValue &gt;= erh-&gt;fendptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(oldValue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And finally we can insert the new field. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dvalues[fnumber] = newValue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dnulls[fnumber] = isnull;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because we don't guarantee atomicity of set_fields(), we can just leave<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checking of domain constraints to occur as the final step; if it throws<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an error, too bad.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (erh-&gt;flags &amp; ER_FLAG_IS_DOMAIN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We run <a href="domains.c.html#L346" title="utils/adt/domains.c:346">domain_check</a> in a short-lived context to limit cruft */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(<a href="#L1379" title="utils/adt/expandedrecord.c:1379">get_short_term_cxt</a>(erh));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="domains.c.html#L346" title="utils/adt/domains.c:346">domain_check</a>(ExpandedRecordGetRODatum(erh), <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; erh-&gt;er_decltypeid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;erh-&gt;er_domaininfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; erh-&gt;hdr.eoh_context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Construct (or reset) working memory context for short-term operations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This context is used for domain check evaluation and for detoasting.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we don't have a short-lived memory context, make one; if we have one,<br/></li>
<li></span><span class="Comment"> * reset it to get rid of <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> leftover cruft.&nbsp; (It is a tad annoying to need a<br/></li>
<li></span><span class="Comment"> * whole context for this, since it will often go unused --- but it's hard to<br/></li>
<li></span><span class="Comment"> * avoid memory leaks otherwise.&nbsp; We can make the context small, at least.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> MemoryContext<br/></li>
<li><a id="L1379">&#x200c;</a><span class="linkable">get_short_term_cxt</span>(ExpandedRecordHeader *erh)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (erh-&gt;er_short_term_cxt == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_short_term_cxt =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AllocSetContextCreate(erh-&gt;hdr.eoh_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;expanded record short-term context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(erh-&gt;er_short_term_cxt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> erh-&gt;er_short_term_cxt;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Construct &quot;dummy header&quot; for checking domain constraints.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since we don't want to modify the state of the expanded record until<br/></li>
<li></span><span class="Comment"> * we've validated the constraints, our approach is to set up a dummy<br/></li>
<li></span><span class="Comment"> * record header containing the new field value(s) and then pass that to<br/></li>
<li></span><span class="Comment"> * <a href="domains.c.html#L346" title="utils/adt/domains.c:346">domain_check</a>.&nbsp; We retain the dummy header as part of the expanded<br/></li>
<li></span><span class="Comment"> * record's state to save <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> cycles, but reinitialize (most of)<br/></li>
<li></span><span class="Comment"> * its contents on each use.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1402">&#x200c;</a></span><span class="linkable">build_dummy_expanded_header</span>(ExpandedRecordHeader *main_erh)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExpandedRecordHeader *erh;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc = expanded_record_get_tupdesc(main_erh);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure we have a short-lived context */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1379" title="utils/adt/expandedrecord.c:1379">get_short_term_cxt</a>(main_erh);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate dummy header on first time through, or in the unlikely event<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the number of fields changes (in which case we just leak the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one).&nbsp; Include space for its field <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the request.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; erh = main_erh-&gt;er_dummy_header;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (erh == <span class="Constant">NULL</span> || erh-&gt;nfields != tupdesc-&gt;natts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *chunk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh = (ExpandedRecordHeader *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(main_erh-&gt;hdr.eoh_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExpandedRecordHeader))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; + tupdesc-&gt;natts * (<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ensure all header fields are initialized to 0/null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memset(erh, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExpandedRecordHeader));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We set up the dummy header with an indication that its memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * context is the short-lived context.&nbsp; This is so that, if <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * detoasting of out-of-line <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> happens due to an attempt to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * extract a composite datum from the dummy header, the detoasted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stuff will end up in the short-lived context and not cause a leak.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is cheating a <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> on the expanded-object protocol; but since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we never pass a R/W pointer to the dummy object to <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other code,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nothing else is authorized to delete or transfer ownership of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * object's context, so it should be safe enough.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="expandeddatum.c.html#L48" title="utils/adt/expandeddatum.c:48">EOH_init_header</a>(&amp;erh-&gt;hdr, &amp;<a href="#L38" title="utils/adt/expandedrecord.c:38">ER_methods</a>, main_erh-&gt;er_short_term_cxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;er_magic = ER_MAGIC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up dvalues/dnulls, with no valid contents as yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; chunk = (<span class="Type">char</span> *) erh + MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ExpandedRecordHeader));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;dvalues = (Datum *) chunk;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;dnulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) (chunk + tupdesc-&gt;natts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; erh-&gt;nfields = tupdesc-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The fields we just set are assumed to remain constant through<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple uses of the dummy header to check domain constraints.&nbsp; All<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other dummy header fields should be explicitly reset below, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ensure there's not accidental effects of one check on the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; main_erh-&gt;er_dummy_header = erh;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If anything inquires about the dummy header's declared type, it should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * report the composite base type, not the domain type (since the VALUE in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a domain check constraint is of the base type not the domain).&nbsp; Hence<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we do not transfer over the IS_DOMAIN flag, nor indeed <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * header's flags, since the dummy header is empty of data at this point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * But don't forget to mark header as dummy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; erh-&gt;flags = ER_FLAG_IS_DUMMY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy composite-type identification info */<br/></li>
<li></span>&nbsp; &nbsp; erh-&gt;er_decltypeid = erh-&gt;er_typeid = main_erh-&gt;er_typeid;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;er_typmod = main_erh-&gt;er_typmod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Dummy header does not need its own tupdesc refcount */<br/></li>
<li></span>&nbsp; &nbsp; erh-&gt;er_tupdesc = tupdesc;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;er_tupdesc_id = main_erh-&gt;er_tupdesc_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's tempting to copy over whatever we know about the flat size, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there's no point since we're surely about to modify the dummy record's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * field(s).&nbsp; Instead just clear anything left over from a previous usage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cycle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; erh-&gt;flat_size = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy over fvalue if we have it, so that system columns are available */<br/></li>
<li></span>&nbsp; &nbsp; erh-&gt;fvalue = main_erh-&gt;fvalue;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;fstartptr = main_erh-&gt;fstartptr;<br/></li>
<li>&nbsp; &nbsp; erh-&gt;fendptr = main_erh-&gt;fendptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Precheck domain constraints for a set_field operation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> pg_noinline <span class="Type">void<br/></li>
<li><a id="L1494">&#x200c;</a></span><span class="linkable">check_domain_for_new_field</span>(ExpandedRecordHeader *erh, <span class="Type">int</span> fnumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum newValue, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExpandedRecordHeader *dummy_erh;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Construct dummy header to contain proposed new field set */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1402" title="utils/adt/expandedrecord.c:1402">build_dummy_expanded_header</a>(erh);<br/></li>
<li>&nbsp; &nbsp; dummy_erh = erh-&gt;er_dummy_header;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If record isn't empty, just deconstruct it (if needed) and copy over<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the existing field <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; If it is empty, just fill fields with nulls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * manually --- don't call <a href="#L952" title="utils/adt/expandedrecord.c:952">deconstruct_expanded_record</a> prematurely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!ExpandedRecordIsEmpty(erh))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L952" title="utils/adt/expandedrecord.c:952">deconstruct_expanded_record</a>(erh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(dummy_erh-&gt;dvalues, erh-&gt;dvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dummy_erh-&gt;nfields * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(dummy_erh-&gt;dnulls, erh-&gt;dnulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dummy_erh-&gt;nfields * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There might be some external <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in there... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dummy_erh-&gt;flags |= erh-&gt;flags &amp; ER_FLAG_HAVE_EXTERNAL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(dummy_erh-&gt;dvalues, <span class="Constant">0</span>, dummy_erh-&gt;nfields * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(dummy_erh-&gt;dnulls, <span class="Constant">true</span>, dummy_erh-&gt;nfields * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Either way, we <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have valid dvalues */<br/></li>
<li></span>&nbsp; &nbsp; dummy_erh-&gt;flags |= ER_FLAG_DVALUES_VALID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Caller error if fnumber is system column or nonexistent column */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(fnumber &lt;= <span class="Constant">0</span> || fnumber &gt; dummy_erh-&gt;nfields))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot assign to field </span><span class="Special">%d</span><span class="Constant"> of expanded record&quot;</span>, fnumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> proposed new value into dummy field array */<br/></li>
<li></span>&nbsp; &nbsp; dummy_erh-&gt;dvalues[fnumber - <span class="Constant">1</span>] = newValue;<br/></li>
<li>&nbsp; &nbsp; dummy_erh-&gt;dnulls[fnumber - <span class="Constant">1</span>] = isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The proposed new value might be external, in which case we'd better set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the flag for that in dummy_erh.&nbsp; (This matters in case something in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * domain check expressions tries to extract a flat value from the dummy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * header.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(erh-&gt;er_tupdesc, fnumber - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!attr-&gt;attbyval &amp;&amp; attr-&gt;attlen == -<span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARATT_IS_EXTERNAL(DatumGetPointer(newValue)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dummy_erh-&gt;flags |= ER_FLAG_HAVE_EXTERNAL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We call <a href="domains.c.html#L346" title="utils/adt/domains.c:346">domain_check</a> in the short-lived context, so that <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cruft<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leaked by expression evaluation can be reclaimed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(erh-&gt;er_short_term_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we can apply the check.&nbsp; Note we use <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> header's domain cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space, so that caching carries across repeated uses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="domains.c.html#L346" title="utils/adt/domains.c:346">domain_check</a>(ExpandedRecordGetRODatum(dummy_erh), <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; erh-&gt;er_decltypeid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;erh-&gt;er_domaininfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; erh-&gt;hdr.eoh_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We might as well clean up cruft immediately. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(erh-&gt;er_short_term_cxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Precheck domain constraints for a set_tuple operation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> pg_noinline <span class="Type">void<br/></li>
<li><a id="L1576">&#x200c;</a></span><span class="linkable">check_domain_for_new_tuple</span>(ExpandedRecordHeader *erh, HeapTuple tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ExpandedRecordHeader *dummy_erh;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we're being told to set record to empty, just see if NULL is OK */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tuple == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We run <a href="domains.c.html#L346" title="utils/adt/domains.c:346">domain_check</a> in a short-lived context to limit cruft */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="#L1379" title="utils/adt/expandedrecord.c:1379">get_short_term_cxt</a>(erh));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="domains.c.html#L346" title="utils/adt/domains.c:346">domain_check</a>((Datum) <span class="Constant">0</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; erh-&gt;er_decltypeid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;erh-&gt;er_domaininfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; erh-&gt;hdr.eoh_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We might as well clean up cruft immediately. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(erh-&gt;er_short_term_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Construct dummy header to contain replacement tuple */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1402" title="utils/adt/expandedrecord.c:1402">build_dummy_expanded_header</a>(erh);<br/></li>
<li>&nbsp; &nbsp; dummy_erh = erh-&gt;er_dummy_header;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> tuple, but don't bother to deconstruct its fields for <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; dummy_erh-&gt;fvalue = tuple;<br/></li>
<li>&nbsp; &nbsp; dummy_erh-&gt;fstartptr = (<span class="Type">char</span> *) tuple-&gt;t_data;<br/></li>
<li>&nbsp; &nbsp; dummy_erh-&gt;fendptr = ((<span class="Type">char</span> *) tuple-&gt;t_data) + tuple-&gt;t_len;<br/></li>
<li>&nbsp; &nbsp; dummy_erh-&gt;flags |= ER_FLAG_FVALUE_VALID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remember if we have <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> out-of-line field <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleHasExternal(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dummy_erh-&gt;flags |= ER_FLAG_HAVE_EXTERNAL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We call <a href="domains.c.html#L346" title="utils/adt/domains.c:346">domain_check</a> in the short-lived context, so that <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cruft<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leaked by expression evaluation can be reclaimed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(erh-&gt;er_short_term_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we can apply the check.&nbsp; Note we use <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> header's domain cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space, so that caching carries across repeated uses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="domains.c.html#L346" title="utils/adt/domains.c:346">domain_check</a>(ExpandedRecordGetRODatum(dummy_erh), <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; erh-&gt;er_decltypeid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;erh-&gt;er_domaininfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; erh-&gt;hdr.eoh_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We might as well clean up cruft immediately. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(erh-&gt;er_short_term_cxt);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
