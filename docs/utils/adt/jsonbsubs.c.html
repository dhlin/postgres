<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/jsonbsubs.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/jsonbsubs.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L27">JsonbSubWorkspace</a></li>
<li><a href="#L33">JsonbSubWorkspace</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L353">jsonb_exec_setup</a></li>
<li><a href="#L261">jsonb_subscript_assign</a></li>
<li><a href="#L175">jsonb_subscript_check_subscripts</a></li>
<li><a href="#L235">jsonb_subscript_fetch</a></li>
<li><a href="#L323">jsonb_subscript_fetch_old</a></li>
<li><a href="#L402">jsonb_subscript_handler</a></li>
<li><a href="#L43">jsonb_subscript_transform</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * jsonbsubs.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Subscripting support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for jsonb.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/jsonbsubs.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;executor/execExpr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/subscripting.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_coerce.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_expr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/jsonb.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* SubscriptingRefState.workspace for jsonb subscripting execution */<br/></li>
<li><a id="L27">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">JsonbSubWorkspace</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; expectArray;&nbsp; &nbsp; <span class="Comment">/* jsonb root is expected to be an array */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *indexOid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OID of coerced subscript expression, could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be only integer or text */<br/></li>
<li></span>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *index;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Subscript <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in Datum format */<br/></li>
<li><a id="L33">&#x200c;</a></span>} <span class="linkable">JsonbSubWorkspace</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Finish <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis of a SubscriptingRef expression for a jsonb.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Transform the subscript expressions, coerce them to text,<br/></li>
<li></span><span class="Comment"> * and determine the result type of the SubscriptingRef node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L43">&#x200c;</a></span><span class="linkable">jsonb_subscript_transform</span>(SubscriptingRef *sbsref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *indirection,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParseState *pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isSlice,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isAssignment)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *upperIndexpr = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *idx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Transform and convert the subscript expressions. Jsonb subscripting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * does not support slices, look only and the <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(idx, indirection)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; A_Indices&nbsp; *ai = lfirst_node(A_Indices, idx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *subExpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isSlice)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *expr = ai-&gt;uidx ? ai-&gt;uidx : ai-&gt;lidx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;jsonb subscript does not support slices&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../parser/parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, <a href="../../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>(expr))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ai-&gt;uidx)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subExprType = InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetType = UNKNOWNOID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subExpr = <a href="../../parser/parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a>(pstate, ai-&gt;uidx, pstate-&gt;p_expr_kind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subExprType = <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(subExpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subExprType != UNKNOWNOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targets[<span class="Constant">2</span>] = {INT4OID, TEXTOID};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Jsonb can handle multiple subscript types, but cases when a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subscript could be coerced to multiple target types must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * avoided, similar to overloaded <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>. It could be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possibly extend with jsonpath in the future.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <span class="Constant">2</span>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../parser/parse_coerce.c.html#L556" title="parser/parse_coerce.c:556">can_coerce_type</a>(<span class="Constant">1</span>, &amp;subExprType, &amp;targets[i], COERCION_IMPLICIT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * One type has already succeeded, it means there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * two coercion targets possible, failure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (targetType != UNKNOWNOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;subscript type </span><span class="Special">%s</span><span class="Constant"> is not supported&quot;</span>, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(subExprType)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;jsonb subscript must be coercible to only one type, integer or text.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../parser/parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, <a href="../../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>(subExpr))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetType = targets[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No suitable types were found, failure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (targetType == UNKNOWNOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;subscript type </span><span class="Special">%s</span><span class="Constant"> is not supported&quot;</span>, <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(subExprType)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;jsonb subscript must be coercible to either integer or text.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../parser/parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, <a href="../../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>(subExpr))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetType = TEXTOID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We known from <a href="../../parser/parse_coerce.c.html#L556" title="parser/parse_coerce.c:556">can_coerce_type</a> that coercion will succeed, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../parser/parse_coerce.c.html#L157" title="parser/parse_coerce.c:157">coerce_type</a> could be used. Note the implicit coercion context,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which is required to handle subscripts of different types,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * similar to overloaded <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subExpr = <a href="../../parser/parse_coerce.c.html#L157" title="parser/parse_coerce.c:157">coerce_type</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subExpr, subExprType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetType, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCION_IMPLICIT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCE_IMPLICIT_CAST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subExpr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;jsonb subscript must have text type&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../parser/parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, <a href="../../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>(subExpr))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Slice with omitted <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound. Should not happen as we already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * errored out on slice earlier, but handle this just in case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(isSlice &amp;&amp; ai-&gt;is_slice);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;jsonb subscript does not support slices&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../parser/parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, <a href="../../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>(ai-&gt;uidx))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; upperIndexpr = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(upperIndexpr, subExpr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* store the transformed lists into the SubscriptRef node */<br/></li>
<li></span>&nbsp; &nbsp; sbsref-&gt;refupperindexpr = upperIndexpr;<br/></li>
<li>&nbsp; &nbsp; sbsref-&gt;reflowerindexpr = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine the result type of the subscripting operation; always jsonb */<br/></li>
<li></span>&nbsp; &nbsp; sbsref-&gt;refrestype = JSONBOID;<br/></li>
<li>&nbsp; &nbsp; sbsref-&gt;reftypmod = -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * During execution, process the subscripts in a SubscriptingRef expression.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The subscript expressions are already evaluated in Datum form in the<br/></li>
<li></span><span class="Comment"> * SubscriptingRefState's arrays.&nbsp; Check and convert them as necessary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subscript is NULL, we throw error in assignment cases, or in fetch<br/></li>
<li></span><span class="Comment"> * cases set result to NULL and return false (instructing caller to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the<br/></li>
<li></span><span class="Comment"> * rest of the SubscriptingRef sequence).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L175">&#x200c;</a></span><span class="linkable">jsonb_subscript_check_subscripts</span>(ExprState *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SubscriptingRefState *sbsrefstate = op-&gt;d.sbsref_subscript.state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L27" title="utils/adt/jsonbsubs.c:27">JsonbSubWorkspace</a> *workspace = (<a href="#L27" title="utils/adt/jsonbsubs.c:27">JsonbSubWorkspace</a> *) sbsrefstate-&gt;workspace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In case if the first subscript is an integer, the source jsonb is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expected to be an array. This information is not used directly, all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * such cases are handled within corresponding jsonb assign <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>. But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the source jsonb is NULL the expected type will be used to construct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an empty source.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sbsrefstate-&gt;numupper &gt; <span class="Constant">0</span> &amp;&amp; sbsrefstate-&gt;upperprovided[<span class="Constant">0</span>] &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !sbsrefstate-&gt;upperindexnull[<span class="Constant">0</span>] &amp;&amp; workspace-&gt;indexOid[<span class="Constant">0</span>] == INT4OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;expectArray = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process <a href="oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> subscripts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; sbsrefstate-&gt;numupper; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sbsrefstate-&gt;upperprovided[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index expr yields NULL, result is NULL or error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sbsrefstate-&gt;upperindexnull[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sbsrefstate-&gt;isassignment)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NULL_VALUE_NOT_ALLOWED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;jsonb subscript in assignment must not be null&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For jsonb fetch and assign <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> we need to provide path in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * text format. Convert if it's not already text.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (workspace-&gt;indexOid[i] == INT4OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum = sbsrefstate-&gt;upperindex[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cs = DatumGetCString(DirectFunctionCall1(<a href="int.c.html#L298" title="utils/adt/int.c:298">int4out</a>, datum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;index[i] = CStringGetTextDatum(cs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;index[i] = sbsrefstate-&gt;upperindex[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate SubscriptingRef fetch for a jsonb <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Source container is in step's result variable (it's known not NULL, since<br/></li>
<li></span><span class="Comment"> * we set fetch_strict to true).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L235">&#x200c;</a></span><span class="linkable">jsonb_subscript_fetch</span>(ExprState *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SubscriptingRefState *sbsrefstate = op-&gt;d.sbsref.state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L27" title="utils/adt/jsonbsubs.c:27">JsonbSubWorkspace</a> *workspace = (<a href="#L27" title="utils/adt/jsonbsubs.c:27">JsonbSubWorkspace</a> *) sbsrefstate-&gt;workspace;<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jsonbSource;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should not get here if source jsonb (or <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subscript) is null */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!(*op-&gt;resnull));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; jsonbSource = DatumGetJsonbP(*op-&gt;resvalue);<br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = <a href="jsonfuncs.c.html#L1528" title="utils/adt/jsonfuncs.c:1528">jsonb_get_element</a>(jsonbSource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;numupper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;resnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Evaluate SubscriptingRef assignment for a jsonb <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> assignment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input container (possibly null) is in result area, replacement value is in<br/></li>
<li></span><span class="Comment"> * SubscriptingRefState's replacevalue/replacenull.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L261">&#x200c;</a></span><span class="linkable">jsonb_subscript_assign</span>(ExprState *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SubscriptingRefState *sbsrefstate = op-&gt;d.sbsref.state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L27" title="utils/adt/jsonbsubs.c:27">JsonbSubWorkspace</a> *workspace = (<a href="#L27" title="utils/adt/jsonbsubs.c:27">JsonbSubWorkspace</a> *) sbsrefstate-&gt;workspace;<br/></li>
<li>&nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jsonbSource;<br/></li>
<li>&nbsp; &nbsp; JsonbValue&nbsp; &nbsp; replacevalue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sbsrefstate-&gt;replacenull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; replacevalue.type = jbvNull;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="jsonb_util.c.html#L72" title="utils/adt/jsonb_util.c:72">JsonbToJsonbValue</a>(DatumGetJsonbP(sbsrefstate-&gt;replacevalue),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;replacevalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In case if the input container is null, set up an empty jsonb and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * proceed with the assignment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JsonbValue&nbsp; &nbsp; newSource;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To avoid <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> surprising results, set up an empty jsonb array in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case of an array is expected (i.e. the first subscript is integer),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise jsonb object.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (workspace-&gt;expectArray)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newSource.type = jbvArray;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newSource.val.array.nElems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newSource.val.array.rawScalar = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newSource.type = jbvObject;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newSource.val.object.nPairs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jsonbSource = <a href="jsonb_util.c.html#L92" title="utils/adt/jsonb_util.c:92">JsonbValueToJsonb</a>(&amp;newSource);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *op-&gt;resnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; jsonbSource = DatumGetJsonbP(*op-&gt;resvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *op-&gt;resvalue = <a href="jsonfuncs.c.html#L1676" title="utils/adt/jsonfuncs.c:1676">jsonb_set_element</a>(jsonbSource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;numupper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;replacevalue);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The result is never NULL, so no need to change *op-&gt;resnull */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute old jsonb <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> value for a SubscriptingRef assignment<br/></li>
<li></span><span class="Comment"> * expression.&nbsp; Will only be called if the new-value subexpression<br/></li>
<li></span><span class="Comment"> * contains SubscriptingRef or FieldStore.&nbsp; This is the same as the<br/></li>
<li></span><span class="Comment"> * regular fetch case, except that we have to handle a null jsonb,<br/></li>
<li></span><span class="Comment"> * and the value should be stored into the SubscriptingRefState's<br/></li>
<li></span><span class="Comment"> * prevvalue/prevnull fields.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L323">&#x200c;</a></span><span class="linkable">jsonb_subscript_fetch_old</span>(ExprState *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprEvalStep *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExprContext *econtext)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SubscriptingRefState *sbsrefstate = op-&gt;d.sbsref.state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*op-&gt;resnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* whole jsonb is null, so <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;prevvalue = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;prevnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Jsonb&nbsp; &nbsp; &nbsp;&nbsp; *jsonbSource = DatumGetJsonbP(*op-&gt;resvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sbsrefstate-&gt;prevvalue = <a href="jsonfuncs.c.html#L1528" title="utils/adt/jsonfuncs.c:1528">jsonb_get_element</a>(jsonbSource,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sbsrefstate-&gt;upperindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sbsrefstate-&gt;numupper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sbsrefstate-&gt;prevnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set up execution state for a jsonb subscript operation. Opposite to the<br/></li>
<li></span><span class="Comment"> * arrays subscription, there is no limit for number of subscripts as jsonb<br/></li>
<li></span><span class="Comment"> * type itself doesn't have nesting limits.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L353">&#x200c;</a></span><span class="linkable">jsonb_exec_setup</span>(<span class="Type">const</span> SubscriptingRef *sbsref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SubscriptingRefState *sbsrefstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SubscriptExecSteps *methods)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L27" title="utils/adt/jsonbsubs.c:27">JsonbSubWorkspace</a> *workspace;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nupper = sbsref-&gt;refupperindexpr-&gt;length;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate type-specific workspace with space for per-subscript data */<br/></li>
<li></span>&nbsp; &nbsp; workspace = <a href="../mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L27" title="utils/adt/jsonbsubs.c:27">JsonbSubWorkspace</a>)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nupper * (<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid)));<br/></li>
<li>&nbsp; &nbsp; workspace-&gt;expectArray = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ptr = ((<span class="Type">char</span> *) workspace) + MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L27" title="utils/adt/jsonbsubs.c:27">JsonbSubWorkspace</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This coding assumes <a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(Datum) &gt;= <a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(Oid), else we might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * misalign the indexOid pointer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; workspace-&gt;index = (Datum *) ptr;<br/></li>
<li>&nbsp; &nbsp; ptr += nupper * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum);<br/></li>
<li>&nbsp; &nbsp; workspace-&gt;indexOid = (Oid *) ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sbsrefstate-&gt;workspace = workspace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Collect subscript data types necessary at execution time */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, sbsref-&gt;refupperindexpr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *expr = lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = foreach_current_index(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; workspace-&gt;indexOid[i] = <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(expr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pass back pointers to appropriate step execution <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; methods-&gt;sbs_check_subscripts = <a href="#L175" title="utils/adt/jsonbsubs.c:175">jsonb_subscript_check_subscripts</a>;<br/></li>
<li>&nbsp; &nbsp; methods-&gt;sbs_fetch = <a href="#L235" title="utils/adt/jsonbsubs.c:235">jsonb_subscript_fetch</a>;<br/></li>
<li>&nbsp; &nbsp; methods-&gt;sbs_assign = <a href="#L261" title="utils/adt/jsonbsubs.c:261">jsonb_subscript_assign</a>;<br/></li>
<li>&nbsp; &nbsp; methods-&gt;sbs_fetch_old = <a href="#L323" title="utils/adt/jsonbsubs.c:323">jsonb_subscript_fetch_old</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L402" title="utils/adt/jsonbsubs.c:402">jsonb_subscript_handler</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Subscripting handler for jsonb.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L402">&#x200c;</a><span class="linkable">jsonb_subscript_handler</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> SubscriptRoutines sbsroutines = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .transform = <a href="#L43" title="utils/adt/jsonbsubs.c:43">jsonb_subscript_transform</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .exec_setup = <a href="#L353" title="utils/adt/jsonbsubs.c:353">jsonb_exec_setup</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .fetch_strict = <span class="Constant">true</span>,&nbsp; &nbsp; <span class="Comment">/* fetch returns NULL for NULL inputs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; .fetch_leakproof = <span class="Constant">true</span>,&nbsp; &nbsp; <span class="Comment">/* fetch returns NULL for bad subscript */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; .store_leakproof = <span class="Constant">false</span>&nbsp; &nbsp; <span class="Comment">/* ... but assignment throws error */<br/></li>
<li></span>&nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(&amp;sbsroutines);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
