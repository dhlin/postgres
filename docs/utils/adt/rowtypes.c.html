<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/rowtypes.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/rowtypes.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L54">ColumnCompareData</a></li>
<li><a href="#L57">ColumnCompareData</a></li>
<li><a href="#L34">ColumnIOData</a></li>
<li><a href="#L41">ColumnIOData</a></li>
<li><a href="#L59">RecordCompareData</a></li>
<li><a href="#L67">RecordCompareData</a></li>
<li><a href="#L43">RecordIOData</a></li>
<li><a href="#L49">RecordIOData</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1313">btrecordcmp</a></li>
<li><a href="#L1783">btrecordimagecmp</a></li>
<li><a href="#L1794">hash_record</a></li>
<li><a href="#L1914">hash_record_extended</a></li>
<li><a href="#L823">record_cmp</a></li>
<li><a href="#L1067">record_eq</a></li>
<li><a href="#L1307">record_ge</a></li>
<li><a href="#L1295">record_gt</a></li>
<li><a href="#L1331">record_image_cmp</a></li>
<li><a href="#L1577">record_image_eq</a></li>
<li><a href="#L1777">record_image_ge</a></li>
<li><a href="#L1765">record_image_gt</a></li>
<li><a href="#L1771">record_image_le</a></li>
<li><a href="#L1759">record_image_lt</a></li>
<li><a href="#L1753">record_image_ne</a></li>
<li><a href="#L74">record_in</a></li>
<li><a href="#L1301">record_le</a></li>
<li><a href="#L1289">record_lt</a></li>
<li><a href="#L1283">record_ne</a></li>
<li><a href="#L329">record_out</a></li>
<li><a href="#L480">record_recv</a></li>
<li><a href="#L687">record_send</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * rowtypes.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; I/O and comparison <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for generic composite types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/rowtypes.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/detoast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * structure to cache metadata needed for record I/O<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L34">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ColumnIOData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column_type;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typiofunc;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typioparam;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typisvarlena;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; proc;<br/></li>
<li><a id="L41">&#x200c;</a>} <span class="linkable">ColumnIOData</span>;<br/></li>
<li><br/></li>
<li><a id="L43">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RecordIOData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record_type;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; record_typmod;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncolumns;<br/></li>
<li>&nbsp; &nbsp; <a href="#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a> columns[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L49">&#x200c;</a>} <span class="linkable">RecordIOData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * structure to cache metadata needed for record comparison<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L54">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ColumnCompareData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typentry;&nbsp; &nbsp; <span class="Comment">/* has everything we need, actually */<br/></li>
<li><a id="L57">&#x200c;</a></span>} <span class="linkable">ColumnCompareData</span>;<br/></li>
<li><br/></li>
<li><a id="L59">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RecordCompareData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncolumns;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocated length of columns[] */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record1_type;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; record1_typmod;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record2_type;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; record2_typmod;<br/></li>
<li>&nbsp; &nbsp; <a href="#L54" title="utils/adt/rowtypes.c:54">ColumnCompareData</a> columns[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L67">&#x200c;</a>} <span class="linkable">RecordCompareData</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L74" title="utils/adt/rowtypes.c:74">record_in</a>&nbsp; &nbsp; &nbsp; &nbsp; - input routine for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> composite type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L74">&#x200c;</a><span class="linkable">record_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *string = PG_GETARG_CSTRING(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupType = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; tupTypmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *escontext = fcinfo-&gt;context;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader result;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; <a href="#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> *my_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needComma = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncolumns;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recurses for record-type columns */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Give a friendly error message if we did not get enough info to identify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the target record type.&nbsp; (<a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a> would fail anyway, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with a non-user-friendly message.)&nbsp; In ordinary SQL usage, we'll get -1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for typmod, since composite types and RECORD have no type modifiers at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the SQL level, and thus must fail for RECORD.&nbsp; However some callers can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * supply a valid typmod, and then we can do something useful for RECORD.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tupType == RECORDOID &amp;&amp; tupTypmod &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereturn(escontext, (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;input of anonymous composite types is not implemented&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This comes from the composite type's pg_type.oid and stores system oids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in user tables, specifically DatumTupleFields. This oid must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * preserved by binary upgrades.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tupdesc = <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(tupType, tupTypmod);<br/></li>
<li>&nbsp; &nbsp; ncolumns = tupdesc-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up the needed I/O info just once per series of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls, assuming the record type doesn't change underneath us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; my_extra = (<a href="#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;ncolumns != ncolumns)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetof(<a href="#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a>, columns) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra = (<a href="#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record_type = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record_typmod = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra-&gt;record_type != tupType ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record_typmod != tupTypmod)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(my_extra, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetof(<a href="#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a>, columns) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record_type = tupType;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record_typmod = tupTypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;ncolumns = ncolumns;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; nulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan the string.&nbsp; We use &quot;buf&quot; to accumulate the de-quoted data for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each column, which is then fed to the appropriate input converter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ptr = string;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allow leading whitespace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (*ptr &amp;&amp; isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *ptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*ptr++ != <span class="Constant">'('</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errsave(escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed record literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Missing left parenthesis.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ncolumns; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(tupdesc, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a> *column_info = &amp;my_extra-&gt;columns[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column_type = att-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *column_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore dropped columns in datatype, but fill with nulls */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needComma)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip comma that separates prior field from this one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*ptr == <span class="Constant">','</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* *ptr must be ')' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errsave(escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed record literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Too few columns.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for null: completely empty input means null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*ptr == <span class="Constant">','</span> || *ptr == <span class="Constant">')'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column_data = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract string for this column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; inquote = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resetStringInfo(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (inquote || !(*ptr == <span class="Constant">','</span> || *ptr == <span class="Constant">')'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; ch = *ptr++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ch == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errsave(escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed record literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Unexpected end of input.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ch == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*ptr == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errsave(escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed record literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Unexpected end of input.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, *ptr++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ch == <span class="Constant">'&quot;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!inquote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inquote = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*ptr == <span class="Constant">'&quot;'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* doubled quote within quote sequence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, *ptr++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inquote = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, ch);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column_data = buf.data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Convert the column value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (column_info-&gt;column_type != column_type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2874" title="utils/cache/lsyscache.c:2874">getTypeInputInfo</a>(column_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;column_info-&gt;typiofunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;column_info-&gt;typioparam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(column_info-&gt;typiofunc, &amp;column_info-&gt;proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_mcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column_info-&gt;column_type = column_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../fmgr/fmgr.c.html#L1585" title="utils/fmgr/fmgr.c:1585">InputFunctionCallSafe</a>(&amp;column_info-&gt;proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; column_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; column_info-&gt;typioparam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; att-&gt;atttypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Prep for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; needComma = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*ptr++ != <span class="Constant">')'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errsave(escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed record literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Too many columns.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allow trailing whitespace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (*ptr &amp;&amp; isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *ptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*ptr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errsave(escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;malformed record literal: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Junk after right parenthesis.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(tupdesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We cannot return tuple-&gt;t_data because <a href="../../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a> allocates it as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * part of a larger chunk, and our caller may expect to be able to <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * our result.&nbsp; So must copy the info into a new <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> chunk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = (HeapTupleHeader) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(tuple-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; memcpy(result, tuple-&gt;t_data, tuple-&gt;t_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls);<br/></li>
<li>&nbsp; &nbsp; ReleaseTupleDesc(tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_HEAPTUPLEHEADER(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* exit here once we've done <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a> */<br/></li>
<li></span><span class="Statement">fail</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; ReleaseTupleDesc(tupdesc);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L329" title="utils/adt/rowtypes.c:329">record_out</a>&nbsp; &nbsp; &nbsp; &nbsp; - output routine for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> composite type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L329">&#x200c;</a><span class="linkable">record_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader rec = PG_GETARG_HEAPTUPLEHEADER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupType;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; tupTypmod;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tuple;<br/></li>
<li>&nbsp; &nbsp; <a href="#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> *my_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needComma = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncolumns;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recurses for record-type columns */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract type info from the tuple itself */<br/></li>
<li></span>&nbsp; &nbsp; tupType = HeapTupleHeaderGetTypeId(rec);<br/></li>
<li>&nbsp; &nbsp; tupTypmod = HeapTupleHeaderGetTypMod(rec);<br/></li>
<li>&nbsp; &nbsp; tupdesc = <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(tupType, tupTypmod);<br/></li>
<li>&nbsp; &nbsp; ncolumns = tupdesc-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build a temporary HeapTuple control structure */<br/></li>
<li></span>&nbsp; &nbsp; tuple.t_len = HeapTupleHeaderGetDatumLength(rec);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tuple.t_self));<br/></li>
<li>&nbsp; &nbsp; tuple.t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; tuple.t_data = rec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up the needed I/O info just once per series of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls, assuming the record type doesn't change underneath us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; my_extra = (<a href="#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;ncolumns != ncolumns)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetof(<a href="#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a>, columns) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra = (<a href="#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record_type = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record_typmod = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra-&gt;record_type != tupType ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record_typmod != tupTypmod)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(my_extra, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetof(<a href="#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a>, columns) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record_type = tupType;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record_typmod = tupTypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;ncolumns = ncolumns;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; nulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Break down the tuple into fields */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(&amp;tuple, tupdesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And build the result string */<br/></li>
<li></span>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Constant">'('</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ncolumns; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(tupdesc, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a> *column_info = &amp;my_extra-&gt;columns[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column_type = att-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; attr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tmp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore dropped columns in datatype */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needComma)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Constant">','</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; needComma = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* emit nothing... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Convert the column value to text<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (column_info-&gt;column_type != column_type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2907" title="utils/cache/lsyscache.c:2907">getTypeOutputInfo</a>(column_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;column_info-&gt;typiofunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;column_info-&gt;typisvarlena);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(column_info-&gt;typiofunc, &amp;column_info-&gt;proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_mcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column_info-&gt;column_type = column_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attr = <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; value = <a href="../fmgr/fmgr.c.html#L1683" title="utils/fmgr/fmgr.c:1683">OutputFunctionCall</a>(&amp;column_info-&gt;proc, attr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Detect whether we need double quotes for this value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nq = (value[<span class="Constant">0</span>] == <span class="Special">'\0'</span>);&nbsp; &nbsp; <span class="Comment">/* force quotes for empty string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (tmp = value; *tmp; tmp++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; ch = *tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ch == <span class="Constant">'&quot;'</span> || ch == <span class="Special">'\\'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ch == <span class="Constant">'('</span> || ch == <span class="Constant">')'</span> || ch == <span class="Constant">','</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) ch))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nq = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And emit the string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nq)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoCharMacro(&amp;buf, <span class="Constant">'&quot;'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (tmp = value; *tmp; tmp++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; ch = *tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ch == <span class="Constant">'&quot;'</span> || ch == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoCharMacro(&amp;buf, ch);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoCharMacro(&amp;buf, ch);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nq)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoCharMacro(&amp;buf, <span class="Constant">'&quot;'</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Constant">')'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls);<br/></li>
<li>&nbsp; &nbsp; ReleaseTupleDesc(tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(buf.data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L480" title="utils/adt/rowtypes.c:480">record_recv</a>&nbsp; &nbsp; &nbsp; &nbsp; - binary input routine for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> composite type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L480">&#x200c;</a><span class="linkable">record_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfo&nbsp; &nbsp; buf = (StringInfo) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupType = PG_GETARG_OID(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; tupTypmod = PG_GETARG_INT32(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader result;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; <a href="#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> *my_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncolumns;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usercols;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; validcols;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recurses for record-type columns */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Give a friendly error message if we did not get enough info to identify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the target record type.&nbsp; (<a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a> would fail anyway, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with a non-user-friendly message.)&nbsp; In ordinary SQL usage, we'll get -1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for typmod, since composite types and RECORD have no type modifiers at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the SQL level, and thus must fail for RECORD.&nbsp; However some callers can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * supply a valid typmod, and then we can do something useful for RECORD.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tupType == RECORDOID &amp;&amp; tupTypmod &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;input of anonymous composite types is not implemented&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tupdesc = <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(tupType, tupTypmod);<br/></li>
<li>&nbsp; &nbsp; ncolumns = tupdesc-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up the needed I/O info just once per series of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls, assuming the record type doesn't change underneath us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; my_extra = (<a href="#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;ncolumns != ncolumns)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetof(<a href="#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a>, columns) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra = (<a href="#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record_type = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record_typmod = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra-&gt;record_type != tupType ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record_typmod != tupTypmod)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(my_extra, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetof(<a href="#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a>, columns) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record_type = tupType;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record_typmod = tupTypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;ncolumns = ncolumns;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; nulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch number of columns user thinks it has */<br/></li>
<li></span>&nbsp; &nbsp; usercols = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need to scan to count nondeleted columns */<br/></li>
<li></span>&nbsp; &nbsp; validcols = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ncolumns; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TupleDescAttr(tupdesc, i)-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; validcols++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (usercols != validcols)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;wrong number of columns: </span><span class="Special">%d</span><span class="Constant">, expected </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usercols, validcols)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process each column */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ncolumns; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(tupdesc, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a> *column_info = &amp;my_extra-&gt;columns[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column_type = att-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coltypoid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData item_buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfo&nbsp; &nbsp; bufptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore dropped columns in datatype, but fill with nulls */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check column type recorded in the data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; coltypoid = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * From a security standpoint, it doesn't matter whether the input's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column type matches what we expect: the column type's receive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function has to be robust enough to cope with invalid data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, from a user-friendliness standpoint, it's nicer to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * complain about type mismatches than to throw &quot;improper binary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * format&quot; errors.&nbsp; But there's a problem: only built-in types have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OIDs that are stable enough to believe that a mismatch is a real<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * issue.&nbsp; So complain only if both OIDs are in the built-in <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, carry on with the column type we &quot;should&quot; be getting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (coltypoid != column_type &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coltypoid &lt; FirstGenbkiObjectId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column_type &lt; FirstGenbkiObjectId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;binary data has type </span><span class="Special">%u</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) instead of expected </span><span class="Special">%u</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) in record column </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coltypoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L112" title="utils/adt/format_type.c:112">format_type_extended</a>(coltypoid, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FORMAT_TYPE_ALLOW_INVALID),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L112" title="utils/adt/format_type.c:112">format_type_extended</a>(column_type, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FORMAT_TYPE_ALLOW_INVALID),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i + <span class="Constant">1</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get and check the item length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itemlen = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(buf, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (itemlen &lt; -<span class="Constant">1</span> || itemlen &gt; (buf-&gt;len - buf-&gt;cursor))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;insufficient data left in message&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (itemlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* -1 length means NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufptr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *strbuff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Rather than copying data around, we just <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * StringInfo pointing to the correct portion of the message<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strbuff = &amp;buf-&gt;data[buf-&gt;cursor];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf-&gt;cursor += itemlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initReadOnlyStringInfo(&amp;item_buf, strbuff, itemlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufptr = &amp;item_buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now call the column's receiveproc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (column_info-&gt;column_type != column_type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2940" title="utils/cache/lsyscache.c:2940">getTypeBinaryInputInfo</a>(column_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;column_info-&gt;typiofunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;column_info-&gt;typioparam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(column_info-&gt;typiofunc, &amp;column_info-&gt;proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_mcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column_info-&gt;column_type = column_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = <a href="../fmgr/fmgr.c.html#L1697" title="utils/fmgr/fmgr.c:1697">ReceiveFunctionCall</a>(&amp;column_info-&gt;proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column_info-&gt;typioparam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att-&gt;atttypmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bufptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Trouble if it didn't eat the whole buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item_buf.cursor != itemlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;improper binary format in record column </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i + <span class="Constant">1</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(tupdesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We cannot return tuple-&gt;t_data because <a href="../../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a> allocates it as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * part of a larger chunk, and our caller may expect to be able to <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * our result.&nbsp; So must copy the info into a new <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> chunk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = (HeapTupleHeader) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(tuple-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; memcpy(result, tuple-&gt;t_data, tuple-&gt;t_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls);<br/></li>
<li>&nbsp; &nbsp; ReleaseTupleDesc(tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_HEAPTUPLEHEADER(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L687" title="utils/adt/rowtypes.c:687">record_send</a>&nbsp; &nbsp; &nbsp; &nbsp; - binary output routine for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> composite type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L687">&#x200c;</a><span class="linkable">record_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader rec = PG_GETARG_HEAPTUPLEHEADER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupType;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; tupTypmod;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tuple;<br/></li>
<li>&nbsp; &nbsp; <a href="#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> *my_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncolumns;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; validcols;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recurses for record-type columns */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract type info from the tuple itself */<br/></li>
<li></span>&nbsp; &nbsp; tupType = HeapTupleHeaderGetTypeId(rec);<br/></li>
<li>&nbsp; &nbsp; tupTypmod = HeapTupleHeaderGetTypMod(rec);<br/></li>
<li>&nbsp; &nbsp; tupdesc = <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(tupType, tupTypmod);<br/></li>
<li>&nbsp; &nbsp; ncolumns = tupdesc-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build a temporary HeapTuple control structure */<br/></li>
<li></span>&nbsp; &nbsp; tuple.t_len = HeapTupleHeaderGetDatumLength(rec);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tuple.t_self));<br/></li>
<li>&nbsp; &nbsp; tuple.t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; tuple.t_data = rec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up the needed I/O info just once per series of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls, assuming the record type doesn't change underneath us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; my_extra = (<a href="#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;ncolumns != ncolumns)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetof(<a href="#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a>, columns) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra = (<a href="#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record_type = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record_typmod = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra-&gt;record_type != tupType ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record_typmod != tupTypmod)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(my_extra, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetof(<a href="#L43" title="utils/adt/rowtypes.c:43">RecordIOData</a>, columns) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record_type = tupType;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record_typmod = tupTypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;ncolumns = ncolumns;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; nulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Break down the tuple into fields */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(&amp;tuple, tupdesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And build the result string */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L326" title="libpq/pqformat.c:326">pq_begintypsend</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need to scan to count nondeleted columns */<br/></li>
<li></span>&nbsp; &nbsp; validcols = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ncolumns; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TupleDescAttr(tupdesc, i)-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; validcols++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;buf, validcols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ncolumns; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(tupdesc, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L34" title="utils/adt/rowtypes.c:34">ColumnIOData</a> *column_info = &amp;my_extra-&gt;columns[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column_type = att-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; attr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *outputbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore dropped columns in datatype */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(&amp;buf, column_type);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* emit -1 data length to signify a NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(&amp;buf, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Convert the column value to binary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (column_info-&gt;column_type != column_type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/lsyscache.c.html#L2973" title="utils/cache/lsyscache.c:2973">getTypeBinaryOutputInfo</a>(column_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;column_info-&gt;typiofunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;column_info-&gt;typisvarlena);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(column_info-&gt;typiofunc, &amp;column_info-&gt;proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_mcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column_info-&gt;column_type = column_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attr = <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outputbytes = <a href="../fmgr/fmgr.c.html#L1744" title="utils/fmgr/fmgr.c:1744">SendFunctionCall</a>(&amp;column_info-&gt;proc, attr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(&amp;buf, VARSIZE(outputbytes) - VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L126" title="libpq/pqformat.c:126">pq_sendbytes</a>(&amp;buf, VARDATA(outputbytes),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE(outputbytes) - VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls);<br/></li>
<li>&nbsp; &nbsp; ReleaseTupleDesc(tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BYTEA_P(<a href="../../libpq/pqformat.c.html#L346" title="libpq/pqformat.c:346">pq_endtypsend</a>(&amp;buf));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L823" title="utils/adt/rowtypes.c:823">record_cmp</a>()<br/></li>
<li></span><span class="Comment"> * Internal comparison function for <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns -1, 0 or 1<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Do not assume that the two inputs are exactly the same record type;<br/></li>
<li></span><span class="Comment"> * for instance we might be comparing an anonymous ROW() construct against a<br/></li>
<li></span><span class="Comment"> * named composite type.&nbsp; We will <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> as long as they have the same number<br/></li>
<li></span><span class="Comment"> * of non-dropped columns of the same types.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L823">&#x200c;</a></span><span class="linkable">record_cmp</span>(FunctionCallInfo fcinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupType1;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupType2;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; tupTypmod1;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; tupTypmod2;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc1;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc2;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tuple1;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tuple2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncolumns1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncolumns2;<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a> *my_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncols;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *values1;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *values2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recurses for record-type columns */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract type info from the tuples */<br/></li>
<li></span>&nbsp; &nbsp; tupType1 = HeapTupleHeaderGetTypeId(record1);<br/></li>
<li>&nbsp; &nbsp; tupTypmod1 = HeapTupleHeaderGetTypMod(record1);<br/></li>
<li>&nbsp; &nbsp; tupdesc1 = <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(tupType1, tupTypmod1);<br/></li>
<li>&nbsp; &nbsp; ncolumns1 = tupdesc1-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; tupType2 = HeapTupleHeaderGetTypeId(record2);<br/></li>
<li>&nbsp; &nbsp; tupTypmod2 = HeapTupleHeaderGetTypMod(record2);<br/></li>
<li>&nbsp; &nbsp; tupdesc2 = <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(tupType2, tupTypmod2);<br/></li>
<li>&nbsp; &nbsp; ncolumns2 = tupdesc2-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build temporary HeapTuple control structures */<br/></li>
<li></span>&nbsp; &nbsp; tuple1.t_len = HeapTupleHeaderGetDatumLength(record1);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tuple1.t_self));<br/></li>
<li>&nbsp; &nbsp; tuple1.t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; tuple1.t_data = record1;<br/></li>
<li>&nbsp; &nbsp; tuple2.t_len = HeapTupleHeaderGetDatumLength(record2);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tuple2.t_self));<br/></li>
<li>&nbsp; &nbsp; tuple2.t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; tuple2.t_data = record2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up the needed comparison info just once per series<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of calls, assuming the record types don't change underneath us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ncols = Max(ncolumns1, ncolumns2);<br/></li>
<li>&nbsp; &nbsp; my_extra = (<a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;ncolumns &lt; ncols)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetof(<a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a>, columns) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ncols * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L54" title="utils/adt/rowtypes.c:54">ColumnCompareData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra = (<a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;ncolumns = ncols;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_type = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_typmod = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_type = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_typmod = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra-&gt;record1_type != tupType1 ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_typmod != tupTypmod1 ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_type != tupType2 ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_typmod != tupTypmod2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(my_extra-&gt;columns, <span class="Constant">0</span>, ncols * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L54" title="utils/adt/rowtypes.c:54">ColumnCompareData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_type = tupType1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_typmod = tupTypmod1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_type = tupType2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_typmod = tupTypmod2;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Break down the tuples into fields */<br/></li>
<li></span>&nbsp; &nbsp; values1 = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns1 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; nulls1 = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns1 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(&amp;tuple1, tupdesc1, values1, nulls1);<br/></li>
<li>&nbsp; &nbsp; values2 = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns2 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; nulls2 = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns2 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(&amp;tuple2, tupdesc2, values2, nulls2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan corresponding columns, allowing for dropped columns in different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * places in the two rows.&nbsp; i1 and i2 are physical column indexes, j is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the logical column index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; i1 = i2 = j = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (i1 &lt; ncolumns1 || i2 &lt; ncolumns2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Skip dropped columns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i1 &lt; ncolumns1 &amp;&amp; TupleDescAttr(tupdesc1, i1)-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i1++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i2 &lt; ncolumns2 &amp;&amp; TupleDescAttr(tupdesc2, i2)-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i1 &gt;= ncolumns1 || i2 &gt;= ncolumns2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we'll deal with mismatch below loop */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att1 = TupleDescAttr(tupdesc1, i1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att2 = TupleDescAttr(tupdesc2, i2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Have two matching columns, they must be same type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att1-&gt;atttypid != att2-&gt;atttypid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> dissimilar column types </span><span class="Special">%s</span><span class="Constant"> and </span><span class="Special">%s</span><span class="Constant"> at record column </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(att1-&gt;atttypid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(att2-&gt;atttypid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j + <span class="Constant">1</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If they're not same collation, we don't complain here, but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comparison function might.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; collation = att1-&gt;attcollation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (collation != att2-&gt;attcollation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lookup the comparison function if not done already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typentry = my_extra-&gt;columns[j].typentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;type_id != att1-&gt;atttypid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(att1-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_CMP_PROC_FINFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typentry-&gt;cmp_proc_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not identify a comparison function for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(typentry-&gt;type_id))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;columns[j].typentry = typentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We consider two NULLs <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>; NULL &gt; not-NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!nulls1[i1] || !nulls2[i2])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCAL_FCINFO(locfcinfo, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; cmpresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls1[i1])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arg1 is greater than arg2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls2[i2])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arg1 is less than arg2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compare the pair of elements */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(*locfcinfo, &amp;typentry-&gt;cmp_proc_finfo, <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].value = values1[i1];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">1</span>].value = values2[i2];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpresult = DatumGetInt32(FunctionCallInvoke(locfcinfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't expect comparison support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to return null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!locfcinfo-&gt;isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cmpresult &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arg1 is less than arg2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cmpresult &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arg1 is greater than arg2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, so continue to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i1++, i2++, j++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we didn't break out of the loop early, check for column count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mismatch.&nbsp; (We do not report such mismatch if we found unequal column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>; is that a feature or a bug?)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i1 != ncolumns1 || i2 != ncolumns2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> record types with different numbers of columns&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(values1);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls1);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(values2);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls2);<br/></li>
<li>&nbsp; &nbsp; ReleaseTupleDesc(tupdesc1);<br/></li>
<li>&nbsp; &nbsp; ReleaseTupleDesc(tupdesc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Avoid leaking memory when handed toasted input. */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(record1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(record2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1067" title="utils/adt/rowtypes.c:1067">record_eq</a> :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compares two <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> for equality<br/></li>
<li></span><span class="Comment"> * result :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returns true if the <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, false otherwise.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we do not use <a href="#L823" title="utils/adt/rowtypes.c:823">record_cmp</a> here, since equality may be meaningful in<br/></li>
<li></span><span class="Comment"> * datatypes that don't have a total ordering (and hence no btree support).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1067">&#x200c;</a><span class="linkable">record_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupType1;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupType2;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; tupTypmod1;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; tupTypmod2;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc1;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc2;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tuple1;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tuple2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncolumns1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncolumns2;<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a> *my_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncols;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *values1;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *values2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recurses for record-type columns */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract type info from the tuples */<br/></li>
<li></span>&nbsp; &nbsp; tupType1 = HeapTupleHeaderGetTypeId(record1);<br/></li>
<li>&nbsp; &nbsp; tupTypmod1 = HeapTupleHeaderGetTypMod(record1);<br/></li>
<li>&nbsp; &nbsp; tupdesc1 = <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(tupType1, tupTypmod1);<br/></li>
<li>&nbsp; &nbsp; ncolumns1 = tupdesc1-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; tupType2 = HeapTupleHeaderGetTypeId(record2);<br/></li>
<li>&nbsp; &nbsp; tupTypmod2 = HeapTupleHeaderGetTypMod(record2);<br/></li>
<li>&nbsp; &nbsp; tupdesc2 = <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(tupType2, tupTypmod2);<br/></li>
<li>&nbsp; &nbsp; ncolumns2 = tupdesc2-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build temporary HeapTuple control structures */<br/></li>
<li></span>&nbsp; &nbsp; tuple1.t_len = HeapTupleHeaderGetDatumLength(record1);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tuple1.t_self));<br/></li>
<li>&nbsp; &nbsp; tuple1.t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; tuple1.t_data = record1;<br/></li>
<li>&nbsp; &nbsp; tuple2.t_len = HeapTupleHeaderGetDatumLength(record2);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tuple2.t_self));<br/></li>
<li>&nbsp; &nbsp; tuple2.t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; tuple2.t_data = record2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up the needed comparison info just once per series<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of calls, assuming the record types don't change underneath us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ncols = Max(ncolumns1, ncolumns2);<br/></li>
<li>&nbsp; &nbsp; my_extra = (<a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;ncolumns &lt; ncols)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetof(<a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a>, columns) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ncols * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L54" title="utils/adt/rowtypes.c:54">ColumnCompareData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra = (<a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;ncolumns = ncols;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_type = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_typmod = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_type = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_typmod = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra-&gt;record1_type != tupType1 ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_typmod != tupTypmod1 ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_type != tupType2 ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_typmod != tupTypmod2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(my_extra-&gt;columns, <span class="Constant">0</span>, ncols * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L54" title="utils/adt/rowtypes.c:54">ColumnCompareData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_type = tupType1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_typmod = tupTypmod1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_type = tupType2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_typmod = tupTypmod2;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Break down the tuples into fields */<br/></li>
<li></span>&nbsp; &nbsp; values1 = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns1 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; nulls1 = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns1 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(&amp;tuple1, tupdesc1, values1, nulls1);<br/></li>
<li>&nbsp; &nbsp; values2 = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns2 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; nulls2 = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns2 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(&amp;tuple2, tupdesc2, values2, nulls2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan corresponding columns, allowing for dropped columns in different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * places in the two rows.&nbsp; i1 and i2 are physical column indexes, j is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the logical column index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; i1 = i2 = j = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (i1 &lt; ncolumns1 || i2 &lt; ncolumns2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCAL_FCINFO(locfcinfo, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; oprresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Skip dropped columns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i1 &lt; ncolumns1 &amp;&amp; TupleDescAttr(tupdesc1, i1)-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i1++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i2 &lt; ncolumns2 &amp;&amp; TupleDescAttr(tupdesc2, i2)-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i1 &gt;= ncolumns1 || i2 &gt;= ncolumns2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we'll deal with mismatch below loop */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att1 = TupleDescAttr(tupdesc1, i1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att2 = TupleDescAttr(tupdesc2, i2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Have two matching columns, they must be same type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att1-&gt;atttypid != att2-&gt;atttypid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> dissimilar column types </span><span class="Special">%s</span><span class="Constant"> and </span><span class="Special">%s</span><span class="Constant"> at record column </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(att1-&gt;atttypid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(att2-&gt;atttypid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j + <span class="Constant">1</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If they're not same collation, we don't complain here, but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * equality function might.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; collation = att1-&gt;attcollation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (collation != att2-&gt;attcollation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lookup the equality function if not done already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typentry = my_extra-&gt;columns[j].typentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;type_id != att1-&gt;atttypid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(att1-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_EQ_OPR_FINFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typentry-&gt;eq_opr_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not identify an equality operator for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(typentry-&gt;type_id))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;columns[j].typentry = typentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We consider two NULLs <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>; NULL &gt; not-NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!nulls1[i1] || !nulls2[i2])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls1[i1] || nulls2[i2])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compare the pair of elements */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(*locfcinfo, &amp;typentry-&gt;eq_opr_finfo, <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].value = values1[i1];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">1</span>].value = values2[i2];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oprresult = DatumGetBool(FunctionCallInvoke(locfcinfo));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locfcinfo-&gt;isnull || !oprresult)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, so continue to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i1++, i2++, j++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we didn't break out of the loop early, check for column count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mismatch.&nbsp; (We do not report such mismatch if we found unequal column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>; is that a feature or a bug?)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i1 != ncolumns1 || i2 != ncolumns2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> record types with different numbers of columns&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(values1);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls1);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(values2);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls2);<br/></li>
<li>&nbsp; &nbsp; ReleaseTupleDesc(tupdesc1);<br/></li>
<li>&nbsp; &nbsp; ReleaseTupleDesc(tupdesc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Avoid leaking memory when handed toasted input. */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(record1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(record2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1283">&#x200c;</a><span class="linkable">record_ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(!DatumGetBool(<a href="#L1067" title="utils/adt/rowtypes.c:1067">record_eq</a>(fcinfo)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1289">&#x200c;</a><span class="linkable">record_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L823" title="utils/adt/rowtypes.c:823">record_cmp</a>(fcinfo) &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1295">&#x200c;</a><span class="linkable">record_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L823" title="utils/adt/rowtypes.c:823">record_cmp</a>(fcinfo) &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1301">&#x200c;</a><span class="linkable">record_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L823" title="utils/adt/rowtypes.c:823">record_cmp</a>(fcinfo) &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1307">&#x200c;</a><span class="linkable">record_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L823" title="utils/adt/rowtypes.c:823">record_cmp</a>(fcinfo) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1313">&#x200c;</a><span class="linkable">btrecordcmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L823" title="utils/adt/rowtypes.c:823">record_cmp</a>(fcinfo));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1331" title="utils/adt/rowtypes.c:1331">record_image_cmp</a> :<br/></li>
<li></span><span class="Comment"> * Internal byte-oriented comparison function for <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns -1, 0 or 1<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: The normal concepts of &quot;equality&quot; do not apply here; different<br/></li>
<li></span><span class="Comment"> * representation of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> considered to be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> are not considered to be<br/></li>
<li></span><span class="Comment"> * identical.&nbsp; As an example, for the citext type 'A' and 'a' are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, but<br/></li>
<li></span><span class="Comment"> * they are not identical.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1331">&#x200c;</a></span><span class="linkable">record_image_cmp</span>(FunctionCallInfo fcinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupType1;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupType2;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; tupTypmod1;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; tupTypmod2;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc1;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc2;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tuple1;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tuple2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncolumns1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncolumns2;<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a> *my_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncols;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *values1;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *values2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract type info from the tuples */<br/></li>
<li></span>&nbsp; &nbsp; tupType1 = HeapTupleHeaderGetTypeId(record1);<br/></li>
<li>&nbsp; &nbsp; tupTypmod1 = HeapTupleHeaderGetTypMod(record1);<br/></li>
<li>&nbsp; &nbsp; tupdesc1 = <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(tupType1, tupTypmod1);<br/></li>
<li>&nbsp; &nbsp; ncolumns1 = tupdesc1-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; tupType2 = HeapTupleHeaderGetTypeId(record2);<br/></li>
<li>&nbsp; &nbsp; tupTypmod2 = HeapTupleHeaderGetTypMod(record2);<br/></li>
<li>&nbsp; &nbsp; tupdesc2 = <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(tupType2, tupTypmod2);<br/></li>
<li>&nbsp; &nbsp; ncolumns2 = tupdesc2-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build temporary HeapTuple control structures */<br/></li>
<li></span>&nbsp; &nbsp; tuple1.t_len = HeapTupleHeaderGetDatumLength(record1);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tuple1.t_self));<br/></li>
<li>&nbsp; &nbsp; tuple1.t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; tuple1.t_data = record1;<br/></li>
<li>&nbsp; &nbsp; tuple2.t_len = HeapTupleHeaderGetDatumLength(record2);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tuple2.t_self));<br/></li>
<li>&nbsp; &nbsp; tuple2.t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; tuple2.t_data = record2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up the needed comparison info just once per series<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of calls, assuming the record types don't change underneath us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ncols = Max(ncolumns1, ncolumns2);<br/></li>
<li>&nbsp; &nbsp; my_extra = (<a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;ncolumns &lt; ncols)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetof(<a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a>, columns) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ncols * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L54" title="utils/adt/rowtypes.c:54">ColumnCompareData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra = (<a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;ncolumns = ncols;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_type = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_typmod = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_type = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_typmod = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra-&gt;record1_type != tupType1 ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_typmod != tupTypmod1 ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_type != tupType2 ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_typmod != tupTypmod2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(my_extra-&gt;columns, <span class="Constant">0</span>, ncols * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L54" title="utils/adt/rowtypes.c:54">ColumnCompareData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_type = tupType1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_typmod = tupTypmod1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_type = tupType2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_typmod = tupTypmod2;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Break down the tuples into fields */<br/></li>
<li></span>&nbsp; &nbsp; values1 = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns1 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; nulls1 = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns1 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(&amp;tuple1, tupdesc1, values1, nulls1);<br/></li>
<li>&nbsp; &nbsp; values2 = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns2 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; nulls2 = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns2 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(&amp;tuple2, tupdesc2, values2, nulls2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan corresponding columns, allowing for dropped columns in different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * places in the two rows.&nbsp; i1 and i2 are physical column indexes, j is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the logical column index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; i1 = i2 = j = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (i1 &lt; ncolumns1 || i2 &lt; ncolumns2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Skip dropped columns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i1 &lt; ncolumns1 &amp;&amp; TupleDescAttr(tupdesc1, i1)-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i1++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i2 &lt; ncolumns2 &amp;&amp; TupleDescAttr(tupdesc2, i2)-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i1 &gt;= ncolumns1 || i2 &gt;= ncolumns2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we'll deal with mismatch below loop */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att1 = TupleDescAttr(tupdesc1, i1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att2 = TupleDescAttr(tupdesc2, i2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Have two matching columns, they must be same type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att1-&gt;atttypid != att2-&gt;atttypid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> dissimilar column types </span><span class="Special">%s</span><span class="Constant"> and </span><span class="Special">%s</span><span class="Constant"> at record column </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(att1-&gt;atttypid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(att2-&gt;atttypid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j + <span class="Constant">1</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The same type should have the same length (or both should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * variable).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(att1-&gt;attlen == att2-&gt;attlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We consider two NULLs <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>; NULL &gt; not-NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!nulls1[i1] || !nulls2[i2])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpresult = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls1[i1])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arg1 is greater than arg2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls2[i2])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arg1 is less than arg2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compare the pair of elements */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att1-&gt;attbyval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (values1[i1] != values2[i2])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpresult = (values1[i1] &lt; values2[i2]) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (att1-&gt;attlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpresult = memcmp(DatumGetPointer(values1[i1]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DatumGetPointer(values2[i2]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; att1-&gt;attlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (att1-&gt;attlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varlena *arg1val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varlena *arg2val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len1 = <a href="../../access/common/detoast.c.html#L545" title="access/common/detoast.c:545">toast_raw_datum_size</a>(values1[i1]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len2 = <a href="../../access/common/detoast.c.html#L545" title="access/common/detoast.c:545">toast_raw_datum_size</a>(values2[i2]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg1val = PG_DETOAST_DATUM_PACKED(values1[i1]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg2val = PG_DETOAST_DATUM_PACKED(values2[i2]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpresult = memcmp(VARDATA_ANY(arg1val),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARDATA_ANY(arg2val),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(len1, len2) - VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cmpresult == <span class="Constant">0</span>) &amp;&amp; (len1 != len2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpresult = (len1 &lt; len2) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((Pointer) arg1val != (Pointer) values1[i1])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(arg1val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((Pointer) arg2val != (Pointer) values2[i2])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(arg2val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected attlen: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, att1-&gt;attlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cmpresult &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arg1 is less than arg2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cmpresult &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arg1 is greater than arg2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, so continue to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i1++, i2++, j++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we didn't break out of the loop early, check for column count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mismatch.&nbsp; (We do not report such mismatch if we found unequal column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>; is that a feature or a bug?)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i1 != ncolumns1 || i2 != ncolumns2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> record types with different numbers of columns&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(values1);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls1);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(values2);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls2);<br/></li>
<li>&nbsp; &nbsp; ReleaseTupleDesc(tupdesc1);<br/></li>
<li>&nbsp; &nbsp; ReleaseTupleDesc(tupdesc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Avoid leaking memory when handed toasted input. */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(record1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(record2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1577" title="utils/adt/rowtypes.c:1577">record_image_eq</a> :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compares two <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> for identical contents, based on byte images<br/></li>
<li></span><span class="Comment"> * result :<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returns true if the <a href="../../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> are identical, false otherwise.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we do not use <a href="#L1331" title="utils/adt/rowtypes.c:1331">record_image_cmp</a> here, since we can avoid<br/></li>
<li></span><span class="Comment"> * de-toasting for unequal lengths this way.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1577">&#x200c;</a><span class="linkable">record_image_eq</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader record1 = PG_GETARG_HEAPTUPLEHEADER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader record2 = PG_GETARG_HEAPTUPLEHEADER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupType1;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupType2;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; tupTypmod1;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; tupTypmod2;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc1;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc2;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tuple1;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tuple2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncolumns1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncolumns2;<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a> *my_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncols;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *values1;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *values2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract type info from the tuples */<br/></li>
<li></span>&nbsp; &nbsp; tupType1 = HeapTupleHeaderGetTypeId(record1);<br/></li>
<li>&nbsp; &nbsp; tupTypmod1 = HeapTupleHeaderGetTypMod(record1);<br/></li>
<li>&nbsp; &nbsp; tupdesc1 = <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(tupType1, tupTypmod1);<br/></li>
<li>&nbsp; &nbsp; ncolumns1 = tupdesc1-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; tupType2 = HeapTupleHeaderGetTypeId(record2);<br/></li>
<li>&nbsp; &nbsp; tupTypmod2 = HeapTupleHeaderGetTypMod(record2);<br/></li>
<li>&nbsp; &nbsp; tupdesc2 = <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(tupType2, tupTypmod2);<br/></li>
<li>&nbsp; &nbsp; ncolumns2 = tupdesc2-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build temporary HeapTuple control structures */<br/></li>
<li></span>&nbsp; &nbsp; tuple1.t_len = HeapTupleHeaderGetDatumLength(record1);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tuple1.t_self));<br/></li>
<li>&nbsp; &nbsp; tuple1.t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; tuple1.t_data = record1;<br/></li>
<li>&nbsp; &nbsp; tuple2.t_len = HeapTupleHeaderGetDatumLength(record2);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tuple2.t_self));<br/></li>
<li>&nbsp; &nbsp; tuple2.t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; tuple2.t_data = record2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up the needed comparison info just once per series<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of calls, assuming the record types don't change underneath us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ncols = Max(ncolumns1, ncolumns2);<br/></li>
<li>&nbsp; &nbsp; my_extra = (<a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;ncolumns &lt; ncols)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetof(<a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a>, columns) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ncols * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L54" title="utils/adt/rowtypes.c:54">ColumnCompareData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra = (<a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;ncolumns = ncols;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_type = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_typmod = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_type = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_typmod = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra-&gt;record1_type != tupType1 ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_typmod != tupTypmod1 ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_type != tupType2 ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_typmod != tupTypmod2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(my_extra-&gt;columns, <span class="Constant">0</span>, ncols * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L54" title="utils/adt/rowtypes.c:54">ColumnCompareData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_type = tupType1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_typmod = tupTypmod1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_type = tupType2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record2_typmod = tupTypmod2;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Break down the tuples into fields */<br/></li>
<li></span>&nbsp; &nbsp; values1 = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns1 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; nulls1 = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns1 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(&amp;tuple1, tupdesc1, values1, nulls1);<br/></li>
<li>&nbsp; &nbsp; values2 = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns2 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; nulls2 = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns2 * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(&amp;tuple2, tupdesc2, values2, nulls2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan corresponding columns, allowing for dropped columns in different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * places in the two rows.&nbsp; i1 and i2 are physical column indexes, j is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the logical column index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; i1 = i2 = j = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (i1 &lt; ncolumns1 || i2 &lt; ncolumns2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Skip dropped columns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i1 &lt; ncolumns1 &amp;&amp; TupleDescAttr(tupdesc1, i1)-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i1++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i2 &lt; ncolumns2 &amp;&amp; TupleDescAttr(tupdesc2, i2)-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i1 &gt;= ncolumns1 || i2 &gt;= ncolumns2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we'll deal with mismatch below loop */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att1 = TupleDescAttr(tupdesc1, i1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att2 = TupleDescAttr(tupdesc2, i2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Have two matching columns, they must be same type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att1-&gt;atttypid != att2-&gt;atttypid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> dissimilar column types </span><span class="Special">%s</span><span class="Constant"> and </span><span class="Special">%s</span><span class="Constant"> at record column </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(att1-&gt;atttypid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(att2-&gt;atttypid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j + <span class="Constant">1</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We consider two NULLs <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>; NULL &gt; not-NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!nulls1[i1] || !nulls2[i2])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls1[i1] || nulls2[i2])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compare the pair of elements */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="datum.c.html#L266" title="utils/adt/datum.c:266">datum_image_eq</a>(values1[i1], values2[i2], att1-&gt;attbyval, att2-&gt;attlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, so continue to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i1++, i2++, j++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we didn't break out of the loop early, check for column count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mismatch.&nbsp; (We do not report such mismatch if we found unequal column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>; is that a feature or a bug?)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i1 != ncolumns1 || i2 != ncolumns2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> record types with different numbers of columns&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(values1);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls1);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(values2);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls2);<br/></li>
<li>&nbsp; &nbsp; ReleaseTupleDesc(tupdesc1);<br/></li>
<li>&nbsp; &nbsp; ReleaseTupleDesc(tupdesc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Avoid leaking memory when handed toasted input. */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(record1, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; PG_FREE_IF_COPY(record2, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1753">&#x200c;</a><span class="linkable">record_image_ne</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(!DatumGetBool(<a href="#L1577" title="utils/adt/rowtypes.c:1577">record_image_eq</a>(fcinfo)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1759">&#x200c;</a><span class="linkable">record_image_lt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L1331" title="utils/adt/rowtypes.c:1331">record_image_cmp</a>(fcinfo) &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1765">&#x200c;</a><span class="linkable">record_image_gt</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L1331" title="utils/adt/rowtypes.c:1331">record_image_cmp</a>(fcinfo) &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1771">&#x200c;</a><span class="linkable">record_image_le</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L1331" title="utils/adt/rowtypes.c:1331">record_image_cmp</a>(fcinfo) &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1777">&#x200c;</a><span class="linkable">record_image_ge</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L1331" title="utils/adt/rowtypes.c:1331">record_image_cmp</a>(fcinfo) &gt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1783">&#x200c;</a><span class="linkable">btrecordimagecmp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32(<a href="#L1331" title="utils/adt/rowtypes.c:1331">record_image_cmp</a>(fcinfo));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Row type <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1794">&#x200c;</a><span class="linkable">hash_record</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader record = PG_GETARG_HEAPTUPLEHEADER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupType;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; tupTypmod;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncolumns;<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a> *my_extra;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recurses for record-type columns */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract type info from tuple */<br/></li>
<li></span>&nbsp; &nbsp; tupType = HeapTupleHeaderGetTypeId(record);<br/></li>
<li>&nbsp; &nbsp; tupTypmod = HeapTupleHeaderGetTypMod(record);<br/></li>
<li>&nbsp; &nbsp; tupdesc = <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(tupType, tupTypmod);<br/></li>
<li>&nbsp; &nbsp; ncolumns = tupdesc-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build temporary HeapTuple control structure */<br/></li>
<li></span>&nbsp; &nbsp; tuple.t_len = HeapTupleHeaderGetDatumLength(record);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tuple.t_self));<br/></li>
<li>&nbsp; &nbsp; tuple.t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; tuple.t_data = record;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up the needed hashing info just once per series of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls, assuming the record type doesn't change underneath us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; my_extra = (<a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;ncolumns &lt; ncolumns)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetof(<a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a>, columns) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L54" title="utils/adt/rowtypes.c:54">ColumnCompareData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra = (<a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;ncolumns = ncolumns;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_type = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_typmod = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra-&gt;record1_type != tupType ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_typmod != tupTypmod)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(my_extra-&gt;columns, <span class="Constant">0</span>, ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L54" title="utils/adt/rowtypes.c:54">ColumnCompareData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_type = tupType;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_typmod = tupTypmod;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Break down the tuple into fields */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; nulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(&amp;tuple, tupdesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; ncolumns; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; <a href="array_typanalyze.c.html#L710" title="utils/adt/array_typanalyze.c:710">element_hash</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att = TupleDescAttr(tupdesc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lookup the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function if not done already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typentry = my_extra-&gt;columns[i].typentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;type_id != att-&gt;atttypid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(att-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_HASH_PROC_FINFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typentry-&gt;hash_proc_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not identify a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(typentry-&gt;type_id))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;columns[i].typentry = typentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> of <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="array_typanalyze.c.html#L710" title="utils/adt/array_typanalyze.c:710">element_hash</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCAL_FCINFO(locfcinfo, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(*locfcinfo, &amp;typentry-&gt;hash_proc_finfo, <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; att-&gt;attcollation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].value = <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="array_typanalyze.c.html#L710" title="utils/adt/array_typanalyze.c:710">element_hash</a> = DatumGetUInt32(FunctionCallInvoke(locfcinfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't expect <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to return null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!locfcinfo-&gt;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see <a href="arrayfuncs.c.html#L4139" title="utils/adt/arrayfuncs.c:4139">hash_array</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (result &lt;&lt; <span class="Constant">5</span>) - result + <a href="array_typanalyze.c.html#L710" title="utils/adt/array_typanalyze.c:710">element_hash</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls);<br/></li>
<li>&nbsp; &nbsp; ReleaseTupleDesc(tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Avoid leaking memory when handed toasted input. */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(record, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_UINT32(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1914">&#x200c;</a><span class="linkable">hash_record_extended</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader record = PG_GETARG_HEAPTUPLEHEADER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; seed = PG_GETARG_INT64(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupType;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; tupTypmod;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncolumns;<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a> *my_extra;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nulls;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recurses for record-type columns */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract type info from tuple */<br/></li>
<li></span>&nbsp; &nbsp; tupType = HeapTupleHeaderGetTypeId(record);<br/></li>
<li>&nbsp; &nbsp; tupTypmod = HeapTupleHeaderGetTypMod(record);<br/></li>
<li>&nbsp; &nbsp; tupdesc = <a href="../cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(tupType, tupTypmod);<br/></li>
<li>&nbsp; &nbsp; ncolumns = tupdesc-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build temporary HeapTuple control structure */<br/></li>
<li></span>&nbsp; &nbsp; tuple.t_len = HeapTupleHeaderGetDatumLength(record);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tuple.t_self));<br/></li>
<li>&nbsp; &nbsp; tuple.t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; tuple.t_data = record;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to look up the needed hashing info just once per series of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls, assuming the record type doesn't change underneath us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; my_extra = (<a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;ncolumns &lt; ncolumns)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetof(<a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a>, columns) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L54" title="utils/adt/rowtypes.c:54">ColumnCompareData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra = (<a href="#L59" title="utils/adt/rowtypes.c:59">RecordCompareData</a> *) fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;ncolumns = ncolumns;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_type = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_typmod = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_extra-&gt;record1_type != tupType ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_typmod != tupTypmod)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(my_extra-&gt;columns, <span class="Constant">0</span>, ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L54" title="utils/adt/rowtypes.c:54">ColumnCompareData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_type = tupType;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;record1_typmod = tupTypmod;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Break down the tuple into fields */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = (Datum *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; nulls = (<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ncolumns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(&amp;tuple, tupdesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; ncolumns; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; <a href="array_typanalyze.c.html#L710" title="utils/adt/array_typanalyze.c:710">element_hash</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att = TupleDescAttr(tupdesc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lookup the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function if not done already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; typentry = my_extra-&gt;columns[i].typentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typentry == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry-&gt;type_id != att-&gt;atttypid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="../cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(att-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_HASH_EXTENDED_PROC_FINFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typentry-&gt;hash_extended_proc_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not identify an extended <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(typentry-&gt;type_id))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my_extra-&gt;columns[i].typentry = typentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> of <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="array_typanalyze.c.html#L710" title="utils/adt/array_typanalyze.c:710">element_hash</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCAL_FCINFO(locfcinfo, <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InitFunctionCallInfoData(*locfcinfo, &amp;typentry-&gt;hash_extended_proc_finfo, <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; att-&gt;attcollation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].value = <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">1</span>].value = <a href="../fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(seed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locfcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="array_typanalyze.c.html#L710" title="utils/adt/array_typanalyze.c:710">element_hash</a> = DatumGetUInt64(FunctionCallInvoke(locfcinfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't expect <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to return null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!locfcinfo-&gt;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see <a href="arrayfuncs.c.html#L4272" title="utils/adt/arrayfuncs.c:4272">hash_array_extended</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (result &lt;&lt; <span class="Constant">5</span>) - result + <a href="array_typanalyze.c.html#L710" title="utils/adt/array_typanalyze.c:710">element_hash</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nulls);<br/></li>
<li>&nbsp; &nbsp; ReleaseTupleDesc(tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Avoid leaking memory when handed toasted input. */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(record, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_UINT64(result);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
