<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/adt/format_type.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/adt/format_type.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L60">format_type</a></li>
<li><a href="#L343">format_type_be</a></li>
<li><a href="#L353">format_type_be_qualified</a></li>
<li><a href="#L112">format_type_extended</a></li>
<li><a href="#L362">format_type_with_typemod</a></li>
<li><a href="#L447">oidvectortypes</a></li>
<li><a href="#L371">printTypmod</a></li>
<li><a href="#L412">type_maximum_size</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L60" title="utils/adt/format_type.c:60">format_type</a>.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Display type names &quot;nicely&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/adt/<a href="#L60" title="utils/adt/format_type.c:60">format_type</a>.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L371" title="utils/adt/format_type.c:371">printTypmod</a>(<span class="Type">const</span> <span class="Type">char</span> *typname, int32 typmod, Oid typmodout);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL function: <a href="#L60" title="utils/adt/format_type.c:60">format_type</a>(type_oid, typemod)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * `type_oid' is from pg_type.oid, `typemod' is from<br/></li>
<li></span><span class="Comment"> * pg_attribute.atttypmod. This function will get the type name and<br/></li>
<li></span><span class="Comment"> * format it and the modifier to canonical SQL format, if the type is<br/></li>
<li></span><span class="Comment"> * a standard type. Otherwise you just get pg_type.typname back,<br/></li>
<li></span><span class="Comment"> * double quoted if it contains funny characters or matches a keyword.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If typemod is NULL then we are formatting a type name in a context where<br/></li>
<li></span><span class="Comment"> * no typemod is available, eg a function argument or result type.&nbsp; This<br/></li>
<li></span><span class="Comment"> * yields a slightly different result from specifying typemod = -1 in some<br/></li>
<li></span><span class="Comment"> * cases.&nbsp; Given typemod = -1 we feel compelled to produce an output that<br/></li>
<li></span><span class="Comment"> * the parser will interpret as having typemod -1, so that pg_dump will<br/></li>
<li></span><span class="Comment"> * produce CREATE TABLE commands that recreate the original state.&nbsp; But<br/></li>
<li></span><span class="Comment"> * given NULL typemod, we assume that the parser's interpretation of<br/></li>
<li></span><span class="Comment"> * typemod doesn't matter, and so we are willing to output a slightly<br/></li>
<li></span><span class="Comment"> * &quot;prettier&quot; representation of the same type.&nbsp; For example, type = <a href="varchar.c.html#L271" title="utils/adt/varchar.c:271">bpchar</a><br/></li>
<li></span><span class="Comment"> * and typemod = NULL gets you &quot;character&quot;, whereas typemod = -1 gets you<br/></li>
<li></span><span class="Comment"> * &quot;<a href="varchar.c.html#L271" title="utils/adt/varchar.c:271">bpchar</a>&quot; --- the former will be interpreted as character(1) by the<br/></li>
<li></span><span class="Comment"> * parser, which does not yield typemod -1.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> encoding a meaning in typemod = NULL is ugly; it'd have been<br/></li>
<li></span><span class="Comment"> * cleaner to make two <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> of one and two arguments respectively.<br/></li>
<li></span><span class="Comment"> * Not worth changing it <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, however.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L60">&#x200c;</a><span class="linkable">format_type</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type_oid;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; typemod;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; bits16&nbsp; &nbsp; &nbsp; &nbsp; flags = FORMAT_TYPE_ALLOW_INVALID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Since this function is not strict, we must test for null args */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; type_oid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PG_ARGISNULL(<span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typemod = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typemod = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags |= FORMAT_TYPE_TYPEMOD_GIVEN;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L112" title="utils/adt/format_type.c:112">format_type_extended</a>(type_oid, typemod, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(result));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L112" title="utils/adt/format_type.c:112">format_type_extended</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Generate a possibly-qualified type name.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The default behavior is to only qualify if the type is not in the search<br/></li>
<li></span><span class="Comment"> * path, to ignore the given typmod, and to raise an error if a non-existent<br/></li>
<li></span><span class="Comment"> * type_oid is given.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The following bits in 'flags' modify the behavior:<br/></li>
<li></span><span class="Comment"> * - FORMAT_TYPE_TYPEMOD_GIVEN<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; include the typmod in the output (typmod could still be -1 though)<br/></li>
<li></span><span class="Comment"> * - FORMAT_TYPE_ALLOW_INVALID<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if the type OID is invalid or unknown, return ??? or such instead<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of failing<br/></li>
<li></span><span class="Comment"> * - FORMAT_TYPE_INVALID_AS_NULL<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if the type OID is invalid or unknown, return NULL instead of ???<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or such<br/></li>
<li></span><span class="Comment"> * - FORMAT_TYPE_FORCE_QUALIFY<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; always schema-qualify type names, regardless of search_path<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that TYPEMOD_GIVEN is not interchangeable with &quot;typemod == -1&quot;;<br/></li>
<li></span><span class="Comment"> * see the comments above for <a href="#L60" title="utils/adt/format_type.c:60">format_type</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string, or NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L112">&#x200c;</a><span class="linkable">format_type_extended</span>(Oid type_oid, int32 typemod, bits16 flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_type typeform;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array_base_type;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_array;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; with_typemod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (type_oid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; FORMAT_TYPE_INVALID_AS_NULL) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((flags &amp; FORMAT_TYPE_ALLOW_INVALID) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;-&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(type_oid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; FORMAT_TYPE_INVALID_AS_NULL) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((flags &amp; FORMAT_TYPE_ALLOW_INVALID) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;???&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, type_oid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; typeform = (Form_pg_type) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if it's a &quot;true&quot; array type.&nbsp; Pseudo-array types such as &quot;name&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shouldn't get deconstructed.&nbsp; Also check the toast property, and don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deconstruct &quot;plain storage&quot; array types --- this is because we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * want to show oidvector as oid[].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; array_base_type = typeform-&gt;typelem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsTrueArrayType(typeform) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typeform-&gt;typstorage != TYPSTORAGE_PLAIN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Switch our attention to the array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(array_base_type));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; FORMAT_TYPE_INVALID_AS_NULL) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((flags &amp; FORMAT_TYPE_ALLOW_INVALID) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;???[]&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, type_oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typeform = (Form_pg_type) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; type_oid = array_base_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; is_array = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; is_array = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; with_typemod = (flags &amp; FORMAT_TYPE_TYPEMOD_GIVEN) != <span class="Constant">0</span> &amp;&amp; (typemod &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if we want to special-case the output for certain built-in types.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that these special cases should all correspond to special<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * productions in gram.y, to ensure that the type name will be taken as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * system type, not a user type of the same name.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we do not provide a special-case output here, the type name will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handled the same way as a user type name --- in particular, it will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * double-quoted if it matches <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lexer keyword.&nbsp; This behavior is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * essential for some cases, such as types &quot;<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>&quot; and &quot;char&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; buf = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* flag for no special case */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (type_oid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BITOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (with_typemod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L371" title="utils/adt/format_type.c:371">printTypmod</a>(<span class="Constant">&quot;<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>&quot;</span>, typemod, typeform-&gt;typmodout);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((flags &amp; FORMAT_TYPE_TYPEMOD_GIVEN) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> with typmod -1 is not the same as BIT, which means<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * BIT(1) per SQL spec.&nbsp; Report it as the quoted typename so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that parser will not assign a bogus typmod.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BOOLOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;boolean&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BPCHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (with_typemod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L371" title="utils/adt/format_type.c:371">printTypmod</a>(<span class="Constant">&quot;character&quot;</span>, typemod, typeform-&gt;typmodout);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((flags &amp; FORMAT_TYPE_TYPEMOD_GIVEN) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="varchar.c.html#L271" title="utils/adt/varchar.c:271">bpchar</a> with typmod -1 is not the same as CHARACTER, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * means CHARACTER(1) per SQL spec.&nbsp; Report it as <a href="varchar.c.html#L271" title="utils/adt/varchar.c:271">bpchar</a> so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that parser will not assign a bogus typmod.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;character&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FLOAT4OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;real&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FLOAT8OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;double precision&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT2OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;smallint&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT4OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;integer&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INT8OID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;bigint&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> NUMERICOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (with_typemod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L371" title="utils/adt/format_type.c:371">printTypmod</a>(<span class="Constant">&quot;<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>&quot;</span>, typemod, typeform-&gt;typmodout);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;<a href="numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERVALOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (with_typemod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L371" title="utils/adt/format_type.c:371">printTypmod</a>(<span class="Constant">&quot;interval&quot;</span>, typemod, typeform-&gt;typmodout);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;interval&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMEOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (with_typemod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L371" title="utils/adt/format_type.c:371">printTypmod</a>(<span class="Constant">&quot;time&quot;</span>, typemod, typeform-&gt;typmodout);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;time without time zone&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMETZOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (with_typemod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L371" title="utils/adt/format_type.c:371">printTypmod</a>(<span class="Constant">&quot;time&quot;</span>, typemod, typeform-&gt;typmodout);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;time with time zone&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMESTAMPOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (with_typemod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L371" title="utils/adt/format_type.c:371">printTypmod</a>(<span class="Constant">&quot;timestamp&quot;</span>, typemod, typeform-&gt;typmodout);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;timestamp without time zone&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TIMESTAMPTZOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (with_typemod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L371" title="utils/adt/format_type.c:371">printTypmod</a>(<span class="Constant">&quot;timestamp&quot;</span>, typemod, typeform-&gt;typmodout);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;timestamp with time zone&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VARBITOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (with_typemod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L371" title="utils/adt/format_type.c:371">printTypmod</a>(<span class="Constant">&quot;<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> varying&quot;</span>, typemod, typeform-&gt;typmodout);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;<a href="varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> varying&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VARCHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (with_typemod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L371" title="utils/adt/format_type.c:371">printTypmod</a>(<span class="Constant">&quot;character varying&quot;</span>, typemod, typeform-&gt;typmodout);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;character varying&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> JSONOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;json&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (buf == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Default handling: report the name as it appears in the catalog.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here, we must qualify the name if it is not visible in the search<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * path or if caller requests it; and we must double-quote it if it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not a standard identifier or if it matches <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> keyword.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nspname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *typname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; FORMAT_TYPE_FORCE_QUALIFY) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/namespace.c.html#L1025" title="catalog/namespace.c:1025">TypeIsVisible</a>(type_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspname = <a href="../cache/lsyscache.c.html#L3390" title="utils/cache/lsyscache.c:3390">get_namespace_name_or_temp</a>(typeform-&gt;typnamespace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; typname = NameStr(typeform-&gt;typname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="ruleutils.c.html#L12707" title="utils/adt/ruleutils.c:12707">quote_qualified_identifier</a>(nspname, typname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (with_typemod)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L371" title="utils/adt/format_type.c:371">printTypmod</a>(buf, typemod, typeform-&gt;typmodout);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_array)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = psprintf(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">[]&quot;</span>, buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This version is for use within the backend in error messages, etc.<br/></li>
<li></span><span class="Comment"> * One difference is that it will fail for an invalid type.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is always a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L343">&#x200c;</a><span class="linkable">format_type_be</span>(Oid type_oid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L112" title="utils/adt/format_type.c:112">format_type_extended</a>(type_oid, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This version returns a name that is always qualified (unless it's one<br/></li>
<li></span><span class="Comment"> * of the SQL-keyword type names, such as TIMESTAMP WITH TIME ZONE).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L353">&#x200c;</a><span class="linkable">format_type_be_qualified</span>(Oid type_oid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L112" title="utils/adt/format_type.c:112">format_type_extended</a>(type_oid, -<span class="Constant">1</span>, FORMAT_TYPE_FORCE_QUALIFY);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This version allows a nondefault typemod to be specified.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L362">&#x200c;</a><span class="linkable">format_type_with_typemod</span>(Oid type_oid, int32 typemod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L112" title="utils/adt/format_type.c:112">format_type_extended</a>(type_oid, typemod, FORMAT_TYPE_TYPEMOD_GIVEN);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add typmod decoration to the basic type name<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L371">&#x200c;</a><span class="linkable">printTypmod</span>(<span class="Type">const</span> <span class="Type">char</span> *typname, int32 typmod, Oid typmodout)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't be called if typmod is -1 */<br/></li>
<li></span>&nbsp; &nbsp; Assert(typmod &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typmodout == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Default behavior: just <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> the integer typmod with parens */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res = psprintf(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>, typname, (<span class="Type">int</span>) typmod);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use the type-specific typmodout procedure */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tmstr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmstr = DatumGetCString(OidFunctionCall1(typmodout,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int32GetDatum(typmod)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = psprintf(<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>, typname, tmstr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L412" title="utils/adt/format_type.c:412">type_maximum_size</a> --- determine maximum width of a variable-width column<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the max width is indeterminate, return -1.&nbsp; In particular, we return<br/></li>
<li></span><span class="Comment"> * -1 for <a href="pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> type not known to this routine.&nbsp; We assume the caller has<br/></li>
<li></span><span class="Comment"> * already determined that the type is a variable-width type, so it's not<br/></li>
<li></span><span class="Comment"> * necessary to look up the type's pg_type tuple here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This may appear unrelated to <a href="#L60" title="utils/adt/format_type.c:60">format_type</a>(), but in fact the two routines<br/></li>
<li></span><span class="Comment"> * share knowledge of the encoding of typmod for different types, so it's<br/></li>
<li></span><span class="Comment"> * convenient to keep them together.&nbsp; (</span><span class="Todo">XXX</span><span class="Comment"> <a href="timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that most of this knowledge<br/></li>
<li></span><span class="Comment"> * has been pushed out of <a href="#L60" title="utils/adt/format_type.c:60">format_type</a> into the typmodout <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, it's<br/></li>
<li></span><span class="Comment"> * interesting to wonder if it's worth trying to factor this code too...)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>int32<br/></li>
<li><a id="L412">&#x200c;</a><span class="linkable">type_maximum_size</span>(Oid type_oid, int32 typemod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (typemod &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (type_oid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BPCHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VARCHAROID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* typemod includes varlena header */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* typemod is in characters not bytes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (typemod - VARHDRSZ) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_encoding_max_length(<a href="../mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + VARHDRSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> NUMERICOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="numeric.c.html#L944" title="utils/adt/numeric.c:944">numeric_maximum_size</a>(typemod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VARBITOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BITOID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* typemod is the (max) number of bits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (typemod + (BITS_PER_BYTE - <span class="Constant">1</span>)) / BITS_PER_BYTE<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + <span class="Constant">2</span> * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unknown type, or unlimited-width type such as 'text' */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L447" title="utils/adt/format_type.c:447">oidvectortypes</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - converts a vector of type OIDs to &quot;typname&quot; list<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L447">&#x200c;</a><span class="linkable">oidvectortypes</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; oidvector&nbsp; *oidArray = (oidvector *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numargs = oidArray-&gt;dim1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; total;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; left;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; total = <span class="Constant">20</span> * numargs + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(total);<br/></li>
<li>&nbsp; &nbsp; result[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; left = total - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (num = <span class="Constant">0</span>; num &lt; numargs; num++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *typename = <a href="#L112" title="utils/adt/format_type.c:112">format_type_extended</a>(oidArray-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[num], -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FORMAT_TYPE_ALLOW_INVALID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; slen = strlen(typename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (left &lt; (slen + <span class="Constant">2</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total += slen + <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(result, total);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left += slen + <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (num &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcat(result, <span class="Constant">&quot;, &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left -= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcat(result, typename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; left -= slen;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(result));<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
