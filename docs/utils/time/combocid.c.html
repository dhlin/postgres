<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/time/combocid.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/time/combocid.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L80">comboCids</a></li>
<li><a href="#L53">comboHash</a></li>
<li><a href="#L82">sizeComboCids</a></li>
<li><a href="#L81">usedComboCids</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L70">ComboCidEntry</a></li>
<li><a href="#L68">ComboCidEntryData</a></li>
<li><a href="#L62">ComboCidKey</a></li>
<li><a href="#L60">ComboCidKeyData</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L182">AtEOXact_ComboCid</a></li>
<li><a href="#L297">EstimateComboCIDStateSpace</a></li>
<li><a href="#L204">GetComboCommandId</a></li>
<li><a href="#L286">GetRealCmax</a></li>
<li><a href="#L279">GetRealCmin</a></li>
<li><a href="#L153">HeapTupleHeaderAdjustCmax</a></li>
<li><a href="#L118">HeapTupleHeaderGetCmax</a></li>
<li><a href="#L104">HeapTupleHeaderGetCmin</a></li>
<li><a href="#L342">RestoreComboCIDState</a></li>
<li><a href="#L316">SerializeComboCIDState</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L85">CCID_ARRAY_SIZE</a></li>
<li><a href="#L73">CCID_HASH_SIZE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * combocid.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Combo command ID support routines<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Before version 8.3, HeapTupleHeaderData had separate fields for cmin<br/></li>
<li></span><span class="Comment"> * and cmax.&nbsp; To reduce the header size, cmin and cmax are <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> overlaid<br/></li>
<li></span><span class="Comment"> * in the same field in the header.&nbsp; That usually works because you rarely<br/></li>
<li></span><span class="Comment"> * insert and delete a tuple in the same transaction, and we don't need<br/></li>
<li></span><span class="Comment"> * either field to remain valid after the originating transaction exits.<br/></li>
<li></span><span class="Comment"> * To make it work when the inserting transaction does delete the tuple,<br/></li>
<li></span><span class="Comment"> * we create a &quot;combo&quot; command ID and store that in the tuple header<br/></li>
<li></span><span class="Comment"> * instead of cmin and cmax. The combo command ID can be mapped to the<br/></li>
<li></span><span class="Comment"> * real cmin and cmax using a backend-private array, which is managed by<br/></li>
<li></span><span class="Comment"> * this module.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To allow reusing existing combo CIDs, we also keep a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table that<br/></li>
<li></span><span class="Comment"> * <a href="../mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> cmin,cmax pairs to combo CIDs.&nbsp; This keeps the data structure size<br/></li>
<li></span><span class="Comment"> * reasonable in most cases, since the number of unique pairs used by <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * one transaction is likely to be small.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * With a 32-<a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> combo command id we can represent 2^32 distinct cmin,cmax<br/></li>
<li></span><span class="Comment"> * combinations. In the most perverse case where each command deletes a tuple<br/></li>
<li></span><span class="Comment"> * generated by every previous command, the number of combo command ids<br/></li>
<li></span><span class="Comment"> * required for N commands is N*(N+1)/2.&nbsp; That means that in the worst case,<br/></li>
<li></span><span class="Comment"> * that's enough for 92682 commands.&nbsp; In practice, you'll run out of memory<br/></li>
<li></span><span class="Comment"> * and/or disk space way <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> you reach that limit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The array and <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table are kept in <a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>, and are<br/></li>
<li></span><span class="Comment"> * destroyed at the end of each transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/time/combocid.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/combocid.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/hsearch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Hash table to lookup combo CIDs by cmin and cmax */<br/></li>
<li><a id="L53">&#x200c;</a></span><span class="Type">static</span> <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">comboHash</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Key and entry structures for the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; CommandId&nbsp; &nbsp; cmin;<br/></li>
<li>&nbsp; &nbsp; CommandId&nbsp; &nbsp; cmax;<br/></li>
<li><a id="L60">&#x200c;</a>} <span class="linkable">ComboCidKeyData</span>;<br/></li>
<li><br/></li>
<li><a id="L62">&#x200c;</a><span class="Type">typedef</span> <a href="#L60" title="utils/time/combocid.c:60">ComboCidKeyData</a> *<span class="linkable">ComboCidKey</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L60" title="utils/time/combocid.c:60">ComboCidKeyData</a> key;<br/></li>
<li>&nbsp; &nbsp; CommandId&nbsp; &nbsp; combocid;<br/></li>
<li><a id="L68">&#x200c;</a>} <span class="linkable">ComboCidEntryData</span>;<br/></li>
<li><br/></li>
<li><a id="L70">&#x200c;</a><span class="Type">typedef</span> <a href="#L68" title="utils/time/combocid.c:68">ComboCidEntryData</a> *<span class="linkable">ComboCidEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Initial size of the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li><a id="L73">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CCID_HASH_SIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">100<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * An array of cmin,cmax pairs, indexed by combo command id.<br/></li>
<li></span><span class="Comment"> * To convert a combo CID to cmin and cmax, you do a simple array lookup.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L80">&#x200c;</a></span><span class="Type">static</span> <a href="#L62" title="utils/time/combocid.c:62">ComboCidKey</a> <span class="linkable">comboCids</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L81">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">usedComboCids</span> = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* number of elements in <a href="#L80" title="utils/time/combocid.c:80">comboCids</a> */<br/></li>
<li><a id="L82">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">sizeComboCids</span> = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* allocated size of array */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Initial size of the array */<br/></li>
<li><a id="L85">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CCID_ARRAY_SIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">100<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* prototypes for <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> CommandId <a href="#L204" title="utils/time/combocid.c:204">GetComboCommandId</a>(CommandId cmin, CommandId cmax);<br/></li>
<li><span class="Type">static</span> CommandId <a href="#L279" title="utils/time/combocid.c:279">GetRealCmin</a>(CommandId combocid);<br/></li>
<li><span class="Type">static</span> CommandId <a href="#L286" title="utils/time/combocid.c:286">GetRealCmax</a>(CommandId combocid);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/**** External API ****/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GetCmin and GetCmax assert that they are only called in situations where<br/></li>
<li></span><span class="Comment"> * they make sense, that is, can deliver a useful answer.&nbsp; If you have<br/></li>
<li></span><span class="Comment"> * reason to examine a tuple's t_cid field from a transaction other than<br/></li>
<li></span><span class="Comment"> * the originating one, use HeapTupleHeaderGetRawCommandId() directly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>CommandId<br/></li>
<li><a id="L104">&#x200c;</a><span class="linkable">HeapTupleHeaderGetCmin</span>(HeapTupleHeader tup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CommandId&nbsp; &nbsp; cid = HeapTupleHeaderGetRawCommandId(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!(tup-&gt;t_infomask &amp; HEAP_MOVED));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../access/transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>(HeapTupleHeaderGetXmin(tup)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tup-&gt;t_infomask &amp; HEAP_COMBOCID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L279" title="utils/time/combocid.c:279">GetRealCmin</a>(cid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>CommandId<br/></li>
<li><a id="L118">&#x200c;</a><span class="linkable">HeapTupleHeaderGetCmax</span>(HeapTupleHeader tup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CommandId&nbsp; &nbsp; cid = HeapTupleHeaderGetRawCommandId(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!(tup-&gt;t_infomask &amp; HEAP_MOVED));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because GetUpdateXid() performs memory allocations if xmax is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multixact we can't Assert() if we're inside a critical section. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * weakens the check, but not using GetCmax() inside one would complicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * things too much.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../init/globals.c.html#L43" title="utils/init/globals.c:43">CritSectionCount</a> &gt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../access/transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>(HeapTupleHeaderGetUpdateXid(tup)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tup-&gt;t_infomask &amp; HEAP_COMBOCID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L286" title="utils/time/combocid.c:286">GetRealCmax</a>(cid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a tuple we are about to delete, determine the correct value to store<br/></li>
<li></span><span class="Comment"> * into its t_cid field.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we don't need a combo CID, *cmax is unchanged and *iscombo is set to<br/></li>
<li></span><span class="Comment"> * false.&nbsp; If we do need one, *cmax is replaced by a combo CID and *iscombo<br/></li>
<li></span><span class="Comment"> * is set to true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The reason this is separate from the actual HeapTupleHeaderSetCmax()<br/></li>
<li></span><span class="Comment"> * operation is that this could fail due to out-of-memory conditions.&nbsp; Hence<br/></li>
<li></span><span class="Comment"> * we need to do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> entering the critical section that actually<br/></li>
<li></span><span class="Comment"> * changes the tuple in shared buffers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L153">&#x200c;</a></span><span class="linkable">HeapTupleHeaderAdjustCmax</span>(HeapTupleHeader tup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommandId *cmax,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *iscombo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're marking a tuple deleted that was inserted by (<a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtransaction of) our transaction, we need to use a combo command id.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Test for HeapTupleHeaderXminCommitted() first, because it's cheaper<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than a <a href="../../access/transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a> call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleHeaderXminCommitted(tup) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>(HeapTupleHeaderGetRawXmin(tup)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CommandId&nbsp; &nbsp; cmin = <a href="#L104" title="utils/time/combocid.c:104">HeapTupleHeaderGetCmin</a>(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *cmax = <a href="#L204" title="utils/time/combocid.c:204">GetComboCommandId</a>(cmin, *cmax);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *iscombo = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *iscombo = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Combo command ids are only interesting to the inserting and deleting<br/></li>
<li></span><span class="Comment"> * transaction, so we can forget about them at the end of transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L182">&#x200c;</a></span><span class="linkable">AtEOXact_ComboCid</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't bother to <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>. These are allocated in <a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they're going to go away at the end of transaction anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L53" title="utils/time/combocid.c:53">comboHash</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L80" title="utils/time/combocid.c:80">comboCids</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L81" title="utils/time/combocid.c:81">usedComboCids</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L82" title="utils/time/combocid.c:82">sizeComboCids</a> = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/**** Internal routines ****/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get a combo command id that <a href="../mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> to cmin and cmax.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We try to reuse old combo command ids when possible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> CommandId<br/></li>
<li><a id="L204">&#x200c;</a><span class="linkable">GetComboCommandId</span>(CommandId cmin, CommandId cmax)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CommandId&nbsp; &nbsp; combocid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L60" title="utils/time/combocid.c:60">ComboCidKeyData</a> key;<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="utils/time/combocid.c:70">ComboCidEntry</a> entry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table and array the first time we need to use combo<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cids in the transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L53" title="utils/time/combocid.c:53">comboHash</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make array first; existence of <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table asserts array exists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L80" title="utils/time/combocid.c:80">comboCids</a> = (<a href="#L60" title="utils/time/combocid.c:60">ComboCidKeyData</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L60" title="utils/time/combocid.c:60">ComboCidKeyData</a>) * <a href="#L85" title="utils/time/combocid.c:85">CCID_ARRAY_SIZE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L82" title="utils/time/combocid.c:82">sizeComboCids</a> = <a href="#L85" title="utils/time/combocid.c:85">CCID_ARRAY_SIZE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L81" title="utils/time/combocid.c:81">usedComboCids</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L60" title="utils/time/combocid.c:60">ComboCidKeyData</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L68" title="utils/time/combocid.c:68">ComboCidEntryData</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl.hcxt = <a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L53" title="utils/time/combocid.c:53">comboHash</a> = <a href="../hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Combo CIDs&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L73" title="utils/time/combocid.c:73">CCID_HASH_SIZE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Grow the array if there's not at least one free slot.&nbsp; We must do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> possibly entering a new hashtable entry, else failure to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a> would leave a corrupt hashtable entry behind.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L81" title="utils/time/combocid.c:81">usedComboCids</a> &gt;= <a href="#L82" title="utils/time/combocid.c:82">sizeComboCids</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newsize = <a href="#L82" title="utils/time/combocid.c:82">sizeComboCids</a> * <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L80" title="utils/time/combocid.c:80">comboCids</a> = (<a href="#L60" title="utils/time/combocid.c:60">ComboCidKeyData</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(<a href="#L80" title="utils/time/combocid.c:80">comboCids</a>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L60" title="utils/time/combocid.c:60">ComboCidKeyData</a>) * newsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L82" title="utils/time/combocid.c:82">sizeComboCids</a> = newsize;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lookup or create a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> entry with the desired cmin/cmax */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We assume there is no struct padding in <a href="#L60" title="utils/time/combocid.c:60">ComboCidKeyData</a>! */<br/></li>
<li></span>&nbsp; &nbsp; key.cmin = cmin;<br/></li>
<li>&nbsp; &nbsp; key.cmax = cmax;<br/></li>
<li>&nbsp; &nbsp; entry = (<a href="#L70" title="utils/time/combocid.c:70">ComboCidEntry</a>) <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L53" title="utils/time/combocid.c:53">comboHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reuse an existing combo CID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> entry-&gt;combocid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We have to create a new combo CID; we already made room in the array */<br/></li>
<li></span>&nbsp; &nbsp; combocid = <a href="#L81" title="utils/time/combocid.c:81">usedComboCids</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L80" title="utils/time/combocid.c:80">comboCids</a>[combocid].cmin = cmin;<br/></li>
<li>&nbsp; &nbsp; <a href="#L80" title="utils/time/combocid.c:80">comboCids</a>[combocid].cmax = cmax;<br/></li>
<li>&nbsp; &nbsp; <a href="#L81" title="utils/time/combocid.c:81">usedComboCids</a>++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry-&gt;combocid = combocid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> combocid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> CommandId<br/></li>
<li><a id="L279">&#x200c;</a><span class="linkable">GetRealCmin</span>(CommandId combocid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(combocid &lt; <a href="#L81" title="utils/time/combocid.c:81">usedComboCids</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L80" title="utils/time/combocid.c:80">comboCids</a>[combocid].cmin;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> CommandId<br/></li>
<li><a id="L286">&#x200c;</a><span class="linkable">GetRealCmax</span>(CommandId combocid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(combocid &lt; <a href="#L81" title="utils/time/combocid.c:81">usedComboCids</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L80" title="utils/time/combocid.c:80">comboCids</a>[combocid].cmax;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimate the amount of space required to serialize the current combo CID<br/></li>
<li></span><span class="Comment"> * state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L297">&#x200c;</a><span class="linkable">EstimateComboCIDStateSpace</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add space required for saving <a href="#L81" title="utils/time/combocid.c:81">usedComboCids</a> */<br/></li>
<li></span>&nbsp; &nbsp; size = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add space required for saving <a href="#L60" title="utils/time/combocid.c:60">ComboCidKeyData</a> */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L60" title="utils/time/combocid.c:60">ComboCidKeyData</a>), <a href="#L81" title="utils/time/combocid.c:81">usedComboCids</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Serialize the combo CID state into the memory, beginning at start_address.<br/></li>
<li></span><span class="Comment"> * maxsize should be at least as large as the value returned by<br/></li>
<li></span><span class="Comment"> * <a href="#L297" title="utils/time/combocid.c:297">EstimateComboCIDStateSpace</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L316">&#x200c;</a></span><span class="linkable">SerializeComboCIDState</span>(Size maxsize, <span class="Type">char</span> *start_address)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First, we store the number of currently-existing combo CIDs. */<br/></li>
<li></span>&nbsp; &nbsp; *(<span class="Type">int</span> *) start_address = <a href="#L81" title="utils/time/combocid.c:81">usedComboCids</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If maxsize is too small, throw an error. */<br/></li>
<li></span>&nbsp; &nbsp; endptr = start_address + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L60" title="utils/time/combocid.c:60">ComboCidKeyData</a>) * <a href="#L81" title="utils/time/combocid.c:81">usedComboCids</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (endptr &lt; start_address || endptr &gt; start_address + maxsize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;not enough space to serialize ComboCID state&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now, copy the actual cmin/cmax pairs. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L81" title="utils/time/combocid.c:81">usedComboCids</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(start_address + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>), <a href="#L80" title="utils/time/combocid.c:80">comboCids</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L60" title="utils/time/combocid.c:60">ComboCidKeyData</a>) * <a href="#L81" title="utils/time/combocid.c:81">usedComboCids</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read the combo CID state at the specified address and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> this<br/></li>
<li></span><span class="Comment"> * backend with the same combo CIDs.&nbsp; This is only valid in a backend that<br/></li>
<li></span><span class="Comment"> * currently has no combo CIDs (and only makes sense if the transaction state<br/></li>
<li></span><span class="Comment"> * is serialized and restored as well).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L342">&#x200c;</a></span><span class="linkable">RestoreComboCIDState</span>(<span class="Type">char</span> *comboCIDstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_elements;<br/></li>
<li>&nbsp; &nbsp; <a href="#L60" title="utils/time/combocid.c:60">ComboCidKeyData</a> *keydata;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; CommandId&nbsp; &nbsp; cid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L80" title="utils/time/combocid.c:80">comboCids</a> &amp;&amp; !<a href="#L53" title="utils/time/combocid.c:53">comboHash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First, we retrieve the number of combo CIDs that were serialized. */<br/></li>
<li></span>&nbsp; &nbsp; num_elements = *(<span class="Type">int</span> *) comboCIDstate;<br/></li>
<li>&nbsp; &nbsp; keydata = (<a href="#L60" title="utils/time/combocid.c:60">ComboCidKeyData</a> *) (comboCIDstate + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use <a href="#L204" title="utils/time/combocid.c:204">GetComboCommandId</a> to restore each combo CID. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_elements; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cid = <a href="#L204" title="utils/time/combocid.c:204">GetComboCommandId</a>(keydata[i].cmin, keydata[i].cmax);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Verify that we got the expected answer. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cid != i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected command ID while restoring combo CIDs&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
