<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/time/snapmgr.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/time/snapmgr.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L120">ActiveSnapshot</a></li>
<li><a href="#L90">CatalogSnapshot</a></li>
<li><a href="#L83">CatalogSnapshotData</a></li>
<li><a href="#L88">CurrentSnapshot</a></li>
<li><a href="#L81">CurrentSnapshotData</a></li>
<li><a href="#L135">FirstSnapshotSet</a></li>
<li><a href="#L142">FirstXactSnapshot</a></li>
<li><a href="#L91">HistoricSnapshot</a></li>
<li><a href="#L123">OldestActiveSnapshot</a></li>
<li><a href="#L99">RecentXmin</a></li>
<li><a href="#L132">RegisteredSnapshots</a></li>
<li><a href="#L89">SecondarySnapshot</a></li>
<li><a href="#L82">SecondarySnapshotData</a></li>
<li><a href="#L85">SnapshotAnyData</a></li>
<li><a href="#L84">SnapshotSelfData</a></li>
<li><a href="#L98">TransactionXmin</a></li>
<li><a href="#L155">exportedSnapshots</a></li>
<li><a href="#L166">snapshot_resowner_desc</a></li>
<li><a href="#L102">tuplecid_data</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L112">ActiveSnapshotElt</a></li>
<li><a href="#L117">ActiveSnapshotElt</a></li>
<li><a href="#L148">ExportedSnapshot</a></li>
<li><a href="#L152">ExportedSnapshot</a></li>
<li><a href="#L193">SerializedSnapshotData</a></li>
<li><a href="#L204">SerializedSnapshotData</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L782">ActiveSnapshotSet</a></li>
<li><a href="#L995">AtEOXact_Snapshot</a></li>
<li><a href="#L959">AtSubAbort_Snapshot</a></li>
<li><a href="#L938">AtSubCommit_Snapshot</a></li>
<li><a href="#L574">CopySnapshot</a></li>
<li><a href="#L1567">DeleteAllExportedSnapshotFiles</a></li>
<li><a href="#L1692">EstimateSnapshotSpace</a></li>
<li><a href="#L1095">ExportSnapshot</a></li>
<li><a href="#L630">FreeSnapshot</a></li>
<li><a href="#L770">GetActiveSnapshot</a></li>
<li><a href="#L352">GetCatalogSnapshot</a></li>
<li><a href="#L291">GetLatestSnapshot</a></li>
<li><a href="#L374">GetNonHistoricCatalogSnapshot</a></li>
<li><a href="#L323">GetOldestSnapshot</a></li>
<li><a href="#L216">GetTransactionSnapshot</a></li>
<li><a href="#L1624">HaveRegisteredOrActiveSnapshot</a></li>
<li><a href="#L1672">HistoricSnapshotActive</a></li>
<li><a href="#L1678">HistoricSnapshotGetTupleCids</a></li>
<li><a href="#L1367">ImportSnapshot</a></li>
<li><a href="#L422">InvalidateCatalogSnapshot</a></li>
<li><a href="#L443">InvalidateCatalogSnapshotConditionally</a></li>
<li><a href="#L743">PopActiveSnapshot</a></li>
<li><a href="#L648">PushActiveSnapshot</a></li>
<li><a href="#L662">PushActiveSnapshotWithLevel</a></li>
<li><a href="#L700">PushCopiedSnapshot</a></li>
<li><a href="#L794">RegisterSnapshot</a></li>
<li><a href="#L807">RegisterSnapshotOnOwner</a></li>
<li><a href="#L1955">ResOwnerReleaseSnapshot</a></li>
<li><a href="#L182">ResourceOwnerForgetSnapshot</a></li>
<li><a href="#L177">ResourceOwnerRememberSnapshot</a></li>
<li><a href="#L1775">RestoreSnapshot</a></li>
<li><a href="#L1840">RestoreTransactionSnapshot</a></li>
<li><a href="#L1716">SerializeSnapshot</a></li>
<li><a href="#L477">SetTransactionSnapshot</a></li>
<li><a href="#L1649">SetupHistoricSnapshot</a></li>
<li><a href="#L914">SnapshotResetXmin</a></li>
<li><a href="#L456">SnapshotSetCommandId</a></li>
<li><a href="#L1665">TeardownHistoricSnapshot</a></li>
<li><a href="#L1606">ThereAreNoPriorRegisteredSnapshots</a></li>
<li><a href="#L836">UnregisterSnapshot</a></li>
<li><a href="#L849">UnregisterSnapshotFromOwner</a></li>
<li><a href="#L859">UnregisterSnapshotNoOwner</a></li>
<li><a href="#L712">UpdateActiveSnapshotCommandId</a></li>
<li><a href="#L1554">XactHasExportedSnapshots</a></li>
<li><a href="#L1856">XidInMVCCSnapshot</a></li>
<li><a href="#L1287">parseIntFromText</a></li>
<li><a href="#L1337">parseVxidFromText</a></li>
<li><a href="#L1312">parseXidFromText</a></li>
<li><a href="#L1272">pg_export_snapshot</a></li>
<li><a href="#L880">xmin_cmp</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L145">SNAPSHOT_EXPORT_DIR</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * snapmgr.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PostgreSQL snapshot manager<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We keep track of snapshots in two ways: those &quot;registered&quot; by resowner.c,<br/></li>
<li></span><span class="Comment"> * and the &quot;active snapshot&quot; stack.&nbsp; All snapshots in either of them live in<br/></li>
<li></span><span class="Comment"> * persistent memory.&nbsp; When a snapshot is no longer in <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of these lists<br/></li>
<li></span><span class="Comment"> * (tracked by separate refcounts on each snapshot), its memory can be freed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="#L142" title="utils/time/snapmgr.c:142">FirstXactSnapshot</a>, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, is treated a <a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> specially: we increment its<br/></li>
<li></span><span class="Comment"> * regd_count and list it in <a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>, but this reference is not<br/></li>
<li></span><span class="Comment"> * tracked by a resource owner. We used to use the <a href="../resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a><br/></li>
<li></span><span class="Comment"> * to track this snapshot reference, but that introduces logical circularity<br/></li>
<li></span><span class="Comment"> * and thus makes it impossible to clean up in a sane fashion.&nbsp; It's better to<br/></li>
<li></span><span class="Comment"> * handle this reference as an internally-tracked registration, so that this<br/></li>
<li></span><span class="Comment"> * module is entirely <a href="../adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level than ResourceOwners.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Likewise, <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> snapshots that have been exported by <a href="#L1272" title="utils/time/snapmgr.c:1272">pg_export_snapshot</a><br/></li>
<li></span><span class="Comment"> * have regd_count = 1 and are listed in <a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>, but are not<br/></li>
<li></span><span class="Comment"> * tracked by <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> resource owner.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Likewise, the <a href="#L90" title="utils/time/snapmgr.c:90">CatalogSnapshot</a> is listed in <a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a> when it<br/></li>
<li></span><span class="Comment"> * is valid, but is not tracked by <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> resource owner.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The same is true for historic snapshots used during logical decoding,<br/></li>
<li></span><span class="Comment"> * their lifetime is managed separately (as they live longer than one xact.c<br/></li>
<li></span><span class="Comment"> * transaction).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These arrangements let us reset <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin when there are no snapshots<br/></li>
<li></span><span class="Comment"> * referenced by this transaction, and advance it when the one with oldest<br/></li>
<li></span><span class="Comment"> * Xmin is no longer referenced.&nbsp; For simplicity however, only registered<br/></li>
<li></span><span class="Comment"> * snapshots not active snapshots participate in tracking which one is oldest;<br/></li>
<li></span><span class="Comment"> * we don't try to change <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin except when the active-snapshot<br/></li>
<li></span><span class="Comment"> * stack is empty.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/time/snapmgr.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/subtrans.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;datatype/timestamp.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/pairingheap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_lfind.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/resowner.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a> points to the only snapshot taken in transaction-snapshot<br/></li>
<li></span><span class="Comment"> * mode, and to the latest one taken in a read-committed transaction.<br/></li>
<li></span><span class="Comment"> * <a href="#L89" title="utils/time/snapmgr.c:89">SecondarySnapshot</a> is a snapshot that's always up-to-date as of the current<br/></li>
<li></span><span class="Comment"> * instant, even in transaction-snapshot mode.&nbsp; It should only be used for<br/></li>
<li></span><span class="Comment"> * special-purpose code (say, RI checking.)&nbsp; <a href="#L90" title="utils/time/snapmgr.c:90">CatalogSnapshot</a> points to an<br/></li>
<li></span><span class="Comment"> * MVCC snapshot intended to be used for catalog scans; we must invalidate it<br/></li>
<li></span><span class="Comment"> * whenever a system catalog change occurs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These SnapshotData structs are static to simplify memory allocation<br/></li>
<li></span><span class="Comment"> * (see the hack in <a href="../../storage/ipc/procarray.c.html#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a> to avoid repeated malloc/free).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L81">&#x200c;</a></span><span class="Type">static</span> SnapshotData <span class="linkable">CurrentSnapshotData</span> = {SNAPSHOT_MVCC};<br/></li>
<li><a id="L82">&#x200c;</a><span class="Type">static</span> SnapshotData <span class="linkable">SecondarySnapshotData</span> = {SNAPSHOT_MVCC};<br/></li>
<li><a id="L83">&#x200c;</a>SnapshotData <span class="linkable">CatalogSnapshotData</span> = {SNAPSHOT_MVCC};<br/></li>
<li><a id="L84">&#x200c;</a>SnapshotData <span class="linkable">SnapshotSelfData</span> = {SNAPSHOT_SELF};<br/></li>
<li><a id="L85">&#x200c;</a>SnapshotData <span class="linkable">SnapshotAnyData</span> = {SNAPSHOT_ANY};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Pointers to valid snapshots */<br/></li>
<li><a id="L88">&#x200c;</a></span><span class="Type">static</span> Snapshot <span class="linkable">CurrentSnapshot</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L89">&#x200c;</a><span class="Type">static</span> Snapshot <span class="linkable">SecondarySnapshot</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L90">&#x200c;</a><span class="Type">static</span> Snapshot <span class="linkable">CatalogSnapshot</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L91">&#x200c;</a><span class="Type">static</span> Snapshot <span class="linkable">HistoricSnapshot</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These are updated by <a href="../../storage/ipc/procarray.c.html#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>.&nbsp; We <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> them this way<br/></li>
<li></span><span class="Comment"> * for the convenience of <a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a>: even in bootstrap<br/></li>
<li></span><span class="Comment"> * mode, we don't want it to say that BootstrapTransactionId is in progress.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L98">&#x200c;</a></span>TransactionId <span class="linkable">TransactionXmin</span> = FirstNormalTransactionId;<br/></li>
<li><a id="L99">&#x200c;</a>TransactionId <span class="linkable">RecentXmin</span> = FirstNormalTransactionId;<br/></li>
<li><br/></li>
<li><span class="Comment">/* (table, ctid) =&gt; (cmin, cmax) mapping during timetravel */<br/></li>
<li><a id="L102">&#x200c;</a></span><span class="Type">static</span> <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">tuplecid_data</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Elements of the active snapshot stack.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Each <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> here accounts for exactly one active_count on SnapshotData.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: the code assumes that elements in this list are in non-increasing<br/></li>
<li></span><span class="Comment"> * order of as_level; also, the list must be NULL-terminated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L112">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ActiveSnapshotElt</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; as_snap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; as_level;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L112" title="utils/time/snapmgr.c:112">ActiveSnapshotElt</a> *as_next;<br/></li>
<li><a id="L117">&#x200c;</a>} <span class="linkable">ActiveSnapshotElt</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Top of the stack of active snapshots */<br/></li>
<li><a id="L120">&#x200c;</a></span><span class="Type">static</span> <a href="#L112" title="utils/time/snapmgr.c:112">ActiveSnapshotElt</a> *<span class="linkable">ActiveSnapshot</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Bottom of the stack of active snapshots */<br/></li>
<li><a id="L123">&#x200c;</a></span><span class="Type">static</span> <a href="#L112" title="utils/time/snapmgr.c:112">ActiveSnapshotElt</a> *<span class="linkable">OldestActiveSnapshot</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Currently registered Snapshots.&nbsp; Ordered in a heap by xmin, so that we can<br/></li>
<li></span><span class="Comment"> * quickly <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the one with lowest xmin, to advance our <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L880" title="utils/time/snapmgr.c:880">xmin_cmp</a>(<span class="Type">const</span> pairingheap_node *a, <span class="Type">const</span> pairingheap_node *b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *arg);<br/></li>
<li><br/></li>
<li><a id="L132">&#x200c;</a><span class="Type">static</span> pairingheap <span class="linkable">RegisteredSnapshots</span> = {&amp;<a href="#L880" title="utils/time/snapmgr.c:880">xmin_cmp</a>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* first <a href="#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a> call in a transaction? */<br/></li>
<li><a id="L135">&#x200c;</a></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">FirstSnapshotSet</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remember the serializable transaction snapshot, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; We cannot trust<br/></li>
<li></span><span class="Comment"> * <a href="#L135" title="utils/time/snapmgr.c:135">FirstSnapshotSet</a> in combination with IsolationUsesXactSnapshot(), because<br/></li>
<li></span><span class="Comment"> * GUC may be reset <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> us, changing the value of IsolationUsesXactSnapshot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L142">&#x200c;</a></span><span class="Type">static</span> Snapshot <span class="linkable">FirstXactSnapshot</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Define pathname of exported-snapshot files */<br/></li>
<li><a id="L145">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SNAPSHOT_EXPORT_DIR</span> </span><span class="Constant">&quot;pg_snapshots&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Structure holding info about exported snapshot. */<br/></li>
<li><a id="L148">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ExportedSnapshot</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *snapfile;<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot;<br/></li>
<li><a id="L152">&#x200c;</a>} <span class="linkable">ExportedSnapshot</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Current xact's exported snapshots (a list of <a href="#L148" title="utils/time/snapmgr.c:148">ExportedSnapshot</a> structs) */<br/></li>
<li><a id="L155">&#x200c;</a></span><span class="Type">static</span> List *<span class="linkable">exportedSnapshots</span> = NIL;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Prototypes for local <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> Snapshot <a href="#L574" title="utils/time/snapmgr.c:574">CopySnapshot</a>(Snapshot snapshot);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L859" title="utils/time/snapmgr.c:859">UnregisterSnapshotNoOwner</a>(Snapshot snapshot);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L630" title="utils/time/snapmgr.c:630">FreeSnapshot</a>(Snapshot snapshot);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L914" title="utils/time/snapmgr.c:914">SnapshotResetXmin</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Comment">/* ResourceOwner callbacks to track snapshot references */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1955" title="utils/time/snapmgr.c:1955">ResOwnerReleaseSnapshot</a>(Datum res);<br/></li>
<li><br/></li>
<li><a id="L166">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> ResourceOwnerDesc <span class="linkable">snapshot_resowner_desc</span> =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; .name = <span class="Constant">&quot;snapshot reference&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; .release_phase = RESOURCE_RELEASE_AFTER_LOCKS,<br/></li>
<li>&nbsp; &nbsp; .release_priority = RELEASE_PRIO_SNAPSHOT_REFS,<br/></li>
<li>&nbsp; &nbsp; .ReleaseResource = <a href="#L1955" title="utils/time/snapmgr.c:1955">ResOwnerReleaseSnapshot</a>,<br/></li>
<li>&nbsp; &nbsp; .DebugPrint = <span class="Constant">NULL</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the default message is fine */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Convenience wrappers over <a href="../resowner/resowner.c.html#L514" title="utils/resowner/resowner.c:514">ResourceOwnerRemember</a>/Forget */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L177">&#x200c;</a></span><span class="linkable">ResourceOwnerRememberSnapshot</span>(ResourceOwner owner, Snapshot snap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../resowner/resowner.c.html#L514" title="utils/resowner/resowner.c:514">ResourceOwnerRemember</a>(owner, PointerGetDatum(snap), &amp;<a href="#L166" title="utils/time/snapmgr.c:166">snapshot_resowner_desc</a>);<br/></li>
<li>}<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L182">&#x200c;</a></span><span class="linkable">ResourceOwnerForgetSnapshot</span>(ResourceOwner owner, Snapshot snap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../resowner/resowner.c.html#L554" title="utils/resowner/resowner.c:554">ResourceOwnerForget</a>(owner, PointerGetDatum(snap), &amp;<a href="#L166" title="utils/time/snapmgr.c:166">snapshot_resowner_desc</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Snapshot fields to be serialized.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Only these fields need to be sent to the cooperating backend; the<br/></li>
<li></span><span class="Comment"> * remaining ones can (and must) be set by the receiver upon restore.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L193">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SerializedSnapshotData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xmin;<br/></li>
<li>&nbsp; &nbsp; TransactionId xmax;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; xcnt;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; subxcnt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; suboverflowed;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; takenDuringRecovery;<br/></li>
<li>&nbsp; &nbsp; CommandId&nbsp; &nbsp; curcid;<br/></li>
<li>&nbsp; &nbsp; TimestampTz whenTaken;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn;<br/></li>
<li><a id="L204">&#x200c;</a>} <span class="linkable">SerializedSnapshotData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the appropriate snapshot for a new query in a transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the return value may point at static storage that will be modified<br/></li>
<li></span><span class="Comment"> * by future calls and by <a href="../../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>().&nbsp; Callers should call<br/></li>
<li></span><span class="Comment"> * <a href="#L794" title="utils/time/snapmgr.c:794">RegisterSnapshot</a> or <a href="#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a> on the returned snap if it is to be<br/></li>
<li></span><span class="Comment"> * used very long.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Snapshot<br/></li>
<li><a id="L216">&#x200c;</a><span class="linkable">GetTransactionSnapshot</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return historic snapshot if doing logical decoding. We'll never need a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-historic transaction snapshot in this (sub-)transaction, so there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no need to be careful to set one up for later calls to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1672" title="utils/time/snapmgr.c:1672">HistoricSnapshotActive</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="#L135" title="utils/time/snapmgr.c:135">FirstSnapshotSet</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L91" title="utils/time/snapmgr.c:91">HistoricSnapshot</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First call in transaction? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L135" title="utils/time/snapmgr.c:135">FirstSnapshotSet</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't allow catalog snapshot to be older than xact snapshot.&nbsp; Must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do this first to allow the empty-heap Assert to succeed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L422" title="utils/time/snapmgr.c:422">InvalidateCatalogSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(pairingheap_is_empty(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L142" title="utils/time/snapmgr.c:142">FirstXactSnapshot</a> == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;cannot take query snapshot during a parallel operation&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In transaction-snapshot mode, the first snapshot must live until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end of xact regardless of what the caller does with it, so we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make a copy of it rather than returning <a href="#L81" title="utils/time/snapmgr.c:81">CurrentSnapshotData</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * directly.&nbsp; Furthermore, if we're running in serializable mode,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * predicate.c needs to wrap the snapshot fetch in its own processing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsolationUsesXactSnapshot())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First, create the snapshot in <a href="#L81" title="utils/time/snapmgr.c:81">CurrentSnapshotData</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsolationIsSerializable())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a> = <a href="../../storage/lmgr/predicate.c.html#L1667" title="storage/lmgr/predicate.c:1667">GetSerializableTransactionSnapshot</a>(&amp;<a href="#L81" title="utils/time/snapmgr.c:81">CurrentSnapshotData</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a> = <a href="../../storage/ipc/procarray.c.html#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>(&amp;<a href="#L81" title="utils/time/snapmgr.c:81">CurrentSnapshotData</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make a saved copy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a> = <a href="#L574" title="utils/time/snapmgr.c:574">CopySnapshot</a>(<a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L142" title="utils/time/snapmgr.c:142">FirstXactSnapshot</a> = <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark it as &quot;registered&quot; in <a href="#L142" title="utils/time/snapmgr.c:142">FirstXactSnapshot</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L142" title="utils/time/snapmgr.c:142">FirstXactSnapshot</a>-&gt;regd_count++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/pairingheap.c.html#L112" title="lib/pairingheap.c:112">pairingheap_add</a>(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>, &amp;<a href="#L142" title="utils/time/snapmgr.c:142">FirstXactSnapshot</a>-&gt;ph_node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a> = <a href="../../storage/ipc/procarray.c.html#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>(&amp;<a href="#L81" title="utils/time/snapmgr.c:81">CurrentSnapshotData</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="utils/time/snapmgr.c:135">FirstSnapshotSet</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsolationUsesXactSnapshot())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't allow catalog snapshot to be older than xact snapshot. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L422" title="utils/time/snapmgr.c:422">InvalidateCatalogSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a> = <a href="../../storage/ipc/procarray.c.html#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>(&amp;<a href="#L81" title="utils/time/snapmgr.c:81">CurrentSnapshotData</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L291" title="utils/time/snapmgr.c:291">GetLatestSnapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get a snapshot that is up-to-date as of the current instant,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; even if we are executing in transaction-snapshot mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Snapshot<br/></li>
<li><a id="L291">&#x200c;</a><span class="linkable">GetLatestSnapshot</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We might be able to relax this, but nothing that could otherwise work<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needs it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;cannot update <a href="#L89" title="utils/time/snapmgr.c:89">SecondarySnapshot</a> during a parallel operation&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * So far there are no cases requiring support for <a href="#L291" title="utils/time/snapmgr.c:291">GetLatestSnapshot</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during logical decoding, but it wouldn't be hard to add if required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="#L1672" title="utils/time/snapmgr.c:1672">HistoricSnapshotActive</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If first call in transaction, go ahead and set the xact snapshot */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L135" title="utils/time/snapmgr.c:135">FirstSnapshotSet</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="utils/time/snapmgr.c:89">SecondarySnapshot</a> = <a href="../../storage/ipc/procarray.c.html#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>(&amp;<a href="#L82" title="utils/time/snapmgr.c:82">SecondarySnapshotData</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L89" title="utils/time/snapmgr.c:89">SecondarySnapshot</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L323" title="utils/time/snapmgr.c:323">GetOldestSnapshot</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the transaction's oldest known snapshot, as judged by the LSN.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Will return NULL if there are no active or registered snapshots.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Snapshot<br/></li>
<li><a id="L323">&#x200c;</a><span class="linkable">GetOldestSnapshot</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; OldestRegisteredSnapshot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; RegisteredLSN = InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!pairingheap_is_empty(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OldestRegisteredSnapshot = pairingheap_container(SnapshotData, ph_node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../lib/pairingheap.c.html#L130" title="lib/pairingheap.c:130">pairingheap_first</a>(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RegisteredLSN = OldestRegisteredSnapshot-&gt;lsn;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L123" title="utils/time/snapmgr.c:123">OldestActiveSnapshot</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; ActiveLSN = <a href="#L123" title="utils/time/snapmgr.c:123">OldestActiveSnapshot</a>-&gt;as_snap-&gt;lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(RegisteredLSN) || RegisteredLSN &gt; ActiveLSN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L123" title="utils/time/snapmgr.c:123">OldestActiveSnapshot</a>-&gt;as_snap;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> OldestRegisteredSnapshot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L352" title="utils/time/snapmgr.c:352">GetCatalogSnapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get a snapshot that is sufficiently up-to-date for scan of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; system catalog with the specified OID.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Snapshot<br/></li>
<li><a id="L352">&#x200c;</a><span class="linkable">GetCatalogSnapshot</span>(Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return historic snapshot while we're doing logical decoding, so we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * see the appropriate state of the catalog.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is the primary reason for needing to reset the system caches after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * finishing decoding.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1672" title="utils/time/snapmgr.c:1672">HistoricSnapshotActive</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L91" title="utils/time/snapmgr.c:91">HistoricSnapshot</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L374" title="utils/time/snapmgr.c:374">GetNonHistoricCatalogSnapshot</a>(relid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L374" title="utils/time/snapmgr.c:374">GetNonHistoricCatalogSnapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get a snapshot that is sufficiently up-to-date for scan of the system<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; catalog with the specified OID, even while historic snapshots are set<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; up.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Snapshot<br/></li>
<li><a id="L374">&#x200c;</a><span class="linkable">GetNonHistoricCatalogSnapshot</span>(Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the caller is trying to scan a relation that has no syscache, no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catcache invalidations will be sent when it is updated.&nbsp; For a few key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relations, snapshot invalidations are sent instead.&nbsp; If we're trying to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan a relation for which neither catcache nor snapshot invalidations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are sent, we must refresh the snapshot every time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L90" title="utils/time/snapmgr.c:90">CatalogSnapshot</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../cache/syscache.c.html#L601" title="utils/cache/syscache.c:601">RelationInvalidatesSnapshotsOnly</a>(relid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../cache/syscache.c.html#L624" title="utils/cache/syscache.c:624">RelationHasSysCache</a>(relid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L422" title="utils/time/snapmgr.c:422">InvalidateCatalogSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L90" title="utils/time/snapmgr.c:90">CatalogSnapshot</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get new snapshot. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L90" title="utils/time/snapmgr.c:90">CatalogSnapshot</a> = <a href="../../storage/ipc/procarray.c.html#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>(&amp;<a href="#L83" title="utils/time/snapmgr.c:83">CatalogSnapshotData</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure the catalog snapshot will be accounted for in decisions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about advancing PGPROC-&gt;xmin.&nbsp; We could apply <a href="#L794" title="utils/time/snapmgr.c:794">RegisterSnapshot</a>, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that would result in making a physical copy, which is overkill; and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it would also create a dependency on some resource owner, which we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do not want for reasons explained at the head of this file. Instead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just shove the <a href="#L90" title="utils/time/snapmgr.c:90">CatalogSnapshot</a> into the pairing heap manually. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has to be reversed in <a href="#L422" title="utils/time/snapmgr.c:422">InvalidateCatalogSnapshot</a>, of course.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB: it had better be impossible for this to throw error, since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L90" title="utils/time/snapmgr.c:90">CatalogSnapshot</a> pointer is already valid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/pairingheap.c.html#L112" title="lib/pairingheap.c:112">pairingheap_add</a>(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>, &amp;<a href="#L90" title="utils/time/snapmgr.c:90">CatalogSnapshot</a>-&gt;ph_node);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L90" title="utils/time/snapmgr.c:90">CatalogSnapshot</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L422" title="utils/time/snapmgr.c:422">InvalidateCatalogSnapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Mark the current catalog snapshot, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, as invalid<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We could change this API to allow the caller to provide more fine-grained<br/></li>
<li></span><span class="Comment"> * invalidation details, so that a change to relation A wouldn't prevent us<br/></li>
<li></span><span class="Comment"> * from using our cached snapshot to scan relation B, but so far there's no<br/></li>
<li></span><span class="Comment"> * evidence that the CPU cycles we spent tracking such fine details would be<br/></li>
<li></span><span class="Comment"> * well-spent.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L422">&#x200c;</a></span><span class="linkable">InvalidateCatalogSnapshot</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L90" title="utils/time/snapmgr.c:90">CatalogSnapshot</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/pairingheap.c.html#L170" title="lib/pairingheap.c:170">pairingheap_remove</a>(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>, &amp;<a href="#L90" title="utils/time/snapmgr.c:90">CatalogSnapshot</a>-&gt;ph_node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L90" title="utils/time/snapmgr.c:90">CatalogSnapshot</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L914" title="utils/time/snapmgr.c:914">SnapshotResetXmin</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L443" title="utils/time/snapmgr.c:443">InvalidateCatalogSnapshotConditionally</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Drop catalog snapshot if it's the only one we have<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called when we are about to wait for client input, so we don't<br/></li>
<li></span><span class="Comment"> * want to continue holding the catalog snapshot if it might mean that the<br/></li>
<li></span><span class="Comment"> * global xmin horizon can't advance.&nbsp; However, if there are other snapshots<br/></li>
<li></span><span class="Comment"> * still active or registered, the catalog snapshot isn't likely to be the<br/></li>
<li></span><span class="Comment"> * oldest one, so we might as well keep it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L443">&#x200c;</a></span><span class="linkable">InvalidateCatalogSnapshotConditionally</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L90" title="utils/time/snapmgr.c:90">CatalogSnapshot</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a> == <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pairingheap_is_singular(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L422" title="utils/time/snapmgr.c:422">InvalidateCatalogSnapshot</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L456" title="utils/time/snapmgr.c:456">SnapshotSetCommandId</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Propagate <a href="../../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a> into the static snapshots, if set<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L456">&#x200c;</a></span><span class="linkable">SnapshotSetCommandId</span>(CommandId curcid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L135" title="utils/time/snapmgr.c:135">FirstSnapshotSet</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>-&gt;curcid = curcid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L89" title="utils/time/snapmgr.c:89">SecondarySnapshot</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L89" title="utils/time/snapmgr.c:89">SecondarySnapshot</a>-&gt;curcid = curcid;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should we do the same with <a href="#L90" title="utils/time/snapmgr.c:90">CatalogSnapshot</a>? */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L477" title="utils/time/snapmgr.c:477">SetTransactionSnapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set the transaction's snapshot from an imported MVCC snapshot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this is very closely tied to <a href="#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a> --- it<br/></li>
<li></span><span class="Comment"> * must take care of all the same considerations as the first-snapshot case<br/></li>
<li></span><span class="Comment"> * in <a href="#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L477">&#x200c;</a></span><span class="linkable">SetTransactionSnapshot</span>(Snapshot sourcesnap, VirtualTransactionId *sourcevxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> sourcepid, PGPROC *sourceproc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Caller should have checked this already */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="#L135" title="utils/time/snapmgr.c:135">FirstSnapshotSet</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Better do this to ensure following Assert succeeds. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L422" title="utils/time/snapmgr.c:422">InvalidateCatalogSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(pairingheap_is_empty(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L142" title="utils/time/snapmgr.c:142">FirstXactSnapshot</a> == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L1672" title="utils/time/snapmgr.c:1672">HistoricSnapshotActive</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even though we are not going to use the snapshot it computes, we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * call <a href="../../storage/ipc/procarray.c.html#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>, for two reasons: (1) to be sure that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L81" title="utils/time/snapmgr.c:81">CurrentSnapshotData</a>'s XID arrays have been allocated, and (2) to update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the state for GlobalVis*.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a> = <a href="../../storage/ipc/procarray.c.html#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a>(&amp;<a href="#L81" title="utils/time/snapmgr.c:81">CurrentSnapshotData</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now copy appropriate fields from the source snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>-&gt;xmin = sourcesnap-&gt;xmin;<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>-&gt;xmax = sourcesnap-&gt;xmax;<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>-&gt;xcnt = sourcesnap-&gt;xcnt;<br/></li>
<li>&nbsp; &nbsp; Assert(sourcesnap-&gt;xcnt &lt;= <a href="../../storage/ipc/procarray.c.html#L2057" title="storage/ipc/procarray.c:2057">GetMaxSnapshotXidCount</a>());<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sourcesnap-&gt;xcnt &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(<a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>-&gt;xip, sourcesnap-&gt;xip,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sourcesnap-&gt;xcnt * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>-&gt;subxcnt = sourcesnap-&gt;subxcnt;<br/></li>
<li>&nbsp; &nbsp; Assert(sourcesnap-&gt;subxcnt &lt;= <a href="../../storage/ipc/procarray.c.html#L2068" title="storage/ipc/procarray.c:2068">GetMaxSnapshotSubxidCount</a>());<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sourcesnap-&gt;subxcnt &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(<a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>-&gt;subxip, sourcesnap-&gt;subxip,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sourcesnap-&gt;subxcnt * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>-&gt;suboverflowed = sourcesnap-&gt;suboverflowed;<br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>-&gt;takenDuringRecovery = sourcesnap-&gt;takenDuringRecovery;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NB: curcid should NOT be copied, it's a local matter */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>-&gt;snapXactCompletionCount = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we have to fix what <a href="../../storage/ipc/procarray.c.html#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a> did with <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>.&nbsp; There is a race condition: to make sure we are not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * causing the global xmin to go backwards, we have to test that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * source transaction is still running, and that has to be done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * atomically. So let procarray.c do it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: in serializable mode, predicate.c will do this a second time. It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't seem worth contorting the logic here to avoid two calls,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * especially since it's not clear that predicate.c *must* do this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sourceproc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/ipc/procarray.c.html#L2608" title="storage/ipc/procarray.c:2608">ProcArrayInstallRestoredXmin</a>(<a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>-&gt;xmin, sourceproc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not import the requested snapshot&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The source transaction is not running anymore.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="../../storage/ipc/procarray.c.html#L2524" title="storage/ipc/procarray.c:2524">ProcArrayInstallImportedXmin</a>(<a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>-&gt;xmin, sourcevxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not import the requested snapshot&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The source process with PID </span><span class="Special">%d</span><span class="Constant"> is not running anymore.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sourcepid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In transaction-snapshot mode, the first snapshot must live until end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xact, so we must make a copy of it.&nbsp; Furthermore, if we're running in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * serializable mode, predicate.c needs to do its own processing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsolationUsesXactSnapshot())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsolationIsSerializable())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L1707" title="storage/lmgr/predicate.c:1707">SetSerializableTransactionSnapshot</a>(<a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>, sourcevxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sourcepid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make a saved copy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a> = <a href="#L574" title="utils/time/snapmgr.c:574">CopySnapshot</a>(<a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L142" title="utils/time/snapmgr.c:142">FirstXactSnapshot</a> = <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark it as &quot;registered&quot; in <a href="#L142" title="utils/time/snapmgr.c:142">FirstXactSnapshot</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L142" title="utils/time/snapmgr.c:142">FirstXactSnapshot</a>-&gt;regd_count++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/pairingheap.c.html#L112" title="lib/pairingheap.c:112">pairingheap_add</a>(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>, &amp;<a href="#L142" title="utils/time/snapmgr.c:142">FirstXactSnapshot</a>-&gt;ph_node);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L135" title="utils/time/snapmgr.c:135">FirstSnapshotSet</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L574" title="utils/time/snapmgr.c:574">CopySnapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Copy the given snapshot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The copy is <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d in <a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a> and has initial refcounts set<br/></li>
<li></span><span class="Comment"> * to 0.&nbsp; The returned snapshot has the copied flag set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Snapshot<br/></li>
<li><a id="L574">&#x200c;</a><span class="linkable">CopySnapshot</span>(Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; newsnap;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; subxipoff;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(snapshot != InvalidSnapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We allocate <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> XID arrays needed in the same <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> block. */<br/></li>
<li></span>&nbsp; &nbsp; size = subxipoff = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SnapshotData) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot-&gt;xcnt * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot-&gt;subxcnt &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size += snapshot-&gt;subxcnt * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newsnap = (Snapshot) <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>, size);<br/></li>
<li>&nbsp; &nbsp; memcpy(newsnap, snapshot, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SnapshotData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newsnap-&gt;regd_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; newsnap-&gt;active_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; newsnap-&gt;copied = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; newsnap-&gt;snapXactCompletionCount = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* setup XID array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot-&gt;xcnt &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newsnap-&gt;xip = (TransactionId *) (newsnap + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(newsnap-&gt;xip, snapshot-&gt;xip,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; snapshot-&gt;xcnt * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newsnap-&gt;xip = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Setup subXID array. Don't bother to copy it if it had overflowed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * though, because it's not used anywhere in that case. Except if it's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot taken during recovery; all the top-level XIDs are in subxip as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * well in that case, so we mustn't lose them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot-&gt;subxcnt &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (!snapshot-&gt;suboverflowed || snapshot-&gt;takenDuringRecovery))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newsnap-&gt;subxip = (TransactionId *) ((<span class="Type">char</span> *) newsnap + subxipoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(newsnap-&gt;subxip, snapshot-&gt;subxip,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; snapshot-&gt;subxcnt * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newsnap-&gt;subxip = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newsnap;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L630" title="utils/time/snapmgr.c:630">FreeSnapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Free the memory associated with a snapshot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L630">&#x200c;</a></span><span class="linkable">FreeSnapshot</span>(Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(snapshot-&gt;regd_count == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(snapshot-&gt;active_count == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(snapshot-&gt;copied);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(snapshot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set the given snapshot as the current active snapshot<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the passed snapshot is a statically-allocated one, or it is possibly<br/></li>
<li></span><span class="Comment"> * subject to a future command counter update, create a new long-lived copy<br/></li>
<li></span><span class="Comment"> * with active refcount=1.&nbsp; Otherwise, only increment the refcount.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L648">&#x200c;</a></span><span class="linkable">PushActiveSnapshot</span>(Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L662" title="utils/time/snapmgr.c:662">PushActiveSnapshotWithLevel</a>(snapshot, <a href="../../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>());<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L662" title="utils/time/snapmgr.c:662">PushActiveSnapshotWithLevel</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set the given snapshot as the current active snapshot<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Same as <a href="#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a> except that caller can specify the<br/></li>
<li></span><span class="Comment"> * transaction nesting level that &quot;owns&quot; the snapshot.&nbsp; This level<br/></li>
<li></span><span class="Comment"> * must not be deeper than the current top of the snapshot stack.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L662">&#x200c;</a></span><span class="linkable">PushActiveSnapshotWithLevel</span>(Snapshot snapshot, <span class="Type">int</span> snap_level)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L112" title="utils/time/snapmgr.c:112">ActiveSnapshotElt</a> *newactive;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(snapshot != InvalidSnapshot);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a> == <span class="Constant">NULL</span> || snap_level &gt;= <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>-&gt;as_level);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newactive = <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L112" title="utils/time/snapmgr.c:112">ActiveSnapshotElt</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Checking <a href="#L89" title="utils/time/snapmgr.c:89">SecondarySnapshot</a> is probably useless here, but it seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * better to be sure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot == <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a> || snapshot == <a href="#L89" title="utils/time/snapmgr.c:89">SecondarySnapshot</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !snapshot-&gt;copied)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newactive-&gt;as_snap = <a href="#L574" title="utils/time/snapmgr.c:574">CopySnapshot</a>(snapshot);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newactive-&gt;as_snap = snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newactive-&gt;as_next = <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>;<br/></li>
<li>&nbsp; &nbsp; newactive-&gt;as_level = snap_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newactive-&gt;as_snap-&gt;active_count++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a> = newactive;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L123" title="utils/time/snapmgr.c:123">OldestActiveSnapshot</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L123" title="utils/time/snapmgr.c:123">OldestActiveSnapshot</a> = <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L700" title="utils/time/snapmgr.c:700">PushCopiedSnapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; As above, except forcibly copy the presented snapshot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be used when the <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a> has to be modifiable, for<br/></li>
<li></span><span class="Comment"> * example if the caller intends to call <a href="#L712" title="utils/time/snapmgr.c:712">UpdateActiveSnapshotCommandId</a>.<br/></li>
<li></span><span class="Comment"> * The new snapshot will be released when popped from the stack.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L700">&#x200c;</a></span><span class="linkable">PushCopiedSnapshot</span>(Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a>(<a href="#L574" title="utils/time/snapmgr.c:574">CopySnapshot</a>(snapshot));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L712" title="utils/time/snapmgr.c:712">UpdateActiveSnapshotCommandId</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Update the current CID of the active snapshot.&nbsp; This can only be applied<br/></li>
<li></span><span class="Comment"> * to a snapshot that is not referenced elsewhere.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L712">&#x200c;</a></span><span class="linkable">UpdateActiveSnapshotCommandId</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CommandId&nbsp; &nbsp; save_curcid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curcid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>-&gt;as_snap-&gt;active_count == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>-&gt;as_snap-&gt;regd_count == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't allow modification of the active snapshot during parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operation.&nbsp; We share the snapshot to worker backends at the beginning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of parallel operation, so <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> change to the snapshot can lead to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inconsistencies.&nbsp; We have other defenses against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>, but there are a few places that call this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * directly, so we put an additional guard here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; save_curcid = <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>-&gt;as_snap-&gt;curcid;<br/></li>
<li>&nbsp; &nbsp; curcid = <a href="../../access/transam/xact.c.html#L826" title="access/transam/xact.c:826">GetCurrentCommandId</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>() &amp;&amp; save_curcid != curcid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot modify commandid in active snapshot during a parallel operation&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>-&gt;as_snap-&gt;curcid = curcid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Remove the topmost snapshot from the active snapshot stack, decrementing the<br/></li>
<li></span><span class="Comment"> * reference count, and free it if this was the last reference.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L743">&#x200c;</a></span><span class="linkable">PopActiveSnapshot</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L112" title="utils/time/snapmgr.c:112">ActiveSnapshotElt</a> *newstack;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newstack = <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>-&gt;as_next;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>-&gt;as_snap-&gt;active_count &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>-&gt;as_snap-&gt;active_count--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>-&gt;as_snap-&gt;active_count == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>-&gt;as_snap-&gt;regd_count == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L630" title="utils/time/snapmgr.c:630">FreeSnapshot</a>(<a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>-&gt;as_snap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a> = newstack;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L123" title="utils/time/snapmgr.c:123">OldestActiveSnapshot</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L914" title="utils/time/snapmgr.c:914">SnapshotResetXmin</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return the topmost snapshot in the Active stack.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Snapshot<br/></li>
<li><a id="L770">&#x200c;</a><span class="linkable">GetActiveSnapshot</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>-&gt;as_snap;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L782" title="utils/time/snapmgr.c:782">ActiveSnapshotSet</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return whether there is at least one snapshot in the Active stack<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L782">&#x200c;</a></span><span class="linkable">ActiveSnapshotSet</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a> != <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L794" title="utils/time/snapmgr.c:794">RegisterSnapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Register a snapshot as being in use by the current resource owner<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If InvalidSnapshot is passed, it is not registered.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Snapshot<br/></li>
<li><a id="L794">&#x200c;</a><span class="linkable">RegisterSnapshot</span>(Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot == InvalidSnapshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidSnapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L807" title="utils/time/snapmgr.c:807">RegisterSnapshotOnOwner</a>(snapshot, <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L807" title="utils/time/snapmgr.c:807">RegisterSnapshotOnOwner</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; As above, but use the specified resource owner<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Snapshot<br/></li>
<li><a id="L807">&#x200c;</a><span class="linkable">RegisterSnapshotOnOwner</span>(Snapshot snapshot, ResourceOwner owner)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot == InvalidSnapshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidSnapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Static snapshot?&nbsp; Create a persistent copy */<br/></li>
<li></span>&nbsp; &nbsp; snap = snapshot-&gt;copied ? snapshot : <a href="#L574" title="utils/time/snapmgr.c:574">CopySnapshot</a>(snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and tell resowner.c about it */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../resowner/resowner.c.html#L442" title="utils/resowner/resowner.c:442">ResourceOwnerEnlarge</a>(owner);<br/></li>
<li>&nbsp; &nbsp; snap-&gt;regd_count++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L177" title="utils/time/snapmgr.c:177">ResourceOwnerRememberSnapshot</a>(owner, snap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (snap-&gt;regd_count == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/pairingheap.c.html#L112" title="lib/pairingheap.c:112">pairingheap_add</a>(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>, &amp;snap-&gt;ph_node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> snap;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L836" title="utils/time/snapmgr.c:836">UnregisterSnapshot</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Decrement the reference count of a snapshot, remove the corresponding<br/></li>
<li></span><span class="Comment"> * reference from <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>, and free the snapshot if no more<br/></li>
<li></span><span class="Comment"> * references remain.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L836">&#x200c;</a></span><span class="linkable">UnregisterSnapshot</span>(Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L849" title="utils/time/snapmgr.c:849">UnregisterSnapshotFromOwner</a>(snapshot, <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L849" title="utils/time/snapmgr.c:849">UnregisterSnapshotFromOwner</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; As above, but use the specified resource owner<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L849">&#x200c;</a></span><span class="linkable">UnregisterSnapshotFromOwner</span>(Snapshot snapshot, ResourceOwner owner)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L182" title="utils/time/snapmgr.c:182">ResourceOwnerForgetSnapshot</a>(owner, snapshot);<br/></li>
<li>&nbsp; &nbsp; <a href="#L859" title="utils/time/snapmgr.c:859">UnregisterSnapshotNoOwner</a>(snapshot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L859">&#x200c;</a></span><span class="linkable">UnregisterSnapshotNoOwner</span>(Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(snapshot-&gt;regd_count &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(!pairingheap_is_empty(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;regd_count--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot-&gt;regd_count == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/pairingheap.c.html#L170" title="lib/pairingheap.c:170">pairingheap_remove</a>(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>, &amp;snapshot-&gt;ph_node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot-&gt;regd_count == <span class="Constant">0</span> &amp;&amp; snapshot-&gt;active_count == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L630" title="utils/time/snapmgr.c:630">FreeSnapshot</a>(snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L914" title="utils/time/snapmgr.c:914">SnapshotResetXmin</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Comparison function for <a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a> heap.&nbsp; Snapshots are ordered<br/></li>
<li></span><span class="Comment"> * by xmin, so that the snapshot with smallest xmin is at the top.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L880">&#x200c;</a></span><span class="linkable">xmin_cmp</span>(<span class="Type">const</span> pairingheap_node *a, <span class="Type">const</span> pairingheap_node *b, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> SnapshotData *asnap = pairingheap_const_container(SnapshotData, ph_node, a);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> SnapshotData *bsnap = pairingheap_const_container(SnapshotData, ph_node, b);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(asnap-&gt;xmin, bsnap-&gt;xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L314" title="access/transam/transam.c:314">TransactionIdFollows</a>(asnap-&gt;xmin, bsnap-&gt;xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L914" title="utils/time/snapmgr.c:914">SnapshotResetXmin</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there are no more snapshots, we can reset our PGPROC-&gt;xmin to<br/></li>
<li></span><span class="Comment"> * InvalidTransactionId. Note we can do this without locking because we assume<br/></li>
<li></span><span class="Comment"> * that storing an Xid is atomic.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Even if there are some remaining snapshots, we may be able to advance our<br/></li>
<li></span><span class="Comment"> * PGPROC-&gt;xmin to some degree.&nbsp; This typically happens when a portal is<br/></li>
<li></span><span class="Comment"> * dropped.&nbsp; For efficiency, we only consider recomputing PGPROC-&gt;xmin when<br/></li>
<li></span><span class="Comment"> * the active snapshot stack is empty; this allows us not to need to track<br/></li>
<li></span><span class="Comment"> * which active snapshot is oldest.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: it's tempting to use <a href="#L323" title="utils/time/snapmgr.c:323">GetOldestSnapshot</a>() here so that we can include<br/></li>
<li></span><span class="Comment"> * active snapshots in the calculation.&nbsp; However, that compares by LSN not<br/></li>
<li></span><span class="Comment"> * xmin so it's not entirely clear that it's the same thing.&nbsp; Also, we'd be<br/></li>
<li></span><span class="Comment"> * critically dependent on the assumption that the bottommost active snapshot<br/></li>
<li></span><span class="Comment"> * stack entry has the oldest xmin.&nbsp; (Current uses of <a href="#L323" title="utils/time/snapmgr.c:323">GetOldestSnapshot</a>() are<br/></li>
<li></span><span class="Comment"> * not actually critical, but this would be.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L914">&#x200c;</a></span><span class="linkable">SnapshotResetXmin</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; minSnapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pairingheap_is_empty(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; minSnapshot = pairingheap_container(SnapshotData, ph_node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/pairingheap.c.html#L130" title="lib/pairingheap.c:130">pairingheap_first</a>(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin, minSnapshot-&gt;xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin = minSnapshot-&gt;xmin;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L938" title="utils/time/snapmgr.c:938">AtSubCommit_Snapshot</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L938">&#x200c;</a></span><span class="linkable">AtSubCommit_Snapshot</span>(<span class="Type">int</span> level)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L112" title="utils/time/snapmgr.c:112">ActiveSnapshotElt</a> *active;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Relabel the active snapshots set in this subtransaction as though they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are owned by the parent subxact.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (active = <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>; active != <span class="Constant">NULL</span>; active = active-&gt;as_next)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (active-&gt;as_level &lt; level)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; active-&gt;as_level = level - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L959" title="utils/time/snapmgr.c:959">AtSubAbort_Snapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Clean up snapshots after a subtransaction abort<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L959">&#x200c;</a></span><span class="linkable">AtSubAbort_Snapshot</span>(<span class="Type">int</span> level)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Forget the active snapshots set by this subtransaction */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a> &amp;&amp; <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>-&gt;as_level &gt;= level)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L112" title="utils/time/snapmgr.c:112">ActiveSnapshotElt</a> *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>-&gt;as_next;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Decrement the snapshot's active count.&nbsp; If it's still registered or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * marked as active by an outer subtransaction, we can't free it yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>-&gt;as_snap-&gt;active_count &gt;= <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>-&gt;as_snap-&gt;active_count -= <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>-&gt;as_snap-&gt;active_count == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>-&gt;as_snap-&gt;regd_count == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L630" title="utils/time/snapmgr.c:630">FreeSnapshot</a>(<a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>-&gt;as_snap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and free the stack <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a> = <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L123" title="utils/time/snapmgr.c:123">OldestActiveSnapshot</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L914" title="utils/time/snapmgr.c:914">SnapshotResetXmin</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L995" title="utils/time/snapmgr.c:995">AtEOXact_Snapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Snapshot manager's <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> function for end of transaction<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L995">&#x200c;</a></span><span class="linkable">AtEOXact_Snapshot</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> resetXmin)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In transaction-snapshot mode we must release our privately-managed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reference to the transaction snapshot.&nbsp; We must remove it from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a> to keep the check below happy.&nbsp; But we don't bother<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to do <a href="#L630" title="utils/time/snapmgr.c:630">FreeSnapshot</a>, for two reasons: the memory will go away with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a> anyway, and if someone has left the snapshot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stacked as active, we don't want the code below to be chasing through a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dangling pointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L142" title="utils/time/snapmgr.c:142">FirstXactSnapshot</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L142" title="utils/time/snapmgr.c:142">FirstXactSnapshot</a>-&gt;regd_count &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!pairingheap_is_empty(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/pairingheap.c.html#L170" title="lib/pairingheap.c:170">pairingheap_remove</a>(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>, &amp;<a href="#L142" title="utils/time/snapmgr.c:142">FirstXactSnapshot</a>-&gt;ph_node);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L142" title="utils/time/snapmgr.c:142">FirstXactSnapshot</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we exported <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> snapshots, clean them up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L155" title="utils/time/snapmgr.c:155">exportedSnapshots</a> != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get rid of the files.&nbsp; Unlink failure is only a WARNING because (1)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's too late to abort the transaction, and (2) leaving a leaked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file around has little real consequence anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We also need to remove the snapshots from <a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prevent a warning below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As with the <a href="#L142" title="utils/time/snapmgr.c:142">FirstXactSnapshot</a>, we don't need to free resources of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the snapshot itself as it will go away with the memory context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, <a href="#L155" title="utils/time/snapmgr.c:155">exportedSnapshots</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L148" title="utils/time/snapmgr.c:148">ExportedSnapshot</a> *esnap = (<a href="#L148" title="utils/time/snapmgr.c:148">ExportedSnapshot</a> *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlink(esnap-&gt;snapfile))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;could not unlink file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; esnap-&gt;snapfile);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/pairingheap.c.html#L170" title="lib/pairingheap.c:170">pairingheap_remove</a>(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;esnap-&gt;snapshot-&gt;ph_node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L155" title="utils/time/snapmgr.c:155">exportedSnapshots</a> = NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Drop catalog snapshot if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L422" title="utils/time/snapmgr.c:422">InvalidateCatalogSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* On commit, complain about leftover snapshots */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L112" title="utils/time/snapmgr.c:112">ActiveSnapshotElt</a> *active;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pairingheap_is_empty(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;registered snapshots seem to remain after <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* complain about unpopped active snapshots */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (active = <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a>; active != <span class="Constant">NULL</span>; active = active-&gt;as_next)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;snapshot </span><span class="Special">%p</span><span class="Constant"> still active&quot;</span>, active);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And reset our state.&nbsp; We don't need to free the memory explicitly --<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it'll go away with <a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L123" title="utils/time/snapmgr.c:123">OldestActiveSnapshot</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pairingheap_reset(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L88" title="utils/time/snapmgr.c:88">CurrentSnapshot</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="utils/time/snapmgr.c:89">SecondarySnapshot</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L135" title="utils/time/snapmgr.c:135">FirstSnapshotSet</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During normal commit processing, we call <a href="../../storage/ipc/procarray.c.html#L667" title="storage/ipc/procarray.c:667">ProcArrayEndTransaction</a>() to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reset the <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin. That call happens prior to the call to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L995" title="utils/time/snapmgr.c:995">AtEOXact_Snapshot</a>(), so we need not touch xmin here at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (resetXmin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L914" title="utils/time/snapmgr.c:914">SnapshotResetXmin</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(resetXmin || <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xmin == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1095" title="utils/time/snapmgr.c:1095">ExportSnapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Export the snapshot to a file so that other backends can import it.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the token (the file name) that can be used to import this<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; snapshot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L1095">&#x200c;</a><span class="linkable">ExportSnapshot</span>(Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId topXid;<br/></li>
<li>&nbsp; &nbsp; TransactionId *children;<br/></li>
<li>&nbsp; &nbsp; <a href="#L148" title="utils/time/snapmgr.c:148">ExportedSnapshot</a> *esnap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nchildren;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addTopXid;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *f;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; pathtmp[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's tempting to call <a href="../../access/transam/xact.c.html#L3662" title="access/transam/xact.c:3662">RequireTransactionBlock</a> here, since it's not very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * useful to export a snapshot that will disappear immediately afterwards.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, we haven't got enough information to do that, since we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * know if we're at top level or not.&nbsp; For example, we could be inside a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plpgsql function that is going to fire off other transactions via<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dblink.&nbsp; Rather than disallow perfectly legitimate usages, don't make a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also note that we don't make <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> restriction on the transaction's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * isolation level; however, importers must check the level if they are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * serializable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get our transaction ID if there is one, to include in the snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; topXid = <a href="../../access/transam/xact.c.html#L438" title="access/transam/xact.c:438">GetTopTransactionIdIfAny</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We cannot export a snapshot from a subtransaction because there's no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * easy way for importers to verify that the same subtransaction is still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/xact.c.html#L4988" title="access/transam/xact.c:4988">IsSubTransaction</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ACTIVE_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot export a snapshot from a subtransaction&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do however allow previous committed subtransactions to exist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Importers of the snapshot must see them as still running, so get their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XIDs to add them to the snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nchildren = <a href="../../access/transam/xact.c.html#L5741" title="access/transam/xact.c:5741">xactGetCommittedChildren</a>(&amp;children);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate file path for the snapshot.&nbsp; We start numbering of snapshots<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inside the transaction from 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(path, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(path), <a href="#L145" title="utils/time/snapmgr.c:145">SNAPSHOT_EXPORT_DIR</a> <span class="Constant">&quot;/</span><span class="Special">%08X</span><span class="Constant">-</span><span class="Special">%08X</span><span class="Constant">-</span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.procNumber, <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.lxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length(<a href="#L155" title="utils/time/snapmgr.c:155">exportedSnapshots</a>) + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the snapshot into <a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>, add it to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L155" title="utils/time/snapmgr.c:155">exportedSnapshots</a> list, and mark it pseudo-registered.&nbsp; We do this to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensure that the snapshot's xmin is honored for the rest of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snapshot = <a href="#L574" title="utils/time/snapmgr.c:574">CopySnapshot</a>(snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>);<br/></li>
<li>&nbsp; &nbsp; esnap = (<a href="#L148" title="utils/time/snapmgr.c:148">ExportedSnapshot</a> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L148" title="utils/time/snapmgr.c:148">ExportedSnapshot</a>));<br/></li>
<li>&nbsp; &nbsp; esnap-&gt;snapfile = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(path);<br/></li>
<li>&nbsp; &nbsp; esnap-&gt;snapshot = snapshot;<br/></li>
<li>&nbsp; &nbsp; <a href="#L155" title="utils/time/snapmgr.c:155">exportedSnapshots</a> = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(<a href="#L155" title="utils/time/snapmgr.c:155">exportedSnapshots</a>, esnap);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;regd_count++;<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/pairingheap.c.html#L112" title="lib/pairingheap.c:112">pairingheap_add</a>(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>, &amp;snapshot-&gt;ph_node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill buf with a text serialization of the snapshot, plus identification<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data about this transaction.&nbsp; The format expected by <a href="#L1367" title="utils/time/snapmgr.c:1367">ImportSnapshot</a> is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pretty rigid: each line must be fieldname:value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;vxid:</span><span class="Special">%d</span><span class="Constant">/</span><span class="Special">%u\n</span><span class="Constant">&quot;</span>, <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.procNumber, <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.lxid);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;pid:</span><span class="Special">%d\n</span><span class="Constant">&quot;</span>, <a href="../init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;dbid:</span><span class="Special">%u\n</span><span class="Constant">&quot;</span>, <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;iso:</span><span class="Special">%d\n</span><span class="Constant">&quot;</span>, <a href="../../access/transam/xact.c.html#L77" title="access/transam/xact.c:77">XactIsoLevel</a>);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;ro:</span><span class="Special">%d\n</span><span class="Constant">&quot;</span>, <a href="../../access/transam/xact.c.html#L80" title="access/transam/xact.c:80">XactReadOnly</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;xmin:</span><span class="Special">%u\n</span><span class="Constant">&quot;</span>, snapshot-&gt;xmin);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;xmax:</span><span class="Special">%u\n</span><span class="Constant">&quot;</span>, snapshot-&gt;xmax);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must include our own top transaction ID in the top-xid data, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by definition we will still be running when the importing transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * adopts the snapshot, but <a href="../../storage/ipc/procarray.c.html#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a> never includes our own XID in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the snapshot.&nbsp; (There must, therefore, be enough room to add it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, it could be that our topXid is after the xmax, in which case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we shouldn't include it because xip[] members are expected to be <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xmax.&nbsp; (We need not make the same check for subxip[] members, see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot.h.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; addTopXid = (TransactionIdIsValid(topXid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(topXid, snapshot-&gt;xmax)) ? <span class="Constant">1</span> : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;xcnt:</span><span class="Special">%d\n</span><span class="Constant">&quot;</span>, snapshot-&gt;xcnt + addTopXid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; snapshot-&gt;xcnt; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;xip:</span><span class="Special">%u\n</span><span class="Constant">&quot;</span>, snapshot-&gt;xip[i]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (addTopXid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;xip:</span><span class="Special">%u\n</span><span class="Constant">&quot;</span>, topXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similarly, we add our subcommitted child XIDs to the subxid data. Here,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we have to cope with possible overflow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot-&gt;suboverflowed ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot-&gt;subxcnt + nchildren &gt; <a href="../../storage/ipc/procarray.c.html#L2068" title="storage/ipc/procarray.c:2068">GetMaxSnapshotSubxidCount</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;sof:1</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;sof:0</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;sxcnt:</span><span class="Special">%d\n</span><span class="Constant">&quot;</span>, snapshot-&gt;subxcnt + nchildren);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; snapshot-&gt;subxcnt; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;sxp:</span><span class="Special">%u\n</span><span class="Constant">&quot;</span>, snapshot-&gt;subxip[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nchildren; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;sxp:</span><span class="Special">%u\n</span><span class="Constant">&quot;</span>, children[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;rec:</span><span class="Special">%u\n</span><span class="Constant">&quot;</span>, snapshot-&gt;takenDuringRecovery);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now write the text representation into a file.&nbsp; We first write to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;.tmp&quot; filename, and rename to final filename if no error.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensures that no other backend can read an incomplete file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (<a href="#L1367" title="utils/time/snapmgr.c:1367">ImportSnapshot</a> won't allow it because of its valid-characters check).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(pathtmp, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pathtmp), <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.tmp&quot;</span>, path);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(f = <a href="../../storage/file/fd.c.html#L2583" title="storage/file/fd.c:2583">AllocateFile</a>(pathtmp, PG_BINARY_W)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, pathtmp)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fwrite(buf.data, buf.len, <span class="Constant">1</span>, f) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write to file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, pathtmp)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no fsync() since file need not survive a system crash */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2781" title="storage/file/fd.c:2781">FreeFile</a>(f))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write to file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, pathtmp)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we have written everything into a .tmp file, rename the file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to remove the .tmp suffix.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rename(pathtmp, path) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not rename file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathtmp, path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The basename of the file is what we return from <a href="#L1272" title="utils/time/snapmgr.c:1272">pg_export_snapshot</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's already in path in a textual format and we know that the path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * starts with <a href="#L145" title="utils/time/snapmgr.c:145">SNAPSHOT_EXPORT_DIR</a>.&nbsp; Skip over the prefix and the slash<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a> it so as not to return the address of a local variable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(path + strlen(<a href="#L145" title="utils/time/snapmgr.c:145">SNAPSHOT_EXPORT_DIR</a>) + <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1272" title="utils/time/snapmgr.c:1272">pg_export_snapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; SQL-callable wrapper for <a href="#L1095" title="utils/time/snapmgr.c:1095">ExportSnapshot</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1272">&#x200c;</a><span class="linkable">pg_export_snapshot</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *snapshotName;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snapshotName = <a href="#L1095" title="utils/time/snapmgr.c:1095">ExportSnapshot</a>(<a href="#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>());<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_TEXT_P(<a href="../adt/varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(snapshotName));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parsing subroutines for <a href="#L1367" title="utils/time/snapmgr.c:1367">ImportSnapshot</a>: <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> a line with the given<br/></li>
<li></span><span class="Comment"> * prefix followed by a value, and advance *s to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> line.&nbsp; The<br/></li>
<li></span><span class="Comment"> * filename is provided for use in error messages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1287">&#x200c;</a></span><span class="linkable">parseIntFromText</span>(<span class="Type">const</span> <span class="Type">char</span> *prefix, <span class="Type">char</span> **s, <span class="Type">const</span> <span class="Type">char</span> *filename)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr = *s;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefixlen = strlen(prefix);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strncmp(ptr, prefix, prefixlen) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid snapshot data in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, filename)));<br/></li>
<li>&nbsp; &nbsp; ptr += prefixlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sscanf(ptr, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, &amp;val) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid snapshot data in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, filename)));<br/></li>
<li>&nbsp; &nbsp; ptr = strchr(ptr, <span class="Special">'\n'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!ptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid snapshot data in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, filename)));<br/></li>
<li>&nbsp; &nbsp; *s = ptr + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> val;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> TransactionId<br/></li>
<li><a id="L1312">&#x200c;</a><span class="linkable">parseXidFromText</span>(<span class="Type">const</span> <span class="Type">char</span> *prefix, <span class="Type">char</span> **s, <span class="Type">const</span> <span class="Type">char</span> *filename)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr = *s;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefixlen = strlen(prefix);<br/></li>
<li>&nbsp; &nbsp; TransactionId val;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strncmp(ptr, prefix, prefixlen) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid snapshot data in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, filename)));<br/></li>
<li>&nbsp; &nbsp; ptr += prefixlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sscanf(ptr, <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant">&quot;</span>, &amp;val) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid snapshot data in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, filename)));<br/></li>
<li>&nbsp; &nbsp; ptr = strchr(ptr, <span class="Special">'\n'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!ptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid snapshot data in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, filename)));<br/></li>
<li>&nbsp; &nbsp; *s = ptr + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> val;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1337">&#x200c;</a></span><span class="linkable">parseVxidFromText</span>(<span class="Type">const</span> <span class="Type">char</span> *prefix, <span class="Type">char</span> **s, <span class="Type">const</span> <span class="Type">char</span> *filename,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId *vxid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr = *s;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefixlen = strlen(prefix);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strncmp(ptr, prefix, prefixlen) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid snapshot data in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, filename)));<br/></li>
<li>&nbsp; &nbsp; ptr += prefixlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sscanf(ptr, <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">&quot;</span>, &amp;vxid-&gt;procNumber, &amp;vxid-&gt;localTransactionId) != <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid snapshot data in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, filename)));<br/></li>
<li>&nbsp; &nbsp; ptr = strchr(ptr, <span class="Special">'\n'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!ptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid snapshot data in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, filename)));<br/></li>
<li>&nbsp; &nbsp; *s = ptr + <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1367" title="utils/time/snapmgr.c:1367">ImportSnapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Import a previously exported snapshot.&nbsp; The argument should be a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; filename in <a href="#L145" title="utils/time/snapmgr.c:145">SNAPSHOT_EXPORT_DIR</a>.&nbsp; Load the snapshot from that file.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is called by &quot;<a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> TRANSACTION SNAPSHOT 'foo'&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1367">&#x200c;</a></span><span class="linkable">ImportSnapshot</span>(<span class="Type">const</span> <span class="Type">char</span> *idstr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *f;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat stat_buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *filebuf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xcnt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; VirtualTransactionId src_vxid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_pid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_dbid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_isolevel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; src_readonly;<br/></li>
<li>&nbsp; &nbsp; SnapshotData snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must be at top level of a fresh transaction.&nbsp; Note in particular that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we check we haven't acquired an XID --- if we have, it's conceivable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the snapshot would show it as not running, making for very screwy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * behavior.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L135" title="utils/time/snapmgr.c:135">FirstSnapshotSet</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L438" title="access/transam/xact.c:438">GetTopTransactionIdIfAny</a>() != InvalidTransactionId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L4988" title="access/transam/xact.c:4988">IsSubTransaction</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ACTIVE_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> TRANSACTION SNAPSHOT must be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> query&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are in read committed mode then the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> query would execute with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a new snapshot thus making this function call quite useless.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsolationUsesXactSnapshot())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;a snapshot-importing transaction must have isolation level SERIALIZABLE or REPEATABLE READ&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Verify the identifier: only 0-9, A-F and hyphens are allowed.&nbsp; We do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this mainly to prevent reading arbitrary files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strspn(idstr, <span class="Constant">&quot;0123456789ABCDEF-&quot;</span>) != strlen(idstr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid snapshot identifier: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, idstr)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, read the file */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(path, MAXPGPATH, <a href="#L145" title="utils/time/snapmgr.c:145">SNAPSHOT_EXPORT_DIR</a> <span class="Constant">&quot;/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, idstr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; f = <a href="../../storage/file/fd.c.html#L2583" title="storage/file/fd.c:2583">AllocateFile</a>(path, PG_BINARY_R);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!f)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If file is missing while identifier has a correct format, avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * system errors.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;snapshot </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, idstr)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> for reading: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* get the size of the file so that we know how much memory we need */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fstat(fileno(f), &amp;stat_buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not stat file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and read the file into a <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string */<br/></li>
<li></span>&nbsp; &nbsp; filebuf = (<span class="Type">char</span> *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(stat_buf.st_size + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fread(filebuf, stat_buf.st_size, <span class="Constant">1</span>, f) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; filebuf[stat_buf.st_size] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2781" title="storage/file/fd.c:2781">FreeFile</a>(f);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct a snapshot struct by parsing the file content.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; memset(&amp;snapshot, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(snapshot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1337" title="utils/time/snapmgr.c:1337">parseVxidFromText</a>(<span class="Constant">&quot;vxid:&quot;</span>, &amp;filebuf, path, &amp;src_vxid);<br/></li>
<li>&nbsp; &nbsp; src_pid = <a href="#L1287" title="utils/time/snapmgr.c:1287">parseIntFromText</a>(<span class="Constant">&quot;pid:&quot;</span>, &amp;filebuf, path);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we abuse <a href="#L1312" title="utils/time/snapmgr.c:1312">parseXidFromText</a> a <a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> here ... */<br/></li>
<li></span>&nbsp; &nbsp; src_dbid = <a href="#L1312" title="utils/time/snapmgr.c:1312">parseXidFromText</a>(<span class="Constant">&quot;dbid:&quot;</span>, &amp;filebuf, path);<br/></li>
<li>&nbsp; &nbsp; src_isolevel = <a href="#L1287" title="utils/time/snapmgr.c:1287">parseIntFromText</a>(<span class="Constant">&quot;iso:&quot;</span>, &amp;filebuf, path);<br/></li>
<li>&nbsp; &nbsp; src_readonly = <a href="#L1287" title="utils/time/snapmgr.c:1287">parseIntFromText</a>(<span class="Constant">&quot;ro:&quot;</span>, &amp;filebuf, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snapshot.snapshot_type = SNAPSHOT_MVCC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snapshot.xmin = <a href="#L1312" title="utils/time/snapmgr.c:1312">parseXidFromText</a>(<span class="Constant">&quot;xmin:&quot;</span>, &amp;filebuf, path);<br/></li>
<li>&nbsp; &nbsp; snapshot.xmax = <a href="#L1312" title="utils/time/snapmgr.c:1312">parseXidFromText</a>(<span class="Constant">&quot;xmax:&quot;</span>, &amp;filebuf, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snapshot.xcnt = xcnt = <a href="#L1287" title="utils/time/snapmgr.c:1287">parseIntFromText</a>(<span class="Constant">&quot;xcnt:&quot;</span>, &amp;filebuf, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity-check the xid count <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (xcnt &lt; <span class="Constant">0</span> || xcnt &gt; <a href="../../storage/ipc/procarray.c.html#L2057" title="storage/ipc/procarray.c:2057">GetMaxSnapshotXidCount</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid snapshot data in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snapshot.xip = (TransactionId *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(xcnt * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; xcnt; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot.xip[i] = <a href="#L1312" title="utils/time/snapmgr.c:1312">parseXidFromText</a>(<span class="Constant">&quot;xip:&quot;</span>, &amp;filebuf, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snapshot.suboverflowed = <a href="#L1287" title="utils/time/snapmgr.c:1287">parseIntFromText</a>(<span class="Constant">&quot;sof:&quot;</span>, &amp;filebuf, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!snapshot.suboverflowed)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot.subxcnt = xcnt = <a href="#L1287" title="utils/time/snapmgr.c:1287">parseIntFromText</a>(<span class="Constant">&quot;sxcnt:&quot;</span>, &amp;filebuf, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sanity-check the xid count <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xcnt &lt; <span class="Constant">0</span> || xcnt &gt; <a href="../../storage/ipc/procarray.c.html#L2068" title="storage/ipc/procarray.c:2068">GetMaxSnapshotSubxidCount</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid snapshot data in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot.subxip = (TransactionId *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(xcnt * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; xcnt; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshot.subxip[i] = <a href="#L1312" title="utils/time/snapmgr.c:1312">parseXidFromText</a>(<span class="Constant">&quot;sxp:&quot;</span>, &amp;filebuf, path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot.subxcnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot.subxip = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snapshot.takenDuringRecovery = <a href="#L1287" title="utils/time/snapmgr.c:1287">parseIntFromText</a>(<span class="Constant">&quot;rec:&quot;</span>, &amp;filebuf, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do some additional sanity checking, just to protect ourselves.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't trouble to check the array elements, just the most critical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!VirtualTransactionIdIsValid(src_vxid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !OidIsValid(src_dbid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdIsNormal(snapshot.xmin) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdIsNormal(snapshot.xmax))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TEXT_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid snapshot data in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're serializable, the source transaction must be too, otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * predicate.c has problems (SxactGlobalXmin could go backwards).&nbsp; Also, a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-read-only transaction can't adopt a snapshot from a read-only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction, as predicate.c handles the cases very differently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsolationIsSerializable())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (src_isolevel != XACT_SERIALIZABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;a serializable transaction cannot import a snapshot from a non-serializable transaction&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (src_readonly &amp;&amp; !<a href="../../access/transam/xact.c.html#L80" title="access/transam/xact.c:80">XactReadOnly</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;a non-read-only serializable transaction cannot import a snapshot from a read-only transaction&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We cannot import a snapshot that was taken in a different database,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> calculates OldestXmin on a per-database basis; so the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * source transaction's xmin doesn't protect us from data loss.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restriction could be removed if the source transaction were to mark its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xmin as being globally applicable.&nbsp; But that would require some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * additional syntax, since that has to be known when the snapshot is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initially taken.&nbsp; (See pgsql-hackers discussion of 2011-10-21.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (src_dbid != <a href="../init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot import a snapshot from a different database&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, install the snapshot */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L477" title="utils/time/snapmgr.c:477">SetTransactionSnapshot</a>(&amp;snapshot, &amp;src_vxid, src_pid, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1554" title="utils/time/snapmgr.c:1554">XactHasExportedSnapshots</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Test whether current transaction has exported <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> snapshots.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1554">&#x200c;</a></span><span class="linkable">XactHasExportedSnapshots</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L155" title="utils/time/snapmgr.c:155">exportedSnapshots</a> != NIL);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1567" title="utils/time/snapmgr.c:1567">DeleteAllExportedSnapshotFiles</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Clean up <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> files that have been left behind by a crashed backend<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; that had exported snapshots <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it died.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be called during database startup or crash recovery.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1567">&#x200c;</a></span><span class="linkable">DeleteAllExportedSnapshotFiles</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[MAXPGPATH + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L145" title="utils/time/snapmgr.c:145">SNAPSHOT_EXPORT_DIR</a>)];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *s_dir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *s_de;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Problems in reading the directory, or unlinking files, are reported at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LOG level.&nbsp; Since we're running in the startup process, ERROR level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would prevent database start, and it's not important enough for that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s_dir = <a href="../../storage/file/fd.c.html#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(<a href="#L145" title="utils/time/snapmgr.c:145">SNAPSHOT_EXPORT_DIR</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((s_de = <a href="../../storage/file/fd.c.html#L2924" title="storage/file/fd.c:2924">ReadDirExtended</a>(s_dir, <a href="#L145" title="utils/time/snapmgr.c:145">SNAPSHOT_EXPORT_DIR</a>, LOG)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(s_de-&gt;d_name, <span class="Constant">&quot;.&quot;</span>) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(s_de-&gt;d_name, <span class="Constant">&quot;..&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buf), <a href="#L145" title="utils/time/snapmgr.c:145">SNAPSHOT_EXPORT_DIR</a> <span class="Constant">&quot;/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, s_de-&gt;d_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlink(buf) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, buf)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2961" title="storage/file/fd.c:2961">FreeDir</a>(s_dir);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1606" title="utils/time/snapmgr.c:1606">ThereAreNoPriorRegisteredSnapshots</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Is the registered snapshot count less than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to one?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Don't use this to settle important decisions.&nbsp; While zero registrations and<br/></li>
<li></span><span class="Comment"> * no <a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a> would confirm a certain idleness, the system makes no<br/></li>
<li></span><span class="Comment"> * guarantees about the significance of one registered snapshot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1606">&#x200c;</a></span><span class="linkable">ThereAreNoPriorRegisteredSnapshots</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pairingheap_is_empty(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pairingheap_is_singular(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1624" title="utils/time/snapmgr.c:1624">HaveRegisteredOrActiveSnapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Is there <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> registered or active snapshot?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: Unless pushed or active, the cached catalog snapshot will not cause<br/></li>
<li></span><span class="Comment"> * this function to return true. That allows this function to be used in<br/></li>
<li></span><span class="Comment"> * checks enforcing a longer-lived snapshot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1624">&#x200c;</a></span><span class="linkable">HaveRegisteredOrActiveSnapshot</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The catalog snapshot is in <a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a> when valid, but can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * removed at <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> time due to invalidation processing. If explicitly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * registered more than one snapshot has to be in <a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L90" title="utils/time/snapmgr.c:90">CatalogSnapshot</a> != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pairingheap_is_singular(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> !pairingheap_is_empty(&amp;<a href="#L132" title="utils/time/snapmgr.c:132">RegisteredSnapshots</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Setup a snapshot that replaces normal catalog snapshots that allows catalog<br/></li>
<li></span><span class="Comment"> * access to behave just like it did at a certain point in the past.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Needed for logical decoding.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1649">&#x200c;</a></span><span class="linkable">SetupHistoricSnapshot</span>(Snapshot historic_snapshot, <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *tuplecids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(historic_snapshot != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* setup the timetravel snapshot */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L91" title="utils/time/snapmgr.c:91">HistoricSnapshot</a> = historic_snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* setup (cmin, cmax) lookup <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L102" title="utils/time/snapmgr.c:102">tuplecid_data</a> = tuplecids;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make catalog snapshots behave normally again.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1665">&#x200c;</a></span><span class="linkable">TeardownHistoricSnapshot</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_error)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L91" title="utils/time/snapmgr.c:91">HistoricSnapshot</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L102" title="utils/time/snapmgr.c:102">tuplecid_data</a> = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1672">&#x200c;</a></span><span class="linkable">HistoricSnapshotActive</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L91" title="utils/time/snapmgr.c:91">HistoricSnapshot</a> != <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<br/></li>
<li><a id="L1678">&#x200c;</a><span class="linkable">HistoricSnapshotGetTupleCids</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L1672" title="utils/time/snapmgr.c:1672">HistoricSnapshotActive</a>());<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L102" title="utils/time/snapmgr.c:102">tuplecid_data</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1692" title="utils/time/snapmgr.c:1692">EstimateSnapshotSpace</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns the size needed to store the given snapshot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We are exporting only required fields from the Snapshot, stored in<br/></li>
<li></span><span class="Comment"> * <a href="#L193" title="utils/time/snapmgr.c:193">SerializedSnapshotData</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L1692">&#x200c;</a><span class="linkable">EstimateSnapshotSpace</span>(Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(snapshot != InvalidSnapshot);<br/></li>
<li>&nbsp; &nbsp; Assert(snapshot-&gt;snapshot_type == SNAPSHOT_MVCC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We allocate <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> XID arrays needed in the same <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> block. */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L193" title="utils/time/snapmgr.c:193">SerializedSnapshotData</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(snapshot-&gt;xcnt, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot-&gt;subxcnt &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (!snapshot-&gt;suboverflowed || snapshot-&gt;takenDuringRecovery))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(snapshot-&gt;subxcnt, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1716" title="utils/time/snapmgr.c:1716">SerializeSnapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Dumps the serialized snapshot (extracted from given snapshot) onto the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; memory location at start_address.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1716">&#x200c;</a></span><span class="linkable">SerializeSnapshot</span>(Snapshot snapshot, <span class="Type">char</span> *start_address)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L193" title="utils/time/snapmgr.c:193">SerializedSnapshotData</a> serialized_snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(snapshot-&gt;subxcnt &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy all required fields */<br/></li>
<li></span>&nbsp; &nbsp; serialized_snapshot.xmin = snapshot-&gt;xmin;<br/></li>
<li>&nbsp; &nbsp; serialized_snapshot.xmax = snapshot-&gt;xmax;<br/></li>
<li>&nbsp; &nbsp; serialized_snapshot.xcnt = snapshot-&gt;xcnt;<br/></li>
<li>&nbsp; &nbsp; serialized_snapshot.subxcnt = snapshot-&gt;subxcnt;<br/></li>
<li>&nbsp; &nbsp; serialized_snapshot.suboverflowed = snapshot-&gt;suboverflowed;<br/></li>
<li>&nbsp; &nbsp; serialized_snapshot.takenDuringRecovery = snapshot-&gt;takenDuringRecovery;<br/></li>
<li>&nbsp; &nbsp; serialized_snapshot.curcid = snapshot-&gt;curcid;<br/></li>
<li>&nbsp; &nbsp; serialized_snapshot.whenTaken = snapshot-&gt;whenTaken;<br/></li>
<li>&nbsp; &nbsp; serialized_snapshot.lsn = snapshot-&gt;lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ignore the SubXID array if it has overflowed, unless the snapshot was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * taken during recovery - in that case, top-level XIDs are in subxip as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * well, and we mustn't lose them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (serialized_snapshot.suboverflowed &amp;&amp; !snapshot-&gt;takenDuringRecovery)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; serialized_snapshot.subxcnt = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy struct to possibly-unaligned buffer */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(start_address,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;serialized_snapshot, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L193" title="utils/time/snapmgr.c:193">SerializedSnapshotData</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy XID array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot-&gt;xcnt &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy((TransactionId *) (start_address +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L193" title="utils/time/snapmgr.c:193">SerializedSnapshotData</a>)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; snapshot-&gt;xip, snapshot-&gt;xcnt * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy SubXID array. Don't bother to copy it if it had overflowed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * though, because it's not used anywhere in that case. Except if it's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot taken during recovery; all the top-level XIDs are in subxip as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * well in that case, so we mustn't lose them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (serialized_snapshot.subxcnt &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; subxipoff = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L193" title="utils/time/snapmgr.c:193">SerializedSnapshotData</a>) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshot-&gt;xcnt * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy((TransactionId *) (start_address + subxipoff),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; snapshot-&gt;subxip, snapshot-&gt;subxcnt * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1775" title="utils/time/snapmgr.c:1775">RestoreSnapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Restore a serialized snapshot from the specified address.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The copy is <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d in <a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a> and has initial refcounts set<br/></li>
<li></span><span class="Comment"> * to 0.&nbsp; The returned snapshot has the copied flag set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Snapshot<br/></li>
<li><a id="L1775">&#x200c;</a><span class="linkable">RestoreSnapshot</span>(<span class="Type">char</span> *start_address)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L193" title="utils/time/snapmgr.c:193">SerializedSnapshotData</a> serialized_snapshot;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot;<br/></li>
<li>&nbsp; &nbsp; TransactionId *serialized_xids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;serialized_snapshot, start_address,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L193" title="utils/time/snapmgr.c:193">SerializedSnapshotData</a>));<br/></li>
<li>&nbsp; &nbsp; serialized_xids = (TransactionId *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (start_address + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L193" title="utils/time/snapmgr.c:193">SerializedSnapshotData</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We allocate <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> XID arrays needed in the same <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> block. */<br/></li>
<li></span>&nbsp; &nbsp; size = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SnapshotData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; + serialized_snapshot.xcnt * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; + serialized_snapshot.subxcnt * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy all required fields */<br/></li>
<li></span>&nbsp; &nbsp; snapshot = (Snapshot) <a href="../mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>, size);<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;snapshot_type = SNAPSHOT_MVCC;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;xmin = serialized_snapshot.xmin;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;xmax = serialized_snapshot.xmax;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;xip = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;xcnt = serialized_snapshot.xcnt;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;subxip = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;subxcnt = serialized_snapshot.subxcnt;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;suboverflowed = serialized_snapshot.suboverflowed;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;takenDuringRecovery = serialized_snapshot.takenDuringRecovery;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;curcid = serialized_snapshot.curcid;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;whenTaken = serialized_snapshot.whenTaken;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;lsn = serialized_snapshot.lsn;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;snapXactCompletionCount = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy XIDs, if present. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (serialized_snapshot.xcnt &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot-&gt;xip = (TransactionId *) (snapshot + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(snapshot-&gt;xip, serialized_xids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; serialized_snapshot.xcnt * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy SubXIDs, if present. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (serialized_snapshot.subxcnt &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot-&gt;subxip = ((TransactionId *) (snapshot + <span class="Constant">1</span>)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; serialized_snapshot.xcnt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(snapshot-&gt;subxip, serialized_xids + serialized_snapshot.xcnt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; serialized_snapshot.subxcnt * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set the copied flag so that the caller will set refcounts correctly. */<br/></li>
<li></span>&nbsp; &nbsp; snapshot-&gt;regd_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;active_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; snapshot-&gt;copied = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> snapshot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Install a restored snapshot as the transaction snapshot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The second argument is of type void * so that snapmgr.h need not include<br/></li>
<li></span><span class="Comment"> * the declaration for PGPROC.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1840">&#x200c;</a></span><span class="linkable">RestoreTransactionSnapshot</span>(Snapshot snapshot, <span class="Type">void</span> *source_pgproc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L477" title="utils/time/snapmgr.c:477">SetTransactionSnapshot</a>(snapshot, <span class="Constant">NULL</span>, InvalidPid, source_pgproc);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1856" title="utils/time/snapmgr.c:1856">XidInMVCCSnapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Is the given XID still-in-progress according to the snapshot?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: <a href="../../storage/ipc/procarray.c.html#L2165" title="storage/ipc/procarray.c:2165">GetSnapshotData</a> never stores either top xid or subxids of our own<br/></li>
<li></span><span class="Comment"> * backend into a snapshot, so these xids will not be reported as &quot;running&quot;<br/></li>
<li></span><span class="Comment"> * by this function.&nbsp; This is OK for current uses, because we always check<br/></li>
<li></span><span class="Comment"> * <a href="../../access/transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a> first, except when it's known the<br/></li>
<li></span><span class="Comment"> * XID could not be ours anyway.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1856">&#x200c;</a></span><span class="linkable">XidInMVCCSnapshot</span>(TransactionId xid, Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make a quick <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> check to eliminate most XIDs without looking at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xip arrays.&nbsp; Note that this is OK even if we convert a subxact XID to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its parent below, because a subxact with XID &lt; xmin has surely also got<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a parent with XID &lt; xmin, while one with XID &gt;= xmax must belong to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent that was not yet committed at the time of this snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Any xid &lt; xmin is not in-progress */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, snapshot-&gt;xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Any xid &gt;= xmax is in-progress */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(xid, snapshot-&gt;xmax))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Snapshot information is stored slightly differently in snapshots taken<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!snapshot-&gt;takenDuringRecovery)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the snapshot contains full subxact data, the fastest way to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check things is just to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the given XID against both subxact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * XIDs and top-level XIDs.&nbsp; If the snapshot overflowed, we have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use pg_subtrans to convert a subxact XID to its parent XID, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then we need only look at top-level XIDs not subxacts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!snapshot-&gt;suboverflowed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we have full data, so search subxip */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_lfind32(xid, snapshot-&gt;subxip, snapshot-&gt;subxcnt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not there, fall through to search xip[] */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Snapshot overflowed, so convert xid to top-level.&nbsp; This is safe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because we eliminated too-old XIDs above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid = <a href="../../access/transam/subtrans.c.html#L163" title="access/transam/subtrans.c:163">SubTransGetTopmostTransaction</a>(xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If xid was indeed a subxact, we might <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have an xid &lt; xmin,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so recheck to avoid an array scan.&nbsp; No point in rechecking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xmax.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, snapshot-&gt;xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_lfind32(xid, snapshot-&gt;xip, snapshot-&gt;xcnt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In recovery we store all xids in the subxip array because it is by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * far the bigger array, and we mostly don't know which xids are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * top-level and which are subxacts. The xip array is empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We start by searching subtrans, if we overflowed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (snapshot-&gt;suboverflowed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Snapshot overflowed, so convert xid to top-level.&nbsp; This is safe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because we eliminated too-old XIDs above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid = <a href="../../access/transam/subtrans.c.html#L163" title="access/transam/subtrans.c:163">SubTransGetTopmostTransaction</a>(xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If xid was indeed a subxact, we might <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have an xid &lt; xmin,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so recheck to avoid an array scan.&nbsp; No point in rechecking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xmax.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, snapshot-&gt;xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have either a top-level xid higher than xmin or an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indeterminate xid. We don't know whether it's top level or subxact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but it doesn't matter. If it's present, the xid is visible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_lfind32(xid, snapshot-&gt;subxip, snapshot-&gt;subxcnt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ResourceOwner callbacks */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1955">&#x200c;</a></span><span class="linkable">ResOwnerReleaseSnapshot</span>(Datum res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L859" title="utils/time/snapmgr.c:859">UnregisterSnapshotNoOwner</a>((Snapshot) DatumGetPointer(res));<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
