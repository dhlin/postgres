<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/init/postinit.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/init/postinit.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L645">BaseInit</a></li>
<li><a href="#L313">CheckMyDatabase</a></li>
<li><a href="#L1441">ClientCheckTimeoutHandler</a></li>
<li><a href="#L101">GetDatabaseTuple</a></li>
<li><a href="#L144">GetDatabaseTupleByOid</a></li>
<li><a href="#L1417">IdleInTransactionSessionTimeoutHandler</a></li>
<li><a href="#L1425">IdleSessionTimeoutHandler</a></li>
<li><a href="#L1433">IdleStatsUpdateTimeoutHandler</a></li>
<li><a href="#L736">InitPostgres</a></li>
<li><a href="#L575">InitializeMaxBackends</a></li>
<li><a href="#L1399">LockTimeoutHandler</a></li>
<li><a href="#L190">PerformAuthentication</a></li>
<li><a href="#L1360">ShutdownPostgres</a></li>
<li><a href="#L1377">StatementTimeoutHandler</a></li>
<li><a href="#L1452">ThereIsAtLeastOneRole</a></li>
<li><a href="#L1409">TransactionTimeoutHandler</a></li>
<li><a href="#L604">check_autovacuum_max_workers</a></li>
<li><a href="#L592">check_max_connections</a></li>
<li><a href="#L628">check_max_wal_senders</a></li>
<li><a href="#L616">check_max_worker_processes</a></li>
<li><a href="#L517">pg_split_opts</a></li>
<li><a href="#L1326">process_settings</a></li>
<li><a href="#L1261">process_startup_options</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * postinit.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; postgres initialization utilities<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/init/postinit.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/session.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_authid.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_collation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_database.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_db_role_setting.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_tablespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/auth.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/libpq-be.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/autovacuum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/postmaster.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/slot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/slotsync.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walsender.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/sinvaladt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/sync.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/acl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_locale.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/portal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ps_status.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timeout.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> HeapTuple <a href="#L101" title="utils/init/postinit.c:101">GetDatabaseTuple</a>(<span class="Type">const</span> <span class="Type">char</span> *dbname);<br/></li>
<li><span class="Type">static</span> HeapTuple <a href="#L144" title="utils/init/postinit.c:144">GetDatabaseTupleByOid</a>(Oid dboid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L190" title="utils/init/postinit.c:190">PerformAuthentication</a>(Port *port);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L313" title="utils/init/postinit.c:313">CheckMyDatabase</a>(<span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> am_superuser, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> override_allow_connections);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1360" title="utils/init/postinit.c:1360">ShutdownPostgres</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1377" title="utils/init/postinit.c:1377">StatementTimeoutHandler</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1399" title="utils/init/postinit.c:1399">LockTimeoutHandler</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1417" title="utils/init/postinit.c:1417">IdleInTransactionSessionTimeoutHandler</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1409" title="utils/init/postinit.c:1409">TransactionTimeoutHandler</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1425" title="utils/init/postinit.c:1425">IdleSessionTimeoutHandler</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1433" title="utils/init/postinit.c:1433">IdleStatsUpdateTimeoutHandler</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1441" title="utils/init/postinit.c:1441">ClientCheckTimeoutHandler</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1452" title="utils/init/postinit.c:1452">ThereIsAtLeastOneRole</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1261" title="utils/init/postinit.c:1261">process_startup_options</a>(Port *port, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> am_superuser);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1326" title="utils/init/postinit.c:1326">process_settings</a>(Oid databaseid, Oid roleid);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*** <a href="#L736" title="utils/init/postinit.c:736">InitPostgres</a> support ***/<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L101" title="utils/init/postinit.c:101">GetDatabaseTuple</a> -- fetch the pg_database row for a database<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used during backend startup when we don't yet have <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> access to<br/></li>
<li></span><span class="Comment"> * system catalogs in general.&nbsp; In the worst case, we can seqscan pg_database<br/></li>
<li></span><span class="Comment"> * using nothing but the hard-wired descriptor that relcache.c creates for<br/></li>
<li></span><span class="Comment"> * pg_database.&nbsp; In more typical cases, relcache.c was able to load<br/></li>
<li></span><span class="Comment"> * descriptors for both pg_database and its indexes from the shared relcache<br/></li>
<li></span><span class="Comment"> * cache file, and so we can do an indexscan.&nbsp; <a href="../cache/relcache.c.html#L146" title="utils/cache/relcache.c:146">criticalSharedRelcachesBuilt</a><br/></li>
<li></span><span class="Comment"> * tells whether we got the cached descriptors.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> HeapTuple<br/></li>
<li><a id="L101">&#x200c;</a><span class="linkable">GetDatabaseTuple</span>(<span class="Type">const</span> <span class="Type">char</span> *dbname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relation;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key[<span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * form a scan key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_database_datname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_NAMEEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum(dbname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open pg_database and fetch a tuple.&nbsp; Force heap scan if we haven't yet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * built the critical shared relcache entries (i.e., we're starting up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without a shared relcache cache file).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relation = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(DatabaseRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(relation, DatabaseNameIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/relcache.c.html#L146" title="utils/cache/relcache.c:146">criticalSharedRelcachesBuilt</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must copy tuple <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing buffer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* all done */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(relation, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L144" title="utils/init/postinit.c:144">GetDatabaseTupleByOid</a> -- as above, but search by database OID<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> HeapTuple<br/></li>
<li><a id="L144">&#x200c;</a><span class="linkable">GetDatabaseTupleByOid</span>(Oid dboid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relation;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key[<span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * form a scan key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_database_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(dboid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open pg_database and fetch a tuple.&nbsp; Force heap scan if we haven't yet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * built the critical shared relcache entries (i.e., we're starting up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without a shared relcache cache file).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relation = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(DatabaseRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(relation, DatabaseOidIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/relcache.c.html#L146" title="utils/cache/relcache.c:146">criticalSharedRelcachesBuilt</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must copy tuple <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing buffer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* all done */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(relation, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L190" title="utils/init/postinit.c:190">PerformAuthentication</a> -- authenticate a remote client<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * returns: nothing.&nbsp; Will not return at all if there's <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> failure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L190">&#x200c;</a></span><span class="linkable">PerformAuthentication</span>(Port *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This should be set already, but let's make sure */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../postmaster/postmaster.c.html#L350" title="postmaster/postmaster.c:350">ClientAuthInProgress</a> = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* limit visibility of log messages */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In EXEC_BACKEND case, we didn't inherit the contents of pg_hba.conf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * etcetera from the postmaster, and have to load them ourselves.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">FIXME</span><span class="Comment">: [fork/exec] Ugh.&nbsp; Is there a way around this overhead?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../libpq/hba.c.html#L2583" title="libpq/hba.c:2583">load_hba</a>() and <a href="../../libpq/hba.c.html#L2959" title="libpq/hba.c:2959">load_ident</a>() want to work within the <a href="../mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so create that if it doesn't exist (which it won't).&nbsp; We'll delete it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * again later, in <a href="../../tcop/postgres.c.html#L4152" title="tcop/postgres.c:4152">PostgresMain</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a> = AllocSetContextCreate(<a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Postmaster&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../libpq/hba.c.html#L2583" title="libpq/hba.c:2583">load_hba</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It makes no sense to continue if we fail to load the HBA file,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since there is no way to <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to the database in this case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a configuration file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not load </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../misc/guc_tables.c.html#L542" title="utils/misc/guc_tables.c:542">HbaFileName</a>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../libpq/hba.c.html#L2959" title="libpq/hba.c:2959">load_ident</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It is ok to continue if we fail to load the IDENT file, although it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * means that you cannot log in using <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the authentication<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * methods that need a user name mapping. <a href="../../libpq/hba.c.html#L2959" title="libpq/hba.c:2959">load_ident</a>() already logged<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the details of error to the log.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up a timeout in case a buggy or malicious client fails to respond<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during authentication.&nbsp; Since we're inside a transaction and might do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database access, we have to use the statement_timeout infrastructure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../misc/timeout.c.html#L560" title="utils/misc/timeout.c:560">enable_timeout_after</a>(STATEMENT_TIMEOUT, <a href="../../postmaster/postmaster.c.html#L228" title="postmaster/postmaster.c:228">AuthenticationTimeout</a> * <span class="Constant">1000</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now perform authentication exchange.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; set_ps_display(<span class="Constant">&quot;authentication&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/auth.c.html#L382" title="libpq/auth.c:382">ClientAuthentication</a>(port); <span class="Comment">/* might not return, if failure */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Done with authentication.&nbsp; Disable the timeout, and log if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../misc/timeout.c.html#L685" title="utils/misc/timeout.c:685">disable_timeout</a>(STATEMENT_TIMEOUT, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../postmaster/postmaster.c.html#L231" title="postmaster/postmaster.c:231">Log_connections</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData logmsg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;logmsg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../replication/walsender.c.html#L115" title="replication/walsender.c:115">am_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;logmsg, <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;replication connection authorized: user=</span><span class="Special">%s</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; port-&gt;user_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;logmsg, <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;connection authorized: user=</span><span class="Special">%s</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; port-&gt;user_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../replication/walsender.c.html#L115" title="replication/walsender.c:115">am_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;logmsg, <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot; database=</span><span class="Special">%s</span><span class="Constant">&quot;</span>), port-&gt;database_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;<a href="../misc/guc_tables.c.html#L546" title="utils/misc/guc_tables.c:546">application_name</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;logmsg, <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot; <a href="../misc/guc_tables.c.html#L546" title="utils/misc/guc_tables.c:546">application_name</a>=</span><span class="Special">%s</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; port-&gt;<a href="../misc/guc_tables.c.html#L546" title="utils/misc/guc_tables.c:546">application_name</a>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_SSL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;ssl_in_use)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;logmsg, <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot; SSL enabled (protocol=</span><span class="Special">%s</span><span class="Constant">, cipher=</span><span class="Special">%s</span><span class="Constant">, bits=</span><span class="Special">%d</span><span class="Constant">)&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../libpq/be-secure-openssl.c.html#L1482" title="libpq/be-secure-openssl.c:1482">be_tls_get_version</a>(port),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../libpq/be-secure-openssl.c.html#L1491" title="libpq/be-secure-openssl.c:1491">be_tls_get_cipher</a>(port),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../libpq/be-secure-openssl.c.html#L1468" title="libpq/be-secure-openssl.c:1468">be_tls_get_cipher_bits</a>(port));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef ENABLE_GSS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;gss)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *princ = <a href="../../libpq/be-secure-gssapi.c.html#L739" title="libpq/be-secure-gssapi.c:739">be_gssapi_get_princ</a>(port);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (princ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;logmsg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot; GSS (authenticated=</span><span class="Special">%s</span><span class="Constant">, encrypted=</span><span class="Special">%s</span><span class="Constant">, delegated_credentials=</span><span class="Special">%s</span><span class="Constant">, principal=</span><span class="Special">%s</span><span class="Constant">)&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../libpq/be-secure-gssapi.c.html#L714" title="libpq/be-secure-gssapi.c:714">be_gssapi_get_auth</a>(port) ? <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;yes&quot;</span>) : <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;no&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../libpq/be-secure-gssapi.c.html#L726" title="libpq/be-secure-gssapi.c:726">be_gssapi_get_enc</a>(port) ? <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;yes&quot;</span>) : <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;no&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../libpq/be-secure-gssapi.c.html#L752" title="libpq/be-secure-gssapi.c:752">be_gssapi_get_delegation</a>(port) ? <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;yes&quot;</span>) : <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;no&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; princ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;logmsg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot; GSS (authenticated=</span><span class="Special">%s</span><span class="Constant">, encrypted=</span><span class="Special">%s</span><span class="Constant">, delegated_credentials=</span><span class="Special">%s</span><span class="Constant">)&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../libpq/be-secure-gssapi.c.html#L714" title="libpq/be-secure-gssapi.c:714">be_gssapi_get_auth</a>(port) ? <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;yes&quot;</span>) : <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;no&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../libpq/be-secure-gssapi.c.html#L726" title="libpq/be-secure-gssapi.c:726">be_gssapi_get_enc</a>(port) ? <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;yes&quot;</span>) : <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;no&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../libpq/be-secure-gssapi.c.html#L752" title="libpq/be-secure-gssapi.c:752">be_gssapi_get_delegation</a>(port) ? <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;yes&quot;</span>) : <a href="../error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;no&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG, <a href="../error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, logmsg.data));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(logmsg.data);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; set_ps_display(<span class="Constant">&quot;startup&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../postmaster/postmaster.c.html#L350" title="postmaster/postmaster.c:350">ClientAuthInProgress</a> = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* <a href="../misc/guc_tables.c.html#L525" title="utils/misc/guc_tables.c:525">client_min_messages</a> is active <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L313" title="utils/init/postinit.c:313">CheckMyDatabase</a> -- fetch information from the pg_database entry for our DB<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L313">&#x200c;</a></span><span class="linkable">CheckMyDatabase</span>(<span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> am_superuser, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> override_allow_connections)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_database dbform;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *collate;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ctype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *datlocale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch our pg_database row normally, via syscache */<br/></li>
<li></span>&nbsp; &nbsp; tup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(DATABASEOID, ObjectIdGetDatum(<a href="globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for database </span><span class="Special">%u</span><span class="Constant">&quot;</span>, <a href="globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>);<br/></li>
<li>&nbsp; &nbsp; dbform = (Form_pg_database) GETSTRUCT(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This recheck is strictly paranoia */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(name, NameStr(dbform-&gt;datname)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_DATABASE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has disappeared from pg_database&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Database OID </span><span class="Special">%u</span><span class="Constant"> <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> seems to belong to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>, NameStr(dbform-&gt;datname))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check permissions to <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to the database.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These checks are not enforced when in standalone mode, so that there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a way to recover from disabling all access to all databases, for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * example &quot;UPDATE pg_database <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> datallowconn = false;&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do not enforce them for autovacuum worker processes either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> &amp;&amp; !AmAutoVacuumWorkerProcess())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that the database is currently allowing connections.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!dbform-&gt;datallowconn &amp;&amp; !override_allow_connections)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not currently accepting connections&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check privilege to <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to the database.&nbsp; (The am_superuser test<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is redundant, but since we have the flag, might as well check it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and save a few cycles.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!am_superuser &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(DatabaseRelationId, <a href="globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>, <a href="miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_CONNECT) != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;permission denied for database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;User does not have CONNECT privilege.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check connection limit for this database.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is a race condition here --- we create our PGPROC <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checking for other PGPROCs.&nbsp; If two backends did this at about the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same time, they might both think they were over the limit, while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ideally one should succeed and one fail.&nbsp; Getting that to work<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exactly seems more trouble than it is worth, however; instead we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just document that the connection limit is approximate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dbform-&gt;datconnlimit &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !am_superuser &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L3616" title="storage/ipc/procarray.c:3616">CountDBConnections</a>(<a href="globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>) &gt; dbform-&gt;datconnlimit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_TOO_MANY_CONNECTIONS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many connections for database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, we're golden.&nbsp; Next to-do item is to save the encoding info out of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the pg_database tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mb/mbutils.c.html#L1161" title="utils/mb/mbutils.c:1161">SetDatabaseEncoding</a>(dbform-&gt;encoding);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Record it as a GUC <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> option, too */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;server_encoding&quot;</span>, <a href="../mb/mbutils.c.html#L1267" title="utils/mb/mbutils.c:1267">GetDatabaseEncodingName</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_INTERNAL, PGC_S_DYNAMIC_DEFAULT);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we have no other source of client_encoding, use server encoding */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;client_encoding&quot;</span>, <a href="../mb/mbutils.c.html#L1267" title="utils/mb/mbutils.c:1267">GetDatabaseEncodingName</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_BACKEND, PGC_S_DYNAMIC_DEFAULT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* assign locale variables */<br/></li>
<li></span>&nbsp; &nbsp; datum = <a href="../cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(DATABASEOID, tup, Anum_pg_database_datcollate);<br/></li>
<li>&nbsp; &nbsp; collate = TextDatumGetCString(datum);<br/></li>
<li>&nbsp; &nbsp; datum = <a href="../cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(DATABASEOID, tup, Anum_pg_database_datctype);<br/></li>
<li>&nbsp; &nbsp; ctype = TextDatumGetCString(datum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../adt/pg_locale.c.html#L212" title="utils/adt/pg_locale.c:212">pg_perm_setlocale</a>(<span class="Constant">LC_COLLATE</span>, collate) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database locale is incompatible with operating system&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The database was initialized with LC_COLLATE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; which is not recognized by setlocale().&quot;</span>, collate),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Recreate the database with another locale or install the missing locale.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../adt/pg_locale.c.html#L212" title="utils/adt/pg_locale.c:212">pg_perm_setlocale</a>(<span class="Constant">LC_CTYPE</span>, ctype) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database locale is incompatible with operating system&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The database was initialized with LC_CTYPE </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; which is not recognized by setlocale().&quot;</span>, ctype),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Recreate the database with another locale or install the missing locale.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(ctype, <span class="Constant">&quot;C&quot;</span>) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcmp(ctype, <span class="Constant">&quot;POSIX&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/pg_locale.c.html#L117" title="utils/adt/pg_locale.c:117">database_ctype_is_c</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dbform-&gt;datlocprovider == COLLPROVIDER_BUILTIN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(DATABASEOID, tup, Anum_pg_database_datlocale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datlocale = TextDatumGetCString(datum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/pg_locale.c.html#L2551" title="utils/adt/pg_locale.c:2551">builtin_validate_locale</a>(dbform-&gt;encoding, datlocale);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/pg_locale.c.html#L1446" title="utils/adt/pg_locale.c:1446">default_locale</a>.info.builtin.locale = <a href="../mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, datlocale);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (dbform-&gt;datlocprovider == COLLPROVIDER_ICU)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *icurules;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(DATABASEOID, tup, Anum_pg_database_datlocale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datlocale = TextDatumGetCString(datum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(DATABASEOID, tup, Anum_pg_database_daticurules, &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; icurules = TextDatumGetCString(datum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; icurules = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/pg_locale.c.html#L1449" title="utils/adt/pg_locale.c:1449">make_icu_collator</a>(datlocale, icurules, &amp;<a href="../adt/pg_locale.c.html#L1446" title="utils/adt/pg_locale.c:1446">default_locale</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; datlocale = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../adt/pg_locale.c.html#L1446" title="utils/adt/pg_locale.c:1446">default_locale</a>.<a href="../../jit/jit.c.html#L43" title="jit/jit.c:43">provider</a> = dbform-&gt;datlocprovider;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Default locale is currently always deterministic.&nbsp; Nondeterministic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * locales currently don't support pattern matching, which would break a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lot of things if applied globally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../adt/pg_locale.c.html#L1446" title="utils/adt/pg_locale.c:1446">default_locale</a>.deterministic = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check collation version.&nbsp; See similar code in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../adt/pg_locale.c.html#L1551" title="utils/adt/pg_locale.c:1551">pg_newlocale_from_collation</a>().&nbsp; Note that here we warn instead of error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, so that we don't prevent connecting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; datum = <a href="../cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(DATABASEOID, tup, Anum_pg_database_datcollversion,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *actual_versionstr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *collversionstr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *locale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collversionstr = TextDatumGetCString(datum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dbform-&gt;datlocprovider == COLLPROVIDER_LIBC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locale = collate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locale = datlocale;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; actual_versionstr = <a href="../adt/pg_locale.c.html#L1729" title="utils/adt/pg_locale.c:1729">get_collation_actual_version</a>(dbform-&gt;datlocprovider, locale);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!actual_versionstr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has no actual collation version, but a version was recorded&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(actual_versionstr, collversionstr) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has a collation version mismatch&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The database was created using collation version </span><span class="Special">%s</span><span class="Constant">, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;but the operating system provides version </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; collversionstr, actual_versionstr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Rebuild all objects in this database that use the default collation and run &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;ALTER DATABASE </span><span class="Special">%s</span><span class="Constant"> REFRESH COLLATION VERSION, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;or build PostgreSQL with the right library version.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../adt/ruleutils.c.html#L12623" title="utils/adt/ruleutils.c:12623">quote_identifier</a>(name))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L517" title="utils/init/postinit.c:517">pg_split_opts</a> -- split a string of options and append it to an argv array<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller is responsible for ensuring the argv array is large enough.&nbsp; The<br/></li>
<li></span><span class="Comment"> * maximum possible number of arguments added by this routine is<br/></li>
<li></span><span class="Comment"> * (strlen(optstr) + 1) / 2.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because some option <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> can contain spaces we allow escaping using<br/></li>
<li></span><span class="Comment"> * backslashes, with \\ representing a literal backslash.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L517">&#x200c;</a></span><span class="linkable">pg_split_opts</span>(<span class="Type">char</span> **argv, <span class="Type">int</span> *argcp, <span class="Type">const</span> <span class="Type">char</span> *optstr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;s);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (*optstr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; last_was_escape = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resetStringInfo(&amp;s);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over leading space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *optstr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; optstr++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*optstr == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Parse a single option, stopping at the first space, unless it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * escaped.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (*optstr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isspace((<span class="Type">unsigned</span> <span class="Type">char</span>) *optstr) &amp;&amp; !last_was_escape)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!last_was_escape &amp;&amp; *optstr == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_was_escape = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_was_escape = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;s, *optstr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; optstr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> store the option in the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> argv[] position */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; argv[(*argcp)++] = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(s.data);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(s.data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize <a href="globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> value from config options.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This must be called after modules have had the chance to alter GUCs in<br/></li>
<li></span><span class="Comment"> * shared_preload_libraries and <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> shared memory size is determined.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that in EXEC_BACKEND environment, the value is passed down from<br/></li>
<li></span><span class="Comment"> * postmaster to subprocesses via <a href="../../postmaster/launch_backend.c.html#L152" title="postmaster/launch_backend.c:152">BackendParameters</a> in <a href="../../postmaster/launch_backend.c.html#L569" title="postmaster/launch_backend.c:569">SubPostmasterMain</a>; only<br/></li>
<li></span><span class="Comment"> * postmaster itself and processes not under postmaster control should call<br/></li>
<li></span><span class="Comment"> * this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L575">&#x200c;</a></span><span class="linkable">InitializeMaxBackends</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the extra unit accounts for the autovacuum launcher */<br/></li>
<li></span>&nbsp; &nbsp; <a href="globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> = <a href="globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a> + <a href="../../postmaster/autovacuum.c.html#L117" title="postmaster/autovacuum.c:117">autovacuum_max_workers</a> + <span class="Constant">1</span> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a> + <a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> error because the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> were all checked previously */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> &gt; MAX_BACKENDS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too many backends configured&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for max_connections<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L592">&#x200c;</a></span><span class="linkable">check_max_connections</span>(<span class="Type">int</span> *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> + <a href="../../postmaster/autovacuum.c.html#L117" title="postmaster/autovacuum.c:117">autovacuum_max_workers</a> + <span class="Constant">1</span> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a> + <a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a> &gt; MAX_BACKENDS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for <a href="../../postmaster/autovacuum.c.html#L117" title="postmaster/autovacuum.c:117">autovacuum_max_workers</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L604">&#x200c;</a></span><span class="linkable">check_autovacuum_max_workers</span>(<span class="Type">int</span> *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a> + *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> + <span class="Constant">1</span> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a> + <a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a> &gt; MAX_BACKENDS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for <a href="globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L616">&#x200c;</a></span><span class="linkable">check_max_worker_processes</span>(<span class="Type">int</span> *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a> + <a href="../../postmaster/autovacuum.c.html#L117" title="postmaster/autovacuum.c:117">autovacuum_max_workers</a> + <span class="Constant">1</span> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> + <a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a> &gt; MAX_BACKENDS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for <a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L628">&#x200c;</a></span><span class="linkable">check_max_wal_senders</span>(<span class="Type">int</span> *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a> + <a href="../../postmaster/autovacuum.c.html#L117" title="postmaster/autovacuum.c:117">autovacuum_max_workers</a> + <span class="Constant">1</span> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a> + *<a href="../misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> &gt; MAX_BACKENDS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Early initialization of a backend (either standalone or under postmaster).<br/></li>
<li></span><span class="Comment"> * This happens even <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="#L736" title="utils/init/postinit.c:736">InitPostgres</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is separate from <a href="#L736" title="utils/init/postinit.c:736">InitPostgres</a> because it is also called by auxiliary<br/></li>
<li></span><span class="Comment"> * processes, such as the background writer process, which may not call<br/></li>
<li></span><span class="Comment"> * <a href="#L736" title="utils/init/postinit.c:736">InitPostgres</a> at all.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L645">&#x200c;</a></span><span class="linkable">BaseInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize our input/output/debugging file descriptors.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../error/elog.c.html#L2077" title="utils/error/elog.c:2077">DebugFileOpen</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize file access. Done early so other subsystems can access<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L903" title="storage/file/fd.c:903">InitFileAccess</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize statistics reporting. This needs to happen early to ensure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that pgstat's shutdown callback runs after the shutdown callbacks of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all subsystems that can produce stats (like e.g. transaction commits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../activity/pgstat.c.html#L537" title="utils/activity/pgstat.c:537">pgstat_initialize</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do local initialization of storage and buffer managers */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/sync/sync.c.html#L124" title="storage/sync/sync.c:124">InitSync</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/smgr/smgr.c.html#L154" title="storage/smgr/smgr.c:154">smgrinit</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3519" title="storage/buffer/bufmgr.c:3519">InitBufferPoolAccess</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize temporary file access after pgstat, so that the temporary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * file shutdown hook can report temporary file statistics.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L933" title="storage/file/fd.c:933">InitTemporaryFileAccess</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize local buffers for WAL record construction, in case we ever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * try to insert XLOG.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/xloginsert.c.html#L1348" title="access/transam/xloginsert.c:1348">InitXLogInsert</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize replication slots after pgstat. The exit hook might need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * drop ephemeral slots, which in turn triggers stats reporting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../replication/slot.c.html#L224" title="replication/slot.c:224">ReplicationSlotInitialize</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> * <a href="#L736" title="utils/init/postinit.c:736">InitPostgres</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Initialize POSTGRES.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Parameters:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; in_dbname, dboid: specify database to <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to, as described below<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; username, useroid: specify role to <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> as, as described below<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; flags:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; - INIT_PG_LOAD_SESSION_LIBS to honor [session|local]_preload_libraries.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; - INIT_PG_OVERRIDE_ALLOW_CONNS to <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> despite !datallowconn.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; - INIT_PG_OVERRIDE_ROLE_LOGIN to <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> despite !rolcanlogin.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; out_dbname: optional output parameter, see below; pass NULL if not used<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The database can be specified by name, using the in_dbname parameter, or by<br/></li>
<li></span><span class="Comment"> * OID, using the dboid parameter.&nbsp; Specify NULL or InvalidOid respectively<br/></li>
<li></span><span class="Comment"> * for the unused parameter.&nbsp; If dboid is provided, the actual database<br/></li>
<li></span><span class="Comment"> * name can be returned to the caller in out_dbname.&nbsp; If out_dbname isn't<br/></li>
<li></span><span class="Comment"> * NULL, it must point to a buffer of size NAMEDATALEN.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Similarly, the role can be passed by name, using the username parameter,<br/></li>
<li></span><span class="Comment"> * or by OID using the useroid parameter.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In bootstrap mode the database and username parameters are NULL/InvalidOid.<br/></li>
<li></span><span class="Comment"> * The autovacuum launcher process doesn't specify these parameters either,<br/></li>
<li></span><span class="Comment"> * because it only goes far enough to be able to read pg_database; it doesn't<br/></li>
<li></span><span class="Comment"> * <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> particular database.&nbsp; An autovacuum worker specifies a<br/></li>
<li></span><span class="Comment"> * database but not a username; conversely, a physical walsender specifies<br/></li>
<li></span><span class="Comment"> * username but not database.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * By convention, INIT_PG_LOAD_SESSION_LIBS should be passed in &quot;flags&quot; in<br/></li>
<li></span><span class="Comment"> * &quot;interactive&quot; sessions (including standalone backends), but not in<br/></li>
<li></span><span class="Comment"> * background processes such as autovacuum.&nbsp; Note in particular that it<br/></li>
<li></span><span class="Comment"> * shouldn't be true in parallel worker processes; those have another<br/></li>
<li></span><span class="Comment"> * mechanism for replicating their leader's set of loaded libraries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We expect that <a href="../../storage/lmgr/proc.c.html#L296" title="storage/lmgr/proc.c:296">InitProcess</a>() was already called, so we already have a<br/></li>
<li></span><span class="Comment"> * PGPROC struct ... but it's not completely filled in yet.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Be very careful with the order of calls in the <a href="#L736" title="utils/init/postinit.c:736">InitPostgres</a> function.<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L736">&#x200c;</a></span><span class="linkable">InitPostgres</span>(<span class="Type">const</span> <span class="Type">char</span> *in_dbname, Oid dboid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *username, Oid useroid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bits32 flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *out_dbname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; bootstrap = IsBootstrapProcessingMode();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; am_superuser;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *fullpath;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; dbname[NAMEDATALEN];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nfree = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;<a href="#L736" title="utils/init/postinit.c:736">InitPostgres</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add my PGPROC struct to the ProcArray.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Once I have done this, I am visible to other backends!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L488" title="storage/lmgr/proc.c:488">InitProcessPhase2</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize my entry in the shared-invalidation manager's array of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * per-backend data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/sinvaladt.c.html#L272" title="storage/ipc/sinvaladt.c:272">SharedInvalBackendInit</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/procsignal.c.html#L158" title="storage/ipc/procsignal.c:158">ProcSignalInit</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also set up timeout handlers needed for backend operation.&nbsp; We need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * these in every case except bootstrap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!bootstrap)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/timeout.c.html#L505" title="utils/misc/timeout.c:505">RegisterTimeout</a>(DEADLOCK_TIMEOUT, <a href="../../storage/lmgr/proc.c.html#L1840" title="storage/lmgr/proc.c:1840">CheckDeadLockAlert</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/timeout.c.html#L505" title="utils/misc/timeout.c:505">RegisterTimeout</a>(STATEMENT_TIMEOUT, <a href="#L1377" title="utils/init/postinit.c:1377">StatementTimeoutHandler</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/timeout.c.html#L505" title="utils/misc/timeout.c:505">RegisterTimeout</a>(LOCK_TIMEOUT, <a href="#L1399" title="utils/init/postinit.c:1399">LockTimeoutHandler</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/timeout.c.html#L505" title="utils/misc/timeout.c:505">RegisterTimeout</a>(IDLE_IN_TRANSACTION_SESSION_TIMEOUT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1417" title="utils/init/postinit.c:1417">IdleInTransactionSessionTimeoutHandler</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/timeout.c.html#L505" title="utils/misc/timeout.c:505">RegisterTimeout</a>(TRANSACTION_TIMEOUT, <a href="#L1409" title="utils/init/postinit.c:1409">TransactionTimeoutHandler</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/timeout.c.html#L505" title="utils/misc/timeout.c:505">RegisterTimeout</a>(IDLE_SESSION_TIMEOUT, <a href="#L1425" title="utils/init/postinit.c:1425">IdleSessionTimeoutHandler</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/timeout.c.html#L505" title="utils/misc/timeout.c:505">RegisterTimeout</a>(CLIENT_CONNECTION_CHECK_TIMEOUT, <a href="#L1441" title="utils/init/postinit.c:1441">ClientCheckTimeoutHandler</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/timeout.c.html#L505" title="utils/misc/timeout.c:505">RegisterTimeout</a>(IDLE_STATS_UPDATE_TIMEOUT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1433" title="utils/init/postinit.c:1433">IdleStatsUpdateTimeoutHandler</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is either a bootstrap process or a standalone backend, start up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the XLOG machinery, and register to have it closed down at exit. In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other cases, the startup process is responsible for starting up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLOG machinery, and the checkpointer for closing it down.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't yet have an aux-process resource owner, but <a href="../../access/transam/xlog.c.html#L5388" title="access/transam/xlog.c:5388">StartupXLOG</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and <a href="../../access/transam/xlog.c.html#L6539" title="access/transam/xlog.c:6539">ShutdownXLOG</a> will need one.&nbsp; Hence, create said resource owner<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (and register a callback to clean it up after <a href="../../access/transam/xlog.c.html#L6539" title="access/transam/xlog.c:6539">ShutdownXLOG</a> runs).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../resowner/resowner.c.html#L982" title="utils/resowner/resowner.c:982">CreateAuxProcessResourceOwner</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xlog.c.html#L5388" title="access/transam/xlog.c:5388">StartupXLOG</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release (and warn about) <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> buffer pins leaked in <a href="../../access/transam/xlog.c.html#L5388" title="access/transam/xlog.c:5388">StartupXLOG</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../resowner/resowner.c.html#L1002" title="utils/resowner/resowner.c:1002">ReleaseAuxProcessResources</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> to nothing for the moment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use <a href="../../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>() so that <a href="../../access/transam/xlog.c.html#L6539" title="access/transam/xlog.c:6539">ShutdownXLOG</a>() can rely on DSM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * segments etc to work (which in turn is required for pgstats).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>(<a href="../activity/pgstat.c.html#L462" title="utils/activity/pgstat.c:462">pgstat_before_server_shutdown</a>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>(<a href="../../access/transam/xlog.c.html#L6539" title="access/transam/xlog.c:6539">ShutdownXLOG</a>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the relation cache and the system catalog caches.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no catalog access happens here; we only set up the hashtable structure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> starting a transaction because transaction abort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would try to touch these hashtables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../cache/relcache.c.html#L3951" title="utils/cache/relcache.c:3951">RelationCacheInitialize</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../cache/syscache.c.html#L107" title="utils/cache/syscache.c:107">InitCatalogCache</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../cache/plancache.c.html#L155" title="utils/cache/plancache.c:155">InitPlanCache</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize portal manager */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mmgr/portalmem.c.html#L104" title="utils/mmgr/portalmem.c:104">EnablePortalManager</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize status reporting */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../activity/backend_status.c.html#L247" title="utils/activity/backend_status.c:247">pgstat_beinit</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Load relcache entries for the shared system catalogs.&nbsp; This must create<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at least entries for pg_database and catalogs used for authentication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../cache/relcache.c.html#L3997" title="utils/cache/relcache.c:3997">RelationCacheInitializePhase2</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up process-exit callback to do pre-shutdown <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.&nbsp; This is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one of the first <a href="../../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a> callbacks we register; thus, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be one the last things we do <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> low-level modules like the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer manager begin to close down.&nbsp; We need to have this in place<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we begin our first transaction --- if we fail during the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initialization transaction, as is entirely possible, we need the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../access/transam/xact.c.html#L2749" title="access/transam/xact.c:2749">AbortTransaction</a> call to clean up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>(<a href="#L1360" title="utils/init/postinit.c:1360">ShutdownPostgres</a>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The autovacuum launcher is done here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (AmAutoVacuumLauncherProcess())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* report this backend in the PgBackendStatus array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../activity/backend_status.c.html#L273" title="utils/activity/backend_status.c:273">pgstat_bestart</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start a new transaction here <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> first access to db, and get a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot.&nbsp; We don't have a use for the snapshot itself, but we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interested in the secondary effect that it sets RecentGlobalXmin. (This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is critical for anything that reads heap pages, because HOT may decide<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to prune them even if the process doesn't attempt to modify <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">FIXME</span><span class="Comment">: This comment is inaccurate / the code buggy. A snapshot that is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not pushed/active does not reliably prevent HOT pruning (-&gt;xmin could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * e.g. be cleared when cache invalidations are processed).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!bootstrap)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../adt/timestamp.c.html#L1624" title="utils/adt/timestamp.c:1624">statement_timestamp</a> must be set for timeouts to work correctly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L911" title="access/transam/xact.c:911">SetCurrentStatementStartTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction_isolation will have been set to the default by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * above.&nbsp; If the default is &quot;serializable&quot;, and we are in hot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * standby, we will fail if we don't change it to something <a href="../adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fortunately, &quot;read committed&quot; is plenty good enough.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L77" title="access/transam/xact.c:77">XactIsoLevel</a> = XACT_READ_COMMITTED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Perform client authentication if necessary, then figure out our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * postgres user ID, and see if we are a <a href="../misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In standalone mode, autovacuum worker processes and slot sync worker<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process, we use a fixed ID, otherwise we figure it out from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * authenticated user name.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bootstrap || AmAutoVacuumWorkerProcess() || AmLogicalSlotSyncWorkerProcess())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="miscinit.c.html#L837" title="utils/init/miscinit.c:837">InitializeSessionUserIdStandalone</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; am_superuser = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="miscinit.c.html#L837" title="utils/init/miscinit.c:837">InitializeSessionUserIdStandalone</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; am_superuser = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1452" title="utils/init/postinit.c:1452">ThereIsAtLeastOneRole</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no roles are defined in this database system&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You should immediately run CREATE USER </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> SUPERUSER;.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; username != <span class="Constant">NULL</span> ? username : <span class="Constant">&quot;postgres&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (AmBackgroundWorkerProcess())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (username == <span class="Constant">NULL</span> &amp;&amp; !OidIsValid(useroid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="miscinit.c.html#L837" title="utils/init/miscinit.c:837">InitializeSessionUserIdStandalone</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; am_superuser = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="miscinit.c.html#L733" title="utils/init/miscinit.c:733">InitializeSessionUserId</a>(username, useroid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; INIT_PG_OVERRIDE_ROLE_LOGIN) != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; am_superuser = <a href="../misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* normal multiuser case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L190" title="utils/init/postinit.c:190">PerformAuthentication</a>(<a href="globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="miscinit.c.html#L733" title="utils/init/miscinit.c:733">InitializeSessionUserId</a>(username, useroid, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ensure that auth_method is actually valid, aka authn_id is not NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="miscinit.c.html#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.authn_id)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="miscinit.c.html#L867" title="utils/init/miscinit.c:867">InitializeSystemUser</a>(<a href="miscinit.c.html#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.authn_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../libpq/hba.c.html#L3061" title="libpq/hba.c:3061">hba_authname</a>(<a href="miscinit.c.html#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.auth_method));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; am_superuser = <a href="../misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Binary upgrades only allowed super-user connections<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="globals.c.html#L118" title="utils/init/globals.c:118">IsBinaryUpgrade</a> &amp;&amp; !am_superuser)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;must be <a href="../misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a> to <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> in binary upgrade mode&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The last few connection slots are reserved for superusers and roles<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with privileges of pg_use_reserved_connections.&nbsp; Replication<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * connections are drawn from slots reserved with <a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a> and are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not limited by max_connections, superuser_reserved_connections, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reserved_connections.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: At this point, the new backend has already claimed a proc struct,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so we must check whether the number of free slots is strictly less than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the reserved connection limits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!am_superuser &amp;&amp; !<a href="../../replication/walsender.c.html#L115" title="replication/walsender.c:115">am_walsender</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../postmaster/postmaster.c.html#L216" title="postmaster/postmaster.c:216">SuperuserReservedConnections</a> + <a href="../../postmaster/postmaster.c.html#L217" title="postmaster/postmaster.c:217">ReservedConnections</a>) &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../storage/lmgr/proc.c.html#L687" title="storage/lmgr/proc.c:687">HaveNFreeProcs</a>(<a href="../../postmaster/postmaster.c.html#L216" title="postmaster/postmaster.c:216">SuperuserReservedConnections</a> + <a href="../../postmaster/postmaster.c.html#L217" title="postmaster/postmaster.c:217">ReservedConnections</a>, &amp;nfree))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nfree &lt; <a href="../../postmaster/postmaster.c.html#L216" title="postmaster/postmaster.c:216">SuperuserReservedConnections</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_TOO_MANY_CONNECTIONS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;remaining connection slots are reserved for roles with the </span><span class="Special">%s</span><span class="Constant"> attribute&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;SUPERUSER&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../adt/acl.c.html#L5128" title="utils/adt/acl.c:5128">has_privs_of_role</a>(<a href="miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), ROLE_PG_USE_RESERVED_CONNECTIONS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_TOO_MANY_CONNECTIONS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;remaining connection slots are reserved for roles with privileges of the </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> role&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;pg_use_reserved_connections&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check replication permissions needed for walsender processes. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../replication/walsender.c.html#L115" title="replication/walsender.c:115">am_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!bootstrap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="miscinit.c.html#L711" title="utils/init/miscinit.c:711">has_rolreplication</a>(<a href="miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>()))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;permission denied to start WAL sender&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Only roles with the </span><span class="Special">%s</span><span class="Constant"> attribute may start a WAL sender process.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;REPLICATION&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is a plain walsender only supporting physical replication, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't want to <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> particular database. Just finish the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backend startup by processing <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> options from the startup packet, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../replication/walsender.c.html#L115" title="replication/walsender.c:115">am_walsender</a> &amp;&amp; !<a href="../../replication/walsender.c.html#L118" title="replication/walsender.c:118">am_db_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* process <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> options passed in the startup packet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1261" title="utils/init/postinit.c:1261">process_startup_options</a>(<a href="globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>, am_superuser);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Apply <a href="../../tcop/postgres.c.html#L101" title="tcop/postgres.c:101">PostAuthDelay</a> as soon as we've read all options */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../tcop/postgres.c.html#L101" title="tcop/postgres.c:101">PostAuthDelay</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<a href="../../tcop/postgres.c.html#L101" title="tcop/postgres.c:101">PostAuthDelay</a> * <span class="Constant">1000000L</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> client encoding */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L281" title="utils/mb/mbutils.c:281">InitializeClientEncoding</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* report this backend in the PgBackendStatus array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../activity/backend_status.c.html#L273" title="utils/activity/backend_status.c:273">pgstat_bestart</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* close the transaction we started above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up the global variables holding database id and default tablespace.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * But note we won't actually try to touch the database just yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We take a shortcut in the bootstrap case, otherwise we have to look up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the db's entry in pg_database.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bootstrap)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dboid = Template1DbOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a> = DEFAULTTABLESPACE_OID;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (in_dbname != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_database dbform;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="#L101" title="utils/init/postinit.c:101">GetDatabaseTuple</a>(in_dbname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_DATABASE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, in_dbname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dbform = (Form_pg_database) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dboid = dbform-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!OidIsValid(dboid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is a background worker not bound to <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> particular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * database, we're done <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; Everything that follows only makes sense<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we are bound to a specific database.&nbsp; We do need to close the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction we started <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!bootstrap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../activity/backend_status.c.html#L273" title="utils/activity/backend_status.c:273">pgstat_bestart</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now, take a writer's lock on the database we are trying to <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is a concurrently running DROP DATABASE on that database, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will block us until it finishes (and has committed its update of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_database).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that the lock is not held long, only until the end of this startup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction.&nbsp; This is OK since we will advertise our use of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database in the ProcArray <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> dropping the lock (in fact, that's the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> thing to do).&nbsp; Anyone trying a DROP DATABASE after this point will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * see us in the array once they have the lock.&nbsp; Ordering is important for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this because we don't want to advertise ourselves as being in this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database until we have the lock; otherwise we create what amounts to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deadlock with <a href="../../storage/ipc/procarray.c.html#L3737" title="storage/ipc/procarray.c:3737">CountOtherDBBackends</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: use of RowExclusiveLock here is reasonable because we envision<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * our session as being a concurrent writer of the database.&nbsp; If we had a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * way of declaring a session as being guaranteed-read-only, we could use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * AccessShareLock for such sessions and thereby not conflict against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CREATE DATABASE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!bootstrap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L1083" title="storage/lmgr/lmgr.c:1083">LockSharedObject</a>(DatabaseRelationId, dboid, <span class="Constant">0</span>, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recheck pg_database to make sure the target database hasn't gone away.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there was a concurrent DROP DATABASE, this ensures we will <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cleanly without creating a mess.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!bootstrap)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_database datform;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="#L144" title="utils/init/postinit.c:144">GetDatabaseTupleByOid</a>(dboid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datform = (Form_pg_database) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (in_dbname &amp;&amp; <a href="../adt/name.c.html#L247" title="utils/adt/name.c:247">namestrcmp</a>(&amp;datform-&gt;datname, in_dbname)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (in_dbname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_DATABASE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, in_dbname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;It seems to have just been dropped or renamed.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_DATABASE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database </span><span class="Special">%u</span><span class="Constant"> does not exist&quot;</span>, dboid)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strlcpy(dbname, NameStr(datform-&gt;datname), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dbname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../commands/dbcommands.c.html#L3177" title="commands/dbcommands.c:3177">database_is_invalid_form</a>(datform))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to invalid database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, dbname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use DROP DATABASE to drop invalid databases.&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a> = datform-&gt;dattablespace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="globals.c.html#L95" title="utils/init/globals.c:95">MyDatabaseHasLoginEventTriggers</a> = datform-&gt;dathasloginevt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pass the database name back to the caller */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (out_dbname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcpy(out_dbname, dbname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we rechecked, we are certain to be connected to a database and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * thus can set <a href="globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is important that <a href="globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> only be set once we are sure that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target database can no longer be concurrently dropped or renamed.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * example, without this guarantee, <a href="../activity/pgstat_database.c.html#L270" title="utils/activity/pgstat_database.c:270">pgstat_update_dbstats</a>() could create<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries for databases that were just dropped in the pgstat shutdown<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callback, which could confuse other code paths like the autovacuum<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scheduler.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> = dboid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we can mark our PGPROC entry with the database ID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We assume this is an atomic store so no lock is needed; though actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * things would work fine even if it weren't atomic.&nbsp; Anyone searching the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ProcArray for this database's ID should hold the database lock, so they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would not be executing concurrently with this store.&nbsp; A process looking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for another database's ID could in theory see a chance match if it read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a partially-updated databaseId value; but as long as all such searches<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wait and retry, as in <a href="../../storage/ipc/procarray.c.html#L3737" title="storage/ipc/procarray.c:3737">CountOtherDBBackends</a>(), they will certainly see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the correct value on their <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> try.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;databaseId = <a href="globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We established a catalog snapshot while reading pg_authid and/or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_database; but until we have set up <a href="globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>, we won't react to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * incoming sinval messages for unshared catalogs, so we won't realize it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the snapshot has been invalidated.&nbsp; Assume it's no good anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../time/snapmgr.c.html#L422" title="utils/time/snapmgr.c:422">InvalidateCatalogSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we should be able to access the database directory safely. Verify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's there and looks reasonable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fullpath = GetDatabasePath(<a href="globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>, <a href="globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!bootstrap)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (access(fullpath, F_OK) == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_DATABASE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dbname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The database subdirectory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is missing.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fullpath)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not access directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fullpath)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="miscinit.c.html#L1710" title="utils/init/miscinit.c:1710">ValidatePgVersion</a>(fullpath);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="miscinit.c.html#L328" title="utils/init/miscinit.c:328">SetDatabasePath</a>(fullpath);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(fullpath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> possible to do real access to the system catalogs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Load relcache entries for the system catalogs.&nbsp; This must create at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * least the minimum set of &quot;nailed-in&quot; cache entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../cache/relcache.c.html#L4056" title="utils/cache/relcache.c:4056">RelationCacheInitializePhase3</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set up ACL framework (so <a href="#L313" title="utils/init/postinit.c:313">CheckMyDatabase</a> can check permissions) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../adt/acl.c.html#L4884" title="utils/adt/acl.c:4884">initialize_acl</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Re-read the pg_database row for our database, check permissions and set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up database-specific GUC settings.&nbsp; We can't do this until all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database-access infrastructure is up.&nbsp; (Also, it wants to know if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * user is a <a href="../misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a>, so the above stuff has to happen first.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!bootstrap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L313" title="utils/init/postinit.c:313">CheckMyDatabase</a>(dbname, am_superuser,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; INIT_PG_OVERRIDE_ALLOW_CONNS) != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now process <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> command-line switches and <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> additional GUC variable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * settings passed in the startup packet.&nbsp;&nbsp; We couldn't do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because we didn't know if client is a <a href="../misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1261" title="utils/init/postinit.c:1261">process_startup_options</a>(<a href="globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>, am_superuser);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process pg_db_role_setting options */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1326" title="utils/init/postinit.c:1326">process_settings</a>(<a href="globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>, <a href="miscinit.c.html#L548" title="utils/init/miscinit.c:548">GetSessionUserId</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Apply <a href="../../tcop/postgres.c.html#L101" title="tcop/postgres.c:101">PostAuthDelay</a> as soon as we've read all options */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../tcop/postgres.c.html#L101" title="tcop/postgres.c:101">PostAuthDelay</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<a href="../../tcop/postgres.c.html#L101" title="tcop/postgres.c:101">PostAuthDelay</a> * <span class="Constant">1000000L</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize various default states that can't be set up until we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selected the active user and gotten the right GUC settings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set default namespace search path */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../catalog/namespace.c.html#L4721" title="catalog/namespace.c:4721">InitializeSearchPath</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> client encoding */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../mb/mbutils.c.html#L281" title="utils/mb/mbutils.c:281">InitializeClientEncoding</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize this backend's session state. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/common/session.c.html#L54" title="access/common/session.c:54">InitializeSession</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is an interactive session, load <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> libraries that should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * preloaded at backend start.&nbsp; Since those are determined by GUCs, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't happen until GUC settings are complete, but we want it to happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during the initial transaction in case anything that requires database<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * access needs to be done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; INIT_PG_LOAD_SESSION_LIBS) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="miscinit.c.html#L1857" title="utils/init/miscinit.c:1857">process_session_preload_libraries</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* report this backend in the PgBackendStatus array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!bootstrap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../activity/backend_status.c.html#L273" title="utils/activity/backend_status.c:273">pgstat_bestart</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* close the transaction we started above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!bootstrap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> command-line switches and <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> additional GUC variable<br/></li>
<li></span><span class="Comment"> * settings passed in the startup packet.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1261">&#x200c;</a></span><span class="linkable">process_startup_options</span>(Port *port, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> am_superuser)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GucContext&nbsp; &nbsp; gucctx;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *gucopts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gucctx = am_superuser ? PGC_SU_BACKEND : PGC_BACKEND;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First process <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> command-line switches that were included in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * startup packet, if we are in a regular backend.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;cmdline_options != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The maximum possible number of commandline arguments that could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * come from port-&gt;cmdline_options is (strlen + 1) / 2; see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L517" title="utils/init/postinit.c:517">pg_split_opts</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; **av;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxac;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxac = <span class="Constant">2</span> + (strlen(port-&gt;cmdline_options) + <span class="Constant">1</span>) / <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; av = (<span class="Type">char</span> **) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(maxac * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span> *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ac = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; av[ac++] = <span class="Constant">&quot;postgres&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L517" title="utils/init/postinit.c:517">pg_split_opts</a>(av, &amp;ac, port-&gt;cmdline_options);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; av[ac] = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ac &lt; maxac);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../tcop/postgres.c.html#L3790" title="tcop/postgres.c:3790">process_postgres_switches</a>(ac, av, gucctx, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Process <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> additional GUC variable settings passed in startup packet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These are handled exactly like command-line variables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; gucopts = list_head(port-&gt;guc_options);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (gucopts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; name = lfirst(gucopts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gucopts = lnext(port-&gt;guc_options, gucopts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; value = lfirst(gucopts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gucopts = lnext(port-&gt;guc_options, gucopts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(name, value, gucctx, PGC_S_CLIENT);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Load GUC settings from pg_db_role_setting.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We try specific settings for the database/role combination, as well as<br/></li>
<li></span><span class="Comment"> * general for this database and for this user.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1326">&#x200c;</a></span><span class="linkable">process_settings</span>(Oid databaseid, Oid roleid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relsetting;<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relsetting = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(DbRoleSettingRelationId, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read all the settings under the same snapshot for efficiency */<br/></li>
<li></span>&nbsp; &nbsp; snapshot = <a href="../time/snapmgr.c.html#L794" title="utils/time/snapmgr.c:794">RegisterSnapshot</a>(<a href="../time/snapmgr.c.html#L352" title="utils/time/snapmgr.c:352">GetCatalogSnapshot</a>(DbRoleSettingRelationId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Later settings are ignored if set earlier. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../catalog/pg_db_role_setting.c.html#L220" title="catalog/pg_db_role_setting.c:220">ApplySetting</a>(snapshot, databaseid, roleid, relsetting, PGC_S_DATABASE_USER);<br/></li>
<li>&nbsp; &nbsp; <a href="../../catalog/pg_db_role_setting.c.html#L220" title="catalog/pg_db_role_setting.c:220">ApplySetting</a>(snapshot, InvalidOid, roleid, relsetting, PGC_S_USER);<br/></li>
<li>&nbsp; &nbsp; <a href="../../catalog/pg_db_role_setting.c.html#L220" title="catalog/pg_db_role_setting.c:220">ApplySetting</a>(snapshot, databaseid, InvalidOid, relsetting, PGC_S_DATABASE);<br/></li>
<li>&nbsp; &nbsp; <a href="../../catalog/pg_db_role_setting.c.html#L220" title="catalog/pg_db_role_setting.c:220">ApplySetting</a>(snapshot, InvalidOid, InvalidOid, relsetting, PGC_S_GLOBAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../time/snapmgr.c.html#L836" title="utils/time/snapmgr.c:836">UnregisterSnapshot</a>(snapshot);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(relsetting, AccessShareLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../postmaster/postmaster.c.html#L177" title="postmaster/postmaster.c:177">Backend</a>-shutdown callback.&nbsp; Do <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> that we want to be sure happens<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> all the supporting modules begin to nail their doors shut via<br/></li>
<li></span><span class="Comment"> * their own callbacks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * User-level <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>, such as temp-relation removal and UNLISTEN, happens<br/></li>
<li></span><span class="Comment"> * via separate callbacks that execute <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> this one.&nbsp; We don't <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> the<br/></li>
<li></span><span class="Comment"> * callbacks because we still want this one to happen if the user-level<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> fails.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1360">&#x200c;</a></span><span class="linkable">ShutdownPostgres</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we've killed <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> active transaction */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../access/transam/xact.c.html#L4811" title="access/transam/xact.c:4811">AbortOutOfAnyTransaction</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * User locks are not released by transaction end, so be sure to release<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them explicitly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lock.c.html#L2147" title="storage/lmgr/lock.c:2147">LockReleaseAll</a>(USER_LOCKMETHOD, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * STATEMENT_TIMEOUT handler: <a href="../adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> a query-cancel interrupt.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1377">&#x200c;</a></span><span class="linkable">StatementTimeoutHandler</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sig = <span class="Constant">SIGINT</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During authentication the timeout is used to deal with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * authentication_timeout - we want to quit in response to such timeouts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../postmaster/postmaster.c.html#L350" title="postmaster/postmaster.c:350">ClientAuthInProgress</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sig = <span class="Constant">SIGTERM</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_SETSID<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* try to signal whole process group */<br/></li>
<li></span>&nbsp; &nbsp; kill(-<a href="globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>, sig);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; kill(<a href="globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>, sig);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * LOCK_TIMEOUT handler: <a href="../adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> a query-cancel interrupt.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1399">&#x200c;</a></span><span class="linkable">LockTimeoutHandler</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef HAVE_SETSID<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* try to signal whole process group */<br/></li>
<li></span>&nbsp; &nbsp; kill(-<a href="globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>, <span class="Constant">SIGINT</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; kill(<a href="globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>, <span class="Constant">SIGINT</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1409">&#x200c;</a></span><span class="linkable">TransactionTimeoutHandler</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="globals.c.html#L36" title="utils/init/globals.c:36">TransactionTimeoutPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1417">&#x200c;</a></span><span class="linkable">IdleInTransactionSessionTimeoutHandler</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="globals.c.html#L35" title="utils/init/globals.c:35">IdleInTransactionSessionTimeoutPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1425">&#x200c;</a></span><span class="linkable">IdleSessionTimeoutHandler</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="globals.c.html#L37" title="utils/init/globals.c:37">IdleSessionTimeoutPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1433">&#x200c;</a></span><span class="linkable">IdleStatsUpdateTimeoutHandler</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="globals.c.html#L40" title="utils/init/globals.c:40">IdleStatsUpdateTimeoutPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1441">&#x200c;</a></span><span class="linkable">ClientCheckTimeoutHandler</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="globals.c.html#L33" title="utils/init/globals.c:33">CheckClientConnectionPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns true if at least one role is defined in this database <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1452">&#x200c;</a></span><span class="linkable">ThereIsAtLeastOneRole</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_authid_rel;<br/></li>
<li>&nbsp; &nbsp; TableScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_authid_rel = <a href="../../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AuthIdRelationId, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan = <a href="../../access/table/tableam.c.html#L112" title="access/table/tableam.c:112">table_beginscan_catalog</a>(pg_authid_rel, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; result = (<a href="../../access/heap/heapam.c.html#L1248" title="access/heap/heapam.c:1248">heap_getnext</a>(scan, ForwardScanDirection) != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; table_endscan(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_authid_rel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
