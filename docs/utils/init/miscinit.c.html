<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/init/miscinit.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/init/miscinit.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L494">AuthenticatedUserId</a></li>
<li><a href="#L497">CurrentUserId</a></li>
<li><a href="#L80">IgnoreSystemIndexes</a></li>
<li><a href="#L68">LocalLatchData</a></li>
<li><a href="#L61">Mode</a></li>
<li><a href="#L63">MyBackendType</a></li>
<li><a href="#L1010">MyClientConnectionInfo</a></li>
<li><a href="#L496">OuterUserId</a></li>
<li><a href="#L503">SecurityRestrictionContext</a></li>
<li><a href="#L495">SessionUserId</a></li>
<li><a href="#L501">SessionUserIsSuperuser</a></li>
<li><a href="#L506">SetRoleIsActive</a></li>
<li><a href="#L498">SystemUser</a></li>
<li><a href="#L1775">local_preload_libraries_string</a></li>
<li><a href="#L66">lock_files</a></li>
<li><a href="#L1779">process_shared_preload_libraries_done</a></li>
<li><a href="#L1778">process_shared_preload_libraries_in_progress</a></li>
<li><a href="#L1782">process_shmem_requests_in_progress</a></li>
<li><a href="#L1773">session_preload_libraries_string</a></li>
<li><a href="#L1774">shared_preload_libraries_string</a></li>
<li><a href="#L1781">shmem_request_hook</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L1017">SerializedClientConnectionInfo</a></li>
<li><a href="#L1021">SerializedClientConnectionInfo</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1511">AddToDataDirLockFile</a></li>
<li><a href="#L454">ChangeToDataDir</a></li>
<li><a href="#L1455">CreateDataDirLockFile</a></li>
<li><a href="#L1150">CreateLockFile</a></li>
<li><a href="#L1464">CreateSocketLockFile</a></li>
<li><a href="#L1027">EstimateClientConnectionInfoSpace</a></li>
<li><a href="#L583">GetAuthenticatedUserId</a></li>
<li><a href="#L263">GetBackendTypeDesc</a></li>
<li><a href="#L924">GetCurrentRoleId</a></li>
<li><a href="#L525">GetOuterUserId</a></li>
<li><a href="#L548">GetSessionUserId</a></li>
<li><a href="#L574">GetSystemUser</a></li>
<li><a href="#L514">GetUserId</a></li>
<li><a href="#L684">GetUserIdAndContext</a></li>
<li><a href="#L635">GetUserIdAndSecContext</a></li>
<li><a href="#L980">GetUserNameFromId</a></li>
<li><a href="#L653">InLocalUserIdChange</a></li>
<li><a href="#L671">InNoForceRLSOperation</a></li>
<li><a href="#L662">InSecurityRestrictedOperation</a></li>
<li><a href="#L95">InitPostmasterChild</a></li>
<li><a href="#L241">InitProcessLocalLatch</a></li>
<li><a href="#L181">InitStandaloneProcess</a></li>
<li><a href="#L733">InitializeSessionUserId</a></li>
<li><a href="#L837">InitializeSessionUserIdStandalone</a></li>
<li><a href="#L867">InitializeSystemUser</a></li>
<li><a href="#L1638">RecheckDataDirLockFile</a></li>
<li><a href="#L1075">RestoreClientConnectionInfo</a></li>
<li><a href="#L1043">SerializeClientConnectionInfo</a></li>
<li><a href="#L945">SetCurrentRoleId</a></li>
<li><a href="#L434">SetDataDir</a></li>
<li><a href="#L328">SetDatabasePath</a></li>
<li><a href="#L533">SetOuterUserId</a></li>
<li><a href="#L908">SetSessionAuthorization</a></li>
<li><a href="#L556">SetSessionUserId</a></li>
<li><a href="#L691">SetUserIdAndContext</a></li>
<li><a href="#L642">SetUserIdAndSecContext</a></li>
<li><a href="#L248">SwitchBackToLocalLatch</a></li>
<li><a href="#L221">SwitchToSharedLatch</a></li>
<li><a href="#L1482">TouchSocketLockFiles</a></li>
<li><a href="#L1115">UnlinkLockFiles</a></li>
<li><a href="#L1710">ValidatePgVersion</a></li>
<li><a href="#L341">checkDataDir</a></li>
<li><a href="#L711">has_rolreplication</a></li>
<li><a href="#L1791">load_libraries</a></li>
<li><a href="#L1880">pg_bindtextdomain</a></li>
<li><a href="#L1857">process_session_preload_libraries</a></li>
<li><a href="#L1843">process_shared_preload_libraries</a></li>
<li><a href="#L1871">process_shmem_requests</a></li>
<li><a href="#L891">system_user</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L59">DIRECTORY_LOCK_FILE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * miscinit.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; miscellaneous initialization support stuff<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/init/miscinit.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;sys/param.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;time.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/file.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/time.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;grp.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;pwd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;netinet/in.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;arpa/inet.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;utime.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_authid.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/file_perm.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/libpq.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/autovacuum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/interrupt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/postmaster.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/slotsync.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/latch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pg_shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pmsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pidfile.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/varlena.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L59">&#x200c;</a><span class="PreProc">#define <span class="linkable">DIRECTORY_LOCK_FILE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">&quot;postmaster.pid&quot;<br/></li>
<li></span><br/></li>
<li><a id="L61">&#x200c;</a>ProcessingMode <span class="linkable">Mode</span> = InitProcessing;<br/></li>
<li><br/></li>
<li><a id="L63">&#x200c;</a>BackendType <span class="linkable">MyBackendType</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* List of lock files to be removed at proc exit */<br/></li>
<li><a id="L66">&#x200c;</a></span><span class="Type">static</span> List *<span class="linkable">lock_files</span> = NIL;<br/></li>
<li><br/></li>
<li><a id="L68">&#x200c;</a><span class="Type">static</span> Latch <span class="linkable">LocalLatchData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ignoring system indexes support stuff<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: &quot;ignoring system indexes&quot; means we do not use the system indexes<br/></li>
<li></span><span class="Comment"> * for lookups (either in hardwired catalog accesses or in <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>-generated<br/></li>
<li></span><span class="Comment"> * plans).&nbsp; We do, however, still update the indexes when a catalog<br/></li>
<li></span><span class="Comment"> * modification is made.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L80">&#x200c;</a><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">IgnoreSystemIndexes</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; common process startup code<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the basic environment for a postmaster child<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Should be called as early as possible after the child's startup. However,<br/></li>
<li></span><span class="Comment"> * on EXEC_BACKEND builds it does need to be after <a href="../../postmaster/launch_backend.c.html#L866" title="postmaster/launch_backend.c:866">read_backend_variables</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L95">&#x200c;</a></span><span class="linkable">InitPostmasterChild</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* we are a postmaster subprocess <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start our win32 signal implementation. This has to be done after we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read the backend variables, because we need to pick up the signal pipe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the parent process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L79" title="port/win32/signal.c:79">pgwin32_signal_initialize</a>();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set reference point for stack-depth checking.&nbsp; This might seem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * redundant in !EXEC_BACKEND builds, but it's better to keep the depth<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * logic the same with and without that build option.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../tcop/postgres.c.html#L3481" title="tcop/postgres.c:3481">set_stack_base</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../postmaster/postmaster.c.html#L2032" title="postmaster/postmaster.c:2032">InitProcessGlobals</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * make sure stderr is in binary mode <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> anything can possibly be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * written to it, in case it's actually the syslogger pipe, so the pipe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chunking protocol isn't disturbed. Non-logpipe data gets translated on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * redirection (e.g. via pg_ctl -l) anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; _setmode(fileno(<span class="Constant">stderr</span>), _O_BINARY);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't want the postmaster's <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>() handlers */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L416" title="storage/ipc/ipc.c:416">on_exit_reset</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* In EXEC_BACKEND case we will not have inherited <a href="../../libpq/pqsignal.c.html#L23" title="libpq/pqsignal.c:23">BlockSig</a> etc <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../libpq/pqsignal.c.html#L41" title="libpq/pqsignal.c:41">pqinitmask</a>();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize process-local latch support */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L232" title="storage/ipc/latch.c:232">InitializeLatchSupport</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L241" title="utils/init/miscinit.c:241">InitProcessLocalLatch</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L346" title="storage/ipc/latch.c:346">InitializeLatchWaitSet</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If possible, make this process a group leader, so that the postmaster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can signal <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> child processes too. Not all processes will have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * children, but for consistency we make all postmaster child processes do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef HAVE_SETSID<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (setsid() &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;setsid() failed: %m&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Every postmaster child process is expected to respond promptly to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SIGQUIT at all times.&nbsp; Therefore we centrally remove SIGQUIT from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../libpq/pqsignal.c.html#L23" title="libpq/pqsignal.c:23">BlockSig</a> and install a suitable signal handler.&nbsp; (Client-facing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processes may choose to replace this default choice of handler with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../tcop/postgres.c.html#L2875" title="tcop/postgres.c:2875">quickdie</a>().)&nbsp; All other blockable signals remain blocked for <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGQUIT</span>, <a href="../../postmaster/interrupt.c.html#L73" title="postmaster/interrupt.c:73">SignalHandlerForCrashExit</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sigdelset(&amp;<a href="../../libpq/pqsignal.c.html#L23" title="libpq/pqsignal.c:23">BlockSig</a>, <span class="Constant">SIGQUIT</span>);<br/></li>
<li>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../../libpq/pqsignal.c.html#L23" title="libpq/pqsignal.c:23">BlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Request a signal if the postmaster dies, if possible. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/pmsignal.c.html#L437" title="storage/ipc/pmsignal.c:437">PostmasterDeathSignalInit</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't give the pipe to subprograms that we execute. */<br/></li>
<li></span><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcntl(<a href="../../postmaster/postmaster.c.html#L479" title="postmaster/postmaster.c:479">postmaster_alive_fds</a>[POSTMASTER_FD_WATCH], F_SETFD, FD_CLOEXEC) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;could not set postmaster death monitoring pipe to FD_CLOEXEC mode: %m&quot;</span>)));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the basic environment for a standalone process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * argv0 has to be suitable to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the program's executable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L181">&#x200c;</a></span><span class="linkable">InitStandaloneProcess</span>(<span class="Type">const</span> <span class="Type">char</span> *argv0)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="globals.c.html#L116" title="utils/init/globals.c:116">IsPostmasterEnvironment</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L63" title="utils/init/miscinit.c:63">MyBackendType</a> = B_STANDALONE_BACKEND;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start our win32 signal implementation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L79" title="port/win32/signal.c:79">pgwin32_signal_initialize</a>();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../postmaster/postmaster.c.html#L2032" title="postmaster/postmaster.c:2032">InitProcessGlobals</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize process-local latch support */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L232" title="storage/ipc/latch.c:232">InitializeLatchSupport</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L241" title="utils/init/miscinit.c:241">InitProcessLocalLatch</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L346" title="storage/ipc/latch.c:346">InitializeLatchWaitSet</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For consistency with <a href="#L95" title="utils/init/miscinit.c:95">InitPostmasterChild</a>, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> signal mask here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * But we don't unblock SIGQUIT or provide a default handler for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../libpq/pqsignal.c.html#L41" title="libpq/pqsignal.c:41">pqinitmask</a>();<br/></li>
<li>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../../libpq/pqsignal.c.html#L23" title="libpq/pqsignal.c:23">BlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute paths, no postmaster to inherit from */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="globals.c.html#L78" title="utils/init/globals.c:78">my_exec_path</a>[<span class="Constant">0</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (find_my_exec(argv0, <a href="globals.c.html#L78" title="utils/init/globals.c:78">my_exec_path</a>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: could not locate my own executable path&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; argv0);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="globals.c.html#L79" title="utils/init/globals.c:79">pkglib_path</a>[<span class="Constant">0</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; get_pkglib_path(<a href="globals.c.html#L78" title="utils/init/globals.c:78">my_exec_path</a>, <a href="globals.c.html#L79" title="utils/init/globals.c:79">pkglib_path</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L221">&#x200c;</a></span><span class="linkable">SwitchToSharedLatch</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a> == &amp;<a href="#L68" title="utils/init/miscinit.c:68">LocalLatchData</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a> = &amp;<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;procLatch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../libpq/pqcomm.c.html#L165" title="libpq/pqcomm.c:165">FeBeWaitSet</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L1049" title="storage/ipc/latch.c:1049">ModifyWaitEvent</a>(<a href="../../libpq/pqcomm.c.html#L165" title="libpq/pqcomm.c:165">FeBeWaitSet</a>, FeBeWaitSetLatchPos, WL_LATCH_SET,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the shared latch as the local one might have been set. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shouldn't normally be necessary as code is supposed to check the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * condition <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the latch, but a <a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> care can't hurt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L241">&#x200c;</a></span><span class="linkable">InitProcessLocalLatch</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a> = &amp;<a href="#L68" title="utils/init/miscinit.c:68">LocalLatchData</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L394" title="storage/ipc/latch.c:394">InitLatch</a>(<a href="globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L248">&#x200c;</a></span><span class="linkable">SwitchBackToLocalLatch</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a> != &amp;<a href="#L68" title="utils/init/miscinit.c:68">LocalLatchData</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a> != <span class="Constant">NULL</span> &amp;&amp; <a href="globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a> == &amp;<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;procLatch);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a> = &amp;<a href="#L68" title="utils/init/miscinit.c:68">LocalLatchData</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../libpq/pqcomm.c.html#L165" title="libpq/pqcomm.c:165">FeBeWaitSet</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L1049" title="storage/ipc/latch.c:1049">ModifyWaitEvent</a>(<a href="../../libpq/pqcomm.c.html#L165" title="libpq/pqcomm.c:165">FeBeWaitSet</a>, FeBeWaitSetLatchPos, WL_LATCH_SET,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L263">&#x200c;</a><span class="linkable">GetBackendTypeDesc</span>(BackendType backendType)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *backendDesc = <span class="Constant">&quot;unknown process type&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (backendType)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_INVALID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backendDesc = <span class="Constant">&quot;not initialized&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_ARCHIVER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backendDesc = <span class="Constant">&quot;archiver&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_AUTOVAC_LAUNCHER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backendDesc = <span class="Constant">&quot;autovacuum launcher&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_AUTOVAC_WORKER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backendDesc = <span class="Constant">&quot;autovacuum worker&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_BACKEND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backendDesc = <span class="Constant">&quot;client backend&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_BG_WORKER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backendDesc = <span class="Constant">&quot;background worker&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_BG_WRITER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backendDesc = <span class="Constant">&quot;background writer&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_CHECKPOINTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backendDesc = <span class="Constant">&quot;checkpointer&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_LOGGER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backendDesc = <span class="Constant">&quot;logger&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_SLOTSYNC_WORKER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backendDesc = <span class="Constant">&quot;slotsync worker&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_STANDALONE_BACKEND:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backendDesc = <span class="Constant">&quot;standalone backend&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_STARTUP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backendDesc = <span class="Constant">&quot;startup&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_WAL_RECEIVER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backendDesc = <span class="Constant">&quot;walreceiver&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_WAL_SENDER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backendDesc = <span class="Constant">&quot;walsender&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_WAL_SUMMARIZER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backendDesc = <span class="Constant">&quot;walsummarizer&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> B_WAL_WRITER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backendDesc = <span class="Constant">&quot;walwriter&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> backendDesc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; database path / name support stuff<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L328">&#x200c;</a></span><span class="linkable">SetDatabasePath</span>(<span class="Type">const</span> <span class="Type">char</span> *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This should happen only once per process */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="globals.c.html#L101" title="utils/init/globals.c:101">DatabasePath</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="globals.c.html#L101" title="utils/init/globals.c:101">DatabasePath</a> = <a href="../mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, path);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Validate the proposed data directory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> file and directory create modes and mode mask.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L341">&#x200c;</a></span><span class="linkable">checkDataDir</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat stat_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(<a href="globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, &amp;stat_buf) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;data directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read permissions of directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* eventual chdir would fail anyway, but let's test ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!S_ISDIR(stat_buf.st_mode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;specified data directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a directory&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that the directory belongs to my userid; if not, reject.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This check is an essential part of the interlock that prevents two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * postmasters from starting in the same directory (see <a href="#L1150" title="utils/init/miscinit.c:1150">CreateLockFile</a>()).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do not remove or weaken it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> can we safely enable this check on Windows?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#if !defined(WIN32) &amp;&amp; !defined(__CYGWIN__)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stat_buf.st_uid != geteuid())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;data directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has wrong ownership&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;The server must be started by the user that owns the data directory.&quot;</span>)));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if the directory has correct permissions.&nbsp; If not, reject.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Only two possible modes are allowed, 0700 and 0750.&nbsp; The latter mode<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indicates that group read/execute should be allowed on all newly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * created files and directories.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> temporarily suppress check when on Windows, because there may not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be proper support for Unix-y file permissions.&nbsp; Need to think of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reasonable check to apply on Windows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#if !defined(WIN32) &amp;&amp; !defined(__CYGWIN__)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stat_buf.st_mode &amp; PG_MODE_MASK_GROUP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;data directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has invalid permissions&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Permissions should be u=rwx (0700) or u=rwx,g=rx (0750).&quot;</span>)));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset creation modes and mask based on the mode of the data directory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The mask was set earlier in startup to disallow group permissions on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * newly created files and directories.&nbsp; However, if group read/execute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are present on the data directory then modify the create modes and mask<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to allow group read/execute on newly created files and directories and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set the <a href="globals.c.html#L74" title="utils/init/globals.c:74">data_directory_mode</a> GUC.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Suppress when on Windows, because there may not be proper support for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unix-y file permissions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#if !defined(WIN32) &amp;&amp; !defined(__CYGWIN__)<br/></li>
<li></span>&nbsp; &nbsp; SetDataDirectoryCreatePerm(stat_buf.st_mode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; umask(pg_mode_mask);<br/></li>
<li>&nbsp; &nbsp; <a href="globals.c.html#L74" title="utils/init/globals.c:74">data_directory_mode</a> = pg_dir_create_mode;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for PG_VERSION */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1710" title="utils/init/miscinit.c:1710">ValidatePgVersion</a>(<a href="globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set data directory, but make sure it's an absolute path.&nbsp; Use this,<br/></li>
<li></span><span class="Comment"> * never set <a href="globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a> directly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L434">&#x200c;</a></span><span class="linkable">SetDataDir</span>(<span class="Type">const</span> <span class="Type">char</span> *dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *new;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(dir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If presented path is relative, convert to absolute */<br/></li>
<li></span>&nbsp; &nbsp; new = make_absolute_path(dir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; free(<a href="globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a> = new;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Change working directory to <a href="globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>.&nbsp; Most of the postmaster and backend<br/></li>
<li></span><span class="Comment"> * code assumes that we are in <a href="globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a> so it can use relative paths to access<br/></li>
<li></span><span class="Comment"> * stuff in and under the data directory.&nbsp; For convenience during path<br/></li>
<li></span><span class="Comment"> * setup, however, we don't force the chdir to occur during <a href="#L434" title="utils/init/miscinit.c:434">SetDataDir</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L454">&#x200c;</a></span><span class="linkable">ChangeToDataDir</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (chdir(<a href="globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not change directory to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; User ID state<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We have to track several different <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> associated with the concept<br/></li>
<li></span><span class="Comment"> * of &quot;user ID&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L494" title="utils/init/miscinit.c:494">AuthenticatedUserId</a> is determined at connection start and never changes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L495" title="utils/init/miscinit.c:495">SessionUserId</a> is initially the same as <a href="#L494" title="utils/init/miscinit.c:494">AuthenticatedUserId</a>, but can be<br/></li>
<li></span><span class="Comment"> * changed by <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> SESSION AUTHORIZATION (if <a href="#L494" title="utils/init/miscinit.c:494">AuthenticatedUserId</a> is a<br/></li>
<li></span><span class="Comment"> * <a href="../misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a>).&nbsp; This is the ID reported by the SESSION_USER SQL function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L496" title="utils/init/miscinit.c:496">OuterUserId</a> is the current user ID in effect at the &quot;outer level&quot; (outside<br/></li>
<li></span><span class="Comment"> * <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transaction or function).&nbsp; This is initially the same as <a href="#L495" title="utils/init/miscinit.c:495">SessionUserId</a>,<br/></li>
<li></span><span class="Comment"> * but can be changed by <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ROLE to <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> role that <a href="#L495" title="utils/init/miscinit.c:495">SessionUserId</a> is a<br/></li>
<li></span><span class="Comment"> * member of.&nbsp; (</span><span class="Todo">XXX</span><span class="Comment"> rename to something like CurrentRoleId?)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L497" title="utils/init/miscinit.c:497">CurrentUserId</a> is the current effective user ID; this is the one to use<br/></li>
<li></span><span class="Comment"> * for all normal permissions-checking purposes.&nbsp; At outer level this will<br/></li>
<li></span><span class="Comment"> * be the same as <a href="#L496" title="utils/init/miscinit.c:496">OuterUserId</a>, but it changes during calls to SECURITY<br/></li>
<li></span><span class="Comment"> * DEFINER <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, as well as locally in some specialized commands.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L503" title="utils/init/miscinit.c:503">SecurityRestrictionContext</a> holds flags indicating reason(s) for changing<br/></li>
<li></span><span class="Comment"> * <a href="#L497" title="utils/init/miscinit.c:497">CurrentUserId</a>.&nbsp; In some cases we need to lock down operations that are<br/></li>
<li></span><span class="Comment"> * not directly controlled by privilege settings, and this provides a<br/></li>
<li></span><span class="Comment"> * convenient way to do it.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L494">&#x200c;</a></span><span class="Type">static</span> Oid&nbsp; &nbsp; <span class="linkable">AuthenticatedUserId</span> = InvalidOid;<br/></li>
<li><a id="L495">&#x200c;</a><span class="Type">static</span> Oid&nbsp; &nbsp; <span class="linkable">SessionUserId</span> = InvalidOid;<br/></li>
<li><a id="L496">&#x200c;</a><span class="Type">static</span> Oid&nbsp; &nbsp; <span class="linkable">OuterUserId</span> = InvalidOid;<br/></li>
<li><a id="L497">&#x200c;</a><span class="Type">static</span> Oid&nbsp; &nbsp; <span class="linkable">CurrentUserId</span> = InvalidOid;<br/></li>
<li><a id="L498">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<span class="linkable">SystemUser</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* We also have to remember the <a href="../misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a> state of the session user */<br/></li>
<li><a id="L501">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">SessionUserIsSuperuser</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><a id="L503">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">SecurityRestrictionContext</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* We also remember if a <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ROLE is currently active */<br/></li>
<li><a id="L506">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">SetRoleIsActive</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L514" title="utils/init/miscinit.c:514">GetUserId</a> - get the current effective user ID.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: there's no SetUserId() anymore; use <a href="#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L514">&#x200c;</a><span class="linkable">GetUserId</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(<a href="#L497" title="utils/init/miscinit.c:497">CurrentUserId</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L497" title="utils/init/miscinit.c:497">CurrentUserId</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L525" title="utils/init/miscinit.c:525">GetOuterUserId</a>/<a href="#L533" title="utils/init/miscinit.c:533">SetOuterUserId</a> - get/set the outer-level user ID.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L525">&#x200c;</a><span class="linkable">GetOuterUserId</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(<a href="#L496" title="utils/init/miscinit.c:496">OuterUserId</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L496" title="utils/init/miscinit.c:496">OuterUserId</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L533">&#x200c;</a></span><span class="linkable">SetOuterUserId</span>(Oid userid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L503" title="utils/init/miscinit.c:503">SecurityRestrictionContext</a> == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(userid));<br/></li>
<li>&nbsp; &nbsp; <a href="#L496" title="utils/init/miscinit.c:496">OuterUserId</a> = userid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We force the effective user ID to match, too */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L497" title="utils/init/miscinit.c:497">CurrentUserId</a> = userid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L548" title="utils/init/miscinit.c:548">GetSessionUserId</a>/<a href="#L556" title="utils/init/miscinit.c:556">SetSessionUserId</a> - get/set the session user ID.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L548">&#x200c;</a><span class="linkable">GetSessionUserId</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(<a href="#L495" title="utils/init/miscinit.c:495">SessionUserId</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L495" title="utils/init/miscinit.c:495">SessionUserId</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L556">&#x200c;</a></span><span class="linkable">SetSessionUserId</span>(Oid userid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_superuser)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L503" title="utils/init/miscinit.c:503">SecurityRestrictionContext</a> == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(userid));<br/></li>
<li>&nbsp; &nbsp; <a href="#L495" title="utils/init/miscinit.c:495">SessionUserId</a> = userid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L501" title="utils/init/miscinit.c:501">SessionUserIsSuperuser</a> = is_superuser;<br/></li>
<li>&nbsp; &nbsp; <a href="#L506" title="utils/init/miscinit.c:506">SetRoleIsActive</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We force the effective user IDs to match, too */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L496" title="utils/init/miscinit.c:496">OuterUserId</a> = userid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L497" title="utils/init/miscinit.c:497">CurrentUserId</a> = userid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the system user representing the authenticated identity.<br/></li>
<li></span><span class="Comment"> * It is defined in <a href="#L867" title="utils/init/miscinit.c:867">InitializeSystemUser</a>() as auth_method:authn_id.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L574">&#x200c;</a><span class="linkable">GetSystemUser</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L498" title="utils/init/miscinit.c:498">SystemUser</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L583" title="utils/init/miscinit.c:583">GetAuthenticatedUserId</a> - get the authenticated user ID<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L583">&#x200c;</a><span class="linkable">GetAuthenticatedUserId</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(<a href="#L494" title="utils/init/miscinit.c:494">AuthenticatedUserId</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L494" title="utils/init/miscinit.c:494">AuthenticatedUserId</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L635" title="utils/init/miscinit.c:635">GetUserIdAndSecContext</a>/<a href="#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a> - get/set the current user ID<br/></li>
<li></span><span class="Comment"> * and the <a href="#L503" title="utils/init/miscinit.c:503">SecurityRestrictionContext</a> flags.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently there are three valid bits in <a href="#L503" title="utils/init/miscinit.c:503">SecurityRestrictionContext</a>:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * SECURITY_LOCAL_USERID_CHANGE indicates that we are inside an operation<br/></li>
<li></span><span class="Comment"> * that is temporarily changing <a href="#L497" title="utils/init/miscinit.c:497">CurrentUserId</a> via these <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; This is<br/></li>
<li></span><span class="Comment"> * needed to indicate that the actual value of <a href="#L497" title="utils/init/miscinit.c:497">CurrentUserId</a> is not in sync<br/></li>
<li></span><span class="Comment"> * with guc.c's <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> state, so <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ROLE has to be disallowed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * SECURITY_RESTRICTED_OPERATION indicates that we are inside an operation<br/></li>
<li></span><span class="Comment"> * that does not wish to trust called user-defined <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> at all.&nbsp; The<br/></li>
<li></span><span class="Comment"> * policy is to use this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> operations, e.g. autovacuum and REINDEX, that<br/></li>
<li></span><span class="Comment"> * enumerate relations of a database or schema and run <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> associated<br/></li>
<li></span><span class="Comment"> * with each found relation.&nbsp; The relation owner is the new user ID.&nbsp; Set this<br/></li>
<li></span><span class="Comment"> * as soon as possible after locking the relation.&nbsp; Restore the old user ID as<br/></li>
<li></span><span class="Comment"> * late as possible <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> closing the relation; restoring it shortly after<br/></li>
<li></span><span class="Comment"> * close is also tolerable.&nbsp; If a command has both relation-enumerating and<br/></li>
<li></span><span class="Comment"> * non-enumerating modes, e.g. ANALYZE, both modes set this <a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>.&nbsp; This <a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment"> * prevents not only <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ROLE, but various other changes of session state that<br/></li>
<li></span><span class="Comment"> * normally is unprotected but might possibly be used to subvert the calling<br/></li>
<li></span><span class="Comment"> * session later.&nbsp; An example is replacing an existing prepared statement with<br/></li>
<li></span><span class="Comment"> * new code, which will then be executed with the outer session's permissions<br/></li>
<li></span><span class="Comment"> * when the prepared statement is <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> used.&nbsp; These restrictions are fairly<br/></li>
<li></span><span class="Comment"> * draconian, but the <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> called in relation-enumerating operations are<br/></li>
<li></span><span class="Comment"> * really supposed to be side-effect-free anyway.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * SECURITY_NOFORCE_RLS indicates that we are inside an operation which should<br/></li>
<li></span><span class="Comment"> * ignore the FORCE ROW LEVEL SECURITY per-table indication.&nbsp; This is used to<br/></li>
<li></span><span class="Comment"> * ensure that FORCE RLS does not mistakenly break referential integrity<br/></li>
<li></span><span class="Comment"> * checks.&nbsp; Note that this is intentionally only checked when running as the<br/></li>
<li></span><span class="Comment"> * owner of the table (which should always be the case for referential<br/></li>
<li></span><span class="Comment"> * integrity checks).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike <a href="#L514" title="utils/init/miscinit.c:514">GetUserId</a>, <a href="#L635" title="utils/init/miscinit.c:635">GetUserIdAndSecContext</a> does *not* Assert that the current<br/></li>
<li></span><span class="Comment"> * value of <a href="#L497" title="utils/init/miscinit.c:497">CurrentUserId</a> is valid; nor does <a href="#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a> require<br/></li>
<li></span><span class="Comment"> * the new value to be valid.&nbsp; In fact, these routines had better not<br/></li>
<li></span><span class="Comment"> * ever throw <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> kind of error.&nbsp; This is because they are used by<br/></li>
<li></span><span class="Comment"> * <a href="../../access/transam/xact.c.html#L2014" title="access/transam/xact.c:2014">StartTransaction</a> and <a href="../../access/transam/xact.c.html#L2749" title="access/transam/xact.c:2749">AbortTransaction</a> to save/restore the settings,<br/></li>
<li></span><span class="Comment"> * and during the first transaction within a backend, the value to be saved<br/></li>
<li></span><span class="Comment"> * and perhaps restored is indeed invalid.&nbsp; We have to be able to get<br/></li>
<li></span><span class="Comment"> * through <a href="../../access/transam/xact.c.html#L2749" title="access/transam/xact.c:2749">AbortTransaction</a> without asserting in case <a href="postinit.c.html#L736" title="utils/init/postinit.c:736">InitPostgres</a> fails.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L635">&#x200c;</a></span><span class="linkable">GetUserIdAndSecContext</span>(Oid *userid, <span class="Type">int</span> *sec_context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; *userid = <a href="#L497" title="utils/init/miscinit.c:497">CurrentUserId</a>;<br/></li>
<li>&nbsp; &nbsp; *sec_context = <a href="#L503" title="utils/init/miscinit.c:503">SecurityRestrictionContext</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L642">&#x200c;</a></span><span class="linkable">SetUserIdAndSecContext</span>(Oid userid, <span class="Type">int</span> sec_context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L497" title="utils/init/miscinit.c:497">CurrentUserId</a> = userid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L503" title="utils/init/miscinit.c:503">SecurityRestrictionContext</a> = sec_context;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L653" title="utils/init/miscinit.c:653">InLocalUserIdChange</a> - are we inside a local change of <a href="#L497" title="utils/init/miscinit.c:497">CurrentUserId</a>?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L653">&#x200c;</a></span><span class="linkable">InLocalUserIdChange</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L503" title="utils/init/miscinit.c:503">SecurityRestrictionContext</a> &amp; SECURITY_LOCAL_USERID_CHANGE) != <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L662" title="utils/init/miscinit.c:662">InSecurityRestrictedOperation</a> - are we inside a security-restricted command?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L662">&#x200c;</a></span><span class="linkable">InSecurityRestrictedOperation</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L503" title="utils/init/miscinit.c:503">SecurityRestrictionContext</a> &amp; SECURITY_RESTRICTED_OPERATION) != <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L671" title="utils/init/miscinit.c:671">InNoForceRLSOperation</a> - are we ignoring FORCE ROW LEVEL SECURITY ?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L671">&#x200c;</a></span><span class="linkable">InNoForceRLSOperation</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L503" title="utils/init/miscinit.c:503">SecurityRestrictionContext</a> &amp; SECURITY_NOFORCE_RLS) != <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These are obsolete versions of Get/<a href="#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a> that are<br/></li>
<li></span><span class="Comment"> * only provided for bug-compatibility with some rather dubious code in<br/></li>
<li></span><span class="Comment"> * pljava.&nbsp; We allow the userid to be set, but only when not inside a<br/></li>
<li></span><span class="Comment"> * security restriction context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L684">&#x200c;</a></span><span class="linkable">GetUserIdAndContext</span>(Oid *userid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *sec_def_context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; *userid = <a href="#L497" title="utils/init/miscinit.c:497">CurrentUserId</a>;<br/></li>
<li>&nbsp; &nbsp; *sec_def_context = <a href="#L653" title="utils/init/miscinit.c:653">InLocalUserIdChange</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L691">&#x200c;</a></span><span class="linkable">SetUserIdAndContext</span>(Oid userid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> sec_def_context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We throw the same error <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ROLE would. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L662" title="utils/init/miscinit.c:662">InSecurityRestrictedOperation</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot set parameter </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> within security-restricted operation&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;role&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <a href="#L497" title="utils/init/miscinit.c:497">CurrentUserId</a> = userid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sec_def_context)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L503" title="utils/init/miscinit.c:503">SecurityRestrictionContext</a> |= SECURITY_LOCAL_USERID_CHANGE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L503" title="utils/init/miscinit.c:503">SecurityRestrictionContext</a> &amp;= ~SECURITY_LOCAL_USERID_CHANGE;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether specified role has explicit REPLICATION privilege<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L711">&#x200c;</a></span><span class="linkable">has_rolreplication</span>(Oid roleid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; utup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Superusers bypass all permission checking. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../misc/superuser.c.html#L56" title="utils/misc/superuser.c:56">superuser_arg</a>(roleid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; utup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(AUTHOID, ObjectIdGetDatum(roleid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(utup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = ((Form_pg_authid) GETSTRUCT(utup))-&gt;rolreplication;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(utup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize user identity during normal backend startup<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L733">&#x200c;</a></span><span class="linkable">InitializeSessionUserId</span>(<span class="Type">const</span> <span class="Type">char</span> *rolename, Oid roleid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> bypass_login_check)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; roleTup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_authid rform;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *rname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_superuser;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't do scans if we're bootstrapping, <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the system catalogs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exist yet, and they should be owned by postgres anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!IsBootstrapProcessingMode());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* call only once */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!OidIsValid(<a href="#L494" title="utils/init/miscinit.c:494">AuthenticatedUserId</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure syscache entries are flushed for recent catalog changes. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allows us to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> roles that were created on-the-fly during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * authentication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../cache/inval.c.html#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rolename != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; roleTup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(AUTHNAME, PointerGetDatum(rolename));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(roleTup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;role </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, rolename)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; roleTup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(AUTHOID, ObjectIdGetDatum(roleid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(roleTup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;role with OID </span><span class="Special">%u</span><span class="Constant"> does not exist&quot;</span>, roleid)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rform = (Form_pg_authid) GETSTRUCT(roleTup);<br/></li>
<li>&nbsp; &nbsp; roleid = rform-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; rname = NameStr(rform-&gt;rolname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L494" title="utils/init/miscinit.c:494">AuthenticatedUserId</a> = roleid;<br/></li>
<li>&nbsp; &nbsp; is_superuser = rform-&gt;rolsuper;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This sets <a href="#L496" title="utils/init/miscinit.c:496">OuterUserId</a>/<a href="#L497" title="utils/init/miscinit.c:497">CurrentUserId</a> too */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L556" title="utils/init/miscinit.c:556">SetSessionUserId</a>(roleid, is_superuser);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Also mark our PGPROC entry with the authenticated user id */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* (We assume this is an atomic store so no lock is needed) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;roleId = roleid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checks are not enforced when in standalone mode, so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there is a way to recover from sillinesses like &quot;UPDATE pg_authid <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rolcanlogin = false;&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Is role allowed to login at all?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!bypass_login_check &amp;&amp; !rform-&gt;rolcanlogin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;role </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not permitted to log in&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check connection limit for this role.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is a race condition here --- we create our PGPROC <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checking for other PGPROCs.&nbsp; If two backends did this at about the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same time, they might both think they were over the limit, while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ideally one should succeed and one fail.&nbsp; Getting that to work<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exactly seems more trouble than it is worth, however; instead we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just document that the connection limit is approximate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rform-&gt;rolconnlimit &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !is_superuser &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L3687" title="storage/ipc/procarray.c:3687">CountUserBackends</a>(roleid) &gt; rform-&gt;rolconnlimit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_TOO_MANY_CONNECTIONS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many connections for role </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rname)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Record username and <a href="../misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a> status as GUC settings too */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;session_authorization&quot;</span>, rname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_BACKEND, PGC_S_OVERRIDE);<br/></li>
<li>&nbsp; &nbsp; <a href="../misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;is_superuser&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_superuser ? <span class="Constant">&quot;on&quot;</span> : <span class="Constant">&quot;off&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_INTERNAL, PGC_S_DYNAMIC_DEFAULT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(roleTup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize user identity during special backend startup<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L837">&#x200c;</a></span><span class="linkable">InitializeSessionUserIdStandalone</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This function should only be called in single-user mode, in autovacuum<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * workers, in slot sync worker and in background workers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> || AmAutoVacuumWorkerProcess() ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AmLogicalSlotSyncWorkerProcess() || AmBackgroundWorkerProcess());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* call only once */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!OidIsValid(<a href="#L494" title="utils/init/miscinit.c:494">AuthenticatedUserId</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L494" title="utils/init/miscinit.c:494">AuthenticatedUserId</a> = BOOTSTRAP_SUPERUSERID;<br/></li>
<li>&nbsp; &nbsp; <a href="#L556" title="utils/init/miscinit.c:556">SetSessionUserId</a>(BOOTSTRAP_SUPERUSERID, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> This should set <a href="../misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(&quot;session_authorization&quot;), too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we don't, C code will get NULL, and current_setting() will get an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * empty string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;is_superuser&quot;</span>, <span class="Constant">&quot;on&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_INTERNAL, PGC_S_DYNAMIC_DEFAULT);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the system user.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is built as auth_method:authn_id.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L867">&#x200c;</a></span><span class="linkable">InitializeSystemUser</span>(<span class="Type">const</span> <span class="Type">char</span> *authn_id, <span class="Type">const</span> <span class="Type">char</span> *auth_method)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<a href="#L891" title="utils/init/miscinit.c:891">system_user</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* call only once */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L498" title="utils/init/miscinit.c:498">SystemUser</a> == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L867" title="utils/init/miscinit.c:867">InitializeSystemUser</a> should be called only when authn_id is not NULL,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * meaning that auth_method is valid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(authn_id != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L891" title="utils/init/miscinit.c:891">system_user</a> = psprintf(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">&quot;</span>, auth_method, authn_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store <a href="#L498" title="utils/init/miscinit.c:498">SystemUser</a> in long-lived storage */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L498" title="utils/init/miscinit.c:498">SystemUser</a> = <a href="../mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, <a href="#L891" title="utils/init/miscinit.c:891">system_user</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="#L891" title="utils/init/miscinit.c:891">system_user</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL-function SYSTEM_USER<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L891">&#x200c;</a><span class="linkable">system_user</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *sysuser = <a href="#L574" title="utils/init/miscinit.c:574">GetSystemUser</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sysuser)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATUM(CStringGetTextDatum(sysuser));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_NULL();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Change session auth ID while running<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we set the GUC variable is_superuser to indicate whether the<br/></li>
<li></span><span class="Comment"> * current role is a <a href="../misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L908">&#x200c;</a></span><span class="linkable">SetSessionAuthorization</span>(Oid userid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_superuser)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L556" title="utils/init/miscinit.c:556">SetSessionUserId</a>(userid, is_superuser);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;is_superuser&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_superuser ? <span class="Constant">&quot;on&quot;</span> : <span class="Constant">&quot;off&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_INTERNAL, PGC_S_DYNAMIC_DEFAULT);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report current role id<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This follows the semantics of <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ROLE, ie return the outer-level ID<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; not the current effective ID, and return InvalidOid when the setting<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; is logically <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ROLE NONE.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L924">&#x200c;</a><span class="linkable">GetCurrentRoleId</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L506" title="utils/init/miscinit.c:506">SetRoleIsActive</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L496" title="utils/init/miscinit.c:496">OuterUserId</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Change Role ID while running (<a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ROLE)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If roleid is InvalidOid, we are doing <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ROLE NONE: revert to the<br/></li>
<li></span><span class="Comment"> * session user authorization.&nbsp; In this case the is_superuser argument<br/></li>
<li></span><span class="Comment"> * is ignored.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When roleid is not InvalidOid, the caller must have checked whether<br/></li>
<li></span><span class="Comment"> * the session user has permission to become that role.&nbsp; (We cannot check<br/></li>
<li></span><span class="Comment"> * here because this routine must be able to execute in a failed transaction<br/></li>
<li></span><span class="Comment"> * to restore a prior value of the ROLE GUC variable.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L945">&#x200c;</a></span><span class="linkable">SetCurrentRoleId</span>(Oid roleid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_superuser)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get correct info if it's <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> ROLE NONE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="#L495" title="utils/init/miscinit.c:495">SessionUserId</a> hasn't been set yet, just do nothing --- the eventual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L556" title="utils/init/miscinit.c:556">SetSessionUserId</a> call will fix everything.&nbsp; This is needed since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will get called during GUC initialization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(roleid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(<a href="#L495" title="utils/init/miscinit.c:495">SessionUserId</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; roleid = <a href="#L495" title="utils/init/miscinit.c:495">SessionUserId</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; is_superuser = <a href="#L501" title="utils/init/miscinit.c:501">SessionUserIsSuperuser</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L506" title="utils/init/miscinit.c:506">SetRoleIsActive</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L506" title="utils/init/miscinit.c:506">SetRoleIsActive</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L533" title="utils/init/miscinit.c:533">SetOuterUserId</a>(roleid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;is_superuser&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_superuser ? <span class="Constant">&quot;on&quot;</span> : <span class="Constant">&quot;off&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_INTERNAL, PGC_S_DYNAMIC_DEFAULT);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get user name from user oid, returns NULL for nonexistent roleid if noerr<br/></li>
<li></span><span class="Comment"> * is true.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L980">&#x200c;</a><span class="linkable">GetUserNameFromId</span>(Oid roleid, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> noerr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(AUTHOID, ObjectIdGetDatum(roleid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!noerr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid role OID: </span><span class="Special">%u</span><span class="Constant">&quot;</span>, roleid)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(((Form_pg_authid) GETSTRUCT(tuple))-&gt;rolname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Client connection state shared with parallel workers<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ClientConnectionInfo contains pieces of information about the client that<br/></li>
<li></span><span class="Comment"> * need to be synced to parallel workers when they <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a>.<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L1010">&#x200c;</a>ClientConnectionInfo <span class="linkable">MyClientConnectionInfo</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Intermediate representation of ClientConnectionInfo for easier<br/></li>
<li></span><span class="Comment"> * serialization.&nbsp; Variable-length fields are allocated right after this<br/></li>
<li></span><span class="Comment"> * header.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L1017">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SerializedClientConnectionInfo</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; authn_id_len;&nbsp; &nbsp; <span class="Comment">/* strlen(authn_id), or -1 if NULL */<br/></li>
<li></span>&nbsp; &nbsp; UserAuth&nbsp; &nbsp; auth_method;<br/></li>
<li><a id="L1021">&#x200c;</a>} <span class="linkable">SerializedClientConnectionInfo</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Calculate the space needed to serialize <a href="#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L1027">&#x200c;</a><span class="linkable">EstimateClientConnectionInfoSpace</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L1017" title="utils/init/miscinit.c:1017">SerializedClientConnectionInfo</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.authn_id)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, strlen(<a href="#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.authn_id) + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Serialize <a href="#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a> for use by parallel workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1043">&#x200c;</a></span><span class="linkable">SerializeClientConnectionInfo</span>(Size maxsize, <span class="Type">char</span> *start_address)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1017" title="utils/init/miscinit.c:1017">SerializedClientConnectionInfo</a> serialized = {<span class="Constant">0</span>};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; serialized.authn_id_len = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; serialized.auth_method = <a href="#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.auth_method;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.authn_id)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; serialized.authn_id_len = strlen(<a href="#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.authn_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy serialized representation to buffer */<br/></li>
<li></span>&nbsp; &nbsp; Assert(maxsize &gt;= <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(serialized));<br/></li>
<li>&nbsp; &nbsp; memcpy(start_address, &amp;serialized, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(serialized));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxsize -= <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(serialized);<br/></li>
<li>&nbsp; &nbsp; start_address += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(serialized);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy authn_id into the space after the struct */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (serialized.authn_id_len &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(maxsize &gt;= (serialized.authn_id_len + <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(start_address,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.authn_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* include the NULL terminator to ease deserialization */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; serialized.authn_id_len + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Restore <a href="#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a> from its serialized representation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1075">&#x200c;</a></span><span class="linkable">RestoreClientConnectionInfo</span>(<span class="Type">char</span> *conninfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1017" title="utils/init/miscinit.c:1017">SerializedClientConnectionInfo</a> serialized;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;serialized, conninfo, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(serialized));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy the fields back into place */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.authn_id = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.auth_method = serialized.auth_method;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (serialized.authn_id_len &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *authn_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; authn_id = conninfo + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(serialized);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.authn_id = <a href="../mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<a href="../mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; authn_id);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Interlock-file support<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These routines are used to create both a data-directory lockfile<br/></li>
<li></span><span class="Comment"> * ($DATADIR/postmaster.pid) and Unix-<a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>-file lockfiles ($SOCKFILE.lock).<br/></li>
<li></span><span class="Comment"> * Both kinds of files contain the same info initially, although we can add<br/></li>
<li></span><span class="Comment"> * more information to a data-directory lockfile after it's created, using<br/></li>
<li></span><span class="Comment"> * <a href="#L1511" title="utils/init/miscinit.c:1511">AddToDataDirLockFile</a>().&nbsp; See pidfile.h for documentation of the contents<br/></li>
<li></span><span class="Comment"> * of these lockfiles.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On successful lockfile creation, a <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a> callback to remove the<br/></li>
<li></span><span class="Comment"> * lockfile is automatically created.<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a> callback to remove lockfiles.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1115">&#x200c;</a></span><span class="linkable">UnlinkLockFiles</span>(<span class="Type">int</span> status, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, <a href="#L66" title="utils/init/miscinit.c:66">lock_files</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *curfile = (<span class="Type">char</span> *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unlink(curfile);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should we complain if the unlink fails? */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Since we're about to exit, no need to reclaim storage */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L66" title="utils/init/miscinit.c:66">lock_files</a> = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lock file removal should always be the last externally visible action<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of a postmaster or standalone backend, while we won't come here at all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when exiting postmaster child processes.&nbsp; Therefore, this is a good<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * place to log completion of shutdown.&nbsp; We could alternatively teach<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>() to do it, but that seems uglier.&nbsp; In a standalone backend,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use NOTICE elevel to be less chatty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ereport(<a href="globals.c.html#L116" title="utils/init/globals.c:116">IsPostmasterEnvironment</a> ? LOG : NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database system is shut down&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a lockfile.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * filename is the path name of the lockfile to create.<br/></li>
<li></span><span class="Comment"> * amPostmaster is used to determine how to encode the output PID.<br/></li>
<li></span><span class="Comment"> * socketDir is the Unix <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> directory path to include (possibly empty).<br/></li>
<li></span><span class="Comment"> * isDDLock and refName are used to determine what error message to produce.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1150">&#x200c;</a></span><span class="linkable">CreateLockFile</span>(<span class="Type">const</span> <span class="Type">char</span> *filename, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> amPostmaster,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *socketDir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isDDLock, <span class="Type">const</span> <span class="Type">char</span> *refName)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buffer[MAXPGPATH * <span class="Constant">2</span> + <span class="Constant">256</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntries;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; encoded_pid;<br/></li>
<li>&nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; other_pid;<br/></li>
<li>&nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; my_pid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my_p_pid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my_gp_pid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *envvar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the PID in the lockfile is our own PID or our parent's or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * grandparent's PID, then the file must be stale (probably left over from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a previous system boot cycle).&nbsp; We need to check this because of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * likelihood that a reboot will assign exactly the same PID as we had in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the previous reboot, or one that's only one or two counts larger and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hence the lockfile's PID <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> refers to an ancestor shell process.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allow pg_ctl to pass down its parent shell PID (our grandparent PID)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * via the environment variable PG_GRANDPARENT_PID; this is so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * launching the postmaster via pg_ctl can be just as reliable as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * launching it directly.&nbsp; There is no provision for detecting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * further-removed ancestor processes, but if the init script is written<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * carefully then all but the immediate parent shell will be root-owned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processes and so the kill test will fail with EPERM.&nbsp; Note that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cannot get a false negative this way, because an existing postmaster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would surely never launch a competing postmaster or pg_ctl process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * directly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; my_pid = getpid();<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; my_p_pid = getppid();<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Windows hasn't got getppid(), but doesn't need it since it's not using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * real kill() either...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; my_p_pid = <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; envvar = getenv(<span class="Constant">&quot;PG_GRANDPARENT_PID&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (envvar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; my_gp_pid = atoi(envvar);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; my_gp_pid = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need a loop here because of race conditions.&nbsp; But don't loop forever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (for example, a non-writable $PGDATA directory might cause a failure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that won't go away).&nbsp; 100 tries seems like plenty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (ntries = <span class="Constant">0</span>;; ntries++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to create the lock file --- O_EXCL makes this atomic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Think not to make the file protection weaker than 0600/0640.&nbsp; See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comments below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fd = open(filename, O_RDWR | O_CREAT | O_EXCL, pg_file_create_mode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fd &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Success; exit the retry loop */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Couldn't create the pid file. Probably it already exists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((errno != <span class="Constant">EEXIST</span> &amp;&amp; errno != <span class="Constant">EACCES</span>) || ntries &gt; <span class="Constant">100</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create lock file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filename)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Read the file to get the old owner's PID.&nbsp; Note race condition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here: file might have been deleted since we tried to create it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fd = open(filename, O_RDONLY, pg_file_create_mode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* race condition; try again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open lock file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filename)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((len = read(fd, buffer, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buffer) - <span class="Constant">1</span>)) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read lock file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filename)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close(fd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_LOCK_FILE_EXISTS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;lock file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is empty&quot;</span>, filename),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Either another server is starting, or the lock file is the remnant of a previous server startup crash.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer[len] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; encoded_pid = atoi(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if pid &lt; 0, the pid is for postgres, not postmaster */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; other_pid = (pid_t) (encoded_pid &lt; <span class="Constant">0</span> ? -encoded_pid : encoded_pid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (other_pid &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;bogus data in lock file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; filename, buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check to see if the other process still exists<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Per discussion above, my_pid, my_p_pid, and my_gp_pid can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ignored as false matches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normally kill() will fail with ESRCH if the given PID doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can treat the EPERM-error case as okay because that error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * implies that the existing process has a different userid than we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do, which means it cannot be a competing postmaster.&nbsp; A postmaster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cannot successfully attach to a data directory owned by a userid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other than its own, as enforced in <a href="#L341" title="utils/init/miscinit.c:341">checkDataDir</a>(). Also, since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * create the lockfiles mode 0600/0640, we'd have failed above if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lockfile belonged to another userid --- which means that whatever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process kill() is reporting about isn't the one that made the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lockfile.&nbsp; (<a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: this last consideration is the only one that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keeps us from blowing away a Unix <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> file belonging to an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * instance of Postgres being run by someone else, at least on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * machines where /tmp hasn't got a stickybit.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (other_pid != my_pid &amp;&amp; other_pid != my_p_pid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; other_pid != my_gp_pid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (kill(other_pid, <span class="Constant">0</span>) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (errno != <span class="Constant">ESRCH</span> &amp;&amp; errno != <span class="Constant">EPERM</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lockfile belongs to a live process */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_LOCK_FILE_EXISTS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;lock file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already exists&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filename),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isDDLock ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (encoded_pid &lt; <span class="Constant">0</span> ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Is another postgres (PID </span><span class="Special">%d</span><span class="Constant">) running in data directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">?&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) other_pid, refName) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Is another postmaster (PID </span><span class="Special">%d</span><span class="Constant">) running in data directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">?&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) other_pid, refName)) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (encoded_pid &lt; <span class="Constant">0</span> ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Is another postgres (PID </span><span class="Special">%d</span><span class="Constant">) using <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">?&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) other_pid, refName) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Is another postmaster (PID </span><span class="Special">%d</span><span class="Constant">) using <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">?&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) other_pid, refName))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No, the creating process did not exist.&nbsp; However, it could be that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the postmaster crashed (or more likely was kill -9'd by a clueless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * admin) but has left orphan backends behind.&nbsp; Check for this by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * looking to see if there is an associated shmem segment that is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still in use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: because postmaster.pid is written in multiple steps, we might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the shmem ID <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in it; we can't treat that as an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isDDLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr = buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">long</span> id1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; id2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lineno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (lineno = <span class="Constant">1</span>; lineno &lt; LOCK_FILE_LINE_SHMEM_KEY; lineno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((ptr = strchr(ptr, <span class="Special">'\n'</span>)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptr != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sscanf(ptr, <span class="Constant">&quot;</span><span class="Special">%lu</span><span class="Constant"> </span><span class="Special">%lu</span><span class="Constant">&quot;</span>, &amp;id1, &amp;id2) == <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../port/win32_shmem.c.html#L113" title="port/win32_shmem.c:113">PGSharedMemoryIsInUse</a>(id1, id2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_LOCK_FILE_EXISTS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;pre-existing shared memory block (key </span><span class="Special">%lu</span><span class="Constant">, ID </span><span class="Special">%lu</span><span class="Constant">) is still in use&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; id1, id2),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Terminate <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> old server processes associated with data directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; refName)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Looks like nobody's home.&nbsp; Unlink the file and try again to create<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it.&nbsp; Need a loop because of possible race condition against other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would-be creators.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlink(filename) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove old lock file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filename),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;The file seems accidentally left over, but &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;it could not be removed. Please remove the file &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;by hand and try again.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Successfully created the file, <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> fill it.&nbsp; See comment in pidfile.h<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about the contents.&nbsp; Note that we write the same first five lines into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * both datadir and <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> lockfiles; although more stuff may get added to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the datadir lockfile later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(buffer, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buffer), <span class="Constant">&quot;</span><span class="Special">%d\n%s\n%ld\n%d\n%s\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; amPostmaster ? (<span class="Type">int</span>) my_pid : -((<span class="Type">int</span>) my_pid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span>) <a href="globals.c.html#L46" title="utils/init/globals.c:46">MyStartTime</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../postmaster/postmaster.c.html#L190" title="postmaster/postmaster.c:190">PostPortNumber</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; socketDir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In a standalone backend, the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> line (LOCK_FILE_LINE_LISTEN_ADDR)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will never receive data, so fill it in as empty <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isDDLock &amp;&amp; !amPostmaster)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strlcat(buffer, <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_WRITE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (write(fd, buffer, strlen(buffer)) != strlen(buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unlink(filename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if write didn't set errno, assume problem is no disk space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno ? save_errno : <span class="Constant">ENOSPC</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write lock file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, filename)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_CREATE_SYNC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L386" title="storage/file/fd.c:386">pg_fsync</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unlink(filename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write lock file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, filename)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (close(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unlink(filename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write lock file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, filename)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Arrange to unlink the lock file(s) at <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>.&nbsp; If this is the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one, set up the <a href="../../storage/ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a> function to do it; then add this lock file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the list of files to unlink.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L66" title="utils/init/miscinit.c:66">lock_files</a> == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a>(<a href="#L1115" title="utils/init/miscinit.c:1115">UnlinkLockFiles</a>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a> so that the lock files are unlinked in reverse order of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * creation; this is critical!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L66" title="utils/init/miscinit.c:66">lock_files</a> = <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(<a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(filename), <a href="#L66" title="utils/init/miscinit.c:66">lock_files</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create the data directory lockfile.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When this is called, we must have already switched the working<br/></li>
<li></span><span class="Comment"> * directory to <a href="globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, so we can just use a relative path.&nbsp; This<br/></li>
<li></span><span class="Comment"> * helps ensure that we are locking the directory we should be.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> directory path line is initially written as empty.<br/></li>
<li></span><span class="Comment"> * postmaster.c will rewrite it upon creating the first Unix <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1455">&#x200c;</a></span><span class="linkable">CreateDataDirLockFile</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> amPostmaster)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1150" title="utils/init/miscinit.c:1150">CreateLockFile</a>(<a href="#L59" title="utils/init/miscinit.c:59">DIRECTORY_LOCK_FILE</a>, amPostmaster, <span class="Constant">&quot;&quot;</span>, <span class="Constant">true</span>, <a href="globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a lockfile for the specified Unix <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1464">&#x200c;</a></span><span class="linkable">CreateSocketLockFile</span>(<span class="Type">const</span> <span class="Type">char</span> *socketfile, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> amPostmaster,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *socketDir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; lockfile[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(lockfile, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(lockfile), <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.lock&quot;</span>, socketfile);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1150" title="utils/init/miscinit.c:1150">CreateLockFile</a>(lockfile, amPostmaster, socketDir, <span class="Constant">false</span>, socketfile);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1482" title="utils/init/miscinit.c:1482">TouchSocketLockFiles</a> -- mark <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> lock files as recently accessed<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine should be called every so often to ensure that the <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a><br/></li>
<li></span><span class="Comment"> * lock files have a recent mod or access date.&nbsp; That saves them<br/></li>
<li></span><span class="Comment"> * from being removed by overenthusiastic /tmp-directory-cleaner daemons.<br/></li>
<li></span><span class="Comment"> * (Another reason we should never have put the <a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> file in /tmp...)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1482">&#x200c;</a></span><span class="linkable">TouchSocketLockFiles</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, <a href="#L66" title="utils/init/miscinit.c:66">lock_files</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *socketLockFile = (<span class="Type">char</span> *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No need to touch the data directory lock file, we trust */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(socketLockFile, <a href="#L59" title="utils/init/miscinit.c:59">DIRECTORY_LOCK_FILE</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we just ignore <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) utime(socketLockFile, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add (or replace) a line in the data directory lock file.<br/></li>
<li></span><span class="Comment"> * The given string should not include a trailing <a href="../../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: because we don't truncate the file, if we were to rewrite a line<br/></li>
<li></span><span class="Comment"> * with less data than it had <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, there would be garbage after the last<br/></li>
<li></span><span class="Comment"> * line.&nbsp; While we could fix that by adding a truncate call, that would make<br/></li>
<li></span><span class="Comment"> * the file update non-atomic, which we'd rather avoid.&nbsp; Therefore, callers<br/></li>
<li></span><span class="Comment"> * should endeavor never to shorten a line once it's been written.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1511">&#x200c;</a></span><span class="linkable">AddToDataDirLockFile</span>(<span class="Type">int</span> target_line, <span class="Type">const</span> <span class="Type">char</span> *str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lineno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *srcptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *destptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; srcbuffer[BLCKSZ];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; destbuffer[BLCKSZ];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = open(<a href="#L59" title="utils/init/miscinit.c:59">DIRECTORY_LOCK_FILE</a>, O_RDWR | PG_BINARY, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="utils/init/miscinit.c:59">DIRECTORY_LOCK_FILE</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_ADDTODATADIR_READ);<br/></li>
<li>&nbsp; &nbsp; len = read(fd, srcbuffer, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(srcbuffer) - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read from file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="utils/init/miscinit.c:59">DIRECTORY_LOCK_FILE</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; srcbuffer[len] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advance over lines we are not supposed to rewrite, then copy them to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * destbuffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; srcptr = srcbuffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (lineno = <span class="Constant">1</span>; lineno &lt; target_line; lineno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *eol = strchr(srcptr, <span class="Special">'\n'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (eol == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not enough lines in file yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; srcptr = eol + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; memcpy(destbuffer, srcbuffer, srcptr - srcbuffer);<br/></li>
<li>&nbsp; &nbsp; destptr = destbuffer + (srcptr - srcbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill in <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> missing lines <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the target line, in case lines are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * added to the file out of order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (; lineno &lt; target_line; lineno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (destptr &lt; destbuffer + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(destbuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *destptr++ = <span class="Special">'\n'</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write or rewrite the target line.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(destptr, destbuffer + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(destbuffer) - destptr, <span class="Constant">&quot;</span><span class="Special">%s\n</span><span class="Constant">&quot;</span>, str);<br/></li>
<li>&nbsp; &nbsp; destptr += strlen(destptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are more lines in the old file, append them to destbuffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((srcptr = strchr(srcptr, <span class="Special">'\n'</span>)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; srcptr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(destptr, destbuffer + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(destbuffer) - destptr, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; srcptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And rewrite the data.&nbsp; Since we write in a single kernel call, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update should appear atomic to onlookers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; len = strlen(destbuffer);<br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_ADDTODATADIR_WRITE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_pwrite(fd, destbuffer, len, <span class="Constant">0</span>) != len)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if write didn't set errno, assume problem is no disk space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ENOSPC</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write to file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="utils/init/miscinit.c:59">DIRECTORY_LOCK_FILE</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_ADDTODATADIR_SYNC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L386" title="storage/file/fd.c:386">pg_fsync</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write to file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="utils/init/miscinit.c:59">DIRECTORY_LOCK_FILE</a>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (close(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write to file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="utils/init/miscinit.c:59">DIRECTORY_LOCK_FILE</a>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recheck that the data directory lock file still exists with expected<br/></li>
<li></span><span class="Comment"> * content.&nbsp; Return true if the lock file appears OK, false if it isn't.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We call this periodically in the postmaster.&nbsp; The idea is that if the<br/></li>
<li></span><span class="Comment"> * lock file has been removed or replaced by another postmaster, we should<br/></li>
<li></span><span class="Comment"> * do a panic database shutdown.&nbsp; Therefore, we should return true if there<br/></li>
<li></span><span class="Comment"> * is <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> doubt: we do not want to cause a panic shutdown unnecessarily.<br/></li>
<li></span><span class="Comment"> * Transient failures like EINTR or ENFILE should not cause us to fail.<br/></li>
<li></span><span class="Comment"> * (If there really is something wrong, we'll detect it on a future recheck.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1638">&#x200c;</a></span><span class="linkable">RecheckDataDirLockFile</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; file_pid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buffer[BLCKSZ];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = open(<a href="#L59" title="utils/init/miscinit.c:59">DIRECTORY_LOCK_FILE</a>, O_RDWR | PG_BINARY, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There are many foreseeable false-positive error conditions.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * safety, fail only on enumerated clearly-something-is-wrong<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * conditions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (errno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">ENOENT</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">ENOTDIR</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* disaster */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="utils/init/miscinit.c:59">DIRECTORY_LOCK_FILE</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* non-fatal, at least for <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m; continuing anyway&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="utils/init/miscinit.c:59">DIRECTORY_LOCK_FILE</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_LOCK_FILE_RECHECKDATADIR_READ);<br/></li>
<li>&nbsp; &nbsp; len = read(fd, buffer, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buffer) - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read from file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="utils/init/miscinit.c:59">DIRECTORY_LOCK_FILE</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* treat read failure as nonfatal */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; buffer[len] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; close(fd);<br/></li>
<li>&nbsp; &nbsp; file_pid = atol(buffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (file_pid == getpid())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all is well */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Trouble: someone's overwritten the lock file */<br/></li>
<li></span>&nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;lock file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains wrong PID: </span><span class="Special">%ld</span><span class="Constant"> instead of </span><span class="Special">%ld</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="utils/init/miscinit.c:59">DIRECTORY_LOCK_FILE</a>, file_pid, (<span class="Type">long</span>) getpid())));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Version checking support<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine whether the PG_VERSION file in directory `path' indicates<br/></li>
<li></span><span class="Comment"> * a data version compatible with the version of this program.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If compatible, return. Otherwise, ereport(FATAL).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1710">&#x200c;</a></span><span class="linkable">ValidatePgVersion</span>(<span class="Type">const</span> <span class="Type">char</span> *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; full_path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *file;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; file_major;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; my_major;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; file_version_string[<span class="Constant">64</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *my_version_string = PG_VERSION;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; my_major = strtol(my_version_string, &amp;endptr, <span class="Constant">10</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(full_path, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(full_path), <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/PG_VERSION&quot;</span>, path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; file = <a href="../../storage/file/fd.c.html#L2583" title="storage/file/fd.c:2583">AllocateFile</a>(full_path, <span class="Constant">&quot;r&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!file)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a valid data directory&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;File </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is missing.&quot;</span>, full_path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, full_path)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; file_version_string[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; ret = fscanf(file, <span class="Constant">&quot;</span><span class="Special">%63s</span><span class="Constant">&quot;</span>, file_version_string);<br/></li>
<li>&nbsp; &nbsp; file_major = strtol(file_version_string, &amp;endptr, <span class="Constant">10</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret != <span class="Constant">1</span> || endptr == file_version_string)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a valid data directory&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;File </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not contain valid data.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; full_path),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You might need to initdb.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2781" title="storage/file/fd.c:2781">FreeFile</a>(file);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (my_major != file_major)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database files are incompatible with server&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The data directory was initialized by PostgreSQL version </span><span class="Special">%s</span><span class="Constant">, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;which is not compatible with this version </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; file_version_string, my_version_string)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Library preload support<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC variables: lists of library names to be preloaded at postmaster<br/></li>
<li></span><span class="Comment"> * start and at backend start<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L1773">&#x200c;</a></span><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">session_preload_libraries_string</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L1774">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">shared_preload_libraries_string</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L1775">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">local_preload_libraries_string</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Flag telling that we are loading shared_preload_libraries */<br/></li>
<li><a id="L1778">&#x200c;</a></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">process_shared_preload_libraries_in_progress</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L1779">&#x200c;</a><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">process_shared_preload_libraries_done</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><a id="L1781">&#x200c;</a>shmem_request_hook_type <span class="linkable">shmem_request_hook</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L1782">&#x200c;</a><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">process_shmem_requests_in_progress</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * load the shared libraries listed in 'libraries'<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'gucname': name of GUC variable, for error reports<br/></li>
<li></span><span class="Comment"> * 'restricted': if true, force libraries to be in $libdir/plugins/<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1791">&#x200c;</a></span><span class="linkable">load_libraries</span>(<span class="Type">const</span> <span class="Type">char</span> *libraries, <span class="Type">const</span> <span class="Type">char</span> *gucname, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> restricted)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *rawstring;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *elemlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (libraries == <span class="Constant">NULL</span> || libraries[<span class="Constant">0</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need a modifiable copy of string */<br/></li>
<li></span>&nbsp; &nbsp; rawstring = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(libraries);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Parse string into list of filename paths */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../adt/varlena.c.html#L3584" title="utils/adt/varlena.c:3584">SplitDirectoriesString</a>(rawstring, <span class="Constant">','</span>, &amp;elemlist))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* syntax error in list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(elemlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rawstring);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid list syntax in parameter </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gucname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, elemlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Note that filename was already canonicalized */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *filename = (<span class="Type">char</span> *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *expanded = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If restricting, insert $libdir/plugins if not mentioned already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (restricted &amp;&amp; first_dir_separator(filename) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expanded = psprintf(<span class="Constant">&quot;$libdir/plugins/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, filename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filename = expanded;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../fmgr/dfmgr.c.html#L144" title="utils/fmgr/dfmgr.c:144">load_file</a>(filename, restricted);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;loaded library </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, filename)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expanded)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(expanded);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(elemlist);<br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rawstring);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * process <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> libraries that should be preloaded at postmaster start<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1843">&#x200c;</a></span><span class="linkable">process_shared_preload_libraries</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1778" title="utils/init/miscinit.c:1778">process_shared_preload_libraries_in_progress</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1791" title="utils/init/miscinit.c:1791">load_libraries</a>(<a href="#L1774" title="utils/init/miscinit.c:1774">shared_preload_libraries_string</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;shared_preload_libraries&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1778" title="utils/init/miscinit.c:1778">process_shared_preload_libraries_in_progress</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1779" title="utils/init/miscinit.c:1779">process_shared_preload_libraries_done</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * process <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> libraries that should be preloaded at backend start<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1857">&#x200c;</a></span><span class="linkable">process_session_preload_libraries</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1791" title="utils/init/miscinit.c:1791">load_libraries</a>(<a href="#L1773" title="utils/init/miscinit.c:1773">session_preload_libraries_string</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;session_preload_libraries&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1791" title="utils/init/miscinit.c:1791">load_libraries</a>(<a href="#L1775" title="utils/init/miscinit.c:1775">local_preload_libraries_string</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;local_preload_libraries&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * process <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> shared memory requests from preloaded libraries<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1871">&#x200c;</a></span><span class="linkable">process_shmem_requests</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1782" title="utils/init/miscinit.c:1782">process_shmem_requests_in_progress</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1781" title="utils/init/miscinit.c:1781">shmem_request_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1781" title="utils/init/miscinit.c:1781">shmem_request_hook</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L1782" title="utils/init/miscinit.c:1782">process_shmem_requests_in_progress</a> = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1880">&#x200c;</a></span><span class="linkable">pg_bindtextdomain</span>(<span class="Type">const</span> <span class="Type">char</span> *domain)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef ENABLE_NLS<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="globals.c.html#L78" title="utils/init/globals.c:78">my_exec_path</a>[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; locale_path[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; get_locale_path(<a href="globals.c.html#L78" title="utils/init/globals.c:78">my_exec_path</a>, locale_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bindtextdomain(domain, locale_path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mb/mbutils.c.html#L1226" title="utils/mb/mbutils.c:1226">pg_bind_textdomain_codeset</a>(domain);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
