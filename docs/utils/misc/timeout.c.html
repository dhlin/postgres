<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/misc/timeout.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/misc/timeout.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L53">active_timeouts</a></li>
<li><a href="#L67">alarm_enabled</a></li>
<li><a href="#L45">all_timeouts</a></li>
<li><a href="#L46">all_timeouts_initialized</a></li>
<li><a href="#L52">num_active_timeouts</a></li>
<li><a href="#L79">signal_due_at</a></li>
<li><a href="#L78">signal_pending</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L26">timeout_params</a></li>
<li><a href="#L40">timeout_params</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L470">InitializeTimeouts</a></li>
<li><a href="#L505">RegisterTimeout</a></li>
<li><a href="#L751">disable_all_timeouts</a></li>
<li><a href="#L685">disable_timeout</a></li>
<li><a href="#L718">disable_timeouts</a></li>
<li><a href="#L158">enable_timeout</a></li>
<li><a href="#L560">enable_timeout_after</a></li>
<li><a href="#L607">enable_timeout_at</a></li>
<li><a href="#L584">enable_timeout_every</a></li>
<li><a href="#L630">enable_timeouts</a></li>
<li><a href="#L96">find_active_timeout</a></li>
<li><a href="#L780">get_timeout_active</a></li>
<li><a href="#L827">get_timeout_finish_time</a></li>
<li><a href="#L793">get_timeout_indicator</a></li>
<li><a href="#L813">get_timeout_start_time</a></li>
<li><a href="#L364">handle_sig_alarm</a></li>
<li><a href="#L114">insert_timeout</a></li>
<li><a href="#L137">remove_timeout_index</a></li>
<li><a href="#L540">reschedule_timeouts</a></li>
<li><a href="#L210">schedule_alarm</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L69">disable_alarm</a></li>
<li><a href="#L70">enable_alarm</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * timeout.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Routines to multiplex SIGALRM interrupts for multiple timeout reasons.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/misc/timeout.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;sys/time.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/latch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timeout.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* Data about <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one timeout reason */<br/></li>
<li><a id="L26">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">timeout_params</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeoutId&nbsp; &nbsp; index;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* identifier of timeout reason */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* volatile because these may be changed from the signal handler */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">volatile</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> active;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* true if timeout is in <a href="#L53" title="utils/misc/timeout.c:53">active_timeouts</a>[] */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">volatile</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> indicator;&nbsp; &nbsp; <span class="Comment">/* true if timeout has occurred */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* callback function for timeout, or NULL if timeout not registered */<br/></li>
<li></span>&nbsp; &nbsp; timeout_handler_proc timeout_handler;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TimestampTz start_time;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* time that timeout was last activated */<br/></li>
<li></span>&nbsp; &nbsp; TimestampTz fin_time;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* time it is, or was last, due to fire */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interval_in_ms; <span class="Comment">/* time between firings, or 0 if just once */<br/></li>
<li><a id="L40">&#x200c;</a></span>} <span class="linkable">timeout_params</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * List of possible timeout reasons in the order of enum TimeoutId.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L45">&#x200c;</a></span><span class="Type">static</span> <a href="#L26" title="utils/misc/timeout.c:26">timeout_params</a> <span class="linkable">all_timeouts</span>[MAX_TIMEOUTS];<br/></li>
<li><a id="L46">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">all_timeouts_initialized</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * List of active timeouts ordered by their fin_time and priority.<br/></li>
<li></span><span class="Comment"> * This list is subject to change by the interrupt handler, so it's volatile.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L52">&#x200c;</a></span><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">int</span> <span class="linkable">num_active_timeouts</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L53">&#x200c;</a><span class="Type">static</span> <a href="#L26" title="utils/misc/timeout.c:26">timeout_params</a> *<span class="Type">volatile</span> <span class="linkable">active_timeouts</span>[MAX_TIMEOUTS];<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Flag controlling whether the signal handler is allowed to do anything.<br/></li>
<li></span><span class="Comment"> * This is useful to avoid race conditions with the handler.&nbsp; Note in<br/></li>
<li></span><span class="Comment"> * particular that this lets us make changes in the data structures without<br/></li>
<li></span><span class="Comment"> * tediously disabling and re-enabling the timer signal.&nbsp; Most of the time,<br/></li>
<li></span><span class="Comment"> * no interrupt would happen anyway during such critical sections, but if<br/></li>
<li></span><span class="Comment"> * one does, this rule ensures it's safe.&nbsp; Leaving the signal enabled across<br/></li>
<li></span><span class="Comment"> * multiple operations can greatly reduce the number of kernel calls we make,<br/></li>
<li></span><span class="Comment"> * too.&nbsp; See comments in <a href="#L210" title="utils/misc/timeout.c:210">schedule_alarm</a>() about that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We leave this &quot;false&quot; when we're not expecting interrupts, just in case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L67">&#x200c;</a></span><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">alarm_enabled</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><a id="L69">&#x200c;</a><span class="PreProc">#define <span class="linkable">disable_alarm</span>() (<a href="#L67" title="utils/misc/timeout.c:67">alarm_enabled</a> = </span><span class="Constant">false</span><span class="PreProc">)<br/></li>
<li><a id="L70">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">enable_alarm</span>()&nbsp; &nbsp; (<a href="#L67" title="utils/misc/timeout.c:67">alarm_enabled</a> = </span><span class="Constant">true</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * State recording if and when we <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> expect the interrupt to fire.<br/></li>
<li></span><span class="Comment"> * (<a href="#L79" title="utils/misc/timeout.c:79">signal_due_at</a> is valid only when <a href="#L78" title="utils/misc/timeout.c:78">signal_pending</a> is true.)<br/></li>
<li></span><span class="Comment"> * Note that the signal handler will unconditionally reset <a href="#L78" title="utils/misc/timeout.c:78">signal_pending</a> to<br/></li>
<li></span><span class="Comment"> * false, so that can change asynchronously even when <a href="#L67" title="utils/misc/timeout.c:67">alarm_enabled</a> is false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L78">&#x200c;</a></span><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">signal_pending</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L79">&#x200c;</a><span class="Type">static</span> <span class="Type">volatile</span> TimestampTz <span class="linkable">signal_due_at</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> * Internal helper <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For all of these, it is caller's responsibility to protect them from<br/></li>
<li></span><span class="Comment"> * interruption by the signal handler.&nbsp; Generally, call <a href="#L69" title="utils/misc/timeout.c:69">disable_alarm</a>()<br/></li>
<li></span><span class="Comment"> * first to prevent interruption, then update state, and last call<br/></li>
<li></span><span class="Comment"> * <a href="#L210" title="utils/misc/timeout.c:210">schedule_alarm</a>(), which will re-enable the signal handler if needed.<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find the index of a given timeout reason in the active array.<br/></li>
<li></span><span class="Comment"> * If it's not there, return -1.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L96">&#x200c;</a></span><span class="linkable">find_active_timeout</span>(TimeoutId id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L52" title="utils/misc/timeout.c:52">num_active_timeouts</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L53" title="utils/misc/timeout.c:53">active_timeouts</a>[i]-&gt;index == id)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> i;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> specified timeout reason into the list of active timeouts<br/></li>
<li></span><span class="Comment"> * at the given index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L114">&#x200c;</a></span><span class="linkable">insert_timeout</span>(TimeoutId id, <span class="Type">int</span> index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (index &lt; <span class="Constant">0</span> || index &gt; <a href="#L52" title="utils/misc/timeout.c:52">num_active_timeouts</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;timeout index </span><span class="Special">%d</span><span class="Constant"> out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> 0..</span><span class="Special">%d</span><span class="Constant">&quot;</span>, index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L52" title="utils/misc/timeout.c:52">num_active_timeouts</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].active);<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].active = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <a href="#L52" title="utils/misc/timeout.c:52">num_active_timeouts</a> - <span class="Constant">1</span>; i &gt;= index; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L53" title="utils/misc/timeout.c:53">active_timeouts</a>[i + <span class="Constant">1</span>] = <a href="#L53" title="utils/misc/timeout.c:53">active_timeouts</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L53" title="utils/misc/timeout.c:53">active_timeouts</a>[index] = &amp;<a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/misc/timeout.c:52">num_active_timeouts</a>++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove the index'th <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> from the timeout list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L137">&#x200c;</a></span><span class="linkable">remove_timeout_index</span>(<span class="Type">int</span> index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (index &lt; <span class="Constant">0</span> || index &gt;= <a href="#L52" title="utils/misc/timeout.c:52">num_active_timeouts</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;timeout index </span><span class="Special">%d</span><span class="Constant"> out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> 0..</span><span class="Special">%d</span><span class="Constant">&quot;</span>, index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L52" title="utils/misc/timeout.c:52">num_active_timeouts</a> - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L53" title="utils/misc/timeout.c:53">active_timeouts</a>[index]-&gt;active);<br/></li>
<li>&nbsp; &nbsp; <a href="#L53" title="utils/misc/timeout.c:53">active_timeouts</a>[index]-&gt;active = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = index + <span class="Constant">1</span>; i &lt; <a href="#L52" title="utils/misc/timeout.c:52">num_active_timeouts</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L53" title="utils/misc/timeout.c:53">active_timeouts</a>[i - <span class="Constant">1</span>] = <a href="#L53" title="utils/misc/timeout.c:53">active_timeouts</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/misc/timeout.c:52">num_active_timeouts</a>--;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Enable the specified timeout reason<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L158">&#x200c;</a></span><span class="linkable">enable_timeout</span>(TimeoutId id, TimestampTz <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, TimestampTz fin_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> interval_in_ms)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assert request is sane */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L46" title="utils/misc/timeout.c:46">all_timeouts_initialized</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].timeout_handler != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this timeout was already active, momentarily disable it.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interpret the call as a directive to reschedule the timeout.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].active)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="utils/misc/timeout.c:137">remove_timeout_index</a>(<a href="#L96" title="utils/misc/timeout.c:96">find_active_timeout</a>(id));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find out the index where to insert the new timeout.&nbsp; We sort by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fin_time, and for <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> fin_time by priority.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L52" title="utils/misc/timeout.c:52">num_active_timeouts</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L26" title="utils/misc/timeout.c:26">timeout_params</a> *old_timeout = <a href="#L53" title="utils/misc/timeout.c:53">active_timeouts</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fin_time &lt; old_timeout-&gt;fin_time)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fin_time == old_timeout-&gt;fin_time &amp;&amp; id &lt; old_timeout-&gt;index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark the timeout active, and insert it into the active list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].indicator = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].start_time = <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].fin_time = fin_time;<br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].interval_in_ms = interval_in_ms;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L114" title="utils/misc/timeout.c:114">insert_timeout</a>(id, i);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Schedule alarm for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> active timeout, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume the caller has obtained the current time, or a close-enough<br/></li>
<li></span><span class="Comment"> * approximation.&nbsp; (It's okay if a tick or two has passed since &quot;<a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>&quot;, or<br/></li>
<li></span><span class="Comment"> * if a little more time elapses <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we reach the kernel call; that will<br/></li>
<li></span><span class="Comment"> * cause us to ask for an interrupt a tick or two later than the nearest<br/></li>
<li></span><span class="Comment"> * timeout, which is no big deal.&nbsp; Passing a &quot;<a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>&quot; value that's in the future<br/></li>
<li></span><span class="Comment"> * would be bad though.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L210">&#x200c;</a></span><span class="linkable">schedule_alarm</span>(TimestampTz <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L52" title="utils/misc/timeout.c:52">num_active_timeouts</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> itimerval timeval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz nearest_timeout;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; secs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usecs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(&amp;timeval, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> itimerval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we think there's a signal pending, but current time is more than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 10ms past when the signal was due, then assume that the timeout<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * request got lost somehow; clear <a href="#L78" title="utils/misc/timeout.c:78">signal_pending</a> so that we'll reset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the interrupt request below.&nbsp; (10ms corresponds to the worst-case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * timeout granularity on modern systems.)&nbsp; It won't hurt us if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interrupt does manage to fire between <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> and when we reach the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../port/win32/timer.c.html#L86" title="port/win32/timer.c:86">setitimer</a>() call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L78" title="utils/misc/timeout.c:78">signal_pending</a> &amp;&amp; <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> &gt; <a href="#L79" title="utils/misc/timeout.c:79">signal_due_at</a> + <span class="Constant">10</span> * <span class="Constant">1000</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="utils/misc/timeout.c:78">signal_pending</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get the time remaining till the nearest pending timeout.&nbsp; If it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * negative, assume that we somehow missed an interrupt, and clear<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L78" title="utils/misc/timeout.c:78">signal_pending</a>.&nbsp; This gives us another chance to recover if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * kernel drops a timeout request for some reason.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nearest_timeout = <a href="#L53" title="utils/misc/timeout.c:53">active_timeouts</a>[<span class="Constant">0</span>]-&gt;fin_time;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> &gt; nearest_timeout)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="utils/misc/timeout.c:78">signal_pending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* force an interrupt as soon as possible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; secs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usecs = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/timestamp.c.html#L1730" title="utils/adt/timestamp.c:1730">TimestampDifference</a>(<a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, nearest_timeout,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;secs, &amp;usecs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's possible that the difference is less than a microsecond;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ensure we don't cancel, rather than set, the interrupt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (secs == <span class="Constant">0</span> &amp;&amp; usecs == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usecs = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timeval.it_value.tv_sec = secs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; timeval.it_value.tv_usec = usecs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must enable the signal handler <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling <a href="../../port/win32/timer.c.html#L86" title="port/win32/timer.c:86">setitimer</a>(); if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * did it in the other order, we'd have a race condition wherein the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interrupt could occur <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can set <a href="#L67" title="utils/misc/timeout.c:67">alarm_enabled</a>, so that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * signal handler would fail to do anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Because we didn't bother to disable the timer in <a href="#L69" title="utils/misc/timeout.c:69">disable_alarm</a>(),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's possible that a previously-set interrupt will fire between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L70" title="utils/misc/timeout.c:70">enable_alarm</a>() and <a href="../../port/win32/timer.c.html#L86" title="port/win32/timer.c:86">setitimer</a>().&nbsp; This is safe, however.&nbsp; There are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * two possible outcomes:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 1. The signal handler finds nothing to do (because the nearest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * timeout event is still in the future).&nbsp; It will re-set the timer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and return.&nbsp; Then we'll overwrite the timer value with a new one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This will mean that the timer fires a little later than we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * intended, but only by the amount of time it takes for the signal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * handler to do nothing useful, which shouldn't be much.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 2. The signal handler executes and removes one or more timeout<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * events.&nbsp; When it returns, either the queue is <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> empty or the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * frontmost event is later than the one we looked at above.&nbsp; So we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overwrite the timer value with one that is too soon (plus or minus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the signal handler's execution time), causing a useless interrupt<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to occur.&nbsp; But the handler will then re-set the timer and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * everything will still work as expected.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since these cases are of very low probability (the window here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * being quite narrow), it's not worth adding cycles to the mainline<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * code to prevent occasional wasted interrupts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L70" title="utils/misc/timeout.c:70">enable_alarm</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there is already an interrupt pending that's at or <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * needed time, we need not do anything more.&nbsp; The signal handler will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do the right thing in the first case, and re-schedule the interrupt<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for later in the second case.&nbsp; It might seem that the extra<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interrupt is wasted work, but it's not terribly much work, and this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * method has very significant advantages in the common use-case where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we repeatedly set a timeout that we don't expect to reach and then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cancel it.&nbsp; Instead of invoking <a href="../../port/win32/timer.c.html#L86" title="port/win32/timer.c:86">setitimer</a>() every time the timeout<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is set or canceled, we perform one interrupt and a re-scheduling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../port/win32/timer.c.html#L86" title="port/win32/timer.c:86">setitimer</a>() call at intervals roughly <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the timeout delay.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For example, with statement_timeout = 1s and a throughput of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * thousands of queries per second, this method requires an interrupt<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and <a href="../../port/win32/timer.c.html#L86" title="port/win32/timer.c:86">setitimer</a>() call roughly once a second, rather than thousands<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of <a href="../../port/win32/timer.c.html#L86" title="port/win32/timer.c:86">setitimer</a>() calls per second.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Because of the possible passage of time between when we obtained<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;<a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>&quot; and when we reach <a href="../../port/win32/timer.c.html#L86" title="port/win32/timer.c:86">setitimer</a>(), the kernel's opinion of when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to <a href="../adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> the interrupt is likely to be a <a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> later than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L79" title="utils/misc/timeout.c:79">signal_due_at</a>.&nbsp; That's fine, for the same reasons described above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L78" title="utils/misc/timeout.c:78">signal_pending</a> &amp;&amp; nearest_timeout &gt;= <a href="#L79" title="utils/misc/timeout.c:79">signal_due_at</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As with calling <a href="#L70" title="utils/misc/timeout.c:70">enable_alarm</a>(), we must set <a href="#L78" title="utils/misc/timeout.c:78">signal_pending</a> *<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * calling <a href="../../port/win32/timer.c.html#L86" title="port/win32/timer.c:86">setitimer</a>(); if we did it after, the signal handler could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we set it, leaving us with a false opinion that a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * signal is still coming.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Other race conditions involved with setting/checking <a href="#L78" title="utils/misc/timeout.c:78">signal_pending</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are okay, for the reasons described above.&nbsp; One additional point is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the signal handler could fire after we set <a href="#L79" title="utils/misc/timeout.c:79">signal_due_at</a>, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the <a href="../../port/win32/timer.c.html#L86" title="port/win32/timer.c:86">setitimer</a>() call.&nbsp; Then the handler could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overwrite <a href="#L79" title="utils/misc/timeout.c:79">signal_due_at</a> with a value it computes, which will be the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same as or perhaps later than what we just computed.&nbsp; After we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * perform <a href="../../port/win32/timer.c.html#L86" title="port/win32/timer.c:86">setitimer</a>(), the net effect would be that <a href="#L79" title="utils/misc/timeout.c:79">signal_due_at</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * gives a time later than when the interrupt will really happen;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which is a safe situation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L79" title="utils/misc/timeout.c:79">signal_due_at</a> = nearest_timeout;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="utils/misc/timeout.c:78">signal_pending</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set the alarm timer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../port/win32/timer.c.html#L86" title="port/win32/timer.c:86">setitimer</a>(ITIMER_REAL, &amp;timeval, <span class="Constant">NULL</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Clearing <a href="#L78" title="utils/misc/timeout.c:78">signal_pending</a> here is a <a href="../adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> pro forma, but not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entirely so, since something in the FATAL exit path could try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to use timeout facilities.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="utils/misc/timeout.c:78">signal_pending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;could not enable SIGALRM timer: %m&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> * Signal handler<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Signal handler for SIGALRM<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Process <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> active timeout reasons and then reschedule the interrupt<br/></li>
<li></span><span class="Comment"> * as needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L364">&#x200c;</a></span><span class="linkable">handle_sig_alarm</span>(SIGNAL_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Bump the holdoff counter, to make sure nothing we call will process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interrupts directly. No timeout handler should do that, but these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * failures are hard to debug, so better be sure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SIGALRM is always cause for waking anything <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> on the process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * latch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Always reset <a href="#L78" title="utils/misc/timeout.c:78">signal_pending</a>, even if !<a href="#L67" title="utils/misc/timeout.c:67">alarm_enabled</a>, since indeed no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * signal is <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> pending.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L78" title="utils/misc/timeout.c:78">signal_pending</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fire <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending timeouts, but only if we're enabled to do so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L67" title="utils/misc/timeout.c:67">alarm_enabled</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Disable alarms, just in case this platform allows signal handlers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to interrupt themselves.&nbsp; <a href="#L210" title="utils/misc/timeout.c:210">schedule_alarm</a>() will re-enable if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L69" title="utils/misc/timeout.c:69">disable_alarm</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L52" title="utils/misc/timeout.c:52">num_active_timeouts</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* While the first pending timeout has been reached ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L52" title="utils/misc/timeout.c:52">num_active_timeouts</a> &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> &gt;= <a href="#L53" title="utils/misc/timeout.c:53">active_timeouts</a>[<span class="Constant">0</span>]-&gt;fin_time)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L26" title="utils/misc/timeout.c:26">timeout_params</a> *this_timeout = <a href="#L53" title="utils/misc/timeout.c:53">active_timeouts</a>[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remove it from the active list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="utils/misc/timeout.c:137">remove_timeout_index</a>(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark it as fired */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_timeout-&gt;indicator = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And call its handler function */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_timeout-&gt;timeout_handler();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it should fire repeatedly, re-enable it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (this_timeout-&gt;interval_in_ms &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz new_fin_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To guard against drift, schedule the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> instance of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the timeout based on the intended firing time rather<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than the actual firing time. But if the timeout was so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * late that we missed an entire cycle, fall back to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scheduling based on the actual firing time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_fin_time =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTzPlusMilliseconds(this_timeout-&gt;fin_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_timeout-&gt;interval_in_ms);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_fin_time &lt; <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_fin_time =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTzPlusMilliseconds(<a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_timeout-&gt;interval_in_ms);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L158" title="utils/misc/timeout.c:158">enable_timeout</a>(this_timeout-&gt;index, <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, new_fin_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; this_timeout-&gt;interval_in_ms);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The handler might not take negligible time (<a href="../../storage/lmgr/proc.c.html#L1754" title="storage/lmgr/proc.c:1754">CheckDeadLock</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for instance isn't too cheap), so let's update our idea of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;<a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>&quot; after each one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done firing timeouts, so reschedule <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> interrupt if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L210" title="utils/misc/timeout.c:210">schedule_alarm</a>(<a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************************************************<br/></li>
<li></span><span class="Comment"> * Public API<br/></li>
<li></span><span class="Comment"> *****************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize timeout module.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This must be called in every process that wants to use timeouts.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the process was forked from another one that was also using this<br/></li>
<li></span><span class="Comment"> * module, be sure to call this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> re-enabling signals; else handlers<br/></li>
<li></span><span class="Comment"> * meant to run in the parent process might get invoked in this one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L470">&#x200c;</a></span><span class="linkable">InitializeTimeouts</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize, or re-<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a>, all local state */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L69" title="utils/misc/timeout.c:69">disable_alarm</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/misc/timeout.c:52">num_active_timeouts</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; MAX_TIMEOUTS; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[i].index = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[i].active = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[i].indicator = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[i].timeout_handler = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[i].start_time = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[i].fin_time = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[i].interval_in_ms = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="utils/misc/timeout.c:46">all_timeouts_initialized</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now establish the signal handler */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGALRM</span>, <a href="#L364" title="utils/misc/timeout.c:364">handle_sig_alarm</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Register a timeout reason<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For predefined timeouts, this just registers the callback function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For user-defined timeouts, pass id == USER_TIMEOUT; we then allocate and<br/></li>
<li></span><span class="Comment"> * return a timeout ID.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TimeoutId<br/></li>
<li><a id="L505">&#x200c;</a><span class="linkable">RegisterTimeout</span>(TimeoutId id, timeout_handler_proc handler)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L46" title="utils/misc/timeout.c:46">all_timeouts_initialized</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There's no need to disable the signal handler here. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (id &gt;= USER_TIMEOUT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allocate a user-defined timeout reason */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (id = USER_TIMEOUT; id &lt; MAX_TIMEOUTS; id++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].timeout_handler == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (id &gt;= MAX_TIMEOUTS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot add more timeout reasons&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].timeout_handler == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].timeout_handler = handler;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> id;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reschedule <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending SIGALRM interrupt.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This can be used during error recovery in case query cancel resulted in loss<br/></li>
<li></span><span class="Comment"> * of a SIGALRM event (due to longjmp'ing out of <a href="#L364" title="utils/misc/timeout.c:364">handle_sig_alarm</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it<br/></li>
<li></span><span class="Comment"> * could do anything).&nbsp; But note it's not necessary if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the public<br/></li>
<li></span><span class="Comment"> * enable_ or <a href="#L685" title="utils/misc/timeout.c:685">disable_timeout</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are called in the same area, since<br/></li>
<li></span><span class="Comment"> * those all do <a href="#L210" title="utils/misc/timeout.c:210">schedule_alarm</a>() internally if needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L540">&#x200c;</a></span><span class="linkable">reschedule_timeouts</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For flexibility, allow this to be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we're initialized. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L46" title="utils/misc/timeout.c:46">all_timeouts_initialized</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Disable timeout interrupts for safety. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L69" title="utils/misc/timeout.c:69">disable_alarm</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reschedule the interrupt, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> timeouts remain active. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L52" title="utils/misc/timeout.c:52">num_active_timeouts</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L210" title="utils/misc/timeout.c:210">schedule_alarm</a>(<a href="../adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>());<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Enable the specified timeout to fire after the specified delay.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Delay is given in milliseconds.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L560">&#x200c;</a></span><span class="linkable">enable_timeout_after</span>(TimeoutId id, <span class="Type">int</span> delay_ms)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; TimestampTz fin_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Disable timeout interrupts for safety. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L69" title="utils/misc/timeout.c:69">disable_alarm</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Queue the timeout at the appropriate time. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; fin_time = TimestampTzPlusMilliseconds(<a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, delay_ms);<br/></li>
<li>&nbsp; &nbsp; <a href="#L158" title="utils/misc/timeout.c:158">enable_timeout</a>(id, <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, fin_time, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set the timer interrupt. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L210" title="utils/misc/timeout.c:210">schedule_alarm</a>(<a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Enable the specified timeout to fire periodically, with the specified<br/></li>
<li></span><span class="Comment"> * delay as the time between firings.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Delay is given in milliseconds.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L584">&#x200c;</a></span><span class="linkable">enable_timeout_every</span>(TimeoutId id, TimestampTz fin_time, <span class="Type">int</span> delay_ms)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Disable timeout interrupts for safety. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L69" title="utils/misc/timeout.c:69">disable_alarm</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Queue the timeout at the appropriate time. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L158" title="utils/misc/timeout.c:158">enable_timeout</a>(id, <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, fin_time, delay_ms);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set the timer interrupt. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L210" title="utils/misc/timeout.c:210">schedule_alarm</a>(<a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Enable the specified timeout to fire at the specified time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is provided to support cases where there's a reason to calculate<br/></li>
<li></span><span class="Comment"> * the timeout by reference to some point other than &quot;<a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>&quot;.&nbsp; If there isn't,<br/></li>
<li></span><span class="Comment"> * use <a href="#L560" title="utils/misc/timeout.c:560">enable_timeout_after</a>(), to avoid calling <a href="../adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>() twice.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L607">&#x200c;</a></span><span class="linkable">enable_timeout_at</span>(TimeoutId id, TimestampTz fin_time)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Disable timeout interrupts for safety. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L69" title="utils/misc/timeout.c:69">disable_alarm</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Queue the timeout at the appropriate time. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L158" title="utils/misc/timeout.c:158">enable_timeout</a>(id, <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, fin_time, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set the timer interrupt. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L210" title="utils/misc/timeout.c:210">schedule_alarm</a>(<a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Enable multiple timeouts at once.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This works like calling <a href="#L560" title="utils/misc/timeout.c:560">enable_timeout_after</a>() and/or <a href="#L607" title="utils/misc/timeout.c:607">enable_timeout_at</a>()<br/></li>
<li></span><span class="Comment"> * multiple times.&nbsp; Use this to reduce the number of <a href="../adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>()<br/></li>
<li></span><span class="Comment"> * and <a href="../../port/win32/timer.c.html#L86" title="port/win32/timer.c:86">setitimer</a>() calls needed to establish multiple timeouts.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L630">&#x200c;</a></span><span class="linkable">enable_timeouts</span>(<span class="Type">const</span> EnableTimeoutParams *timeouts, <span class="Type">int</span> count)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Disable timeout interrupts for safety. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L69" title="utils/misc/timeout.c:69">disable_alarm</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Queue the timeout(s) at the appropriate times. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; count; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeoutId&nbsp; &nbsp; id = timeouts[i].id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz fin_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (timeouts[i].type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TMPARAM_AFTER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fin_time = TimestampTzPlusMilliseconds(<a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; timeouts[i].delay_ms);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L158" title="utils/misc/timeout.c:158">enable_timeout</a>(id, <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, fin_time, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TMPARAM_AT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L158" title="utils/misc/timeout.c:158">enable_timeout</a>(id, <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, timeouts[i].fin_time, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TMPARAM_EVERY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fin_time = TimestampTzPlusMilliseconds(<a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; timeouts[i].delay_ms);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L158" title="utils/misc/timeout.c:158">enable_timeout</a>(id, <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, fin_time, timeouts[i].delay_ms);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized timeout type </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) timeouts[i].type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set the timer interrupt. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L210" title="utils/misc/timeout.c:210">schedule_alarm</a>(<a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cancel the specified timeout.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The timeout's I've-been-fired indicator is reset,<br/></li>
<li></span><span class="Comment"> * unless keep_indicator is true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When a timeout is canceled, <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other active timeout remains in force.<br/></li>
<li></span><span class="Comment"> * It's not an error to disable a timeout that is not enabled.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L685">&#x200c;</a></span><span class="linkable">disable_timeout</span>(TimeoutId id, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> keep_indicator)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assert request is sane */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L46" title="utils/misc/timeout.c:46">all_timeouts_initialized</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].timeout_handler != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Disable timeout interrupts for safety. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L69" title="utils/misc/timeout.c:69">disable_alarm</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the timeout and remove it from the active list. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].active)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="utils/misc/timeout.c:137">remove_timeout_index</a>(<a href="#L96" title="utils/misc/timeout.c:96">find_active_timeout</a>(id));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark it inactive, whether it was active or not. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!keep_indicator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].indicator = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reschedule the interrupt, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> timeouts remain active. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L52" title="utils/misc/timeout.c:52">num_active_timeouts</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L210" title="utils/misc/timeout.c:210">schedule_alarm</a>(<a href="../adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>());<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cancel multiple timeouts at once.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The timeouts' I've-been-fired indicators are reset,<br/></li>
<li></span><span class="Comment"> * unless timeouts[i].keep_indicator is true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This works like calling <a href="#L685" title="utils/misc/timeout.c:685">disable_timeout</a>() multiple times.<br/></li>
<li></span><span class="Comment"> * Use this to reduce the number of <a href="../adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>()<br/></li>
<li></span><span class="Comment"> * and <a href="../../port/win32/timer.c.html#L86" title="port/win32/timer.c:86">setitimer</a>() calls needed to cancel multiple timeouts.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L718">&#x200c;</a></span><span class="linkable">disable_timeouts</span>(<span class="Type">const</span> DisableTimeoutParams *timeouts, <span class="Type">int</span> count)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L46" title="utils/misc/timeout.c:46">all_timeouts_initialized</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Disable timeout interrupts for safety. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L69" title="utils/misc/timeout.c:69">disable_alarm</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cancel the timeout(s). */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; count; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeoutId&nbsp; &nbsp; id = timeouts[i].id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].timeout_handler != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].active)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="utils/misc/timeout.c:137">remove_timeout_index</a>(<a href="#L96" title="utils/misc/timeout.c:96">find_active_timeout</a>(id));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!timeouts[i].keep_indicator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].indicator = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reschedule the interrupt, if <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> timeouts remain active. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L52" title="utils/misc/timeout.c:52">num_active_timeouts</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L210" title="utils/misc/timeout.c:210">schedule_alarm</a>(<a href="../adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>());<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Disable the signal handler, remove all timeouts from the active list,<br/></li>
<li></span><span class="Comment"> * and optionally reset their timeout indicators.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L751">&#x200c;</a></span><span class="linkable">disable_all_timeouts</span>(<span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> keep_indicators)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L69" title="utils/misc/timeout.c:69">disable_alarm</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We used to disable the timer interrupt here, but in common usage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * patterns it's cheaper to leave it enabled; that may save us from having<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to enable it again shortly.&nbsp; See comments in <a href="#L210" title="utils/misc/timeout.c:210">schedule_alarm</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="utils/misc/timeout.c:52">num_active_timeouts</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; MAX_TIMEOUTS; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[i].active = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!keep_indicators)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[i].indicator = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return true if the timeout is active (enabled and not yet fired)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is, of course, subject to race conditions, as the timeout could fire<br/></li>
<li></span><span class="Comment"> * immediately after we look.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L780">&#x200c;</a></span><span class="linkable">get_timeout_active</span>(TimeoutId id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].active;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the timeout's I've-been-fired indicator<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If reset_indicator is true, reset the indicator when returning true.<br/></li>
<li></span><span class="Comment"> * To avoid missing timeouts due to race conditions, we are careful not to<br/></li>
<li></span><span class="Comment"> * reset the indicator when returning false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L793">&#x200c;</a></span><span class="linkable">get_timeout_indicator</span>(TimeoutId id, <span class="Type"><a href="../fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> reset_indicator)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].indicator)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reset_indicator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].indicator = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the time when the timeout was most recently activated<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: will return 0 if timeout has never been activated in this process.<br/></li>
<li></span><span class="Comment"> * However, we do *not* reset the start_time when a timeout occurs, so as<br/></li>
<li></span><span class="Comment"> * not to create a race condition if SIGALRM fires just as some code is<br/></li>
<li></span><span class="Comment"> * about to fetch the value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TimestampTz<br/></li>
<li><a id="L813">&#x200c;</a><span class="linkable">get_timeout_start_time</span>(TimeoutId id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].start_time;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the time when the timeout is, or most recently was, due to fire<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: will return 0 if timeout has never been activated in this process.<br/></li>
<li></span><span class="Comment"> * However, we do *not* reset the fin_time when a timeout occurs, so as<br/></li>
<li></span><span class="Comment"> * not to create a race condition if SIGALRM fires just as some code is<br/></li>
<li></span><span class="Comment"> * about to fetch the value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TimestampTz<br/></li>
<li><a id="L827">&#x200c;</a><span class="linkable">get_timeout_finish_time</span>(TimeoutId id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L45" title="utils/misc/timeout.c:45">all_timeouts</a>[id].fin_time;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
