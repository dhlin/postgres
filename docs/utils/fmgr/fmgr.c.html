<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>utils/fmgr/fmgr.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>utils/fmgr/fmgr.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L55">CFuncHash</a></li>
<li><a href="#L40">fmgr_hook</a></li>
<li><a href="#L39">needs_fmgr_hook</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L53">CFuncHashTabEntry</a></li>
<li><a href="#L611">fmgr_security_definer_cache</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1065">CallerFInfoFunctionCall1</a></li>
<li><a href="#L1085">CallerFInfoFunctionCall2</a></li>
<li><a href="#L2145">CheckFunctionValidatorAccess</a></li>
<li><a href="#L792">DirectFunctionCall1Coll</a></li>
<li><a href="#L812">DirectFunctionCall2Coll</a></li>
<li><a href="#L834">DirectFunctionCall3Coll</a></li>
<li><a href="#L859">DirectFunctionCall4Coll</a></li>
<li><a href="#L886">DirectFunctionCall5Coll</a></li>
<li><a href="#L915">DirectFunctionCall6Coll</a></li>
<li><a href="#L947">DirectFunctionCall7Coll</a></li>
<li><a href="#L981">DirectFunctionCall8Coll</a></li>
<li><a href="#L1017">DirectFunctionCall9Coll</a></li>
<li><a href="#L1640">DirectInputFunctionCallSafe</a></li>
<li><a href="#L1816">Float8GetDatum</a></li>
<li><a href="#L1112">FunctionCall0Coll</a></li>
<li><a href="#L1129">FunctionCall1Coll</a></li>
<li><a href="#L1149">FunctionCall2Coll</a></li>
<li><a href="#L1171">FunctionCall3Coll</a></li>
<li><a href="#L1196">FunctionCall4Coll</a></li>
<li><a href="#L1223">FunctionCall5Coll</a></li>
<li><a href="#L1252">FunctionCall6Coll</a></li>
<li><a href="#L1284">FunctionCall7Coll</a></li>
<li><a href="#L1318">FunctionCall8Coll</a></li>
<li><a href="#L1354">FunctionCall9Coll</a></li>
<li><a href="#L1530">InputFunctionCall</a></li>
<li><a href="#L1585">InputFunctionCallSafe</a></li>
<li><a href="#L1807">Int64GetDatum</a></li>
<li><a href="#L1401">OidFunctionCall0Coll</a></li>
<li><a href="#L1411">OidFunctionCall1Coll</a></li>
<li><a href="#L1421">OidFunctionCall2Coll</a></li>
<li><a href="#L1431">OidFunctionCall3Coll</a></li>
<li><a href="#L1442">OidFunctionCall4Coll</a></li>
<li><a href="#L1453">OidFunctionCall5Coll</a></li>
<li><a href="#L1464">OidFunctionCall6Coll</a></li>
<li><a href="#L1477">OidFunctionCall7Coll</a></li>
<li><a href="#L1490">OidFunctionCall8Coll</a></li>
<li><a href="#L1503">OidFunctionCall9Coll</a></li>
<li><a href="#L1754">OidInputFunctionCall</a></li>
<li><a href="#L1763">OidOutputFunctionCall</a></li>
<li><a href="#L1772">OidReceiveFunctionCall</a></li>
<li><a href="#L1782">OidSendFunctionCall</a></li>
<li><a href="#L1683">OutputFunctionCall</a></li>
<li><a href="#L1697">ReceiveFunctionCall</a></li>
<li><a href="#L1744">SendFunctionCall</a></li>
<li><a href="#L455">fetch_finfo_record</a></li>
<li><a href="#L127">fmgr_info</a></li>
<li><a href="#L349">fmgr_info_C_lang</a></li>
<li><a href="#L580">fmgr_info_copy</a></li>
<li><a href="#L137">fmgr_info_cxt</a></li>
<li><a href="#L147">fmgr_info_cxt_security</a></li>
<li><a href="#L418">fmgr_info_other_lang</a></li>
<li><a href="#L595">fmgr_internal_function</a></li>
<li><a href="#L76">fmgr_isbuiltin</a></li>
<li><a href="#L101">fmgr_lookupByName</a></li>
<li><a href="#L632">fmgr_security_definer</a></li>
<li><a href="#L281">fmgr_symbol</a></li>
<li><a href="#L1994">get_call_expr_arg_stable</a></li>
<li><a href="#L1929">get_call_expr_argtype</a></li>
<li><a href="#L1975">get_fn_expr_arg_stable</a></li>
<li><a href="#L1910">get_fn_expr_argtype</a></li>
<li><a href="#L1888">get_fn_expr_rettype</a></li>
<li><a href="#L2044">get_fn_expr_variadic</a></li>
<li><a href="#L2097">get_fn_opclass_options</a></li>
<li><a href="#L2081">has_fn_opclass_options</a></li>
<li><a href="#L515">lookup_C_func</a></li>
<li><a href="#L1832">pg_detoast_datum</a></li>
<li><a href="#L1841">pg_detoast_datum_copy</a></li>
<li><a href="#L1864">pg_detoast_datum_packed</a></li>
<li><a href="#L1857">pg_detoast_datum_slice</a></li>
<li><a href="#L539">record_C_func</a></li>
<li><a href="#L2070">set_fn_opclass_options</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * fmgr.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The Postgres function manager.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/utils/fmgr/fmgr.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/detoast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_language.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/<a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/stringinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/miscnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/acl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrtab.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Hooks for function calls<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L39">&#x200c;</a></span>PGDLLIMPORT needs_fmgr_hook_type <span class="linkable">needs_fmgr_hook</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L40">&#x200c;</a>PGDLLIMPORT fmgr_hook_type <span class="linkable">fmgr_hook</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Hashtable for fast lookup of external C <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fn_oid is the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key and so must be first! */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fn_oid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OID of an external C function */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId fn_xmin;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for checking up-to-dateness */<br/></li>
<li></span>&nbsp; &nbsp; ItemPointerData fn_tid;<br/></li>
<li>&nbsp; &nbsp; PGFunction&nbsp; &nbsp; user_fn;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the function's address */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">const</span> Pg_finfo_record *inforec; <span class="Comment">/* address of its info record */<br/></li>
<li><a id="L53">&#x200c;</a></span>} <span class="linkable">CFuncHashTabEntry</span>;<br/></li>
<li><br/></li>
<li><a id="L55">&#x200c;</a><span class="Type">static</span> <a href="../hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">CFuncHash</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L147" title="utils/fmgr/fmgr.c:147">fmgr_info_cxt_security</a>(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> ignore_security);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L349" title="utils/fmgr/fmgr.c:349">fmgr_info_C_lang</a>(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L418" title="utils/fmgr/fmgr.c:418">fmgr_info_other_lang</a>(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple);<br/></li>
<li><span class="Type">static</span> <a href="#L53" title="utils/fmgr/fmgr.c:53">CFuncHashTabEntry</a> *<a href="#L515" title="utils/fmgr/fmgr.c:515">lookup_C_func</a>(HeapTuple procedureTuple);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L539" title="utils/fmgr/fmgr.c:539">record_C_func</a>(HeapTuple procedureTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGFunction user_fn, <span class="Type">const</span> Pg_finfo_record *inforec);<br/></li>
<li><br/></li>
<li><span class="Comment">/* extern so it's callable via JIT */<br/></li>
<li></span><span class="Type">extern</span> Datum <a href="#L632" title="utils/fmgr/fmgr.c:632">fmgr_security_definer</a>(PG_FUNCTION_ARGS);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Lookup routines for builtin-function table.&nbsp; We can search by either Oid<br/></li>
<li></span><span class="Comment"> * or name, but search by Oid is much faster.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> FmgrBuiltin *<br/></li>
<li><a id="L76">&#x200c;</a><span class="linkable">fmgr_isbuiltin</span>(Oid id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fast lookup only possible if original oid still assigned */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (id &gt; fmgr_last_builtin_oid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lookup function data. If there's a <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> in that <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> it's likely a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nonexistent function, returning NULL here will <a href="../adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> an ERROR later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; index = fmgr_builtin_oid_index[id];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (index == InvalidOidBuiltinMapping)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;fmgr_builtins[index];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Lookup a builtin by name.&nbsp; Note there can be more than one entry in<br/></li>
<li></span><span class="Comment"> * the array with the same name, but they should all point to the same<br/></li>
<li></span><span class="Comment"> * routine.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> FmgrBuiltin *<br/></li>
<li><a id="L101">&#x200c;</a><span class="linkable">fmgr_lookupByName</span>(<span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; fmgr_nbuiltins; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(name, fmgr_builtins[i].funcName) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> fmgr_builtins + i;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This routine fills a FmgrInfo struct, given the OID<br/></li>
<li></span><span class="Comment"> * of the function to be called.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller's <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> is used as the fn_mcxt of the info<br/></li>
<li></span><span class="Comment"> * struct; this means that <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsidiary data attached to the info struct<br/></li>
<li></span><span class="Comment"> * (either by <a href="#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a> itself, or later on by a function call handler)<br/></li>
<li></span><span class="Comment"> * will be allocated in that context.&nbsp; The caller must ensure that this<br/></li>
<li></span><span class="Comment"> * context is at least as long-lived as the info struct itself.&nbsp; This is<br/></li>
<li></span><span class="Comment"> * not a problem in typical cases where the info struct is on the stack or<br/></li>
<li></span><span class="Comment"> * in freshly-<a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d space.&nbsp; However, if one intends to store an info<br/></li>
<li></span><span class="Comment"> * struct in a long-lived table, it's better to use <a href="#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L127">&#x200c;</a></span><span class="linkable">fmgr_info</span>(Oid functionId, FmgrInfo *finfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L147" title="utils/fmgr/fmgr.c:147">fmgr_info_cxt_security</a>(functionId, finfo, <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fill a FmgrInfo struct, specifying a memory context in which its<br/></li>
<li></span><span class="Comment"> * subsidiary data should go.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L137">&#x200c;</a></span><span class="linkable">fmgr_info_cxt</span>(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L147" title="utils/fmgr/fmgr.c:147">fmgr_info_cxt_security</a>(functionId, finfo, mcxt, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This one does the actual work.&nbsp; ignore_security is ordinarily false<br/></li>
<li></span><span class="Comment"> * but is set to true when we need to avoid recursion.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L147">&#x200c;</a></span><span class="linkable">fmgr_info_cxt_security</span>(Oid functionId, FmgrInfo *finfo, MemoryContext mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> ignore_security)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> FmgrBuiltin *fbp;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; procedureTuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_proc procedureStruct;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; prosrcdatum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *prosrc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fn_oid *must* be filled in last.&nbsp; Some code assumes that if fn_oid is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * valid, the whole struct is valid.&nbsp; Some FmgrInfo struct's do survive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * elogs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; finfo-&gt;fn_oid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; finfo-&gt;fn_extra = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; finfo-&gt;fn_mcxt = mcxt;<br/></li>
<li>&nbsp; &nbsp; finfo-&gt;fn_expr = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caller may set this later */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((fbp = <a href="#L76" title="utils/fmgr/fmgr.c:76">fmgr_isbuiltin</a>(functionId)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fast path for builtin <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>: don't bother consulting pg_proc<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;fn_nargs = fbp-&gt;nargs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;fn_strict = fbp-&gt;strict;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;fn_retset = fbp-&gt;retset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;fn_stats = TRACK_FUNC_ALL;&nbsp; &nbsp; <span class="Comment">/* ie, never track */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;fn_addr = fbp-&gt;func;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;fn_oid = functionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise we need the pg_proc entry */<br/></li>
<li></span>&nbsp; &nbsp; procedureTuple = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(functionId));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(procedureTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for function </span><span class="Special">%u</span><span class="Constant">&quot;</span>, functionId);<br/></li>
<li>&nbsp; &nbsp; procedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; finfo-&gt;fn_nargs = procedureStruct-&gt;pronargs;<br/></li>
<li>&nbsp; &nbsp; finfo-&gt;fn_strict = procedureStruct-&gt;proisstrict;<br/></li>
<li>&nbsp; &nbsp; finfo-&gt;fn_retset = procedureStruct-&gt;proretset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it has prosecdef set, non-null proconfig, or if a plugin wants to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hook function entry/exit, use <a href="#L632" title="utils/fmgr/fmgr.c:632">fmgr_security_definer</a> call handler ---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unless we are being called again by <a href="#L632" title="utils/fmgr/fmgr.c:632">fmgr_security_definer</a> or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L418" title="utils/fmgr/fmgr.c:418">fmgr_info_other_lang</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When using <a href="#L632" title="utils/fmgr/fmgr.c:632">fmgr_security_definer</a>, function stats tracking is always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disabled at the outer level, and instead we set the flag properly in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L632" title="utils/fmgr/fmgr.c:632">fmgr_security_definer</a>'s private flinfo and implement the tracking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inside <a href="#L632" title="utils/fmgr/fmgr.c:632">fmgr_security_definer</a>.&nbsp; This loses the ability to <a href="../adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overhead of <a href="#L632" title="utils/fmgr/fmgr.c:632">fmgr_security_definer</a> to the function, but gains the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ability to set the track_functions GUC as a local GUC parameter of an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interesting function and have the right things happen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!ignore_security &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (procedureStruct-&gt;prosecdef ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="../../access/common/heaptuple.c.html#L455" title="access/common/heaptuple.c:455">heap_attisnull</a>(procedureTuple, Anum_pg_proc_proconfig, <span class="Constant">NULL</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FmgrHookIsNeeded(functionId)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;fn_addr = <a href="#L632" title="utils/fmgr/fmgr.c:632">fmgr_security_definer</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;fn_stats = TRACK_FUNC_ALL;&nbsp; &nbsp; <span class="Comment">/* ie, never track */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;fn_oid = functionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(procedureTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (procedureStruct-&gt;prolang)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERNALlanguageId:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For an ordinary builtin function, we should never get here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because the <a href="#L76" title="utils/fmgr/fmgr.c:76">fmgr_isbuiltin</a>() search above will have succeeded.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, if the user has done a CREATE FUNCTION to create an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * alias for a builtin function, we can end up here.&nbsp; In that case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we have to look up the function by name.&nbsp; The name of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> function is stored in prosrc (it doesn't have to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same as the name of the alias!)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prosrcdatum = <a href="../cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(PROCOID, procedureTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Anum_pg_proc_prosrc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prosrc = TextDatumGetCString(prosrcdatum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fbp = <a href="#L101" title="utils/fmgr/fmgr.c:101">fmgr_lookupByName</a>(prosrc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fbp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> function </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not in <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> lookup table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prosrc)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(prosrc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should we check that nargs, strict, retset match the table? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;fn_addr = fbp-&gt;func;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* note this policy is also assumed in fast path above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;fn_stats = TRACK_FUNC_ALL;&nbsp; &nbsp; <span class="Comment">/* ie, never track */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ClanguageId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L349" title="utils/fmgr/fmgr.c:349">fmgr_info_C_lang</a>(functionId, finfo, procedureTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;fn_stats = TRACK_FUNC_PL;&nbsp; &nbsp; <span class="Comment">/* ie, track if ALL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SQLlanguageId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;fn_addr = <a href="../../executor/functions.c.html#L1028" title="executor/functions.c:1028">fmgr_sql</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;fn_stats = TRACK_FUNC_PL;&nbsp; &nbsp; <span class="Comment">/* ie, track if ALL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L418" title="utils/fmgr/fmgr.c:418">fmgr_info_other_lang</a>(functionId, finfo, procedureTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;fn_stats = TRACK_FUNC_OFF;&nbsp; &nbsp; <span class="Comment">/* ie, track if not <a href="../../regex/regexec.c.html#L131" title="regex/regexec.c:131">OFF</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; finfo-&gt;fn_oid = functionId;<br/></li>
<li>&nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(procedureTuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return module and C function name providing implementation of functionId.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If *mod == NULL and *fn == NULL, no C symbol is known to implement<br/></li>
<li></span><span class="Comment"> * function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If *mod == NULL and *fn != NULL, the function is implemented by a symbol in<br/></li>
<li></span><span class="Comment"> * the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> binary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If *mod != NULL and *fn != NULL the function is implemented in an extension<br/></li>
<li></span><span class="Comment"> * shared object.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned module and function names are <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>'ed into the current<br/></li>
<li></span><span class="Comment"> * memory context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L281">&#x200c;</a></span><span class="linkable">fmgr_symbol</span>(Oid functionId, <span class="Type">char</span> **mod, <span class="Type">char</span> **fn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; procedureTuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_proc procedureStruct;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; prosrcattr;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; probinattr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; procedureTuple = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(functionId));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(procedureTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for function </span><span class="Special">%u</span><span class="Constant">&quot;</span>, functionId);<br/></li>
<li>&nbsp; &nbsp; procedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (procedureStruct-&gt;prosecdef ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../access/common/heaptuple.c.html#L455" title="access/common/heaptuple.c:455">heap_attisnull</a>(procedureTuple, Anum_pg_proc_proconfig, <span class="Constant">NULL</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FmgrHookIsNeeded(functionId))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *mod = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* core binary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *fn = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;<a href="#L632" title="utils/fmgr/fmgr.c:632">fmgr_security_definer</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(procedureTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* see <a href="#L147" title="utils/fmgr/fmgr.c:147">fmgr_info_cxt_security</a> for the individual cases */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (procedureStruct-&gt;prolang)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INTERNALlanguageId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prosrcattr = <a href="../cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(PROCOID, procedureTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_proc_prosrc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *mod = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* core binary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *fn = TextDatumGetCString(prosrcattr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> ClanguageId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prosrcattr = <a href="../cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(PROCOID, procedureTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_proc_prosrc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; probinattr = <a href="../cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(PROCOID, procedureTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_proc_probin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No need to check symbol presence / API version here, already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checked in <a href="#L147" title="utils/fmgr/fmgr.c:147">fmgr_info_cxt_security</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *mod = TextDatumGetCString(probinattr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *fn = TextDatumGetCString(prosrcattr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SQLlanguageId:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *mod = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* core binary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *fn = <a href="../mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;<a href="../../executor/functions.c.html#L1028" title="executor/functions.c:1028">fmgr_sql</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *mod = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *fn = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unknown, pass pointer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(procedureTuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Special <a href="#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a> processing for C-language <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; Note that<br/></li>
<li></span><span class="Comment"> * finfo-&gt;fn_oid is not valid yet.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L349">&#x200c;</a></span><span class="linkable">fmgr_info_C_lang</span>(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L53" title="utils/fmgr/fmgr.c:53">CFuncHashTabEntry</a> *hashentry;<br/></li>
<li>&nbsp; &nbsp; PGFunction&nbsp; &nbsp; user_fn;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> Pg_finfo_record *inforec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if we have the function address cached already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hashentry = <a href="#L515" title="utils/fmgr/fmgr.c:515">lookup_C_func</a>(procedureTuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hashentry)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; user_fn = hashentry-&gt;user_fn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inforec = hashentry-&gt;inforec;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; prosrcattr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; probinattr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *prosrcstring,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *probinstring;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *libraryhandle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get prosrc and probin strings (link symbol and library filename).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * While in general these columns might be null, that's not allowed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for C-language <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; prosrcattr = <a href="../cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(PROCOID, procedureTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_proc_prosrc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prosrcstring = TextDatumGetCString(prosrcattr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; probinattr = <a href="../cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(PROCOID, procedureTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_proc_probin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; probinstring = TextDatumGetCString(probinattr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Look up the function itself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; user_fn = <a href="dfmgr.c.html#L105" title="utils/fmgr/dfmgr.c:105">load_external_function</a>(probinstring, prosrcstring, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;libraryhandle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the function information record (real or default) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; inforec = <a href="#L455" title="utils/fmgr/fmgr.c:455">fetch_finfo_record</a>(libraryhandle, prosrcstring);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Cache the addresses for later calls */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L539" title="utils/fmgr/fmgr.c:539">record_C_func</a>(procedureTuple, user_fn, inforec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(prosrcstring);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(probinstring);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (inforec-&gt;api_version)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* New style: call directly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo-&gt;fn_addr = user_fn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Shouldn't get here if <a href="#L455" title="utils/fmgr/fmgr.c:455">fetch_finfo_record</a> did its job */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized function API version: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inforec-&gt;api_version);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Special <a href="#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a> processing for other-language <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; Note<br/></li>
<li></span><span class="Comment"> * that finfo-&gt;fn_oid is not valid yet.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L418">&#x200c;</a></span><span class="linkable">fmgr_info_other_lang</span>(Oid functionId, FmgrInfo *finfo, HeapTuple procedureTuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Form_pg_proc procedureStruct = (Form_pg_proc) GETSTRUCT(procedureTuple);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; language = procedureStruct-&gt;prolang;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; languageTuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_language languageStruct;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; plfinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; languageTuple = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(LANGOID, ObjectIdGetDatum(language));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(languageTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for language </span><span class="Special">%u</span><span class="Constant">&quot;</span>, language);<br/></li>
<li>&nbsp; &nbsp; languageStruct = (Form_pg_language) GETSTRUCT(languageTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the language's call handler function, ignoring <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> attributes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that would normally cause insertion of <a href="#L632" title="utils/fmgr/fmgr.c:632">fmgr_security_definer</a>.&nbsp; We need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to get back a bare pointer to the actual C-language function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L147" title="utils/fmgr/fmgr.c:147">fmgr_info_cxt_security</a>(languageStruct-&gt;lanplcallfoid, &amp;plfinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; finfo-&gt;fn_addr = plfinfo.fn_addr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(languageTuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch and validate the information record for the given external function.<br/></li>
<li></span><span class="Comment"> * The function is specified by a handle for the containing library<br/></li>
<li></span><span class="Comment"> * (obtained from <a href="dfmgr.c.html#L105" title="utils/fmgr/dfmgr.c:105">load_external_function</a>) as well as the function name.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If no info function exists for the given name an error is raised.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is broken out of <a href="#L349" title="utils/fmgr/fmgr.c:349">fmgr_info_C_lang</a> so that <a href="../../catalog/pg_proc.c.html#L768" title="catalog/pg_proc.c:768">fmgr_c_validator</a><br/></li>
<li></span><span class="Comment"> * can validate the information record for a function not yet entered into<br/></li>
<li></span><span class="Comment"> * pg_proc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> Pg_finfo_record *<br/></li>
<li><a id="L455">&#x200c;</a><span class="linkable">fetch_finfo_record</span>(<span class="Type">void</span> *filehandle, <span class="Type">const</span> <span class="Type">char</span> *funcname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *infofuncname;<br/></li>
<li>&nbsp; &nbsp; PGFInfoFunction infofunc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> Pg_finfo_record *inforec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; infofuncname = psprintf(<span class="Constant">&quot;pg_finfo_</span><span class="Special">%s</span><span class="Constant">&quot;</span>, funcname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to look up the info function */<br/></li>
<li></span>&nbsp; &nbsp; infofunc = (PGFInfoFunction) <a href="dfmgr.c.html#L166" title="utils/fmgr/dfmgr.c:166">lookup_external_function</a>(filehandle,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; infofuncname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (infofunc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> function information for function </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; funcname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;SQL-callable <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> need an accompanying PG_FUNCTION_INFO_V1(funcname).&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* silence compiler */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Found, so call it */<br/></li>
<li></span>&nbsp; &nbsp; inforec = (*infofunc) ();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Validate result as best we can */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (inforec == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;null result from info function </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, infofuncname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (inforec-&gt;api_version)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, no additional fields to validate */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unrecognized API version </span><span class="Special">%d</span><span class="Constant"> reported by info function </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inforec-&gt;api_version, infofuncname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(infofuncname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> inforec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Routines for caching lookup information for external C <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The routines in dfmgr.c are relatively slow, so we try to avoid running<br/></li>
<li></span><span class="Comment"> * them more than once per external function per session.&nbsp; We use a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table<br/></li>
<li></span><span class="Comment"> * with the function OID as the lookup key.<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L515" title="utils/fmgr/fmgr.c:515">lookup_C_func</a>: try to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a C function in the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If an entry exists and is up to date, return it; else return NULL<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L53" title="utils/fmgr/fmgr.c:53">CFuncHashTabEntry</a> *<br/></li>
<li><a id="L515">&#x200c;</a><span class="linkable">lookup_C_func</span>(HeapTuple procedureTuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fn_oid = ((Form_pg_proc) GETSTRUCT(procedureTuple))-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L53" title="utils/fmgr/fmgr.c:53">CFuncHashTabEntry</a> *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L55" title="utils/fmgr/fmgr.c:55">CFuncHash</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no table yet */<br/></li>
<li></span>&nbsp; &nbsp; entry = (<a href="#L53" title="utils/fmgr/fmgr.c:53">CFuncHashTabEntry</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L55" title="utils/fmgr/fmgr.c:55">CFuncHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;fn_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no such entry */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;fn_xmin == HeapTupleHeaderGetRawXmin(procedureTuple-&gt;t_data) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;entry-&gt;fn_tid, &amp;procedureTuple-&gt;t_self))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> entry;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* entry is out of date */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L539" title="utils/fmgr/fmgr.c:539">record_C_func</a>: enter (or update) info about a C function in the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L539">&#x200c;</a></span><span class="linkable">record_C_func</span>(HeapTuple procedureTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGFunction user_fn, <span class="Type">const</span> Pg_finfo_record *inforec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fn_oid = ((Form_pg_proc) GETSTRUCT(procedureTuple))-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L53" title="utils/fmgr/fmgr.c:53">CFuncHashTabEntry</a> *entry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table if it doesn't exist yet */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L55" title="utils/fmgr/fmgr.c:55">CFuncHash</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L53" title="utils/fmgr/fmgr.c:53">CFuncHashTabEntry</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L55" title="utils/fmgr/fmgr.c:55">CFuncHash</a> = <a href="../hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;<a href="#L55" title="utils/fmgr/fmgr.c:55">CFuncHash</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">100</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry = (<a href="#L53" title="utils/fmgr/fmgr.c:53">CFuncHashTabEntry</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L55" title="utils/fmgr/fmgr.c:55">CFuncHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;fn_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OID is already filled in */<br/></li>
<li></span>&nbsp; &nbsp; entry-&gt;fn_xmin = HeapTupleHeaderGetRawXmin(procedureTuple-&gt;t_data);<br/></li>
<li>&nbsp; &nbsp; entry-&gt;fn_tid = procedureTuple-&gt;t_self;<br/></li>
<li>&nbsp; &nbsp; entry-&gt;user_fn = user_fn;<br/></li>
<li>&nbsp; &nbsp; entry-&gt;inforec = inforec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy an FmgrInfo struct<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is inherently somewhat bogus since we can't reliably duplicate<br/></li>
<li></span><span class="Comment"> * language-dependent subsidiary info.&nbsp; We cheat by zeroing fn_extra,<br/></li>
<li></span><span class="Comment"> * instead, meaning that subsidiary info will have to be recomputed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L580">&#x200c;</a></span><span class="linkable">fmgr_info_copy</span>(FmgrInfo *dstinfo, FmgrInfo *srcinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MemoryContext destcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; memcpy(dstinfo, srcinfo, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FmgrInfo));<br/></li>
<li>&nbsp; &nbsp; dstinfo-&gt;fn_mcxt = destcxt;<br/></li>
<li>&nbsp; &nbsp; dstinfo-&gt;fn_extra = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Specialized lookup routine for <a href="../../catalog/pg_proc.c.html#L725" title="catalog/pg_proc.c:725">fmgr_internal_validator</a>: given the alleged<br/></li>
<li></span><span class="Comment"> * name of an <a href="../adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> function, return the OID of the function.<br/></li>
<li></span><span class="Comment"> * If the name is not recognized, return InvalidOid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L595">&#x200c;</a><span class="linkable">fmgr_internal_function</span>(<span class="Type">const</span> <span class="Type">char</span> *proname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> FmgrBuiltin *fbp = <a href="#L101" title="utils/fmgr/fmgr.c:101">fmgr_lookupByName</a>(proname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fbp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> fbp-&gt;foid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Support for security-definer and proconfig-using <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; We support<br/></li>
<li></span><span class="Comment"> * both of these features using the same call handler, because they are<br/></li>
<li></span><span class="Comment"> * often used together and it would be inefficient (as well as notationally<br/></li>
<li></span><span class="Comment"> * messy) to have two levels of call handler involved.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L611">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">fmgr_security_definer_cache</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; flinfo;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lookup info for target function */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; userid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* userid to set, or InvalidOid */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *configNames;&nbsp; &nbsp; <span class="Comment">/* GUC names to set, or NIL */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *configHandles;&nbsp; &nbsp; <span class="Comment">/* GUC handles to set, or NIL */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *configValues;&nbsp; &nbsp; <span class="Comment">/* GUC <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to set, or NIL */<br/></li>
<li></span>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* passthrough argument for plugin modules */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Function handler for security-definer/proconfig/plugin-hooked <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> * We extract the OID of the actual function and do a fmgr lookup again.<br/></li>
<li></span><span class="Comment"> * Then we fetch the pg_proc row and copy the owner ID and proconfig fields.<br/></li>
<li></span><span class="Comment"> * (All this info is cached for the duration of the current query.)<br/></li>
<li></span><span class="Comment"> * To execute a call, we temporarily replace the flinfo with the cached<br/></li>
<li></span><span class="Comment"> * and looked-up one, while keeping the outer fcinfo (which contains all<br/></li>
<li></span><span class="Comment"> * the actual arguments, etc.) intact.&nbsp; This is not re-entrant, but then<br/></li>
<li></span><span class="Comment"> * the fcinfo itself can't be used reentrantly anyway.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">extern</span> Datum<br/></li>
<li><a id="L632">&#x200c;</a><span class="linkable">fmgr_security_definer</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L611" title="utils/fmgr/fmgr.c:611">fmgr_security_definer_cache</a> *<span class="Type">volatile</span> fcache;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *save_flinfo;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_userid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_sec_context;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lc2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lc3;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> <span class="Type">int</span> save_nestlevel;<br/></li>
<li>&nbsp; &nbsp; PgStat_FunctionCallUsage fcusage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!fcinfo-&gt;flinfo-&gt;fn_extra)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_proc procedureStruct;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcache = <a href="../mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(fcinfo-&gt;flinfo-&gt;fn_mcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*fcache));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L147" title="utils/fmgr/fmgr.c:147">fmgr_info_cxt_security</a>(fcinfo-&gt;flinfo-&gt;fn_oid, &amp;fcache-&gt;flinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fcinfo-&gt;flinfo-&gt;fn_mcxt, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcache-&gt;flinfo.fn_expr = fcinfo-&gt;flinfo-&gt;fn_expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(fcinfo-&gt;flinfo-&gt;fn_oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for function </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fcinfo-&gt;flinfo-&gt;fn_oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; procedureStruct = (Form_pg_proc) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (procedureStruct-&gt;prosecdef)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcache-&gt;userid = procedureStruct-&gt;proowner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(PROCOID, tuple, Anum_pg_proc_proconfig,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *array;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(fcinfo-&gt;flinfo-&gt;fn_mcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array = DatumGetArrayTypeP(datum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc.c.html#L6358" title="utils/misc/guc.c:6358">TransformGUCArray</a>(array, &amp;fcache-&gt;configNames,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;fcache-&gt;configValues);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* transform names to config handles to avoid lookup cost */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcache-&gt;configHandles = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, fcache-&gt;configNames)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name = (<span class="Type">char</span> *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fcache-&gt;configHandles = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(fcache-&gt;configHandles,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc.c.html#L4237" title="utils/misc/guc.c:4237">get_config_handle</a>(name));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo-&gt;fn_extra = fcache;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fcache = fcinfo-&gt;flinfo-&gt;fn_extra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../init/miscinit.c.html#L635" title="utils/init/miscinit.c:635">GetUserIdAndSecContext</a> is cheap enough that no harm in a wasted call */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../init/miscinit.c.html#L635" title="utils/init/miscinit.c:635">GetUserIdAndSecContext</a>(&amp;save_userid, &amp;save_sec_context);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fcache-&gt;configNames != NIL) <span class="Comment">/* Need a new GUC nesting level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; save_nestlevel = <a href="../misc/guc.c.html#L2237" title="utils/misc/guc.c:2237">NewGUCNestLevel</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; save_nestlevel = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(fcache-&gt;userid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(fcache-&gt;userid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; save_sec_context | SECURITY_LOCAL_USERID_CHANGE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; forthree(lc1, fcache-&gt;configNames,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lc2, fcache-&gt;configHandles,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lc3, fcache-&gt;configValues)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GucContext&nbsp; &nbsp; context = <a href="../misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a>() ? PGC_SUSET : PGC_USERSET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GucSource&nbsp; &nbsp; source = PGC_S_SESSION;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GucAction&nbsp; &nbsp; action = GUC_ACTION_SAVE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name = lfirst(lc1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; config_handle *handle = lfirst(lc2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *value = lfirst(lc3);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../misc/guc.c.html#L3403" title="utils/misc/guc.c:3403">set_config_with_handle</a>(name, handle, value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context, source, <a href="../init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action, <span class="Constant">true</span>, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* function manager hook */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L40" title="utils/fmgr/fmgr.c:40">fmgr_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L40" title="utils/fmgr/fmgr.c:40">fmgr_hook</a>) (FHET_START, &amp;fcache-&gt;flinfo, &amp;fcache-&gt;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't need to restore GUC or userid settings on error, because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensuing xact or subxact abort will do that.&nbsp; The PG_TRY block is only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needed to clean up the flinfo link.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; save_flinfo = fcinfo-&gt;flinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo = &amp;fcache-&gt;flinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See notes in <a href="#L147" title="utils/fmgr/fmgr.c:147">fmgr_info_cxt_security</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../activity/pgstat_function.c.html#L72" title="utils/activity/pgstat_function.c:72">pgstat_init_function_usage</a>(fcinfo, &amp;fcusage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = FunctionCallInvoke(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could be calling either a regular or a set-returning function,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so we have to test to see what finalize flag to use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../activity/pgstat_function.c.html#L146" title="utils/activity/pgstat_function.c:146">pgstat_end_function_usage</a>(&amp;fcusage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fcinfo-&gt;resultinfo == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !IsA(fcinfo-&gt;resultinfo, ReturnSetInfo) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((ReturnSetInfo *) fcinfo-&gt;resultinfo)-&gt;isDone != ExprMultipleResult));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fcinfo-&gt;flinfo = save_flinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L40" title="utils/fmgr/fmgr.c:40">fmgr_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L40" title="utils/fmgr/fmgr.c:40">fmgr_hook</a>) (FHET_ABORT, &amp;fcache-&gt;flinfo, &amp;fcache-&gt;arg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;flinfo = save_flinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fcache-&gt;configNames != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../misc/guc.c.html#L2264" title="utils/misc/guc.c:2264">AtEOXact_GUC</a>(<span class="Constant">true</span>, save_nestlevel);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(fcache-&gt;userid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(save_userid, save_sec_context);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L40" title="utils/fmgr/fmgr.c:40">fmgr_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L40" title="utils/fmgr/fmgr.c:40">fmgr_hook</a>) (FHET_END, &amp;fcache-&gt;flinfo, &amp;fcache-&gt;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Support routines for callers of fmgr-compatible <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These are for invocation of a specifically named function with a<br/></li>
<li></span><span class="Comment"> * directly-computed parameter list.&nbsp; Note that neither arguments nor result<br/></li>
<li></span><span class="Comment"> * are allowed to be NULL.&nbsp; Also, the function cannot be one that needs to<br/></li>
<li></span><span class="Comment"> * look at FmgrInfo, since there won't be <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L792">&#x200c;</a><span class="linkable">DirectFunctionCall1Coll</span>(PGFunction func, Oid collation, Datum arg1)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, <span class="Constant">NULL</span>, <span class="Constant">1</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = arg1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (*func) (fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%p</span><span class="Constant"> returned NULL&quot;</span>, (<span class="Type">void</span> *) func);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L812">&#x200c;</a><span class="linkable">DirectFunctionCall2Coll</span>(PGFunction func, Oid collation, Datum arg1, Datum arg2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, <span class="Constant">NULL</span>, <span class="Constant">2</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = arg1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = arg2;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (*func) (fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%p</span><span class="Constant"> returned NULL&quot;</span>, (<span class="Type">void</span> *) func);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L834">&#x200c;</a><span class="linkable">DirectFunctionCall3Coll</span>(PGFunction func, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg3)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, <span class="Constant">NULL</span>, <span class="Constant">3</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = arg1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = arg2;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].value = arg3;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (*func) (fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%p</span><span class="Constant"> returned NULL&quot;</span>, (<span class="Type">void</span> *) func);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L859">&#x200c;</a><span class="linkable">DirectFunctionCall4Coll</span>(PGFunction func, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg3, Datum arg4)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, <span class="Constant">NULL</span>, <span class="Constant">4</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = arg1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = arg2;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].value = arg3;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].value = arg4;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (*func) (fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%p</span><span class="Constant"> returned NULL&quot;</span>, (<span class="Type">void</span> *) func);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L886">&#x200c;</a><span class="linkable">DirectFunctionCall5Coll</span>(PGFunction func, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg3, Datum arg4, Datum arg5)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">5</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, <span class="Constant">NULL</span>, <span class="Constant">5</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = arg1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = arg2;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].value = arg3;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].value = arg4;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">4</span>].value = arg5;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">4</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (*func) (fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%p</span><span class="Constant"> returned NULL&quot;</span>, (<span class="Type">void</span> *) func);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L915">&#x200c;</a><span class="linkable">DirectFunctionCall6Coll</span>(PGFunction func, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg3, Datum arg4, Datum arg5,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg6)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, <span class="Constant">NULL</span>, <span class="Constant">6</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = arg1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = arg2;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].value = arg3;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].value = arg4;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">4</span>].value = arg5;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">4</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">5</span>].value = arg6;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">5</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (*func) (fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%p</span><span class="Constant"> returned NULL&quot;</span>, (<span class="Type">void</span> *) func);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L947">&#x200c;</a><span class="linkable">DirectFunctionCall7Coll</span>(PGFunction func, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg3, Datum arg4, Datum arg5,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg6, Datum arg7)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">7</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, <span class="Constant">NULL</span>, <span class="Constant">7</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = arg1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = arg2;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].value = arg3;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].value = arg4;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">4</span>].value = arg5;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">4</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">5</span>].value = arg6;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">5</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">6</span>].value = arg7;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">6</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (*func) (fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%p</span><span class="Constant"> returned NULL&quot;</span>, (<span class="Type">void</span> *) func);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L981">&#x200c;</a><span class="linkable">DirectFunctionCall8Coll</span>(PGFunction func, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg3, Datum arg4, Datum arg5,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg6, Datum arg7, Datum arg8)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">8</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, <span class="Constant">NULL</span>, <span class="Constant">8</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = arg1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = arg2;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].value = arg3;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].value = arg4;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">4</span>].value = arg5;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">4</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">5</span>].value = arg6;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">5</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">6</span>].value = arg7;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">6</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">7</span>].value = arg8;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">7</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (*func) (fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%p</span><span class="Constant"> returned NULL&quot;</span>, (<span class="Type">void</span> *) func);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1017">&#x200c;</a><span class="linkable">DirectFunctionCall9Coll</span>(PGFunction func, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg3, Datum arg4, Datum arg5,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg6, Datum arg7, Datum arg8,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg9)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">9</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, <span class="Constant">NULL</span>, <span class="Constant">9</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = arg1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = arg2;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].value = arg3;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].value = arg4;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">4</span>].value = arg5;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">4</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">5</span>].value = arg6;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">5</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">6</span>].value = arg7;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">6</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">7</span>].value = arg8;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">7</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">8</span>].value = arg9;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">8</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (*func) (fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%p</span><span class="Constant"> returned NULL&quot;</span>, (<span class="Type">void</span> *) func);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> work like the DirectFunctionCall <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> except that<br/></li>
<li></span><span class="Comment"> * they use the flinfo parameter to initialise the fcinfo for the call.<br/></li>
<li></span><span class="Comment"> * It's recommended that the callee only use the fn_extra and fn_mcxt<br/></li>
<li></span><span class="Comment"> * fields, as other fields will typically describe the calling function<br/></li>
<li></span><span class="Comment"> * not the callee.&nbsp; Conversely, the calling function should not have<br/></li>
<li></span><span class="Comment"> * used fn_extra, unless its use is known to be compatible with the callee's.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1065">&#x200c;</a><span class="linkable">CallerFInfoFunctionCall1</span>(PGFunction func, FmgrInfo *flinfo, Oid collation, Datum arg1)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, flinfo, <span class="Constant">1</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = arg1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (*func) (fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%p</span><span class="Constant"> returned NULL&quot;</span>, (<span class="Type">void</span> *) func);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1085">&#x200c;</a><span class="linkable">CallerFInfoFunctionCall2</span>(PGFunction func, FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, flinfo, <span class="Constant">2</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = arg1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = arg2;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (*func) (fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%p</span><span class="Constant"> returned NULL&quot;</span>, (<span class="Type">void</span> *) func);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These are for invocation of a previously-looked-up function with a<br/></li>
<li></span><span class="Comment"> * directly-computed parameter list.&nbsp; Note that neither arguments nor result<br/></li>
<li></span><span class="Comment"> * are allowed to be NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1112">&#x200c;</a><span class="linkable">FunctionCall0Coll</span>(FmgrInfo *flinfo, Oid collation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, flinfo, <span class="Constant">0</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = FunctionCallInvoke(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%u</span><span class="Constant"> returned NULL&quot;</span>, flinfo-&gt;fn_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1129">&#x200c;</a><span class="linkable">FunctionCall1Coll</span>(FmgrInfo *flinfo, Oid collation, Datum arg1)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, flinfo, <span class="Constant">1</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = arg1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = FunctionCallInvoke(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%u</span><span class="Constant"> returned NULL&quot;</span>, flinfo-&gt;fn_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1149">&#x200c;</a><span class="linkable">FunctionCall2Coll</span>(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, flinfo, <span class="Constant">2</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = arg1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = arg2;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = FunctionCallInvoke(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%u</span><span class="Constant"> returned NULL&quot;</span>, flinfo-&gt;fn_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1171">&#x200c;</a><span class="linkable">FunctionCall3Coll</span>(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg3)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, flinfo, <span class="Constant">3</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = arg1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = arg2;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].value = arg3;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = FunctionCallInvoke(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%u</span><span class="Constant"> returned NULL&quot;</span>, flinfo-&gt;fn_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1196">&#x200c;</a><span class="linkable">FunctionCall4Coll</span>(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg3, Datum arg4)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, flinfo, <span class="Constant">4</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = arg1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = arg2;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].value = arg3;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].value = arg4;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = FunctionCallInvoke(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%u</span><span class="Constant"> returned NULL&quot;</span>, flinfo-&gt;fn_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1223">&#x200c;</a><span class="linkable">FunctionCall5Coll</span>(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg3, Datum arg4, Datum arg5)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">5</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, flinfo, <span class="Constant">5</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = arg1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = arg2;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].value = arg3;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].value = arg4;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">4</span>].value = arg5;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">4</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = FunctionCallInvoke(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%u</span><span class="Constant"> returned NULL&quot;</span>, flinfo-&gt;fn_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1252">&#x200c;</a><span class="linkable">FunctionCall6Coll</span>(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg3, Datum arg4, Datum arg5,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg6)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">6</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, flinfo, <span class="Constant">6</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = arg1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = arg2;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].value = arg3;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].value = arg4;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">4</span>].value = arg5;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">4</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">5</span>].value = arg6;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">5</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = FunctionCallInvoke(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%u</span><span class="Constant"> returned NULL&quot;</span>, flinfo-&gt;fn_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1284">&#x200c;</a><span class="linkable">FunctionCall7Coll</span>(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg3, Datum arg4, Datum arg5,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg6, Datum arg7)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">7</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, flinfo, <span class="Constant">7</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = arg1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = arg2;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].value = arg3;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].value = arg4;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">4</span>].value = arg5;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">4</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">5</span>].value = arg6;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">5</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">6</span>].value = arg7;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">6</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = FunctionCallInvoke(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%u</span><span class="Constant"> returned NULL&quot;</span>, flinfo-&gt;fn_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1318">&#x200c;</a><span class="linkable">FunctionCall8Coll</span>(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg3, Datum arg4, Datum arg5,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg6, Datum arg7, Datum arg8)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">8</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, flinfo, <span class="Constant">8</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = arg1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = arg2;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].value = arg3;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].value = arg4;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">4</span>].value = arg5;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">4</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">5</span>].value = arg6;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">5</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">6</span>].value = arg7;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">6</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">7</span>].value = arg8;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">7</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = FunctionCallInvoke(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%u</span><span class="Constant"> returned NULL&quot;</span>, flinfo-&gt;fn_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1354">&#x200c;</a><span class="linkable">FunctionCall9Coll</span>(FmgrInfo *flinfo, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg3, Datum arg4, Datum arg5,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg6, Datum arg7, Datum arg8,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum arg9)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">9</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, flinfo, <span class="Constant">9</span>, collation, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = arg1;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = arg2;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].value = arg3;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].value = arg4;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">3</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">4</span>].value = arg5;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">4</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">5</span>].value = arg6;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">5</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">6</span>].value = arg7;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">6</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">7</span>].value = arg8;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">7</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">8</span>].value = arg9;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">8</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = FunctionCallInvoke(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for null result, since caller is clearly not expecting one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;function </span><span class="Special">%u</span><span class="Constant"> returned NULL&quot;</span>, flinfo-&gt;fn_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These are for invocation of a function identified by OID with a<br/></li>
<li></span><span class="Comment"> * directly-computed parameter list.&nbsp; Note that neither arguments nor result<br/></li>
<li></span><span class="Comment"> * are allowed to be NULL.&nbsp; These are essentially <a href="#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>() followed<br/></li>
<li></span><span class="Comment"> * by FunctionCallN().&nbsp; If the same function is to be invoked repeatedly,<br/></li>
<li></span><span class="Comment"> * do the <a href="#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>() once and then use FunctionCallN().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1401">&#x200c;</a><span class="linkable">OidFunctionCall0Coll</span>(Oid functionId, Oid collation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; flinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(functionId, &amp;flinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1112" title="utils/fmgr/fmgr.c:1112">FunctionCall0Coll</a>(&amp;flinfo, collation);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1411">&#x200c;</a><span class="linkable">OidFunctionCall1Coll</span>(Oid functionId, Oid collation, Datum arg1)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; flinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(functionId, &amp;flinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1129" title="utils/fmgr/fmgr.c:1129">FunctionCall1Coll</a>(&amp;flinfo, collation, arg1);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1421">&#x200c;</a><span class="linkable">OidFunctionCall2Coll</span>(Oid functionId, Oid collation, Datum arg1, Datum arg2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; flinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(functionId, &amp;flinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;flinfo, collation, arg1, arg2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1431">&#x200c;</a><span class="linkable">OidFunctionCall3Coll</span>(Oid functionId, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum arg3)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; flinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(functionId, &amp;flinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1171" title="utils/fmgr/fmgr.c:1171">FunctionCall3Coll</a>(&amp;flinfo, collation, arg1, arg2, arg3);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1442">&#x200c;</a><span class="linkable">OidFunctionCall4Coll</span>(Oid functionId, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum arg3, Datum arg4)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; flinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(functionId, &amp;flinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1196" title="utils/fmgr/fmgr.c:1196">FunctionCall4Coll</a>(&amp;flinfo, collation, arg1, arg2, arg3, arg4);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1453">&#x200c;</a><span class="linkable">OidFunctionCall5Coll</span>(Oid functionId, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum arg3, Datum arg4, Datum arg5)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; flinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(functionId, &amp;flinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1223" title="utils/fmgr/fmgr.c:1223">FunctionCall5Coll</a>(&amp;flinfo, collation, arg1, arg2, arg3, arg4, arg5);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1464">&#x200c;</a><span class="linkable">OidFunctionCall6Coll</span>(Oid functionId, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum arg3, Datum arg4, Datum arg5,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum arg6)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; flinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(functionId, &amp;flinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1252" title="utils/fmgr/fmgr.c:1252">FunctionCall6Coll</a>(&amp;flinfo, collation, arg1, arg2, arg3, arg4, arg5,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arg6);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1477">&#x200c;</a><span class="linkable">OidFunctionCall7Coll</span>(Oid functionId, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum arg3, Datum arg4, Datum arg5,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum arg6, Datum arg7)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; flinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(functionId, &amp;flinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1284" title="utils/fmgr/fmgr.c:1284">FunctionCall7Coll</a>(&amp;flinfo, collation, arg1, arg2, arg3, arg4, arg5,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arg6, arg7);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1490">&#x200c;</a><span class="linkable">OidFunctionCall8Coll</span>(Oid functionId, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum arg3, Datum arg4, Datum arg5,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum arg6, Datum arg7, Datum arg8)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; flinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(functionId, &amp;flinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1318" title="utils/fmgr/fmgr.c:1318">FunctionCall8Coll</a>(&amp;flinfo, collation, arg1, arg2, arg3, arg4, arg5,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arg6, arg7, arg8);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1503">&#x200c;</a><span class="linkable">OidFunctionCall9Coll</span>(Oid functionId, Oid collation, Datum arg1, Datum arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum arg3, Datum arg4, Datum arg5,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum arg6, Datum arg7, Datum arg8,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum arg9)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; flinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(functionId, &amp;flinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1354" title="utils/fmgr/fmgr.c:1354">FunctionCall9Coll</a>(&amp;flinfo, collation, arg1, arg2, arg3, arg4, arg5,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arg6, arg7, arg8, arg9);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Special cases for convenient invocation of datatype I/O <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Call a previously-looked-up datatype input function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;str&quot; may be NULL to indicate we are reading a NULL.&nbsp; In this case<br/></li>
<li></span><span class="Comment"> * the caller should assume the result is NULL, but we'll call the input<br/></li>
<li></span><span class="Comment"> * function anyway if it's not strict.&nbsp; So this is almost but not quite<br/></li>
<li></span><span class="Comment"> * the same as FunctionCall3.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1530">&#x200c;</a><span class="linkable">InputFunctionCall</span>(FmgrInfo *flinfo, <span class="Type">char</span> *str, Oid typioparam, int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (str == <span class="Constant">NULL</span> &amp;&amp; flinfo-&gt;fn_strict)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just return null result */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, flinfo, <span class="Constant">3</span>, InvalidOid, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = CStringGetDatum(str);<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = ObjectIdGetDatum(typioparam);<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].value = Int32GetDatum(typmod);<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = FunctionCallInvoke(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should get null result if and only if str is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (str == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;input function </span><span class="Special">%u</span><span class="Constant"> returned non-NULL&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; flinfo-&gt;fn_oid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;input function </span><span class="Special">%u</span><span class="Constant"> returned NULL&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; flinfo-&gt;fn_oid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Call a previously-looked-up datatype input function, with non-exception<br/></li>
<li></span><span class="Comment"> * handling of &quot;soft&quot; errors.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is basically like <a href="#L1530" title="utils/fmgr/fmgr.c:1530">InputFunctionCall</a>, but the converted Datum is<br/></li>
<li></span><span class="Comment"> * returned into *result while the function result is true for success or<br/></li>
<li></span><span class="Comment"> * false for failure.&nbsp; Also, the caller may pass an ErrorSaveContext node.<br/></li>
<li></span><span class="Comment"> * (We declare that as &quot;fmNodePtr&quot; to avoid including nodes.h in fmgr.h.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If escontext points to an ErrorSaveContext, <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> &quot;soft&quot; errors detected by<br/></li>
<li></span><span class="Comment"> * the input function will be reported by filling the escontext struct and<br/></li>
<li></span><span class="Comment"> * returning false.&nbsp; (The caller can choose to test SOFT_ERROR_OCCURRED(),<br/></li>
<li></span><span class="Comment"> * but checking the function result instead is usually cheaper.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If escontext does not point to an ErrorSaveContext, errors are reported<br/></li>
<li></span><span class="Comment"> * via ereport(ERROR), so that there is no functional difference from<br/></li>
<li></span><span class="Comment"> * <a href="#L1530" title="utils/fmgr/fmgr.c:1530">InputFunctionCall</a>; the result will always be true if control returns.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1585">&#x200c;</a></span><span class="linkable">InputFunctionCallSafe</span>(FmgrInfo *flinfo, <span class="Type">char</span> *str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid typioparam, int32 typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fmNodePtr escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">3</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (str == <span class="Constant">NULL</span> &amp;&amp; flinfo-&gt;fn_strict)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = (Datum) <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* just return null result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, flinfo, <span class="Constant">3</span>, InvalidOid, escontext, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = CStringGetDatum(str);<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = ObjectIdGetDatum(typioparam);<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].value = Int32GetDatum(typmod);<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *result = FunctionCallInvoke(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Result value is garbage, and could be null, if an error was reported */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (SOFT_ERROR_OCCURRED(escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, should get null result if and only if str is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (str == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;input function </span><span class="Special">%u</span><span class="Constant"> returned non-NULL&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; flinfo-&gt;fn_oid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;input function </span><span class="Special">%u</span><span class="Constant"> returned NULL&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; flinfo-&gt;fn_oid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Call a directly-named datatype input function, with non-exception<br/></li>
<li></span><span class="Comment"> * handling of &quot;soft&quot; errors.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is like <a href="#L1585" title="utils/fmgr/fmgr.c:1585">InputFunctionCallSafe</a>, except that it is given a direct<br/></li>
<li></span><span class="Comment"> * pointer to the C function to call.&nbsp; We assume that that function is<br/></li>
<li></span><span class="Comment"> * strict.&nbsp; Also, the function cannot be one that needs to<br/></li>
<li></span><span class="Comment"> * look at FmgrInfo, since there won't be <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1640">&#x200c;</a></span><span class="linkable">DirectInputFunctionCallSafe</span>(PGFunction func, <span class="Type">char</span> *str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid typioparam, int32 typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fmNodePtr escontext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">3</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (str == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = (Datum) <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* just return null result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, <span class="Constant">NULL</span>, <span class="Constant">3</span>, InvalidOid, escontext, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = CStringGetDatum(str);<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = ObjectIdGetDatum(typioparam);<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].value = Int32GetDatum(typmod);<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *result = (*func) (fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Result value is garbage, and could be null, if an error was reported */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (SOFT_ERROR_OCCURRED(escontext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, shouldn't get null result */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;input function </span><span class="Special">%p</span><span class="Constant"> returned NULL&quot;</span>, (<span class="Type">void</span> *) func);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Call a previously-looked-up datatype output function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Do not call this on NULL datums.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is currently little more than window dressing for FunctionCall1.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L1683">&#x200c;</a><span class="linkable">OutputFunctionCall</span>(FmgrInfo *flinfo, Datum val)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetCString(FunctionCall1(flinfo, val));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Call a previously-looked-up datatype binary-input function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;buf&quot; may be NULL to indicate we are reading a NULL.&nbsp; In this case<br/></li>
<li></span><span class="Comment"> * the caller should assume the result is NULL, but we'll call the receive<br/></li>
<li></span><span class="Comment"> * function anyway if it's not strict.&nbsp; So this is almost but not quite<br/></li>
<li></span><span class="Comment"> * the same as FunctionCall3.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1697">&#x200c;</a><span class="linkable">ReceiveFunctionCall</span>(FmgrInfo *flinfo, StringInfo buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid typioparam, int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LOCAL_FCINFO(fcinfo, <span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (buf == <span class="Constant">NULL</span> &amp;&amp; flinfo-&gt;fn_strict)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just return null result */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; InitFunctionCallInfoData(*fcinfo, flinfo, <span class="Constant">3</span>, InvalidOid, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].value = PointerGetDatum(buf);<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">0</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].value = ObjectIdGetDatum(typioparam);<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">1</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].value = Int32GetDatum(typmod);<br/></li>
<li>&nbsp; &nbsp; fcinfo-&gt;args[<span class="Constant">2</span>].isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = FunctionCallInvoke(fcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should get null result if and only if buf is NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (buf == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;receive function </span><span class="Special">%u</span><span class="Constant"> returned non-NULL&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; flinfo-&gt;fn_oid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fcinfo-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;receive function </span><span class="Special">%u</span><span class="Constant"> returned NULL&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; flinfo-&gt;fn_oid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Call a previously-looked-up datatype binary-output function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Do not call this on NULL datums.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is little more than window dressing for FunctionCall1, but it does<br/></li>
<li></span><span class="Comment"> * guarantee a non-toasted result, which strictly speaking the underlying<br/></li>
<li></span><span class="Comment"> * function doesn't.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>bytea *<br/></li>
<li><a id="L1744">&#x200c;</a><span class="linkable">SendFunctionCall</span>(FmgrInfo *flinfo, Datum val)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetByteaP(FunctionCall1(flinfo, val));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * As above, for I/O <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> identified by OID.&nbsp; These are only to be used<br/></li>
<li></span><span class="Comment"> * in seldom-executed code paths.&nbsp; They are not only slow but leak memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1754">&#x200c;</a><span class="linkable">OidInputFunctionCall</span>(Oid functionId, <span class="Type">char</span> *str, Oid typioparam, int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; flinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(functionId, &amp;flinfo);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1530" title="utils/fmgr/fmgr.c:1530">InputFunctionCall</a>(&amp;flinfo, str, typioparam, typmod);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">char</span> *<br/></li>
<li><a id="L1763">&#x200c;</a><span class="linkable">OidOutputFunctionCall</span>(Oid functionId, Datum val)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; flinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(functionId, &amp;flinfo);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1683" title="utils/fmgr/fmgr.c:1683">OutputFunctionCall</a>(&amp;flinfo, val);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1772">&#x200c;</a><span class="linkable">OidReceiveFunctionCall</span>(Oid functionId, StringInfo buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid typioparam, int32 typmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; flinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(functionId, &amp;flinfo);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1697" title="utils/fmgr/fmgr.c:1697">ReceiveFunctionCall</a>(&amp;flinfo, buf, typioparam, typmod);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>bytea *<br/></li>
<li><a id="L1782">&#x200c;</a><span class="linkable">OidSendFunctionCall</span>(Oid functionId, Datum val)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; flinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(functionId, &amp;flinfo);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1744" title="utils/fmgr/fmgr.c:1744">SendFunctionCall</a>(&amp;flinfo, val);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Support routines for standard maybe-pass-by-reference datatypes<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * int8 and float8 can be passed by value if Datum is wide enough.<br/></li>
<li></span><span class="Comment"> * (For backwards-compatibility reasons, we allow pass-by-ref to be chosen<br/></li>
<li></span><span class="Comment"> * at compile time even if pass-by-val is possible.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: there is only one switch controlling the pass-by-value option for<br/></li>
<li></span><span class="Comment"> * both int8 and float8; this is to avoid making things unduly complicated<br/></li>
<li></span><span class="Comment"> * for the timestamp types, which might have either representation.<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifndef USE_FLOAT8_BYVAL&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* controls int8 too */<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1807">&#x200c;</a><span class="linkable">Int64GetDatum</span>(int64 X)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp;&nbsp; *retval = (int64 *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *retval = X;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(retval);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1816">&#x200c;</a><span class="linkable">Float8GetDatum</span>(float8 X)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp;&nbsp; *retval = (float8 *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(float8));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *retval = X;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(retval);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_FLOAT8_BYVAL */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Support routines for toastable datatypes<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">struct</span> varlena *<br/></li>
<li><a id="L1832">&#x200c;</a><span class="linkable">pg_detoast_datum</span>(<span class="Type">struct</span> varlena *datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXTENDED(datum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../access/common/detoast.c.html#L116" title="access/common/detoast.c:116">detoast_attr</a>(datum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> datum;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">struct</span> varlena *<br/></li>
<li><a id="L1841">&#x200c;</a><span class="linkable">pg_detoast_datum_copy</span>(<span class="Type">struct</span> varlena *datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXTENDED(datum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../access/common/detoast.c.html#L116" title="access/common/detoast.c:116">detoast_attr</a>(datum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make a modifiable copy of the varlena object */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len = VARSIZE(datum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varlena *result = (<span class="Type">struct</span> varlena *) <a href="../mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(result, datum, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">struct</span> varlena *<br/></li>
<li><a id="L1857">&#x200c;</a><span class="linkable">pg_detoast_datum_slice</span>(<span class="Type">struct</span> varlena *datum, int32 first, int32 count)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Only get the specified portion from the toast rel */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../access/common/detoast.c.html#L205" title="access/common/detoast.c:205">detoast_attr_slice</a>(datum, first, count);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">struct</span> varlena *<br/></li>
<li><a id="L1864">&#x200c;</a><span class="linkable">pg_detoast_datum_packed</span>(<span class="Type">struct</span> varlena *datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_COMPRESSED(datum) || VARATT_IS_EXTERNAL(datum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../access/common/detoast.c.html#L116" title="access/common/detoast.c:116">detoast_attr</a>(datum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> datum;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Support routines for extracting info from fn_expr <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These are needed by polymorphic <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, which <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> multiple possible<br/></li>
<li></span><span class="Comment"> * input types and need <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> from the parser to know what they've got.<br/></li>
<li></span><span class="Comment"> * Also, some <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> might be interested in whether a parameter is constant.<br/></li>
<li></span><span class="Comment"> * Functions taking VARIADIC ANY also need to know about the VARIADIC keyword.<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the actual type OID of the function return type<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidOid if information is not available<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1888">&#x200c;</a><span class="linkable">get_fn_expr_rettype</span>(FmgrInfo *flinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't return anything useful if we have no FmgrInfo or if its fn_expr<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * node has not been initialized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!flinfo || !flinfo-&gt;fn_expr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; expr = flinfo-&gt;fn_expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(expr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the actual type OID of a specific function argument (counting from 0)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidOid if information is not available<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1910">&#x200c;</a><span class="linkable">get_fn_expr_argtype</span>(FmgrInfo *flinfo, <span class="Type">int</span> argnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't return anything useful if we have no FmgrInfo or if its fn_expr<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * node has not been initialized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!flinfo || !flinfo-&gt;fn_expr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1929" title="utils/fmgr/fmgr.c:1929">get_call_expr_argtype</a>(flinfo-&gt;fn_expr, argnum);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the actual type OID of a specific function argument (counting from 0),<br/></li>
<li></span><span class="Comment"> * but working from the calling expression tree instead of FmgrInfo<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidOid if information is not available<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1929">&#x200c;</a><span class="linkable">get_call_expr_argtype</span>(Node *expr, <span class="Type">int</span> argnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *args;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argtype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (expr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(expr, FuncExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; args = ((FuncExpr *) expr)-&gt;args;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(expr, OpExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; args = ((OpExpr *) expr)-&gt;args;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(expr, DistinctExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; args = ((DistinctExpr *) expr)-&gt;args;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(expr, ScalarArrayOpExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; args = ((ScalarArrayOpExpr *) expr)-&gt;args;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(expr, NullIfExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; args = ((NullIfExpr *) expr)-&gt;args;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(expr, WindowFunc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; args = ((WindowFunc *) expr)-&gt;args;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (argnum &lt; <span class="Constant">0</span> || argnum &gt;= list_length(args))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; argtype = <a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) list_nth(args, argnum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * special hack for ScalarArrayOpExpr: what the underlying function will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actually get passed is the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type of the array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(expr, ScalarArrayOpExpr) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; argnum == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; argtype = <a href="../cache/lsyscache.c.html#L2832" title="utils/cache/lsyscache.c:2832">get_base_element_type</a>(argtype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> argtype;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find out whether a specific function argument is constant for the<br/></li>
<li></span><span class="Comment"> * duration of a query<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false if information is not available<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1975">&#x200c;</a></span><span class="linkable">get_fn_expr_arg_stable</span>(FmgrInfo *flinfo, <span class="Type">int</span> argnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't return anything useful if we have no FmgrInfo or if its fn_expr<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * node has not been initialized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!flinfo || !flinfo-&gt;fn_expr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1994" title="utils/fmgr/fmgr.c:1994">get_call_expr_arg_stable</a>(flinfo-&gt;fn_expr, argnum);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find out whether a specific function argument is constant for the<br/></li>
<li></span><span class="Comment"> * duration of a query, but working from the calling expression tree<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false if information is not available<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1994">&#x200c;</a></span><span class="linkable">get_call_expr_arg_stable</span>(Node *expr, <span class="Type">int</span> argnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *args;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (expr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(expr, FuncExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; args = ((FuncExpr *) expr)-&gt;args;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(expr, OpExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; args = ((OpExpr *) expr)-&gt;args;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(expr, DistinctExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; args = ((DistinctExpr *) expr)-&gt;args;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(expr, ScalarArrayOpExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; args = ((ScalarArrayOpExpr *) expr)-&gt;args;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(expr, NullIfExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; args = ((NullIfExpr *) expr)-&gt;args;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(expr, WindowFunc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; args = ((WindowFunc *) expr)-&gt;args;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (argnum &lt; <span class="Constant">0</span> || argnum &gt;= list_length(args))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; arg = (Node *) list_nth(args, argnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Either a true Const or an external Param will have a value that doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * change during the execution of the query.&nbsp; In future we might want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consider other cases too, e.g. <a href="../adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(arg, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(arg, Param) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((Param *) arg)-&gt;paramkind == PARAM_EXTERN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the VARIADIC flag from the function invocation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false (the default assumption) if information is not available<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note this is generally only of interest to VARIADIC ANY <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2044">&#x200c;</a></span><span class="linkable">get_fn_expr_variadic</span>(FmgrInfo *flinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't return anything useful if we have no FmgrInfo or if its fn_expr<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * node has not been initialized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!flinfo || !flinfo-&gt;fn_expr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; expr = flinfo-&gt;fn_expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(expr, FuncExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> ((FuncExpr *) expr)-&gt;funcvariadic;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set options to FmgrInfo of opclass support function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Opclass support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are called outside of expressions.&nbsp; Thanks to that<br/></li>
<li></span><span class="Comment"> * we can use fn_expr to store opclass options as bytea constant.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2070">&#x200c;</a></span><span class="linkable">set_fn_opclass_options</span>(FmgrInfo *flinfo, bytea *options)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; flinfo-&gt;fn_expr = (Node *) <a href="../../nodes/makefuncs.c.html#L301" title="nodes/makefuncs.c:301">makeConst</a>(BYTEAOID, -<span class="Constant">1</span>, InvalidOid, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(options),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; options == <span class="Constant">NULL</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if options are defined for opclass support function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2081">&#x200c;</a></span><span class="linkable">has_fn_opclass_options</span>(FmgrInfo *flinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flinfo &amp;&amp; flinfo-&gt;fn_expr &amp;&amp; IsA(flinfo-&gt;fn_expr, Const))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *expr = (Const *) flinfo-&gt;fn_expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expr-&gt;consttype == BYTEAOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> !expr-&gt;constisnull;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get options for opclass support function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>bytea *<br/></li>
<li><a id="L2097">&#x200c;</a><span class="linkable">get_fn_opclass_options</span>(FmgrInfo *flinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flinfo &amp;&amp; flinfo-&gt;fn_expr &amp;&amp; IsA(flinfo-&gt;fn_expr, Const))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *expr = (Const *) flinfo-&gt;fn_expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expr-&gt;consttype == BYTEAOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> expr-&gt;constisnull ? <span class="Constant">NULL</span> : DatumGetByteaP(expr-&gt;constvalue);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;operator class options info is absent in function call context&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Support routines for procedural language implementations<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Verify that a validator is actually associated with the language of a<br/></li>
<li></span><span class="Comment"> * particular function and that the user has access to both the language and<br/></li>
<li></span><span class="Comment"> * the function.&nbsp; All validators should call this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing anything<br/></li>
<li></span><span class="Comment"> * substantial.&nbsp; Doing so ensures a user cannot achieve anything with explicit<br/></li>
<li></span><span class="Comment"> * calls to validators that he could not achieve with CREATE FUNCTION or by<br/></li>
<li></span><span class="Comment"> * simply calling an existing function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When this function returns false, callers should <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> all validation work<br/></li>
<li></span><span class="Comment"> * and call PG_RETURN_VOID().&nbsp; This never happens at present; it is reserved<br/></li>
<li></span><span class="Comment"> * for future expansion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In particular, checking that the validator corresponds to the function's<br/></li>
<li></span><span class="Comment"> * language allows untrusted language validators to assume they process only<br/></li>
<li></span><span class="Comment"> * <a href="../misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a>-chosen source code.&nbsp; (Untrusted language call handlers, by<br/></li>
<li></span><span class="Comment"> * definition, do assume that.)&nbsp; A user lacking the USAGE language privilege<br/></li>
<li></span><span class="Comment"> * would be unable to reach the validator through CREATE FUNCTION, so we check<br/></li>
<li></span><span class="Comment"> * that to block explicit calls as well.&nbsp; Checking the EXECUTE privilege on<br/></li>
<li></span><span class="Comment"> * the function is often superfluous, because most users can clone the<br/></li>
<li></span><span class="Comment"> * function to get an executable copy.&nbsp; It is meaningful against users with no<br/></li>
<li></span><span class="Comment"> * database TEMP right and no permanent schema CREATE right, thereby unable to<br/></li>
<li></span><span class="Comment"> * create <a href="../adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> function.&nbsp; Also, if the function tracks persistent state by<br/></li>
<li></span><span class="Comment"> * function OID or name, validating the original function might permit more<br/></li>
<li></span><span class="Comment"> * mischief than creating and validating a clone thereof.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2145">&#x200c;</a></span><span class="linkable">CheckFunctionValidatorAccess</span>(Oid validatorOid, Oid functionOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; procTup;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; langTup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_proc procStruct;<br/></li>
<li>&nbsp; &nbsp; Form_pg_language langStruct;<br/></li>
<li>&nbsp; &nbsp; AclResult&nbsp; &nbsp; aclresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the function's pg_proc entry.&nbsp; Throw a user-facing error for bad<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OID, because validators can be called with user-specified OIDs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; procTup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(functionOid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(procTup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;function with OID </span><span class="Special">%u</span><span class="Constant"> does not exist&quot;</span>, functionOid)));<br/></li>
<li>&nbsp; &nbsp; procStruct = (Form_pg_proc) GETSTRUCT(procTup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch pg_language entry to know if this is the correct validation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function for that pg_proc entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; langTup = <a href="../cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(LANGOID, ObjectIdGetDatum(procStruct-&gt;prolang));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(langTup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for language </span><span class="Special">%u</span><span class="Constant">&quot;</span>, procStruct-&gt;prolang);<br/></li>
<li>&nbsp; &nbsp; langStruct = (Form_pg_language) GETSTRUCT(langTup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (langStruct-&gt;lanvalidator != validatorOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;language validation function </span><span class="Special">%u</span><span class="Constant"> called for language </span><span class="Special">%u</span><span class="Constant"> instead of </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; validatorOid, procStruct-&gt;prolang,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; langStruct-&gt;lanvalidator)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* first validate that we have permissions to use the language */<br/></li>
<li></span>&nbsp; &nbsp; aclresult = <a href="../../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(LanguageRelationId, procStruct-&gt;prolang, <a href="../init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_USAGE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, OBJECT_LANGUAGE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(langStruct-&gt;lanname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check whether we are allowed to execute the function itself. If we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * execute it, there should be no possible side-effect of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compiling/validation that execution can't have.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; aclresult = <a href="../../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(ProcedureRelationId, functionOid, <a href="../init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), ACL_EXECUTE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, OBJECT_FUNCTION, NameStr(procStruct-&gt;proname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(procTup);<br/></li>
<li>&nbsp; &nbsp; <a href="../cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(langTup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
