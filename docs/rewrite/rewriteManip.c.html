<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>rewrite/rewriteManip.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>rewrite/rewriteManip.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L561">ChangeVarNodes_context</a></li>
<li><a href="#L773">IncrementVarSublevelsUp_context</a></li>
<li><a href="#L388">OffsetVarNodes_context</a></li>
<li><a href="#L1662">ReplaceVarsFromTargetList_context</a></li>
<li><a href="#L48">add_nulling_relids_context</a></li>
<li><a href="#L30">contain_aggs_of_level_context</a></li>
<li><a href="#L36">locate_agg_of_level_context</a></li>
<li><a href="#L41">locate_windowfunc_context</a></li>
<li><a href="#L1485">map_variable_attnos_context</a></li>
<li><a href="#L896">rangeTableEntry_used_context</a></li>
<li><a href="#L55">remove_nulling_relids_context</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1124">AddInvertedQual</a></li>
<li><a href="#L1056">AddQual</a></li>
<li><a href="#L674">ChangeVarNodes</a></li>
<li><a href="#L564">ChangeVarNodes_walker</a></li>
<li><a href="#L350">CombineRangeTables</a></li>
<li><a href="#L849">IncrementVarSublevelsUp</a></li>
<li><a href="#L872">IncrementVarSublevelsUp_rtable</a></li>
<li><a href="#L776">IncrementVarSublevelsUp_walker</a></li>
<li><a href="#L480">OffsetVarNodes</a></li>
<li><a href="#L391">OffsetVarNodes_walker</a></li>
<li><a href="#L1769">ReplaceVarsFromTargetList</a></li>
<li><a href="#L1665">ReplaceVarsFromTargetList_callback</a></li>
<li><a href="#L1147">add_nulling_relids</a></li>
<li><a href="#L1163">add_nulling_relids_mutator</a></li>
<li><a href="#L737">adjust_relid_set</a></li>
<li><a href="#L295">checkExprHasSubLink</a></li>
<li><a href="#L308">checkExprHasSubLink_walker</a></li>
<li><a href="#L85">contain_aggs_of_level</a></li>
<li><a href="#L102">contain_aggs_of_level_walker</a></li>
<li><a href="#L215">contain_windowfuncs</a></li>
<li><a href="#L228">contain_windowfuncs_walker</a></li>
<li><a href="#L324">contains_multiexpr_param</a></li>
<li><a href="#L998">getInsertSelectQuery</a></li>
<li><a href="#L149">locate_agg_of_level</a></li>
<li><a href="#L169">locate_agg_of_level_walker</a></li>
<li><a href="#L253">locate_windowfunc</a></li>
<li><a href="#L272">locate_windowfunc_walker</a></li>
<li><a href="#L1611">map_variable_attnos</a></li>
<li><a href="#L1488">map_variable_attnos_mutator</a></li>
<li><a href="#L532">offset_relid_set</a></li>
<li><a href="#L966">rangeTableEntry_used</a></li>
<li><a href="#L899">rangeTableEntry_used_walker</a></li>
<li><a href="#L1234">remove_nulling_relids</a></li>
<li><a href="#L1250">remove_nulling_relids_mutator</a></li>
<li><a href="#L1342">replace_rte_variables</a></li>
<li><a href="#L1389">replace_rte_variables_mutator</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * rewriteManip.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/rewrite/rewriteManip.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/pathnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/plannodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_coerce.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parsetree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteManip.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublevels_up;<br/></li>
<li><a id="L30">&#x200c;</a>} <span class="linkable">contain_aggs_of_level_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; agg_location;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublevels_up;<br/></li>
<li><a id="L36">&#x200c;</a>} <span class="linkable">locate_agg_of_level_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; win_location;<br/></li>
<li><a id="L41">&#x200c;</a>} <span class="linkable">locate_windowfunc_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> Bitmapset *target_relids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> Bitmapset *added_relids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublevels_up;<br/></li>
<li><a id="L48">&#x200c;</a>} <span class="linkable">add_nulling_relids_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> Bitmapset *removable_relids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> Bitmapset *except_relids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublevels_up;<br/></li>
<li><a id="L55">&#x200c;</a>} <span class="linkable">remove_nulling_relids_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L102" title="rewrite/rewriteManip.c:102">contain_aggs_of_level_walker</a>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L30" title="rewrite/rewriteManip.c:30">contain_aggs_of_level_context</a> *context);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L169" title="rewrite/rewriteManip.c:169">locate_agg_of_level_walker</a>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L36" title="rewrite/rewriteManip.c:36">locate_agg_of_level_context</a> *context);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L228" title="rewrite/rewriteManip.c:228">contain_windowfuncs_walker</a>(Node *node, <span class="Type">void</span> *context);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L272" title="rewrite/rewriteManip.c:272">locate_windowfunc_walker</a>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L41" title="rewrite/rewriteManip.c:41">locate_windowfunc_context</a> *context);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L308" title="rewrite/rewriteManip.c:308">checkExprHasSubLink_walker</a>(Node *node, <span class="Type">void</span> *context);<br/></li>
<li><span class="Type">static</span> Relids <a href="#L532" title="rewrite/rewriteManip.c:532">offset_relid_set</a>(Relids relids, <span class="Type">int</span> offset);<br/></li>
<li><span class="Type">static</span> Relids <a href="#L737" title="rewrite/rewriteManip.c:737">adjust_relid_set</a>(Relids relids, <span class="Type">int</span> oldrelid, <span class="Type">int</span> newrelid);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L1163" title="rewrite/rewriteManip.c:1163">add_nulling_relids_mutator</a>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L48" title="rewrite/rewriteManip.c:48">add_nulling_relids_context</a> *context);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L1250" title="rewrite/rewriteManip.c:1250">remove_nulling_relids_mutator</a>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L55" title="rewrite/rewriteManip.c:55">remove_nulling_relids_context</a> *context);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L85" title="rewrite/rewriteManip.c:85">contain_aggs_of_level</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Check if an expression contains an aggregate function call of a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; specified query level.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The objective of this routine is to detect whether there are aggregates<br/></li>
<li></span><span class="Comment"> * belonging to the given query level.&nbsp; Aggregates belonging to subqueries<br/></li>
<li></span><span class="Comment"> * or outer queries do NOT cause a true result.&nbsp; We must recurse into<br/></li>
<li></span><span class="Comment"> * subqueries to detect outer-reference aggregates that logically belong to<br/></li>
<li></span><span class="Comment"> * the specified query level.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L85">&#x200c;</a></span><span class="linkable">contain_aggs_of_level</span>(Node *node, <span class="Type">int</span> levelsup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L30" title="rewrite/rewriteManip.c:30">contain_aggs_of_level_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.sublevels_up = levelsup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must be prepared to start with a Query or a bare expression tree; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's a Query, we don't want to increment sublevels_up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> query_or_expression_tree_walker(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L102" title="rewrite/rewriteManip.c:102">contain_aggs_of_level_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) &amp;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L102">&#x200c;</a></span><span class="linkable">contain_aggs_of_level_walker</span>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L30" title="rewrite/rewriteManip.c:30">contain_aggs_of_level_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Aggref))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((Aggref *) node)-&gt;agglevelsup == context-&gt;sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* abort the tree traversal and return true */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else fall through to examine argument */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, GroupingFunc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((GroupingFunc *) node)-&gt;agglevelsup == context-&gt;sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else fall through to examine argument */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into subselects */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = query_tree_walker((Query *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L102" title="rewrite/rewriteManip.c:102">contain_aggs_of_level_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L102" title="rewrite/rewriteManip.c:102">contain_aggs_of_level_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L149" title="rewrite/rewriteManip.c:149">locate_agg_of_level</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Find the <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> location of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> aggregate of the specified query level.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns -1 if no such agg is in the querytree, or if they all have<br/></li>
<li></span><span class="Comment"> * unknown <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> location.&nbsp; (The former case is probably caller error,<br/></li>
<li></span><span class="Comment"> * but we don't bother to distinguish it from the latter case.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: it might seem appropriate to <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> this functionality into<br/></li>
<li></span><span class="Comment"> * <a href="#L85" title="rewrite/rewriteManip.c:85">contain_aggs_of_level</a>, but that would complicate that function's API.<br/></li>
<li></span><span class="Comment"> * Currently, the only uses of this function are for error reporting,<br/></li>
<li></span><span class="Comment"> * and so shaving cycles probably isn't very important.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L149">&#x200c;</a></span><span class="linkable">locate_agg_of_level</span>(Node *node, <span class="Type">int</span> levelsup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L36" title="rewrite/rewriteManip.c:36">locate_agg_of_level_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.agg_location = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* in case we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> nothing */<br/></li>
<li></span>&nbsp; &nbsp; context.sublevels_up = levelsup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must be prepared to start with a Query or a bare expression tree; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's a Query, we don't want to increment sublevels_up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) query_or_expression_tree_walker(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L169" title="rewrite/rewriteManip.c:169">locate_agg_of_level_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) &amp;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> context.agg_location;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L169">&#x200c;</a></span><span class="linkable">locate_agg_of_level_walker</span>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L36" title="rewrite/rewriteManip.c:36">locate_agg_of_level_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Aggref))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((Aggref *) node)-&gt;agglevelsup == context-&gt;sublevels_up &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((Aggref *) node)-&gt;location &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;agg_location = ((Aggref *) node)-&gt;location;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* abort the tree traversal and return true */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else fall through to examine argument */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, GroupingFunc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((GroupingFunc *) node)-&gt;agglevelsup == context-&gt;sublevels_up &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((GroupingFunc *) node)-&gt;location &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;agg_location = ((GroupingFunc *) node)-&gt;location;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* abort the tree traversal and return true */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into subselects */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = query_tree_walker((Query *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L169" title="rewrite/rewriteManip.c:169">locate_agg_of_level_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L169" title="rewrite/rewriteManip.c:169">locate_agg_of_level_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L215" title="rewrite/rewriteManip.c:215">contain_windowfuncs</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Check if an expression contains a window function call of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; current query level.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L215">&#x200c;</a></span><span class="linkable">contain_windowfuncs</span>(Node *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must be prepared to start with a Query or a bare expression tree; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's a Query, we don't want to increment sublevels_up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> query_or_expression_tree_walker(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L228" title="rewrite/rewriteManip.c:228">contain_windowfuncs_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L228">&#x200c;</a></span><span class="linkable">contain_windowfuncs_walker</span>(Node *node, <span class="Type">void</span> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, WindowFunc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* abort the tree traversal and return true */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Mustn't recurse into subselects */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L228" title="rewrite/rewriteManip.c:228">contain_windowfuncs_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L253" title="rewrite/rewriteManip.c:253">locate_windowfunc</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Find the <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> location of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> windowfunc of the current query level.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns -1 if no such windowfunc is in the querytree, or if they all have<br/></li>
<li></span><span class="Comment"> * unknown <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> location.&nbsp; (The former case is probably caller error,<br/></li>
<li></span><span class="Comment"> * but we don't bother to distinguish it from the latter case.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: it might seem appropriate to <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> this functionality into<br/></li>
<li></span><span class="Comment"> * <a href="#L215" title="rewrite/rewriteManip.c:215">contain_windowfuncs</a>, but that would complicate that function's API.<br/></li>
<li></span><span class="Comment"> * Currently, the only uses of this function are for error reporting,<br/></li>
<li></span><span class="Comment"> * and so shaving cycles probably isn't very important.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L253">&#x200c;</a></span><span class="linkable">locate_windowfunc</span>(Node *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L41" title="rewrite/rewriteManip.c:41">locate_windowfunc_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.win_location = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* in case we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> nothing */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must be prepared to start with a Query or a bare expression tree; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's a Query, we don't want to increment sublevels_up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) query_or_expression_tree_walker(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L272" title="rewrite/rewriteManip.c:272">locate_windowfunc_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) &amp;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> context.win_location;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L272">&#x200c;</a></span><span class="linkable">locate_windowfunc_walker</span>(Node *node, <a href="#L41" title="rewrite/rewriteManip.c:41">locate_windowfunc_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, WindowFunc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((WindowFunc *) node)-&gt;location &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;win_location = ((WindowFunc *) node)-&gt;location;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* abort the tree traversal and return true */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else fall through to examine argument */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mustn't recurse into subselects */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L272" title="rewrite/rewriteManip.c:272">locate_windowfunc_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L295" title="rewrite/rewriteManip.c:295">checkExprHasSubLink</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Check if an expression contains a SubLink.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L295">&#x200c;</a></span><span class="linkable">checkExprHasSubLink</span>(Node *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a Query is passed, examine it --- but we should not recurse into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sub-Queries that are in its rangetable or CTE list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> query_or_expression_tree_walker(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L308" title="rewrite/rewriteManip.c:308">checkExprHasSubLink_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; QTW_IGNORE_RC_SUBQUERIES);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L308">&#x200c;</a></span><span class="linkable">checkExprHasSubLink_walker</span>(Node *node, <span class="Type">void</span> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, SubLink))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* abort the tree traversal and return true */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L308" title="rewrite/rewriteManip.c:308">checkExprHasSubLink_walker</a>, context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check for MULTIEXPR Param within expression tree<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We intentionally don't descend into SubLinks: only Params at the current<br/></li>
<li></span><span class="Comment"> * query level are of interest.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L324">&#x200c;</a></span><span class="linkable">contains_multiexpr_param</span>(Node *node, <span class="Type">void</span> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Param))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((Param *) node)-&gt;paramkind == PARAM_MULTIEXPR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* abort the tree traversal and return true */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L324" title="rewrite/rewriteManip.c:324">contains_multiexpr_param</a>, context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L350" title="rewrite/rewriteManip.c:350">CombineRangeTables</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Adds the RTEs of 'src_rtable' into 'dst_rtable'<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This also adds the RTEPermissionInfos of 'src_perminfos' (belonging to the<br/></li>
<li></span><span class="Comment"> * RTEs in 'src_rtable') into *dst_perminfos and also updates perminfoindex of<br/></li>
<li></span><span class="Comment"> * the RTEs in 'src_rtable' to <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> point to the perminfos' indexes in<br/></li>
<li></span><span class="Comment"> * *dst_perminfos.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this changes both 'dst_rtable' and 'dst_perminfos' destructively,<br/></li>
<li></span><span class="Comment"> * so the caller should have better passed safe-to-modify copies.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L350">&#x200c;</a></span><span class="linkable">CombineRangeTables</span>(List **dst_rtable, List **dst_perminfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *src_rtable, List *src_perminfos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset = list_length(*dst_perminfos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (offset &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, src_rtable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = lfirst_node(RangeTblEntry, l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;perminfoindex &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;perminfoindex += offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *dst_perminfos = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(*dst_perminfos, src_perminfos);<br/></li>
<li>&nbsp; &nbsp; *dst_rtable = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(*dst_rtable, src_rtable);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L480" title="rewrite/rewriteManip.c:480">OffsetVarNodes</a> - adjust Vars when appending one query's RT to another<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Find all Var nodes in the given tree with varlevelsup == sublevels_up,<br/></li>
<li></span><span class="Comment"> * and increment their varno fields (rangetable indexes) by 'offset'.<br/></li>
<li></span><span class="Comment"> * The varnosyn fields are adjusted similarly.&nbsp; Also, adjust other nodes<br/></li>
<li></span><span class="Comment"> * that contain rangetable indexes, such as RangeTblRef and JoinExpr.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: although this has the form of a walker, we cheat and modify the<br/></li>
<li></span><span class="Comment"> * nodes in-place.&nbsp; The given expression tree should have been copied<br/></li>
<li></span><span class="Comment"> * earlier to ensure that no unwanted side-effects occur!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublevels_up;<br/></li>
<li><a id="L388">&#x200c;</a>} <span class="linkable">OffsetVarNodes_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L391">&#x200c;</a></span><span class="linkable">OffsetVarNodes_walker</span>(Node *node, <a href="#L388" title="rewrite/rewriteManip.c:388">OffsetVarNodes_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varlevelsup == context-&gt;sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varno += context-&gt;offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varnullingrels = <a href="#L532" title="rewrite/rewriteManip.c:532">offset_relid_set</a>(var-&gt;varnullingrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varnosyn &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varnosyn += context-&gt;offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, CurrentOfExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CurrentOfExpr *cexpr = (CurrentOfExpr *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;sublevels_up == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cexpr-&gt;cvarno += context-&gt;offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, RangeTblRef))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblRef *rtr = (RangeTblRef *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;sublevels_up == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtr-&gt;rtindex += context-&gt;offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the subquery itself is visited separately */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, JoinExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JoinExpr&nbsp;&nbsp; *j = (JoinExpr *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j-&gt;rtindex &amp;&amp; context-&gt;sublevels_up == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j-&gt;rtindex += context-&gt;offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through to examine children */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (phv-&gt;phlevelsup == context-&gt;sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phrels = <a href="#L532" title="rewrite/rewriteManip.c:532">offset_relid_set</a>(phv-&gt;phrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phnullingrels = <a href="#L532" title="rewrite/rewriteManip.c:532">offset_relid_set</a>(phv-&gt;phnullingrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through to examine children */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, AppendRelInfo))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AppendRelInfo *appinfo = (AppendRelInfo *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;sublevels_up == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appinfo-&gt;parent_relid += context-&gt;offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appinfo-&gt;child_relid += context-&gt;offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through to examine children */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't need to handle other <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> auxiliary nodes here */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!IsA(node, PlanRowMark));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, SpecialJoinInfo));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, PlaceHolderInfo));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, MinMaxAggInfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into subselects */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = query_tree_walker((Query *) node, <a href="#L391" title="rewrite/rewriteManip.c:391">OffsetVarNodes_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L391" title="rewrite/rewriteManip.c:391">OffsetVarNodes_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L480">&#x200c;</a></span><span class="linkable">OffsetVarNodes</span>(Node *node, <span class="Type">int</span> offset, <span class="Type">int</span> sublevels_up)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L388" title="rewrite/rewriteManip.c:388">OffsetVarNodes_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.offset = offset;<br/></li>
<li>&nbsp; &nbsp; context.sublevels_up = sublevels_up;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must be prepared to start with a Query or a bare expression tree; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's a Query, go straight to query_tree_walker to make sure that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sublevels_up doesn't get incremented prematurely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node &amp;&amp; IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *qry = (Query *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are starting at a Query, and sublevels_up is zero, then we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must also fix rangetable indexes in the Query itself --- namely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * resultRelation, mergeTargetRelation, exclRelIndex and rowMarks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entries.&nbsp; sublevels_up cannot be zero when recursing into a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subquery, so there's no need to have the same logic inside<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L391" title="rewrite/rewriteManip.c:391">OffsetVarNodes_walker</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sublevels_up == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qry-&gt;resultRelation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;resultRelation += offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qry-&gt;mergeTargetRelation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;mergeTargetRelation += offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qry-&gt;onConflict &amp;&amp; qry-&gt;onConflict-&gt;exclRelIndex)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;onConflict-&gt;exclRelIndex += offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, qry-&gt;rowMarks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RowMarkClause *rc = (RowMarkClause *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc-&gt;rti += offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query_tree_walker(qry, <a href="#L391" title="rewrite/rewriteManip.c:391">OffsetVarNodes_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) &amp;context, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L391" title="rewrite/rewriteManip.c:391">OffsetVarNodes_walker</a>(node, &amp;context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Relids<br/></li>
<li><a id="L532">&#x200c;</a><span class="linkable">offset_relid_set</span>(Relids relids, <span class="Type">int</span> offset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtindex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rtindex = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((rtindex = <a href="../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(relids, rtindex)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(result, rtindex + offset);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L674" title="rewrite/rewriteManip.c:674">ChangeVarNodes</a> - adjust Var nodes for a specific change of RT index<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Find all Var nodes in the given tree belonging to a specific relation<br/></li>
<li></span><span class="Comment"> * (identified by sublevels_up and rt_index), and change their varno fields<br/></li>
<li></span><span class="Comment"> * to 'new_index'.&nbsp; The varnosyn fields are changed too.&nbsp; Also, adjust other<br/></li>
<li></span><span class="Comment"> * nodes that contain rangetable indexes, such as RangeTblRef and JoinExpr.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: although this has the form of a walker, we cheat and modify the<br/></li>
<li></span><span class="Comment"> * nodes in-place.&nbsp; The given expression tree should have been copied<br/></li>
<li></span><span class="Comment"> * earlier to ensure that no unwanted side-effects occur!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rt_index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublevels_up;<br/></li>
<li><a id="L561">&#x200c;</a>} <span class="linkable">ChangeVarNodes_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L564">&#x200c;</a></span><span class="linkable">ChangeVarNodes_walker</span>(Node *node, <a href="#L561" title="rewrite/rewriteManip.c:561">ChangeVarNodes_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varlevelsup == context-&gt;sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varno == context-&gt;rt_index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varno = context-&gt;new_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varnullingrels = <a href="#L737" title="rewrite/rewriteManip.c:737">adjust_relid_set</a>(var-&gt;varnullingrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;rt_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;new_index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varnosyn == context-&gt;rt_index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varnosyn = context-&gt;new_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, CurrentOfExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CurrentOfExpr *cexpr = (CurrentOfExpr *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;sublevels_up == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cexpr-&gt;cvarno == context-&gt;rt_index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cexpr-&gt;cvarno = context-&gt;new_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, RangeTblRef))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblRef *rtr = (RangeTblRef *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;sublevels_up == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtr-&gt;rtindex == context-&gt;rt_index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtr-&gt;rtindex = context-&gt;new_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the subquery itself is visited separately */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, JoinExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JoinExpr&nbsp;&nbsp; *j = (JoinExpr *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;sublevels_up == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j-&gt;rtindex == context-&gt;rt_index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j-&gt;rtindex = context-&gt;new_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through to examine children */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (phv-&gt;phlevelsup == context-&gt;sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phrels = <a href="#L737" title="rewrite/rewriteManip.c:737">adjust_relid_set</a>(phv-&gt;phrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;rt_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;new_index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phnullingrels = <a href="#L737" title="rewrite/rewriteManip.c:737">adjust_relid_set</a>(phv-&gt;phnullingrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;rt_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;new_index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through to examine children */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, PlanRowMark))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlanRowMark *rowmark = (PlanRowMark *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;sublevels_up == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rowmark-&gt;rti == context-&gt;rt_index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowmark-&gt;rti = context-&gt;new_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rowmark-&gt;prti == context-&gt;rt_index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowmark-&gt;prti = context-&gt;new_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, AppendRelInfo))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AppendRelInfo *appinfo = (AppendRelInfo *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;sublevels_up == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (appinfo-&gt;parent_relid == context-&gt;rt_index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appinfo-&gt;parent_relid = context-&gt;new_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (appinfo-&gt;child_relid == context-&gt;rt_index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appinfo-&gt;child_relid = context-&gt;new_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through to examine children */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't need to handle other <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> auxiliary nodes here */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!IsA(node, SpecialJoinInfo));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, PlaceHolderInfo));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, MinMaxAggInfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into subselects */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = query_tree_walker((Query *) node, <a href="#L564" title="rewrite/rewriteManip.c:564">ChangeVarNodes_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L564" title="rewrite/rewriteManip.c:564">ChangeVarNodes_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L674">&#x200c;</a></span><span class="linkable">ChangeVarNodes</span>(Node *node, <span class="Type">int</span> rt_index, <span class="Type">int</span> new_index, <span class="Type">int</span> sublevels_up)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="rewrite/rewriteManip.c:561">ChangeVarNodes_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.rt_index = rt_index;<br/></li>
<li>&nbsp; &nbsp; context.new_index = new_index;<br/></li>
<li>&nbsp; &nbsp; context.sublevels_up = sublevels_up;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must be prepared to start with a Query or a bare expression tree; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's a Query, go straight to query_tree_walker to make sure that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sublevels_up doesn't get incremented prematurely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node &amp;&amp; IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *qry = (Query *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are starting at a Query, and sublevels_up is zero, then we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must also fix rangetable indexes in the Query itself --- namely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * resultRelation, mergeTargetRelation, exclRelIndex&nbsp; and rowMarks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entries.&nbsp; sublevels_up cannot be zero when recursing into a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subquery, so there's no need to have the same logic inside<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L564" title="rewrite/rewriteManip.c:564">ChangeVarNodes_walker</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sublevels_up == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qry-&gt;resultRelation == rt_index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;resultRelation = new_index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qry-&gt;mergeTargetRelation == rt_index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;mergeTargetRelation = new_index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this is unlikely to ever be used, but ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qry-&gt;onConflict &amp;&amp; qry-&gt;onConflict-&gt;exclRelIndex == rt_index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;onConflict-&gt;exclRelIndex = new_index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, qry-&gt;rowMarks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RowMarkClause *rc = (RowMarkClause *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc-&gt;rti == rt_index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc-&gt;rti = new_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query_tree_walker(qry, <a href="#L564" title="rewrite/rewriteManip.c:564">ChangeVarNodes_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) &amp;context, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L564" title="rewrite/rewriteManip.c:564">ChangeVarNodes_walker</a>(node, &amp;context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Substitute newrelid for oldrelid in a Relid set<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: some extensions may pass a special varno such as INDEX_VAR for<br/></li>
<li></span><span class="Comment"> * oldrelid.&nbsp; <a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a> won't like that, but we should tolerate it.<br/></li>
<li></span><span class="Comment"> * (Perhaps newrelid could also be a special varno, but there had better<br/></li>
<li></span><span class="Comment"> * not be a reason to inject that into a nullingrels or phrels set.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Relids<br/></li>
<li><a id="L737">&#x200c;</a><span class="linkable">adjust_relid_set</span>(Relids relids, <span class="Type">int</span> oldrelid, <span class="Type">int</span> newrelid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!IS_SPECIAL_VARNO(oldrelid) &amp;&amp; <a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(oldrelid, relids))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ensure we have a modifiable copy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relids = <a href="../nodes/bitmapset.c.html#L122" title="nodes/bitmapset.c:122">bms_copy</a>(relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remove old, add new */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relids = <a href="../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(relids, oldrelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relids = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(relids, newrelid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> relids;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L849" title="rewrite/rewriteManip.c:849">IncrementVarSublevelsUp</a> - adjust Var nodes when pushing them down in tree<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Find all Var nodes in the given tree having varlevelsup &gt;= min_sublevels_up,<br/></li>
<li></span><span class="Comment"> * and add delta_sublevels_up to their varlevelsup value.&nbsp; This is needed when<br/></li>
<li></span><span class="Comment"> * an expression that's correct for some nesting level is inserted into a<br/></li>
<li></span><span class="Comment"> * subquery.&nbsp; Ordinarily the initial call has min_sublevels_up == 0 so that<br/></li>
<li></span><span class="Comment"> * all Vars are affected.&nbsp; The point of min_sublevels_up is that we can<br/></li>
<li></span><span class="Comment"> * increment it when we recurse into a sublink, so that local variables in<br/></li>
<li></span><span class="Comment"> * that sublink are not affected, only outer references to <a href="../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> that belong<br/></li>
<li></span><span class="Comment"> * to the expression's original query level or parents thereof.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Likewise for other nodes containing levelsup fields, such as Aggref.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: although this has the form of a walker, we cheat and modify the<br/></li>
<li></span><span class="Comment"> * Var nodes in-place.&nbsp; The given expression tree should have been copied<br/></li>
<li></span><span class="Comment"> * earlier to ensure that no unwanted side-effects occur!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delta_sublevels_up;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_sublevels_up;<br/></li>
<li><a id="L773">&#x200c;</a>} <span class="linkable">IncrementVarSublevelsUp_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L776">&#x200c;</a></span><span class="linkable">IncrementVarSublevelsUp_walker</span>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L773" title="rewrite/rewriteManip.c:773">IncrementVarSublevelsUp_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varlevelsup &gt;= context-&gt;min_sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varlevelsup += context-&gt;delta_sublevels_up;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* done here */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, CurrentOfExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;min_sublevels_up == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot <a href="../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> down CurrentOfExpr&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Aggref))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Aggref&nbsp; &nbsp; &nbsp;&nbsp; *agg = (Aggref *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (agg-&gt;agglevelsup &gt;= context-&gt;min_sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; agg-&gt;agglevelsup += context-&gt;delta_sublevels_up;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through to recurse into argument */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, GroupingFunc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GroupingFunc *grp = (GroupingFunc *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (grp-&gt;agglevelsup &gt;= context-&gt;min_sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; grp-&gt;agglevelsup += context-&gt;delta_sublevels_up;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through to recurse into argument */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (phv-&gt;phlevelsup &gt;= context-&gt;min_sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phlevelsup += context-&gt;delta_sublevels_up;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through to recurse into argument */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, RangeTblEntry))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = (RangeTblEntry *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_CTE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;ctelevelsup &gt;= context-&gt;min_sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;ctelevelsup += context-&gt;delta_sublevels_up;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allow range_table_walker to continue */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into subselects */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;min_sublevels_up++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = query_tree_walker((Query *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L776" title="rewrite/rewriteManip.c:776">IncrementVarSublevelsUp_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; QTW_EXAMINE_RTES_BEFORE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;min_sublevels_up--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L776" title="rewrite/rewriteManip.c:776">IncrementVarSublevelsUp_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L849">&#x200c;</a></span><span class="linkable">IncrementVarSublevelsUp</span>(Node *node, <span class="Type">int</span> delta_sublevels_up,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> min_sublevels_up)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L773" title="rewrite/rewriteManip.c:773">IncrementVarSublevelsUp_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.delta_sublevels_up = delta_sublevels_up;<br/></li>
<li>&nbsp; &nbsp; context.min_sublevels_up = min_sublevels_up;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must be prepared to start with a Query or a bare expression tree; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's a Query, we don't want to increment sublevels_up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; query_or_expression_tree_walker(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L776" title="rewrite/rewriteManip.c:776">IncrementVarSublevelsUp_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) &amp;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QTW_EXAMINE_RTES_BEFORE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L872" title="rewrite/rewriteManip.c:872">IncrementVarSublevelsUp_rtable</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Same as <a href="#L849" title="rewrite/rewriteManip.c:849">IncrementVarSublevelsUp</a>, but to be invoked on a <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L872">&#x200c;</a></span><span class="linkable">IncrementVarSublevelsUp_rtable</span>(List *rtable, <span class="Type">int</span> delta_sublevels_up,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> min_sublevels_up)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L773" title="rewrite/rewriteManip.c:773">IncrementVarSublevelsUp_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.delta_sublevels_up = delta_sublevels_up;<br/></li>
<li>&nbsp; &nbsp; context.min_sublevels_up = min_sublevels_up;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; range_table_walker(rtable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L776" title="rewrite/rewriteManip.c:776">IncrementVarSublevelsUp_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) &amp;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; QTW_EXAMINE_RTES_BEFORE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L966" title="rewrite/rewriteManip.c:966">rangeTableEntry_used</a> - detect whether an RTE is referenced somewhere<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; in var nodes or join or setOp trees of a query or expression.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rt_index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublevels_up;<br/></li>
<li><a id="L896">&#x200c;</a>} <span class="linkable">rangeTableEntry_used_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L899">&#x200c;</a></span><span class="linkable">rangeTableEntry_used_walker</span>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L896" title="rewrite/rewriteManip.c:896">rangeTableEntry_used_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varlevelsup == context-&gt;sublevels_up &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (var-&gt;varno == context-&gt;rt_index ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(context-&gt;rt_index, var-&gt;varnullingrels)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, CurrentOfExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CurrentOfExpr *cexpr = (CurrentOfExpr *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;sublevels_up == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cexpr-&gt;cvarno == context-&gt;rt_index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, RangeTblRef))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblRef *rtr = (RangeTblRef *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rtr-&gt;rtindex == context-&gt;rt_index &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the subquery itself is visited separately */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, JoinExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JoinExpr&nbsp;&nbsp; *j = (JoinExpr *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j-&gt;rtindex == context-&gt;rt_index &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through to examine children */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't need to handle <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> auxiliary nodes here */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!IsA(node, PlaceHolderVar));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, PlanRowMark));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, SpecialJoinInfo));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, AppendRelInfo));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, PlaceHolderInfo));<br/></li>
<li>&nbsp; &nbsp; Assert(!IsA(node, MinMaxAggInfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into subselects */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = query_tree_walker((Query *) node, <a href="#L899" title="rewrite/rewriteManip.c:899">rangeTableEntry_used_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L899" title="rewrite/rewriteManip.c:899">rangeTableEntry_used_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L966">&#x200c;</a></span><span class="linkable">rangeTableEntry_used</span>(Node *node, <span class="Type">int</span> rt_index, <span class="Type">int</span> sublevels_up)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L896" title="rewrite/rewriteManip.c:896">rangeTableEntry_used_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.rt_index = rt_index;<br/></li>
<li>&nbsp; &nbsp; context.sublevels_up = sublevels_up;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must be prepared to start with a Query or a bare expression tree; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's a Query, we don't want to increment sublevels_up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> query_or_expression_tree_walker(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L899" title="rewrite/rewriteManip.c:899">rangeTableEntry_used_walker</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) &amp;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If the given Query is an INSERT ... SELECT construct, extract and<br/></li>
<li></span><span class="Comment"> * return the sub-Query node that represents the SELECT part.&nbsp; Otherwise<br/></li>
<li></span><span class="Comment"> * return the given Query.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If subquery_ptr is not NULL, then *subquery_ptr is set to the location<br/></li>
<li></span><span class="Comment"> * of the link to the SELECT subquery inside parsetree, or NULL if not an<br/></li>
<li></span><span class="Comment"> * INSERT ... SELECT.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a hack needed because transformations on INSERT ... SELECTs that<br/></li>
<li></span><span class="Comment"> * appear in rule actions should be applied to the source SELECT, not to the<br/></li>
<li></span><span class="Comment"> * INSERT part.&nbsp; Perhaps this can be cleaned up with redesigned querytrees.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Query *<br/></li>
<li><a id="L998">&#x200c;</a><span class="linkable">getInsertSelectQuery</span>(Query *parsetree, Query ***subquery_ptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *selectquery;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *selectrte;<br/></li>
<li>&nbsp; &nbsp; RangeTblRef *rtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (subquery_ptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *subquery_ptr = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parsetree == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> parsetree;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;commandType != CMD_INSERT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> parsetree;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently, this is ONLY applied to rule-action queries, and so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expect to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the OLD and NEW placeholder entries in the given query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If they're not there, it must be an INSERT/SELECT in which they've been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pushed down to the SELECT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(parsetree-&gt;rtable) &gt;= <span class="Constant">2</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcmp(rt_fetch(PRS2_OLD_VARNO, parsetree-&gt;rtable)-&gt;eref-&gt;aliasname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;old&quot;</span>) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcmp(rt_fetch(PRS2_NEW_VARNO, parsetree-&gt;rtable)-&gt;eref-&gt;aliasname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;new&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> parsetree;<br/></li>
<li>&nbsp; &nbsp; Assert(parsetree-&gt;jointree &amp;&amp; IsA(parsetree-&gt;jointree, FromExpr));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(parsetree-&gt;jointree-&gt;fromlist) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> SELECT subquery&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; rtr = (RangeTblRef *) linitial(parsetree-&gt;jointree-&gt;fromlist);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(rtr, RangeTblRef))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> SELECT subquery&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; selectrte = rt_fetch(rtr-&gt;rtindex, parsetree-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(selectrte-&gt;rtekind == RTE_SUBQUERY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selectrte-&gt;subquery &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IsA(selectrte-&gt;subquery, Query) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selectrte-&gt;subquery-&gt;commandType == CMD_SELECT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> SELECT subquery&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; selectquery = selectrte-&gt;subquery;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(selectquery-&gt;rtable) &gt;= <span class="Constant">2</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcmp(rt_fetch(PRS2_OLD_VARNO, selectquery-&gt;rtable)-&gt;eref-&gt;aliasname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;old&quot;</span>) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcmp(rt_fetch(PRS2_NEW_VARNO, selectquery-&gt;rtable)-&gt;eref-&gt;aliasname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;new&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subquery_ptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *subquery_ptr = &amp;(selectrte-&gt;subquery);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> selectquery;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> rule placeholders&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not reached */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add the given qualifier condition to the query's WHERE clause<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1056">&#x200c;</a></span><span class="linkable">AddQual</span>(Query *parsetree, Node *qual)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *copy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (qual == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;commandType == CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's noplace to put the qual on a utility statement.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a NOTIFY, silently ignore the qual; this means that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NOTIFY will execute, whether or not there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> qualifying rows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * While clearly wrong, this is much more useful than refusing to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * execute the rule at all, and extra NOTIFY events are harmless for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * typical uses of NOTIFY.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it isn't a NOTIFY, error out, since unconditional execution of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other utility stmts is unlikely to be wanted.&nbsp; (This case is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * currently allowed anyway, but keep the test for safety.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;utilityStmt &amp;&amp; IsA(parsetree-&gt;utilityStmt, NotifyStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conditional utility statements are not implemented&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;setOperations != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's noplace to put the qual on a setop statement, either. (This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could be fixed, but right <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> simply ignores <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> qual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * condition on a setop query.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conditional UNION/INTERSECT/EXCEPT statements are not implemented&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* INTERSECT wants the original, but we need to copy - Jan */<br/></li>
<li></span>&nbsp; &nbsp; copy = copyObject(qual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; parsetree-&gt;jointree-&gt;quals = <a href="../nodes/makefuncs.c.html#L707" title="nodes/makefuncs.c:707">make_and_qual</a>(parsetree-&gt;jointree-&gt;quals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; copy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We had better not have stuck an aggregate into the WHERE clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="#L85" title="rewrite/rewriteManip.c:85">contain_aggs_of_level</a>(copy, <span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure query is marked correctly if added qual has sublinks. Need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not search qual when query is already marked.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!parsetree-&gt;hasSubLinks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;hasSubLinks = <a href="#L295" title="rewrite/rewriteManip.c:295">checkExprHasSubLink</a>(copy);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Invert the given clause and add it to the WHERE qualifications of the<br/></li>
<li></span><span class="Comment"> * given querytree.&nbsp; Inversion means &quot;x IS NOT TRUE&quot;, not just &quot;NOT x&quot;,<br/></li>
<li></span><span class="Comment"> * else we will do the wrong thing when x evaluates to NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1124">&#x200c;</a></span><span class="linkable">AddInvertedQual</span>(Query *parsetree, Node *qual)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BooleanTest *invqual;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (qual == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need not copy input qual, because <a href="#L1056" title="rewrite/rewriteManip.c:1056">AddQual</a> will... */<br/></li>
<li></span>&nbsp; &nbsp; invqual = makeNode(BooleanTest);<br/></li>
<li>&nbsp; &nbsp; invqual-&gt;arg = (Expr *) qual;<br/></li>
<li>&nbsp; &nbsp; invqual-&gt;booltesttype = IS_NOT_TRUE;<br/></li>
<li>&nbsp; &nbsp; invqual-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1056" title="rewrite/rewriteManip.c:1056">AddQual</a>(parsetree, (Node *) invqual);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1147" title="rewrite/rewriteManip.c:1147">add_nulling_relids</a>() finds Vars and PlaceHolderVars that belong to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * of the target_relids, and adds added_relids to their varnullingrels<br/></li>
<li></span><span class="Comment"> * and phnullingrels fields.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Node *<br/></li>
<li><a id="L1147">&#x200c;</a><span class="linkable">add_nulling_relids</span>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> Bitmapset *target_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> Bitmapset *added_relids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="rewrite/rewriteManip.c:48">add_nulling_relids_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.target_relids = target_relids;<br/></li>
<li>&nbsp; &nbsp; context.added_relids = added_relids;<br/></li>
<li>&nbsp; &nbsp; context.sublevels_up = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> query_or_expression_tree_mutator(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1163" title="rewrite/rewriteManip.c:1163">add_nulling_relids_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Node *<br/></li>
<li><a id="L1163">&#x200c;</a><span class="linkable">add_nulling_relids_mutator</span>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L48" title="rewrite/rewriteManip.c:48">add_nulling_relids_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varlevelsup == context-&gt;sublevels_up &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(var-&gt;varno, context-&gt;target_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; newnullingrels = <a href="../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(var-&gt;varnullingrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;added_relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy the Var ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var = copyObject(var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and replace the copy's varnullingrels field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varnullingrels = newnullingrels;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) var;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise fall through to copy the Var normally */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (phv-&gt;phlevelsup == context-&gt;sublevels_up &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(phv-&gt;phrels, context-&gt;target_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relids&nbsp; &nbsp; &nbsp; &nbsp; newnullingrels = <a href="../nodes/bitmapset.c.html#L251" title="nodes/bitmapset.c:251">bms_union</a>(phv-&gt;phnullingrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;added_relids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't modify the contents of the PHV's expression, only add<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to phnullingrels.&nbsp; This corresponds to assuming that the PHV<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will be evaluated at the same level as <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, then perhaps be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nulled as it bubbles up.&nbsp; Hence, just flat-copy the node ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv = makeNode(PlaceHolderVar);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(phv, node, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PlaceHolderVar));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and replace the copy's phnullingrels field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phnullingrels = newnullingrels;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) phv;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise fall through to copy the PlaceHolderVar normally */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into RTE or sublink subquery */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *newnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newnode = query_tree_mutator((Query *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1163" title="rewrite/rewriteManip.c:1163">add_nulling_relids_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) newnode;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_mutator(node, <a href="#L1163" title="rewrite/rewriteManip.c:1163">add_nulling_relids_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1234" title="rewrite/rewriteManip.c:1234">remove_nulling_relids</a>() removes mentions of the specified RT index(es)<br/></li>
<li></span><span class="Comment"> * in Var.varnullingrels and PlaceHolderVar.phnullingrels fields within<br/></li>
<li></span><span class="Comment"> * the given expression, except in nodes belonging to rels listed in<br/></li>
<li></span><span class="Comment"> * except_relids.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Node *<br/></li>
<li><a id="L1234">&#x200c;</a><span class="linkable">remove_nulling_relids</span>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> Bitmapset *removable_relids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> Bitmapset *except_relids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="rewrite/rewriteManip.c:55">remove_nulling_relids_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.removable_relids = removable_relids;<br/></li>
<li>&nbsp; &nbsp; context.except_relids = except_relids;<br/></li>
<li>&nbsp; &nbsp; context.sublevels_up = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> query_or_expression_tree_mutator(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1250" title="rewrite/rewriteManip.c:1250">remove_nulling_relids_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Node *<br/></li>
<li><a id="L1250">&#x200c;</a><span class="linkable">remove_nulling_relids_mutator</span>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L55" title="rewrite/rewriteManip.c:55">remove_nulling_relids_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varlevelsup == context-&gt;sublevels_up &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(var-&gt;varno, context-&gt;except_relids) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(var-&gt;varnullingrels, context-&gt;removable_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy the Var ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var = copyObject(var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and replace the copy's varnullingrels field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varnullingrels = <a href="../nodes/bitmapset.c.html#L346" title="nodes/bitmapset.c:346">bms_difference</a>(var-&gt;varnullingrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;removable_relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) var;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise fall through to copy the Var normally */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, PlaceHolderVar))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlaceHolderVar *phv = (PlaceHolderVar *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (phv-&gt;phlevelsup == context-&gt;sublevels_up &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(phv-&gt;phrels, context-&gt;except_relids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: it might seem desirable to remove the PHV altogether if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * phnullingrels goes to empty.&nbsp; Currently we dare not do that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because we use PHVs in some cases to enforce separate identity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of subexpressions; see wrap_non_vars usages in prepjointree.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy the PlaceHolderVar and mutate what's below ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv = (PlaceHolderVar *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expression_tree_mutator(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1250" title="rewrite/rewriteManip.c:1250">remove_nulling_relids_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and replace the copy's phnullingrels field */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phnullingrels = <a href="../nodes/bitmapset.c.html#L346" title="nodes/bitmapset.c:346">bms_difference</a>(phv-&gt;phnullingrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;removable_relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We must also update phrels, if it contains a removable RTI */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phv-&gt;phrels = <a href="../nodes/bitmapset.c.html#L346" title="nodes/bitmapset.c:346">bms_difference</a>(phv-&gt;phrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; context-&gt;removable_relids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!bms_is_empty(phv-&gt;phrels));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) phv;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise fall through to copy the PlaceHolderVar normally */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into RTE or sublink subquery */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *newnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newnode = query_tree_mutator((Query *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1250" title="rewrite/rewriteManip.c:1250">remove_nulling_relids_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) newnode;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_mutator(node, <a href="#L1250" title="rewrite/rewriteManip.c:1250">remove_nulling_relids_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1342" title="rewrite/rewriteManip.c:1342">replace_rte_variables</a>() finds all Vars in an expression tree<br/></li>
<li></span><span class="Comment"> * that reference a particular RTE, and replaces them with substitute<br/></li>
<li></span><span class="Comment"> * expressions obtained from a caller-supplied callback function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When invoking <a href="#L1342" title="rewrite/rewriteManip.c:1342">replace_rte_variables</a> on a portion of a Query, pass the<br/></li>
<li></span><span class="Comment"> * address of the containing Query's hasSubLinks field as outer_hasSubLinks.<br/></li>
<li></span><span class="Comment"> * Otherwise, pass NULL, but inserting a SubLink into a non-Query expression<br/></li>
<li></span><span class="Comment"> * will then cause an error.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the business with inserted_sublink is needed to update hasSubLinks<br/></li>
<li></span><span class="Comment"> * in subqueries when the replacement adds a subquery inside a subquery.<br/></li>
<li></span><span class="Comment"> * Messy, isn't it?&nbsp; We do not need to do similar pushups for hasAggs,<br/></li>
<li></span><span class="Comment"> * because it isn't possible for this transformation to insert a level-zero<br/></li>
<li></span><span class="Comment"> * aggregate reference into a subquery --- it could only insert outer aggs.<br/></li>
<li></span><span class="Comment"> * Likewise for hasWindowFuncs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: usually, we'd not expose the mutator function or context struct<br/></li>
<li></span><span class="Comment"> * for a function like this.&nbsp; We do so because callbacks often <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it<br/></li>
<li></span><span class="Comment"> * convenient to recurse directly to the mutator on sub-expressions of<br/></li>
<li></span><span class="Comment"> * what they will return.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Node *<br/></li>
<li><a id="L1342">&#x200c;</a><span class="linkable">replace_rte_variables</span>(Node *node, <span class="Type">int</span> target_varno, <span class="Type">int</span> sublevels_up,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replace_rte_variables_callback callback,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *callback_arg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *outer_hasSubLinks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; replace_rte_variables_context context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.callback = callback;<br/></li>
<li>&nbsp; &nbsp; context.callback_arg = callback_arg;<br/></li>
<li>&nbsp; &nbsp; context.target_varno = target_varno;<br/></li>
<li>&nbsp; &nbsp; context.sublevels_up = sublevels_up;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We try to <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> inserted_sublink to true if there is no need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * detect new sublinks because the query already has some.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (node &amp;&amp; IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context.inserted_sublink = ((Query *) node)-&gt;hasSubLinks;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (outer_hasSubLinks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context.inserted_sublink = *outer_hasSubLinks;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; context.inserted_sublink = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must be prepared to start with a Query or a bare expression tree; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's a Query, we don't want to increment sublevels_up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = query_or_expression_tree_mutator(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1389" title="rewrite/rewriteManip.c:1389">replace_rte_variables_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) &amp;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (context.inserted_sublink)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &amp;&amp; IsA(result, Query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((Query *) result)-&gt;hasSubLinks = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (outer_hasSubLinks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *outer_hasSubLinks = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1342" title="rewrite/rewriteManip.c:1342">replace_rte_variables</a> inserted a SubLink, but has noplace to record it&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Node *<br/></li>
<li><a id="L1389">&#x200c;</a><span class="linkable">replace_rte_variables_mutator</span>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replace_rte_variables_context *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varno == context-&gt;target_varno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varlevelsup == context-&gt;sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found a matching variable, make the substitution */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *newnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newnode = context-&gt;callback(var, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Detect if we are adding a sublink to query */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!context-&gt;inserted_sublink)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;inserted_sublink = <a href="#L295" title="rewrite/rewriteManip.c:295">checkExprHasSubLink</a>(newnode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> newnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise fall through to copy the var normally */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, CurrentOfExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CurrentOfExpr *cexpr = (CurrentOfExpr *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cexpr-&gt;cvarno == context-&gt;target_varno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We get here if a WHERE CURRENT OF expression turns out to apply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to a view.&nbsp; Someday we might be able to <a href="../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expression to apply to an underlying table of the view, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * right <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> it's not implemented.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;WHERE CURRENT OF on a view is not implemented&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise fall through to copy the expr normally */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into RTE subquery or not-yet-planned sublink subquery */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *newnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; save_inserted_sublink;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; save_inserted_sublink = context-&gt;inserted_sublink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;inserted_sublink = ((Query *) node)-&gt;hasSubLinks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newnode = query_tree_mutator((Query *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1389" title="rewrite/rewriteManip.c:1389">replace_rte_variables_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newnode-&gt;hasSubLinks |= context-&gt;inserted_sublink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;inserted_sublink = save_inserted_sublink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) newnode;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_mutator(node, <a href="#L1389" title="rewrite/rewriteManip.c:1389">replace_rte_variables_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1611" title="rewrite/rewriteManip.c:1611">map_variable_attnos</a>() finds all user-column Vars in an expression tree<br/></li>
<li></span><span class="Comment"> * that reference a particular RTE, and adjusts their varattnos according<br/></li>
<li></span><span class="Comment"> * to the given mapping array (varattno n is replaced by attno_map[n-1]).<br/></li>
<li></span><span class="Comment"> * Vars for system columns are not modified.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A zero in the mapping array represents a dropped column, which should not<br/></li>
<li></span><span class="Comment"> * appear in the expression.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the expression tree contains a whole-row Var for the target RTE,<br/></li>
<li></span><span class="Comment"> * *found_whole_row is set to true.&nbsp; In addition, if to_rowtype is<br/></li>
<li></span><span class="Comment"> * not InvalidOid, we replace the Var with a Var of that vartype, inserting<br/></li>
<li></span><span class="Comment"> * a ConvertRowtypeExpr to map back to the rowtype expected by the expression.<br/></li>
<li></span><span class="Comment"> * (Therefore, to_rowtype had better be a child rowtype of the rowtype of the<br/></li>
<li></span><span class="Comment"> * RTE we're changing references to.)&nbsp; Callers that don't provide to_rowtype<br/></li>
<li></span><span class="Comment"> * should report an error if *found_whole_row is true; we don't do that here<br/></li>
<li></span><span class="Comment"> * because we don't know exactly what wording for the error message would<br/></li>
<li></span><span class="Comment"> * be most appropriate.&nbsp; The caller will be aware of the context.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This could be built using <a href="#L1342" title="rewrite/rewriteManip.c:1342">replace_rte_variables</a> and a callback function,<br/></li>
<li></span><span class="Comment"> * but since we don't ever need to insert sublinks, <a href="#L1342" title="rewrite/rewriteManip.c:1342">replace_rte_variables</a> is<br/></li>
<li></span><span class="Comment"> * overly complicated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target_varno;&nbsp; &nbsp; <span class="Comment">/* RTE index to search for */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublevels_up;&nbsp; &nbsp; <span class="Comment">/* (current) nesting depth */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">const</span> AttrMap *attno_map;&nbsp; &nbsp; <span class="Comment">/* map array for user attnos */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to_rowtype;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* change whole-row Vars to this type */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *found_whole_row;&nbsp; &nbsp; <span class="Comment">/* output flag */<br/></li>
<li><a id="L1485">&#x200c;</a></span>} <span class="linkable">map_variable_attnos_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Node *<br/></li>
<li><a id="L1488">&#x200c;</a><span class="linkable">map_variable_attnos_mutator</span>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1485" title="rewrite/rewriteManip.c:1485">map_variable_attnos_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varno == context-&gt;target_varno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varlevelsup == context-&gt;sublevels_up)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found a matching variable, make the substitution */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newvar = (Var *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Var));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attno = var-&gt;varattno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *newvar = *var;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* initially copy all fields of the Var */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attno &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* user-defined column, replace attno */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attno &gt; context-&gt;attno_map-&gt;maplen ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;attno_map-&gt;attnums[attno - <span class="Constant">1</span>] == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected varattno </span><span class="Special">%d</span><span class="Constant"> in expression to be mapped&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar-&gt;varattno = context-&gt;attno_map-&gt;attnums[attno - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the syntactic referent is same RTE, fix it too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newvar-&gt;varnosyn == context-&gt;target_varno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar-&gt;varattnosyn = newvar-&gt;varattno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (attno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* whole-row variable, warn caller */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(context-&gt;found_whole_row) = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the caller expects us to convert the Var, do so. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(context-&gt;to_rowtype) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;to_rowtype != var-&gt;vartype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ConvertRowtypeExpr *r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This certainly won't work for a RECORD variable. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;vartype != RECORDOID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Var itself is changed to the requested type. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar-&gt;vartype = context-&gt;to_rowtype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add a conversion node on top to convert back to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original type expected by the expression.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = makeNode(ConvertRowtypeExpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r-&gt;arg = (Expr *) newvar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r-&gt;resulttype = var-&gt;vartype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r-&gt;convertformat = COERCE_IMPLICIT_CAST;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) r;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) newvar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise fall through to copy the var normally */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, ConvertRowtypeExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ConvertRowtypeExpr *r = (ConvertRowtypeExpr *) node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) r-&gt;arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is coercing a whole-row Var that we need to convert, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just convert the Var without adding an extra ConvertRowtypeExpr.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Effectively we're simplifying var::parenttype::grandparenttype into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just var::grandparenttype.&nbsp; This avoids building stacks of CREs if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this function is applied repeatedly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(var, Var) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varno == context-&gt;target_varno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varlevelsup == context-&gt;sublevels_up &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varattno == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OidIsValid(context-&gt;to_rowtype) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;to_rowtype != var-&gt;vartype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ConvertRowtypeExpr *newnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newvar = (Var *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Var));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* whole-row variable, warn caller */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(context-&gt;found_whole_row) = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *newvar = *var;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* initially copy all fields of the Var */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This certainly won't work for a RECORD variable. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(var-&gt;vartype != RECORDOID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Var itself is changed to the requested type. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newvar-&gt;vartype = context-&gt;to_rowtype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newnode = (ConvertRowtypeExpr *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ConvertRowtypeExpr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *newnode = *r;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* initially copy all fields of the CRE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newnode-&gt;arg = (Expr *) newvar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) newnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise fall through to process the expression normally */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recurse into RTE subquery or not-yet-planned sublink subquery */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *newnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newnode = query_tree_mutator((Query *) node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1488" title="rewrite/rewriteManip.c:1488">map_variable_attnos_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;sublevels_up--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) newnode;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_mutator(node, <a href="#L1488" title="rewrite/rewriteManip.c:1488">map_variable_attnos_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Node *<br/></li>
<li><a id="L1611">&#x200c;</a><span class="linkable">map_variable_attnos</span>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> target_varno, <span class="Type">int</span> sublevels_up,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> AttrMap *attno_map,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid to_rowtype, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *found_whole_row)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1485" title="rewrite/rewriteManip.c:1485">map_variable_attnos_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.target_varno = target_varno;<br/></li>
<li>&nbsp; &nbsp; context.sublevels_up = sublevels_up;<br/></li>
<li>&nbsp; &nbsp; context.attno_map = attno_map;<br/></li>
<li>&nbsp; &nbsp; context.to_rowtype = to_rowtype;<br/></li>
<li>&nbsp; &nbsp; context.found_whole_row = found_whole_row;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *found_whole_row = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must be prepared to start with a Query or a bare expression tree; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's a Query, we don't want to increment sublevels_up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> query_or_expression_tree_mutator(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1488" title="rewrite/rewriteManip.c:1488">map_variable_attnos_mutator</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) &amp;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1769" title="rewrite/rewriteManip.c:1769">ReplaceVarsFromTargetList</a> - replace Vars with items from a targetlist<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Vars matching target_varno and sublevels_up are replaced by the<br/></li>
<li></span><span class="Comment"> * entry with matching resno from targetlist, if there is one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there is no matching resno for such a Var, the action depends on the<br/></li>
<li></span><span class="Comment"> * nomatch_option:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; REPLACEVARS_REPORT_ERROR: throw an error<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; REPLACEVARS_CHANGE_VARNO: change Var's varno to nomatch_varno<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; REPLACEVARS_SUBSTITUTE_NULL: replace Var with a NULL Const of same type<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must also provide target_rte, the RTE describing the target<br/></li>
<li></span><span class="Comment"> * relation.&nbsp; This is needed to handle whole-row Vars referencing the target.<br/></li>
<li></span><span class="Comment"> * We expand such Vars into RowExpr constructs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * outer_hasSubLinks works the same as for <a href="#L1342" title="rewrite/rewriteManip.c:1342">replace_rte_variables</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *target_rte;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *targetlist;<br/></li>
<li>&nbsp; &nbsp; ReplaceVarsNoMatchOption nomatch_option;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nomatch_varno;<br/></li>
<li><a id="L1662">&#x200c;</a>} <span class="linkable">ReplaceVarsFromTargetList_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Node *<br/></li>
<li><a id="L1665">&#x200c;</a><span class="linkable">ReplaceVarsFromTargetList_callback</span>(Var *var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; replace_rte_variables_context *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1662" title="rewrite/rewriteManip.c:1662">ReplaceVarsFromTargetList_context</a> *rcon = (<a href="#L1662" title="rewrite/rewriteManip.c:1662">ReplaceVarsFromTargetList_context</a> *) context-&gt;callback_arg;<br/></li>
<li>&nbsp; &nbsp; TargetEntry *tle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varattno == InvalidAttrNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must expand whole-tuple reference into RowExpr */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; RowExpr&nbsp; &nbsp; *rowexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *colnames;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *fields;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If generating an expansion for a var of a named rowtype (ie, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is a plain relation RTE), then we must include dummy items for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dropped columns.&nbsp; If the var is RECORD (ie, this is a JOIN), then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * omit dropped columns.&nbsp; In the latter case, attach column names to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the RowExpr for use of the executor and ruleutils.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../parser/parse_relation.c.html#L2659" title="parser/parse_relation.c:2659">expandRTE</a>(rcon-&gt;target_rte,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varno, var-&gt;varlevelsup, var-&gt;location,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (var-&gt;vartype != RECORDOID),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;colnames, &amp;fields);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust the generated per-field Vars... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fields = (List *) <a href="#L1389" title="rewrite/rewriteManip.c:1389">replace_rte_variables_mutator</a>((Node *) fields,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rowexpr = makeNode(RowExpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rowexpr-&gt;args = fields;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rowexpr-&gt;row_typeid = var-&gt;vartype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rowexpr-&gt;row_format = COERCE_IMPLICIT_CAST;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rowexpr-&gt;colnames = (var-&gt;vartype == RECORDOID) ? colnames : NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rowexpr-&gt;location = var-&gt;location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) rowexpr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Normal case referencing one targetlist <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; tle = <a href="../parser/parse_relation.c.html#L3439" title="parser/parse_relation.c:3439">get_tle_by_resno</a>(rcon-&gt;targetlist, var-&gt;varattno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tle == <span class="Constant">NULL</span> || tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Failed to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> column in targetlist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (rcon-&gt;nomatch_option)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REPLACEVARS_REPORT_ERROR:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through, throw error below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REPLACEVARS_CHANGE_VARNO:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var = (Var *) copyObject(var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varno = rcon-&gt;nomatch_varno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we leave the syntactic referent alone */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> REPLACEVARS_SUBSTITUTE_NULL:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If Var is of domain type, we should add a CoerceToDomain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * node, in case there is a NOT NULL domain constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../parser/parse_coerce.c.html#L676" title="parser/parse_coerce.c:676">coerce_to_domain</a>((Node *) <a href="../nodes/makefuncs.c.html#L339" title="nodes/makefuncs.c:339">makeNullConst</a>(var-&gt;vartype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var-&gt;vartypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var-&gt;varcollid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;vartype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCION_IMPLICIT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCE_IMPLICIT_CAST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> replacement targetlist entry for attno </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; var-&gt;varattno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make a copy of the tlist item to return */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *newnode = copyObject(tle-&gt;expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must adjust varlevelsup if tlist item is from higher query */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varlevelsup &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L849" title="rewrite/rewriteManip.c:849">IncrementVarSublevelsUp</a>((Node *) newnode, var-&gt;varlevelsup, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check to see if the tlist item contains a PARAM_MULTIEXPR Param,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and throw error if so.&nbsp; This case could only happen when expanding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an ON UPDATE rule's NEW variable and the referenced tlist item in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the original UPDATE command is part of a multiple assignment. There<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * seems no practical way to handle such cases without multiple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * evaluation of the multiple assignment's sub-<a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>, which would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * create semantic oddities that users of rules would probably prefer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not to cope with.&nbsp; So treat it as an unimplemented feature.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L324" title="rewrite/rewriteManip.c:324">contains_multiexpr_param</a>((Node *) newnode, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;NEW variables in ON UPDATE rules cannot reference columns that are part of a multiple assignment in the subject UPDATE command&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) newnode;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Node *<br/></li>
<li><a id="L1769">&#x200c;</a><span class="linkable">ReplaceVarsFromTargetList</span>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> target_varno, <span class="Type">int</span> sublevels_up,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *target_rte,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReplaceVarsNoMatchOption nomatch_option,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nomatch_varno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *outer_hasSubLinks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1662" title="rewrite/rewriteManip.c:1662">ReplaceVarsFromTargetList_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.target_rte = target_rte;<br/></li>
<li>&nbsp; &nbsp; context.targetlist = targetlist;<br/></li>
<li>&nbsp; &nbsp; context.nomatch_option = nomatch_option;<br/></li>
<li>&nbsp; &nbsp; context.nomatch_varno = nomatch_varno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1342" title="rewrite/rewriteManip.c:1342">replace_rte_variables</a>(node, target_varno, sublevels_up,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1665" title="rewrite/rewriteManip.c:1665">ReplaceVarsFromTargetList_callback</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) &amp;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_hasSubLinks);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
