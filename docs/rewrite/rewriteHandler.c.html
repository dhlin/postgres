<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>rewrite/rewriteHandler.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>rewrite/rewriteHandler.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L56">acquireLocksOnSubLinks_context</a></li>
<li><a href="#L59">acquireLocksOnSubLinks_context</a></li>
<li><a href="#L50">rewrite_event</a></li>
<li><a href="#L54">rewrite_event</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L140">AcquireRewriteLocks</a></li>
<li><a href="#L1733">ApplyRetrieveRule</a></li>
<li><a href="#L2286">CopyAndAddInvertedQual</a></li>
<li><a href="#L4371">QueryRewrite</a></li>
<li><a href="#L3825">RewriteQuery</a></li>
<li><a href="#L302">acquireLocksOnSubLinks</a></li>
<li><a href="#L696">adjustJoinTreeList</a></li>
<li><a href="#L3010">adjust_view_column_set</a></li>
<li><a href="#L1224">build_column_default</a></li>
<li><a href="#L3084">error_view_not_updatable</a></li>
<li><a href="#L1337">findDefaultOnlyColumns</a></li>
<li><a href="#L1963">fireRIRonSubLink</a></li>
<li><a href="#L1994">fireRIRrules</a></li>
<li><a href="#L2356">fireRules</a></li>
<li><a href="#L1195">get_assignment_input</a></li>
<li><a href="#L2447">get_view_query</a></li>
<li><a href="#L1899">markQueryForLocking</a></li>
<li><a href="#L1658">matchLocks</a></li>
<li><a href="#L1042">process_matched_tle</a></li>
<li><a href="#L2829">relation_is_updatable</a></li>
<li><a href="#L343">rewriteRuleAction</a></li>
<li><a href="#L758">rewriteTargetListIU</a></li>
<li><a href="#L3179">rewriteTargetView</a></li>
<li><a href="#L1425">rewriteValuesRTE</a></li>
<li><a href="#L1620">rewriteValuesRTEToNulls</a></li>
<li><a href="#L1311">searchForDefault</a></li>
<li><a href="#L2550">view_col_is_auto_updatable</a></li>
<li><a href="#L2746">view_cols_are_auto_updatable</a></li>
<li><a href="#L2486">view_has_instead_trigger</a></li>
<li><a href="#L2598">view_query_is_auto_updatable</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L2838">ALL_EVENTS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * rewriteHandler.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Primary module of query rewriter.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/rewrite/rewriteHandler.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Some of the terms used in this file are of historic nature: &quot;retrieve&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; was the PostQUEL keyword for what today is SELECT. &quot;RIR&quot; stands for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &quot;Retrieve-Instead-Retrieve&quot;, that is an ON SELECT DO INSTEAD SELECT rule<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (which has to be unconditional and where only one rule can exist on each<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; relation).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/sysattr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/dependency.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/partition.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;foreign/fdwapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/<a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_coerce.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parsetree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteDefine.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteHandler.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteManip.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteSearchCycle.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rowsecurity.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* We use a list of these to detect recursion in <a href="#L3825" title="rewrite/rewriteHandler.c:3825">RewriteQuery</a> */<br/></li>
<li><a id="L50">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">rewrite_event</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OID of relation having rules */<br/></li>
<li></span>&nbsp; &nbsp; CmdType&nbsp; &nbsp; &nbsp; &nbsp; event;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* type of rule being fired */<br/></li>
<li><a id="L54">&#x200c;</a></span>} <span class="linkable">rewrite_event</span>;<br/></li>
<li><br/></li>
<li><a id="L56">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">acquireLocksOnSubLinks_context</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; for_execute;&nbsp; &nbsp; <span class="Comment">/* <a href="#L140" title="rewrite/rewriteHandler.c:140">AcquireRewriteLocks</a>' forExecute param */<br/></li>
<li><a id="L59">&#x200c;</a></span>} <span class="linkable">acquireLocksOnSubLinks_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L302" title="rewrite/rewriteHandler.c:302">acquireLocksOnSubLinks</a>(Node *node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L56" title="rewrite/rewriteHandler.c:56">acquireLocksOnSubLinks_context</a> *context);<br/></li>
<li><span class="Type">static</span> Query *<a href="#L343" title="rewrite/rewriteHandler.c:343">rewriteRuleAction</a>(Query *parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query *rule_action,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *rule_qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> rt_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CmdType event,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *returning_flag);<br/></li>
<li><span class="Type">static</span> List *<a href="#L696" title="rewrite/rewriteHandler.c:696">adjustJoinTreeList</a>(Query *parsetree, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> removert, <span class="Type">int</span> rt_index);<br/></li>
<li><span class="Type">static</span> List *<a href="#L758" title="rewrite/rewriteHandler.c:758">rewriteTargetListIU</a>(List *targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CmdType commandType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OverridingKind override,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation target_relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RangeTblEntry *values_rte,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> values_rte_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Bitmapset **unused_values_attrnos);<br/></li>
<li><span class="Type">static</span> TargetEntry *<a href="#L1042" title="rewrite/rewriteHandler.c:1042">process_matched_tle</a>(TargetEntry *src_tle,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *prior_tle,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *attrName);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L1195" title="rewrite/rewriteHandler.c:1195">get_assignment_input</a>(Node *node);<br/></li>
<li><span class="Type">static</span> Bitmapset *<a href="#L1337" title="rewrite/rewriteHandler.c:1337">findDefaultOnlyColumns</a>(RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1425" title="rewrite/rewriteHandler.c:1425">rewriteValuesRTE</a>(Query *parsetree, RangeTblEntry *rte, <span class="Type">int</span> rti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation target_relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Bitmapset *unused_cols);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1620" title="rewrite/rewriteHandler.c:1620">rewriteValuesRTEToNulls</a>(Query *parsetree, RangeTblEntry *rte);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1899" title="rewrite/rewriteHandler.c:1899">markQueryForLocking</a>(Query *qry, Node *jtnode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LockClauseStrength strength, LockWaitPolicy waitPolicy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> pushedDown);<br/></li>
<li><span class="Type">static</span> List *<a href="#L1658" title="rewrite/rewriteHandler.c:1658">matchLocks</a>(CmdType event, Relation relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> varno, Query *parsetree, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *hasUpdate);<br/></li>
<li><span class="Type">static</span> Query *<a href="#L1994" title="rewrite/rewriteHandler.c:1994">fireRIRrules</a>(Query *parsetree, List *activeRIRs);<br/></li>
<li><span class="Type">static</span> Bitmapset *<a href="#L3010" title="rewrite/rewriteHandler.c:3010">adjust_view_column_set</a>(Bitmapset *cols, List *targetlist);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L140" title="rewrite/rewriteHandler.c:140">AcquireRewriteLocks</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Acquire suitable locks on all the relations mentioned in the Query.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; These locks will ensure that the relation schemas don't change under us<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; while we are rewriting, planning, and executing the query.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caution: this may modify the querytree, therefore caller should usually<br/></li>
<li></span><span class="Comment"> * have done a copyObject() to make a writable copy of the querytree in the<br/></li>
<li></span><span class="Comment"> * current memory context.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * forExecute indicates that the query is about to be executed.&nbsp; If so,<br/></li>
<li></span><span class="Comment"> * we'll acquire the lock modes specified in the RTE rellockmode fields.<br/></li>
<li></span><span class="Comment"> * If forExecute is false, AccessShareLock is acquired on all relations.<br/></li>
<li></span><span class="Comment"> * This case is suitable for ruleutils.c, for example, where we only need<br/></li>
<li></span><span class="Comment"> * schema stability and we don't intend to actually modify <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * forUpdatePushedDown indicates that a pushed-down FOR [<a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>] UPDATE/SHARE<br/></li>
<li></span><span class="Comment"> * applies to the current subquery, requiring all rels to be opened with at<br/></li>
<li></span><span class="Comment"> * least RowShareLock.&nbsp; This should always be false at the top of the<br/></li>
<li></span><span class="Comment"> * recursion.&nbsp; When it is true, we adjust RTE rellockmode fields to reflect<br/></li>
<li></span><span class="Comment"> * the higher lock level.&nbsp; This flag is ignored if forExecute is false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A secondary purpose of this routine is to fix up JOIN RTE references to<br/></li>
<li></span><span class="Comment"> * dropped columns (see details below).&nbsp; Such RTEs are modified in-place.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This processing can, and for efficiency's sake should, be skipped when the<br/></li>
<li></span><span class="Comment"> * querytree has just been built by the parser: <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis already got<br/></li>
<li></span><span class="Comment"> * all the same locks we'd get here, and the parser will have omitted dropped<br/></li>
<li></span><span class="Comment"> * columns from JOINs to begin with.&nbsp; But we must do this whenever we are<br/></li>
<li></span><span class="Comment"> * dealing with a querytree produced earlier than the current command.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * About JOINs and dropped columns: although the parser never includes an<br/></li>
<li></span><span class="Comment"> * already-dropped column in a JOIN RTE's alias var list, it is possible for<br/></li>
<li></span><span class="Comment"> * such a list in a stored rule to include references to dropped columns.<br/></li>
<li></span><span class="Comment"> * (If the column is not explicitly referenced anywhere else in the query,<br/></li>
<li></span><span class="Comment"> * the dependency mechanism won't consider it used by the rule and so won't<br/></li>
<li></span><span class="Comment"> * prevent the column drop.)&nbsp; To support <a href="../parser/parse_relation.c.html#L3291" title="parser/parse_relation.c:3291">get_rte_attribute_is_dropped</a>(), we<br/></li>
<li></span><span class="Comment"> * replace join alias <a href="../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> that reference dropped columns with null pointers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (In PostgreSQL 8.0, we did not do this processing but instead had<br/></li>
<li></span><span class="Comment"> * <a href="../parser/parse_relation.c.html#L3291" title="parser/parse_relation.c:3291">get_rte_attribute_is_dropped</a>() recurse to detect dropped columns in joins.<br/></li>
<li></span><span class="Comment"> * That approach had horrible performance unfortunately; in particular<br/></li>
<li></span><span class="Comment"> * construction of a nested join was O(N^2) in the nesting depth.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L140">&#x200c;</a></span><span class="linkable">AcquireRewriteLocks</span>(Query *parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forExecute,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forUpdatePushedDown)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rt_index;<br/></li>
<li>&nbsp; &nbsp; <a href="#L56" title="rewrite/rewriteHandler.c:56">acquireLocksOnSubLinks_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.for_execute = forExecute;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, process RTEs of the current query level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rt_index = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(l, parsetree-&gt;rtable)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = (RangeTblEntry *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; lockmode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newaliasvars;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; curinputvarno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *curinputrte;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *ll;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ++rt_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (rte-&gt;rtekind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_RELATION:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Grab the appropriate lock type for the relation, and do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * release it until end of transaction.&nbsp; This protects the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rewriter, <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>, and executor against schema changes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mid-query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If forExecute is false, ignore rellockmode and just use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AccessShareLock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!forExecute)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmode = AccessShareLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (forUpdatePushedDown)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Upgrade RTE's lock mode to reflect pushed-down lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rellockmode == AccessShareLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;rellockmode = RowShareLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmode = rte-&gt;rellockmode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockmode = rte-&gt;rellockmode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(rte-&gt;relid, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * While we have the relation open, update the RTE's relkind,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just in case it changed since this rule was made.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;relkind = rel-&gt;rd_rel-&gt;relkind;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_JOIN:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Scan the join's alias var list to see if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> columns have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * been dropped, and if so replace those Vars with null<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since a join has only two inputs, we can expect to see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple references to the same input RTE; <a href="../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> away<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple fetches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newaliasvars = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curinputvarno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curinputrte = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(ll, rte-&gt;joinaliasvars)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *aliasitem = (Var *) lfirst(ll);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *aliasvar = aliasitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Look through <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> implicit coercion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aliasvar = (Var *) <a href="../nodes/nodeFuncs.c.html#L700" title="nodes/nodeFuncs.c:700">strip_implicit_coercions</a>((Node *) aliasvar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the list item isn't a simple Var, then it must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * represent a merged column, ie a USING column, and so it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * couldn't possibly be dropped, since it's referenced in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the join clause.&nbsp; (Conceivably it could also be a null<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointer already?&nbsp; But that's OK too.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aliasvar &amp;&amp; IsA(aliasvar, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The elements of an alias list have to refer to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * earlier RTEs of the same rtable, because that's the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * order the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> builds things in.&nbsp; So we already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processed the referenced RTE, and so it's safe to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use <a href="../parser/parse_relation.c.html#L3291" title="parser/parse_relation.c:3291">get_rte_attribute_is_dropped</a> on it. (This might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not hold after rewriting or planning, but it's OK<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to assume here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(aliasvar-&gt;varlevelsup == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aliasvar-&gt;varno != curinputvarno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curinputvarno = aliasvar-&gt;varno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curinputvarno &gt;= rt_index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected varno </span><span class="Special">%d</span><span class="Constant"> in JOIN RTE </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curinputvarno, rt_index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curinputrte = rt_fetch(curinputvarno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parsetree-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../parser/parse_relation.c.html#L3291" title="parser/parse_relation.c:3291">get_rte_attribute_is_dropped</a>(curinputrte,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; aliasvar-&gt;varattno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Replace the join alias item with a NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aliasitem = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newaliasvars = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newaliasvars, aliasitem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;joinaliasvars = newaliasvars;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_SUBQUERY:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The subquery RTE itself is all right, but we have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recurse to process the represented subquery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="rewrite/rewriteHandler.c:140">AcquireRewriteLocks</a>(rte-&gt;subquery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forExecute,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (forUpdatePushedDown ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../parser/parse_relation.c.html#L3459" title="parser/parse_relation.c:3459">get_parse_rowmark</a>(parsetree, rt_index) != <span class="Constant">NULL</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore other types of RTEs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recurse into subqueries in WITH */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, parsetree-&gt;cteList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CommonTableExpr *cte = (CommonTableExpr *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="rewrite/rewriteHandler.c:140">AcquireRewriteLocks</a>((Query *) cte-&gt;ctequery, forExecute, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recurse into sublink subqueries, too.&nbsp; But we already did the ones in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the rtable and cteList.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;hasSubLinks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query_tree_walker(parsetree, <a href="#L302" title="rewrite/rewriteHandler.c:302">acquireLocksOnSubLinks</a>, &amp;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QTW_IGNORE_RC_SUBQUERIES);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Walker to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> sublink subqueries for <a href="#L140" title="rewrite/rewriteHandler.c:140">AcquireRewriteLocks</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L302">&#x200c;</a></span><span class="linkable">acquireLocksOnSubLinks</span>(Node *node, <a href="#L56" title="rewrite/rewriteHandler.c:56">acquireLocksOnSubLinks_context</a> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, SubLink))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SubLink&nbsp; &nbsp; *sub = (SubLink *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do what we came for */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="rewrite/rewriteHandler.c:140">AcquireRewriteLocks</a>((Query *) sub-&gt;subselect,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;for_execute,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fall through to process lefthand args of SubLink */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do NOT recurse into Query nodes, because <a href="#L140" title="rewrite/rewriteHandler.c:140">AcquireRewriteLocks</a> already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processed subselects of subselects for us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L302" title="rewrite/rewriteHandler.c:302">acquireLocksOnSubLinks</a>, context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L343" title="rewrite/rewriteHandler.c:343">rewriteRuleAction</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Rewrite the rule action with appropriate qualifiers (taken from<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the triggering query).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input arguments:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; parsetree - original query<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rule_action - one action (query) of a rule<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rule_qual - WHERE condition of rule, or NULL if unconditional<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rt_index - RT index of result relation in original query<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; event - type of rule event<br/></li>
<li></span><span class="Comment"> * Output arguments:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *returning_flag - set true if we rewrite RETURNING clause in rule_action<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (must be initialized to false)<br/></li>
<li></span><span class="Comment"> * Return value:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rewritten form of rule_action<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Query *<br/></li>
<li><a id="L343">&#x200c;</a><span class="linkable">rewriteRuleAction</span>(Query *parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query *rule_action,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node *rule_qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> rt_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CmdType event,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *returning_flag)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_varno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_varno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rt_length;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *sub_action;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp; **sub_action_ptr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L56" title="rewrite/rewriteHandler.c:56">acquireLocksOnSubLinks_context</a> context;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.for_execute = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make modifiable copies of rule action and qual (what we're passed are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the stored versions in the relcache; don't touch 'em!).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rule_action = copyObject(rule_action);<br/></li>
<li>&nbsp; &nbsp; rule_qual = copyObject(rule_qual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Acquire necessary locks and fix <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> deleted JOIN RTE entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L140" title="rewrite/rewriteHandler.c:140">AcquireRewriteLocks</a>(rule_action, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L302" title="rewrite/rewriteHandler.c:302">acquireLocksOnSubLinks</a>(rule_qual, &amp;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; current_varno = rt_index;<br/></li>
<li>&nbsp; &nbsp; rt_length = list_length(parsetree-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; new_varno = PRS2_NEW_VARNO + rt_length;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adjust rule action and qual to offset its varnos, so that we can <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its rtable with the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> parsetree's rtable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the rule action is an INSERT...SELECT, the OLD/NEW rtable entries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be in the SELECT part, and we have to modify that rather than the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * top-level INSERT (kluge!).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sub_action = <a href="rewriteManip.c.html#L998" title="rewrite/rewriteManip.c:998">getInsertSelectQuery</a>(rule_action, &amp;sub_action_ptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="rewriteManip.c.html#L480" title="rewrite/rewriteManip.c:480">OffsetVarNodes</a>((Node *) sub_action, rt_length, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="rewriteManip.c.html#L480" title="rewrite/rewriteManip.c:480">OffsetVarNodes</a>(rule_qual, rt_length, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* but references to OLD should point at original rt_index */<br/></li>
<li></span>&nbsp; &nbsp; <a href="rewriteManip.c.html#L674" title="rewrite/rewriteManip.c:674">ChangeVarNodes</a>((Node *) sub_action,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PRS2_OLD_VARNO + rt_length, rt_index, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="rewriteManip.c.html#L674" title="rewrite/rewriteManip.c:674">ChangeVarNodes</a>(rule_qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PRS2_OLD_VARNO + rt_length, rt_index, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subquery RTEs in the rule action as LATERAL if they contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Vars referring to the current query level (references to NEW/OLD).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Those really are lateral references, but we've historically not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * required users to mark such subqueries with LATERAL explicitly.&nbsp; But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> will complain if such Vars exist in a non-LATERAL subquery,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so we have to fix things up here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, sub_action-&gt;rtable)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_SUBQUERY &amp;&amp; !rte-&gt;lateral &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../optimizer/util/var.c.html#L441" title="optimizer/util/var.c:441">contain_vars_of_level</a>((Node *) rte-&gt;subquery, <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;lateral = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate expanded rtable consisting of <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> parsetree's rtable plus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rule action's rtable; this becomes the complete rtable for the rule<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * action.&nbsp; Some of the entries may be unused after we finish rewriting,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but we leave them all in place to avoid having to adjust the query's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * varnos.&nbsp; RT entries that are not referenced in the completed jointree<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be ignored by the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>, so they do not affect query semantics.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> RTEPermissionInfo lists to ensure that all permissions are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checked correctly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the rule is INSTEAD, then the original query won't be executed at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all, and so its rteperminfos must be preserved so that the executor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will do the correct permissions checks on the relations referenced in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it. This allows us to check that the caller has, say, insert-permission<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on a view, when the view is not semantically referenced at all in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * resulting query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When a rule is not INSTEAD, the permissions checks done using the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copied entries will be redundant with those done during execution of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the original query, but we don't bother to treat that case differently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: because <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> will destructively alter rtable and rteperminfos,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we must ensure that rule action's lists are separate and shares no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * substructure with the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> query's lists.&nbsp; Hence do a deep copy here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for both.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rtable_tail = sub_action-&gt;rtable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *perminfos_tail = sub_action-&gt;rteperminfos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3825" title="rewrite/rewriteHandler.c:3825">RewriteQuery</a> relies on the fact that RT entries from the original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query appear at the start of the expanded rtable, so we put the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * action's original table at the end of the list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sub_action-&gt;rtable = copyObject(parsetree-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sub_action-&gt;rteperminfos = copyObject(parsetree-&gt;rteperminfos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="rewriteManip.c.html#L350" title="rewrite/rewriteManip.c:350">CombineRangeTables</a>(&amp;sub_action-&gt;rtable, &amp;sub_action-&gt;rteperminfos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rtable_tail, perminfos_tail);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There could have been some SubLinks in parsetree's rtable, in which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case we'd better mark the sub_action correctly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;hasSubLinks &amp;&amp; !sub_action-&gt;hasSubLinks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, parsetree-&gt;rtable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (rte-&gt;rtekind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_action-&gt;hasSubLinks =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rewriteManip.c.html#L295" title="rewrite/rewriteManip.c:295">checkExprHasSubLink</a>((Node *) rte-&gt;tablesample);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_FUNCTION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_action-&gt;hasSubLinks =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rewriteManip.c.html#L295" title="rewrite/rewriteManip.c:295">checkExprHasSubLink</a>((Node *) rte-&gt;<a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_TABLEFUNC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_action-&gt;hasSubLinks =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rewriteManip.c.html#L295" title="rewrite/rewriteManip.c:295">checkExprHasSubLink</a>((Node *) rte-&gt;tablefunc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_VALUES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_action-&gt;hasSubLinks =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rewriteManip.c.html#L295" title="rewrite/rewriteManip.c:295">checkExprHasSubLink</a>((Node *) rte-&gt;values_lists);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* other RTE types don't contain bare expressions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_action-&gt;hasSubLinks |=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rewriteManip.c.html#L295" title="rewrite/rewriteManip.c:295">checkExprHasSubLink</a>((Node *) rte-&gt;securityQuals);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sub_action-&gt;hasSubLinks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no need to keep scanning rtable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, we might have absorbed some RTEs with RLS conditions into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sub_action.&nbsp; If so, mark it as hasRowSecurity, whether or not those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RTEs will be referenced after we finish rewriting.&nbsp; (Note: currently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this is a no-op because RLS conditions aren't added till later, but it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seems like good future-proofing to do this anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sub_action-&gt;hasRowSecurity |= parsetree-&gt;hasRowSecurity;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Each rule action's jointree should be the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> parsetree's jointree<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plus that rule's jointree, but usually *without* the original rtindex<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we're replacing (if present, which it won't be for INSERT). Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that if the rule action refers to OLD, its jointree will add a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reference to rt_index.&nbsp; If the rule action doesn't refer to OLD, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either the rule_qual or the user query quals do, then we need to keep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the original rtindex in the jointree to provide data for the quals.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't want the original rtindex to be joined twice, however, so avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keeping it if the rule action mentions it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As above, the action's jointree must not share substructure with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> parsetree's.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sub_action-&gt;commandType != CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; keeporig;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newjointree;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(sub_action-&gt;jointree != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; keeporig = (!<a href="rewriteManip.c.html#L966" title="rewrite/rewriteManip.c:966">rangeTableEntry_used</a>((Node *) sub_action-&gt;jointree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rt_index, <span class="Constant">0</span>)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="rewriteManip.c.html#L966" title="rewrite/rewriteManip.c:966">rangeTableEntry_used</a>(rule_qual, rt_index, <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="rewriteManip.c.html#L966" title="rewrite/rewriteManip.c:966">rangeTableEntry_used</a>(parsetree-&gt;jointree-&gt;quals, rt_index, <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newjointree = <a href="#L696" title="rewrite/rewriteHandler.c:696">adjustJoinTreeList</a>(parsetree, !keeporig, rt_index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newjointree != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If sub_action is a setop, manipulating its jointree will do no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * good at all, because the jointree is dummy.&nbsp; (Perhaps someday<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we could <a href="../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> the joining and quals down to the member<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * statements of the setop?)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sub_action-&gt;setOperations != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conditional UNION/INTERSECT/EXCEPT statements are not implemented&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_action-&gt;jointree-&gt;fromlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(newjointree, sub_action-&gt;jointree-&gt;fromlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There could have been some SubLinks in newjointree, in which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case we'd better mark the sub_action correctly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;hasSubLinks &amp;&amp; !sub_action-&gt;hasSubLinks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_action-&gt;hasSubLinks =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rewriteManip.c.html#L295" title="rewrite/rewriteManip.c:295">checkExprHasSubLink</a>((Node *) newjointree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the original query has <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> CTEs, copy them into the rule action. But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we don't need them for a utility action.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;cteList != NIL &amp;&amp; sub_action-&gt;commandType != CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Annoying implementation restriction: because CTEs are identified by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * name within a cteList, we can't <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> a CTE from the original query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if it has the same name as <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> CTE in the rule action.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This could possibly be fixed by using some sort of internally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generated ID, instead of names, to link CTE RTEs to their CTEs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, decompiling the results would be quite confusing; note the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> of hasRecursive flags below, which could change the apparent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * semantics of such redundantly-named CTEs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, parsetree-&gt;cteList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommonTableExpr *cte = (CommonTableExpr *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, sub_action-&gt;cteList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommonTableExpr *cte2 = (CommonTableExpr *) lfirst(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(cte-&gt;ctename, cte2-&gt;ctename) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;WITH query name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> appears in both a rule action and the query being rewritten&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;ctename)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, it's safe to <a href="../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> the CTE lists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sub_action-&gt;cteList = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(sub_action-&gt;cteList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; copyObject(parsetree-&gt;cteList));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and don't forget about the associated flags */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sub_action-&gt;hasRecursive |= parsetree-&gt;hasRecursive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sub_action-&gt;hasModifyingCTE |= parsetree-&gt;hasModifyingCTE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If rule_action is different from sub_action (i.e., the rule action<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is an INSERT...SELECT), then we might have just added some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * data-modifying CTEs that are not at the top query level.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * disallowed by the parser and we mustn't generate such trees here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either, so throw an error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Conceivably such cases could be supported by attaching the original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query's CTEs to rule_action not sub_action.&nbsp; But to do that, we'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to increment ctelevelsup in RTEs and SubLinks copied from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original query.&nbsp; For <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, it doesn't seem worth the trouble.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sub_action-&gt;hasModifyingCTE &amp;&amp; rule_action != sub_action)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;INSERT ... SELECT rule actions are not supported for queries having data-modifying statements in WITH&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Event Qualification forces copying of parsetree and splitting into two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * queries one w/rule_qual, one w/NOT rule_qual. Also add user query qual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * onto rule action<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="rewriteManip.c.html#L1056" title="rewrite/rewriteManip.c:1056">AddQual</a>(sub_action, rule_qual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="rewriteManip.c.html#L1056" title="rewrite/rewriteManip.c:1056">AddQual</a>(sub_action, parsetree-&gt;jointree-&gt;quals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Rewrite new.attribute with right hand side of target-list entry for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appropriate field name in insert/update.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * KLUGE ALERT: since <a href="rewriteManip.c.html#L1769" title="rewrite/rewriteManip.c:1769">ReplaceVarsFromTargetList</a> returns a mutated copy, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't just apply it to sub_action; we have to remember to update the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sublink inside rule_action, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((event == CMD_INSERT || event == CMD_UPDATE) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sub_action-&gt;commandType != CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sub_action = (Query *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rewriteManip.c.html#L1769" title="rewrite/rewriteManip.c:1769">ReplaceVarsFromTargetList</a>((Node *) sub_action,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_varno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rt_fetch(new_varno, sub_action-&gt;rtable),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (event == CMD_UPDATE) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; REPLACEVARS_CHANGE_VARNO :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; REPLACEVARS_SUBSTITUTE_NULL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_varno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sub_action_ptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *sub_action_ptr = sub_action;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rule_action = sub_action;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If rule_action has a RETURNING clause, then either throw it away if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * triggering query has no RETURNING clause, or rewrite it to emit what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the triggering query's RETURNING clause asks for.&nbsp; Throw an error if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more than one rule has a RETURNING clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!parsetree-&gt;returningList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rule_action-&gt;returningList = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rule_action-&gt;returningList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*returning_flag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot have RETURNING lists in multiple rules&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *returning_flag = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rule_action-&gt;returningList = (List *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rewriteManip.c.html#L1769" title="rewrite/rewriteManip.c:1769">ReplaceVarsFromTargetList</a>((Node *) parsetree-&gt;returningList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;resultRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rt_fetch(parsetree-&gt;resultRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parsetree-&gt;rtable),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rule_action-&gt;returningList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; REPLACEVARS_REPORT_ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;rule_action-&gt;hasSubLinks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There could have been some SubLinks in parsetree's returningList,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in which case we'd better mark the rule_action correctly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;hasSubLinks &amp;&amp; !rule_action-&gt;hasSubLinks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rule_action-&gt;hasSubLinks =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rewriteManip.c.html#L295" title="rewrite/rewriteManip.c:295">checkExprHasSubLink</a>((Node *) rule_action-&gt;returningList);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rule_action;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy the query's jointree list, and optionally attempt to remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * occurrence of the given rt_index as a top-level join item (we do not look<br/></li>
<li></span><span class="Comment"> * for it within join items; this is OK because we are only expecting to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment"> * it as an UPDATE or DELETE target relation, which will be at the top level<br/></li>
<li></span><span class="Comment"> * of the join).&nbsp; Returns modified jointree list --- this is a separate copy<br/></li>
<li></span><span class="Comment"> * sharing no nodes with the original.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L696">&#x200c;</a><span class="linkable">adjustJoinTreeList</span>(Query *parsetree, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> removert, <span class="Type">int</span> rt_index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newjointree = copyObject(parsetree-&gt;jointree-&gt;fromlist);<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (removert)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, newjointree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblRef *rtr = lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(rtr, RangeTblRef) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtr-&gt;rtindex == rt_index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newjointree = foreach_delete_current(newjointree, l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newjointree;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L758" title="rewrite/rewriteHandler.c:758">rewriteTargetListIU</a> - rewrite INSERT/UPDATE targetlist into standard form<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This has the following responsibilities:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1. For an INSERT, add tlist entries to compute default <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * attributes that have defaults and are not assigned to in the given tlist.<br/></li>
<li></span><span class="Comment"> * (We do not insert anything for default-less attributes, however.&nbsp; The<br/></li>
<li></span><span class="Comment"> * <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> will later insert NULLs for them, but there's no reason to slow<br/></li>
<li></span><span class="Comment"> * down rewriter processing with extra tlist nodes.)&nbsp; Also, for both INSERT<br/></li>
<li></span><span class="Comment"> * and UPDATE, replace explicit DEFAULT specifications with column default<br/></li>
<li></span><span class="Comment"> * expressions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 2. Merge multiple entries for the same target attribute, or declare error<br/></li>
<li></span><span class="Comment"> * if we can't.&nbsp; Multiple entries are only allowed for INSERT/UPDATE of<br/></li>
<li></span><span class="Comment"> * portions of an array or record field, for example<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UPDATE table <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> foo[2] = 42, foo[4] = 43;<br/></li>
<li></span><span class="Comment"> * We can <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> such operations into a single assignment op.&nbsp; Essentially,<br/></li>
<li></span><span class="Comment"> * the expression we want to produce in this case is like<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; foo = <a href="../utils/adt/arrayfuncs.c.html#L2201" title="utils/adt/arrayfuncs.c:2201">array_set_element</a>(<a href="../utils/adt/arrayfuncs.c.html#L2201" title="utils/adt/arrayfuncs.c:2201">array_set_element</a>(foo, 2, 42), 4, 43)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 3. Sort the tlist into standard order: non-junk fields in order by resno,<br/></li>
<li></span><span class="Comment"> * then junk fields (these in no particular order).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We must do items 1 and 2 <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> firing rewrite rules, else rewritten<br/></li>
<li></span><span class="Comment"> * references to NEW.foo will produce wrong or incomplete results.&nbsp; Item 3<br/></li>
<li></span><span class="Comment"> * is not needed for rewriting, but it is helpful for the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>, and we<br/></li>
<li></span><span class="Comment"> * can do it essentially for free while handling the other items.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If values_rte is non-NULL (i.e., we are doing a multi-row INSERT using<br/></li>
<li></span><span class="Comment"> * <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> from a VALUES RTE), we populate *unused_values_attrnos with the<br/></li>
<li></span><span class="Comment"> * attribute numbers of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unused columns from the VALUES RTE.&nbsp; This can<br/></li>
<li></span><span class="Comment"> * happen for identity and generated columns whose targetlist entries are<br/></li>
<li></span><span class="Comment"> * replaced with generated expressions (if INSERT ... OVERRIDING USER VALUE is<br/></li>
<li></span><span class="Comment"> * used, or all the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to be inserted are DEFAULT).&nbsp; This information is<br/></li>
<li></span><span class="Comment"> * required by <a href="#L1425" title="rewrite/rewriteHandler.c:1425">rewriteValuesRTE</a>() to handle <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> DEFAULT items in the unused<br/></li>
<li></span><span class="Comment"> * columns.&nbsp; The caller must have initialized *unused_values_attrnos to NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L758">&#x200c;</a><span class="linkable">rewriteTargetListIU</span>(List *targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CmdType commandType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OverridingKind override,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation target_relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *values_rte,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> values_rte_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset **unused_values_attrnos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TargetEntry **new_tles;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *new_tlist = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *junk_tlist = NIL;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute att_tup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_junk_attrno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numattrs;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *temp;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *default_only_cols = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We process the normal (non-junk) attributes by scanning the input tlist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * once and transferring TLEs into an array, then scanning the array to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * build an output tlist.&nbsp; This avoids O(N^2) behavior for large numbers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of attributes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Junk attributes are tossed into a separate list during the same tlist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan, then appended to the reconstructed tlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; numattrs = RelationGetNumberOfAttributes(target_relation);<br/></li>
<li>&nbsp; &nbsp; new_tles = (TargetEntry **) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(numattrs * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TargetEntry *));<br/></li>
<li>&nbsp; &nbsp; next_junk_attrno = numattrs + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(temp, targetList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *old_tle = (TargetEntry *) lfirst(temp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!old_tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Normal attr: stash it into new_tles[] */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrno = old_tle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attrno &lt; <span class="Constant">1</span> || attrno &gt; numattrs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;bogus resno </span><span class="Special">%d</span><span class="Constant"> in targetlist&quot;</span>, attrno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att_tup = TupleDescAttr(target_relation-&gt;rd_att, attrno - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can (and must) ignore deleted attributes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att_tup-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Merge with <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> prior assignment to same attribute */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_tles[attrno - <span class="Constant">1</span>] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1042" title="rewrite/rewriteHandler.c:1042">process_matched_tle</a>(old_tle,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_tles[attrno - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(att_tup-&gt;attname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy all resjunk tlist entries to junk_tlist, and assign them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * resnos above the last real resno.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Typical junk entries include ORDER BY or GROUP BY expressions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (are these actually possible in an INSERT or UPDATE?), system<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attribute references, etc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the resno right, but don't copy unnecessarily */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_tle-&gt;resno != next_junk_attrno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_tle = <a href="../nodes/makefuncs.c.html#L273" title="nodes/makefuncs.c:273">flatCopyTargetEntry</a>(old_tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_tle-&gt;resno = next_junk_attrno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; junk_tlist = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(junk_tlist, old_tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_junk_attrno++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (attrno = <span class="Constant">1</span>; attrno &lt;= numattrs; attrno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *new_tle = new_tles[attrno - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; apply_default;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att_tup = TupleDescAttr(target_relation-&gt;rd_att, attrno - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can (and must) ignore deleted attributes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att_tup-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Handle the two cases where we need to insert a default expression:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's an INSERT and there's no tlist entry for the column, or the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tlist entry is a DEFAULT placeholder node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; apply_default = ((new_tle == <span class="Constant">NULL</span> &amp;&amp; commandType == CMD_INSERT) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (new_tle &amp;&amp; new_tle-&gt;expr &amp;&amp; IsA(new_tle-&gt;expr, SetToDefault)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (commandType == CMD_INSERT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; values_attrno = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Source attribute number for <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that come from a VALUES RTE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (values_rte &amp;&amp; new_tle &amp;&amp; IsA(new_tle-&gt;expr, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) new_tle-&gt;expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varno == values_rte_index)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; values_attrno = var-&gt;varattno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Can only insert DEFAULT into GENERATED ALWAYS identity columns,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unless either OVERRIDING USER VALUE or OVERRIDING SYSTEM VALUE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is specified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att_tup-&gt;attidentity == ATTRIBUTE_IDENTITY_ALWAYS &amp;&amp; !apply_default)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (override == OVERRIDING_USER_VALUE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apply_default = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (override != OVERRIDING_SYSTEM_VALUE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this column's <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> come from a VALUES RTE, test<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether it contains only SetToDefault items.&nbsp; Since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * VALUES list might be quite large, we arrange to only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan it once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (values_attrno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (default_only_cols == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default_only_cols = <a href="#L1337" title="rewrite/rewriteHandler.c:1337">findDefaultOnlyColumns</a>(values_rte);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(values_attrno, default_only_cols))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apply_default = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!apply_default)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_GENERATED_ALWAYS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot insert a non-DEFAULT value into column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(att_tup-&gt;attname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is an identity column defined as GENERATED ALWAYS.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(att_tup-&gt;attname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use OVERRIDING SYSTEM VALUE to override.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Although inserting into a GENERATED BY DEFAULT identity column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is allowed, apply the default if OVERRIDING USER VALUE is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * specified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att_tup-&gt;attidentity == ATTRIBUTE_IDENTITY_BY_DEFAULT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; override == OVERRIDING_USER_VALUE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apply_default = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Can only insert DEFAULT into generated columns, regardless of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> OVERRIDING clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att_tup-&gt;attgenerated &amp;&amp; !apply_default)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this column's <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> come from a VALUES RTE, test<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether it contains only SetToDefault items, as above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (values_attrno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (default_only_cols == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default_only_cols = <a href="#L1337" title="rewrite/rewriteHandler.c:1337">findDefaultOnlyColumns</a>(values_rte);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(values_attrno, default_only_cols))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; apply_default = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!apply_default)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_GENERATED_ALWAYS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot insert a non-DEFAULT value into column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(att_tup-&gt;attname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is a generated column.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(att_tup-&gt;attname))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For an INSERT from a VALUES RTE, return the attribute numbers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> VALUES columns that will no longer be used (due to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * targetlist entry being replaced by a default expression).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (values_attrno != <span class="Constant">0</span> &amp;&amp; apply_default &amp;&amp; unused_values_attrnos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *unused_values_attrnos = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(*unused_values_attrnos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; values_attrno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Updates to identity and generated columns follow the same rules as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * above, except that UPDATE doesn't admit OVERRIDING clauses.&nbsp; Also,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the source can't be a VALUES RTE, so we needn't consider that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (commandType == CMD_UPDATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att_tup-&gt;attidentity == ATTRIBUTE_IDENTITY_ALWAYS &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_tle &amp;&amp; !apply_default)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_GENERATED_ALWAYS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> can only be updated to DEFAULT&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(att_tup-&gt;attname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is an identity column defined as GENERATED ALWAYS.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(att_tup-&gt;attname))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att_tup-&gt;attgenerated &amp;&amp; new_tle &amp;&amp; !apply_default)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_GENERATED_ALWAYS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> can only be updated to DEFAULT&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(att_tup-&gt;attname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is a generated column.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(att_tup-&gt;attname))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att_tup-&gt;attgenerated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stored generated column will be fixed in executor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_tle = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (apply_default)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *new_expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_expr = <a href="#L1224" title="rewrite/rewriteHandler.c:1224">build_column_default</a>(target_relation, attrno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there is no default (ie, default is effectively NULL), we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can omit the tlist entry in the INSERT case, since the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can insert a NULL for itself, and there's no point in spending<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more rewriter cycles on the entry.&nbsp; But in the UPDATE case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we've got to explicitly set the column to NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!new_expr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (commandType == CMD_INSERT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_tle = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_expr = (Node *) <a href="../nodes/makefuncs.c.html#L301" title="nodes/makefuncs.c:301">makeConst</a>(att_tup-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att_tup-&gt;attcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att_tup-&gt;attlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Comment">/* isnull */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att_tup-&gt;attbyval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this is to catch a NOT NULL domain constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_expr = <a href="../parser/parse_coerce.c.html#L676" title="parser/parse_coerce.c:676">coerce_to_domain</a>(new_expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att_tup-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCION_IMPLICIT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCE_IMPLICIT_CAST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_expr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_tle = <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) new_expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(att_tup-&gt;attname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_tle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_tlist = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(new_tlist, new_tle);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(new_tles);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(new_tlist, junk_tlist);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a matched TLE from the original tlist into a correct new TLE.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine detects and handles multiple assignments to the same target<br/></li>
<li></span><span class="Comment"> * attribute.&nbsp; (The attribute name is needed only for error messages.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TargetEntry *<br/></li>
<li><a id="L1042">&#x200c;</a><span class="linkable">process_matched_tle</span>(TargetEntry *src_tle,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *prior_tle,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *attrName)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TargetEntry *result;<br/></li>
<li>&nbsp; &nbsp; CoerceToDomain *coerce_expr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *src_expr;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *prior_expr;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *src_input;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *prior_input;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *priorbottom;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *newexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prior_tle == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normal case where this is the first assignment to the attribute.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> src_tle;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Multiple assignments to same attribute.&nbsp; Allow only if all are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FieldStore or SubscriptingRef assignment operations.&nbsp; This is a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tricky because what we may actually be looking at is a nest of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * such nodes; consider<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; UPDATE tab <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> col.fld1.subfld1 = x, col.fld2.subfld2 = y<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The two expressions produced by the parser will look like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; FieldStore(col, fld1, FieldStore(placeholder, subfld1, x))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; FieldStore(col, fld2, FieldStore(placeholder, subfld2, y))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, we can ignore the substructure and just consider the top<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FieldStore or SubscriptingRef from each assignment, because it works to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> these as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; FieldStore(FieldStore(col, fld1,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FieldStore(placeholder, subfld1, x)),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fld2, FieldStore(placeholder, subfld2, y))<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note the leftmost expression goes on the inside so that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assignments appear to occur left-to-right.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For FieldStore, instead of nesting we can generate a single<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FieldStore with multiple target fields.&nbsp; We must nest when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SubscriptingRefs are involved though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As a further complication, the destination column might be a domain,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * resulting in each assignment containing a CoerceToDomain node over a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FieldStore or SubscriptingRef.&nbsp; These should have matching target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * domains, so we strip them and reconstitute a single CoerceToDomain over<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the combined FieldStore/SubscriptingRef nodes.&nbsp; (Notice that this has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the result that the domain's checks are applied only after we do all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the field or <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> updates, not after each one.&nbsp; This is desirable.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; src_expr = (Node *) src_tle-&gt;expr;<br/></li>
<li>&nbsp; &nbsp; prior_expr = (Node *) prior_tle-&gt;expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (src_expr &amp;&amp; IsA(src_expr, CoerceToDomain) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prior_expr &amp;&amp; IsA(prior_expr, CoerceToDomain) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((CoerceToDomain *) src_expr)-&gt;resulttype ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((CoerceToDomain *) prior_expr)-&gt;resulttype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we assume without checking that resulttypmod/resultcollid match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; coerce_expr = (CoerceToDomain *) src_expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; src_expr = (Node *) ((CoerceToDomain *) src_expr)-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prior_expr = (Node *) ((CoerceToDomain *) prior_expr)-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; src_input = <a href="#L1195" title="rewrite/rewriteHandler.c:1195">get_assignment_input</a>(src_expr);<br/></li>
<li>&nbsp; &nbsp; prior_input = <a href="#L1195" title="rewrite/rewriteHandler.c:1195">get_assignment_input</a>(prior_expr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (src_input == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prior_input == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(src_expr) != <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(prior_expr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;multiple assignments to same column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prior TLE could be a nest of assignments if we do this more than once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; priorbottom = prior_input;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *newbottom = <a href="#L1195" title="rewrite/rewriteHandler.c:1195">get_assignment_input</a>(priorbottom);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newbottom == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found the original Var reference */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; priorbottom = newbottom;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(priorbottom, src_input))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;multiple assignments to same column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Looks OK to nest 'em.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(src_expr, FieldStore))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FieldStore *fstore = makeNode(FieldStore);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(prior_expr, FieldStore))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> the two */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(fstore, prior_expr, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FieldStore));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fstore-&gt;newvals =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L598" title="nodes/list.c:598">list_concat_copy</a>(((FieldStore *) prior_expr)-&gt;newvals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((FieldStore *) src_expr)-&gt;newvals);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fstore-&gt;fieldnums =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L598" title="nodes/list.c:598">list_concat_copy</a>(((FieldStore *) prior_expr)-&gt;fieldnums,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((FieldStore *) src_expr)-&gt;fieldnums);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* general case, just nest 'em */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(fstore, src_expr, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FieldStore));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fstore-&gt;arg = (Expr *) prior_expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newexpr = (Node *) fstore;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(src_expr, SubscriptingRef))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SubscriptingRef *sbsref = makeNode(SubscriptingRef);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(sbsref, src_expr, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SubscriptingRef));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sbsref-&gt;refexpr = (Expr *) prior_expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newexpr = (Node *) sbsref;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot happen&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newexpr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (coerce_expr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* put back the CoerceToDomain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CoerceToDomain *newcoerce = makeNode(CoerceToDomain);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(newcoerce, coerce_expr, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CoerceToDomain));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newcoerce-&gt;arg = (Expr *) newexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newexpr = (Node *) newcoerce;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../nodes/makefuncs.c.html#L273" title="nodes/makefuncs.c:273">flatCopyTargetEntry</a>(src_tle);<br/></li>
<li>&nbsp; &nbsp; result-&gt;expr = (Expr *) newexpr;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If node is an assignment node, return its input; else return NULL<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L1195">&#x200c;</a><span class="linkable">get_assignment_input</span>(Node *node)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, FieldStore))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FieldStore *fstore = (FieldStore *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) fstore-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(node, SubscriptingRef))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SubscriptingRef *sbsref = (SubscriptingRef *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sbsref-&gt;refassgnexpr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) sbsref-&gt;refexpr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make an expression tree for the default value for a column.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there is no default, return a NULL instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Node *<br/></li>
<li><a id="L1224">&#x200c;</a><span class="linkable">build_column_default</span>(Relation rel, <span class="Type">int</span> attrno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; rd_att = rel-&gt;rd_att;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute att_tup = TupleDescAttr(rd_att, attrno - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atttype = att_tup-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; atttypmod = att_tup-&gt;atttypmod;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *expr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exprtype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (att_tup-&gt;attidentity)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; NextValueExpr *nve = makeNode(NextValueExpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reloid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The identity sequence is associated with the topmost partitioned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relispartition)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *ancestors =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/partition.c.html#L134" title="catalog/partition.c:134">get_partition_ancestors</a>(RelationGetRelid(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reloid = llast_oid(ancestors);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(ancestors);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reloid = RelationGetRelid(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nve-&gt;seqid = <a href="../catalog/pg_depend.c.html#L944" title="catalog/pg_depend.c:944">getIdentitySequence</a>(reloid, attrno, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nve-&gt;typeId = att_tup-&gt;atttypid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) nve;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If relation has a default for this column, fetch that expression.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (att_tup-&gt;atthasdef)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expr = <a href="../access/common/tupdesc.c.html#L899" title="access/common/tupdesc.c:899">TupleDescGetDefault</a>(rd_att, attrno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;default expression not found for attribute </span><span class="Special">%d</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attrno, RelationGetRelationName(rel));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No per-column default, so look for a default for the type itself.&nbsp; But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not for generated columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (expr == <span class="Constant">NULL</span> &amp;&amp; !att_tup-&gt;attgenerated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expr = <a href="../utils/cache/lsyscache.c.html#L2448" title="utils/cache/lsyscache.c:2448">get_typdefault</a>(atttype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (expr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No default anywhere */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure the value is coerced to the target column type; this will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generally be true already, but there seem to be some corner cases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * involving domain defaults where it might not be true. This should match<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the parser's processing of non-defaulted expressions --- see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../parser/parse_target.c.html#L452" title="parser/parse_target.c:452">transformAssignedExpr</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; exprtype = <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; expr = <a href="../parser/parse_coerce.c.html#L78" title="parser/parse_coerce.c:78">coerce_to_target_type</a>(<span class="Constant">NULL</span>,&nbsp; &nbsp; <span class="Comment">/* no UNKNOWN params here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; expr, exprtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; atttype, atttypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; COERCION_ASSIGNMENT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; COERCE_IMPLICIT_CAST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (expr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is of type </span><span class="Special">%s</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; but default expression is of type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(att_tup-&gt;attname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(atttype),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(exprtype)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You will need to rewrite or cast the expression.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> expr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Does VALUES RTE contain <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SetToDefault items? */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1311">&#x200c;</a></span><span class="linkable">searchForDefault</span>(RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, rte-&gt;values_lists)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sublist = (List *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, sublist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *col = (Node *) lfirst(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(col, SetToDefault))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Search a VALUES RTE for columns that contain only SetToDefault items,<br/></li>
<li></span><span class="Comment"> * returning a Bitmapset containing the attribute numbers of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such columns.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Bitmapset *<br/></li>
<li><a id="L1337">&#x200c;</a><span class="linkable">findDefaultOnlyColumns</span>(RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *default_only_cols = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, rte-&gt;values_lists)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sublist = (List *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (default_only_cols == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Populate the initial result bitmap from the first row */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, sublist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *col = (Node *) lfirst(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(col, SetToDefault))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default_only_cols = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(default_only_cols, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update the result bitmap from this <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> row */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, sublist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *col = (Node *) lfirst(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(col, SetToDefault))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; default_only_cols = <a href="../nodes/bitmapset.c.html#L868" title="nodes/bitmapset.c:868">bms_del_member</a>(default_only_cols, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If no column in the rows read so far contains only DEFAULT items,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we are done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bms_is_empty(default_only_cols))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> default_only_cols;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When processing INSERT ... VALUES with a VALUES RTE (ie, multiple VALUES<br/></li>
<li></span><span class="Comment"> * lists), we have to replace <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> DEFAULT items in the VALUES lists with<br/></li>
<li></span><span class="Comment"> * the appropriate default expressions.&nbsp; The other aspects of targetlist<br/></li>
<li></span><span class="Comment"> * rewriting need be applied only to the query's targetlist proper.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For an auto-updatable view, each DEFAULT item in the VALUES list is<br/></li>
<li></span><span class="Comment"> * replaced with the default from the view, if it has one.&nbsp; Otherwise it is<br/></li>
<li></span><span class="Comment"> * left untouched so that the underlying base relation's default can be<br/></li>
<li></span><span class="Comment"> * applied instead (when we later recurse to here after rewriting the query<br/></li>
<li></span><span class="Comment"> * to refer to the base relation instead of the view).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For other types of relation, including rule- and <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-updatable views,<br/></li>
<li></span><span class="Comment"> * all DEFAULT items are replaced, and if the target relation doesn't have a<br/></li>
<li></span><span class="Comment"> * default, the value is explicitly set to NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also, if a DEFAULT item is found in a column mentioned in unused_cols,<br/></li>
<li></span><span class="Comment"> * it is explicitly set to NULL.&nbsp; This happens for columns in the VALUES RTE<br/></li>
<li></span><span class="Comment"> * whose corresponding targetlist entries have already been replaced with the<br/></li>
<li></span><span class="Comment"> * relation's default expressions, so that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in those columns of the<br/></li>
<li></span><span class="Comment"> * VALUES RTE are no longer used.&nbsp; This can happen for identity and generated<br/></li>
<li></span><span class="Comment"> * columns (if INSERT ... OVERRIDING USER VALUE is used, or all the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to<br/></li>
<li></span><span class="Comment"> * be inserted are DEFAULT).&nbsp; In principle we could replace all entries in<br/></li>
<li></span><span class="Comment"> * such a column with NULL, whether DEFAULT or not; but it doesn't seem worth<br/></li>
<li></span><span class="Comment"> * the trouble.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we may have subscripted or field assignment targetlist entries,<br/></li>
<li></span><span class="Comment"> * as well as more complex expressions from already-replaced DEFAULT items if<br/></li>
<li></span><span class="Comment"> * we have recursed to here for an auto-updatable view. However, it ought to<br/></li>
<li></span><span class="Comment"> * be impossible for such entries to have DEFAULTs assigned to them, except<br/></li>
<li></span><span class="Comment"> * for unused columns, as described above --- we should only have to replace<br/></li>
<li></span><span class="Comment"> * DEFAULT items for targetlist entries that contain simple Vars referencing<br/></li>
<li></span><span class="Comment"> * the VALUES RTE, or which are no longer referred to by the targetlist.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if all DEFAULT items were replaced, and false if some were<br/></li>
<li></span><span class="Comment"> * left untouched.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1425">&#x200c;</a></span><span class="linkable">rewriteValuesRTE</span>(Query *parsetree, RangeTblEntry *rte, <span class="Type">int</span> rti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation target_relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Bitmapset *unused_cols)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newValues;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isAutoUpdatableView;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; allReplaced;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numattrs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *attrnos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Steps below are not sensible for non-INSERT queries */<br/></li>
<li></span>&nbsp; &nbsp; Assert(parsetree-&gt;commandType == CMD_INSERT);<br/></li>
<li>&nbsp; &nbsp; Assert(rte-&gt;rtekind == RTE_VALUES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Rebuilding all the lists is a pretty expensive proposition in a big<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * VALUES list, and it's a waste of time if there aren't <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> DEFAULT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * placeholders.&nbsp; So first scan to see if there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1311" title="rewrite/rewriteHandler.c:1311">searchForDefault</a>(rte))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan the targetlist for entries referring to the VALUES RTE, and note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the target attributes. As noted above, we should only need to do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for targetlist entries containing simple Vars --- nothing else in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * VALUES RTE should contain DEFAULT items (except possibly for unused<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * columns), and we complain if such a thing does occur.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; numattrs = list_length(linitial(rte-&gt;values_lists));<br/></li>
<li>&nbsp; &nbsp; attrnos = (<span class="Type">int</span> *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(numattrs * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, parsetree-&gt;targetList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(tle-&gt;expr, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) tle-&gt;expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varno == rti)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrno = var-&gt;varattno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(attrno &gt;= <span class="Constant">1</span> &amp;&amp; attrno &lt;= numattrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrnos[attrno - <span class="Constant">1</span>] = tle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if the target relation is an auto-updatable view, in which case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unresolved defaults will be left untouched rather than being set to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; isAutoUpdatableView = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (target_relation-&gt;rd_rel-&gt;relkind == RELKIND_VIEW &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L2486" title="rewrite/rewriteHandler.c:2486">view_has_instead_trigger</a>(target_relation, CMD_INSERT, NIL))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *locks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasUpdate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Look for an unconditional DO INSTEAD rule */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; locks = <a href="#L1658" title="rewrite/rewriteHandler.c:1658">matchLocks</a>(CMD_INSERT, target_relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parsetree-&gt;resultRelation, parsetree, &amp;hasUpdate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, locks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RewriteRule *rule_lock = (RewriteRule *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rule_lock-&gt;isInstead &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rule_lock-&gt;qual == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we didn't <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an unconditional DO INSTEAD rule, assume that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * view is auto-updatable.&nbsp; If it isn't, <a href="#L3179" title="rewrite/rewriteHandler.c:3179">rewriteTargetView</a>() will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * throw an error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isAutoUpdatableView = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newValues = NIL;<br/></li>
<li>&nbsp; &nbsp; allReplaced = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, rte-&gt;values_lists)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sublist = (List *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newList = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(sublist) == numattrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, sublist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *col = (Node *) lfirst(lc2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrno = attrnos[i++];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(col, SetToDefault))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att_tup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *new_expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this column isn't used, just replace the DEFAULT with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL (attrno will be 0 in this case because the targetlist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry will have been replaced by the default expression).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(i, unused_cols))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SetToDefault *def = (SetToDefault *) col;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/makefuncs.c.html#L339" title="nodes/makefuncs.c:339">makeNullConst</a>(def-&gt;typeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def-&gt;typeMod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def-&gt;collation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attrno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot set value in column </span><span class="Special">%d</span><span class="Constant"> to DEFAULT&quot;</span>, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(attrno &gt; <span class="Constant">0</span> &amp;&amp; attrno &lt;= target_relation-&gt;rd_att-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att_tup = TupleDescAttr(target_relation-&gt;rd_att, attrno - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!att_tup-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_expr = <a href="#L1224" title="rewrite/rewriteHandler.c:1224">build_column_default</a>(target_relation, attrno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_expr = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* force a NULL if dropped */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there is no default (ie, default is effectively NULL),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we've got to explicitly set the column to NULL, unless the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * target relation is an auto-updatable view.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!new_expr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isAutoUpdatableView)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Leave the value untouched */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newList, col);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allReplaced = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_expr = (Node *) <a href="../nodes/makefuncs.c.html#L301" title="nodes/makefuncs.c:301">makeConst</a>(att_tup-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att_tup-&gt;attcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att_tup-&gt;attlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Comment">/* isnull */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att_tup-&gt;attbyval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this is to catch a NOT NULL domain constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_expr = <a href="../parser/parse_coerce.c.html#L676" title="parser/parse_coerce.c:676">coerce_to_domain</a>(new_expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att_tup-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCION_IMPLICIT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCE_IMPLICIT_CAST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newList, new_expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newList, col);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newValues = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newValues, newList);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; rte-&gt;values_lists = newValues;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(attrnos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> allReplaced;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Mop up <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining DEFAULT items in the given VALUES RTE by<br/></li>
<li></span><span class="Comment"> * replacing them with NULL constants.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used for the product queries generated by DO ALSO rules attached to<br/></li>
<li></span><span class="Comment"> * an auto-updatable view.&nbsp; The action can't depend on the &quot;target relation&quot;<br/></li>
<li></span><span class="Comment"> * since the product query might not have one (it needn't be an INSERT).<br/></li>
<li></span><span class="Comment"> * Essentially, such queries are treated as being attached to a rule-updatable<br/></li>
<li></span><span class="Comment"> * view.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1620">&#x200c;</a></span><span class="linkable">rewriteValuesRTEToNulls</span>(Query *parsetree, RangeTblEntry *rte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newValues;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newValues = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, rte-&gt;values_lists)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sublist = (List *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newList = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, sublist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *col = (Node *) lfirst(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(col, SetToDefault))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SetToDefault *def = (SetToDefault *) col;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newList, <a href="../nodes/makefuncs.c.html#L339" title="nodes/makefuncs.c:339">makeNullConst</a>(def-&gt;typeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; def-&gt;typeMod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; def-&gt;collation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newList, col);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newValues = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newValues, newList);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; rte-&gt;values_lists = newValues;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1658" title="rewrite/rewriteHandler.c:1658">matchLocks</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; match a relation's list of locks and returns the matching rules<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L1658">&#x200c;</a><span class="linkable">matchLocks</span>(CmdType event,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> varno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Query *parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *hasUpdate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RuleLock&nbsp;&nbsp; *rulelocks = relation-&gt;rd_rules;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *matching_locks = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nlocks;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rulelocks == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;commandType != CMD_SELECT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;resultRelation != varno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nlocks = rulelocks-&gt;numLocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nlocks; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RewriteRule *oneLock = rulelocks-&gt;rules[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oneLock-&gt;event == CMD_UPDATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *hasUpdate = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Suppress ON INSERT/UPDATE/DELETE rules that are disabled or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * configured to not fire during the current session's replication<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * role. ON SELECT rules will always be applied in order to keep views<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * working even in LOCAL or REPLICA role.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oneLock-&gt;event != CMD_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../commands/trigger.c.html#L63" title="commands/trigger.c:63">SessionReplicationRole</a> == SESSION_REPLICATION_ROLE_REPLICA)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oneLock-&gt;enabled == RULE_FIRES_ON_ORIGIN ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oneLock-&gt;enabled == RULE_DISABLED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ORIGIN or LOCAL ROLE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oneLock-&gt;enabled == RULE_FIRES_ON_REPLICA ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oneLock-&gt;enabled == RULE_DISABLED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Non-SELECT rules are not supported for MERGE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;commandType == CMD_MERGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot execute MERGE on relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;MERGE is not supported for relations with rules.&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oneLock-&gt;event == event)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;commandType != CMD_SELECT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rewriteManip.c.html#L966" title="rewrite/rewriteManip.c:966">rangeTableEntry_used</a>((Node *) parsetree, varno, <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matching_locks = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(matching_locks, oneLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> matching_locks;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1733" title="rewrite/rewriteHandler.c:1733">ApplyRetrieveRule</a> - expand an ON SELECT rule<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Query *<br/></li>
<li><a id="L1733">&#x200c;</a><span class="linkable">ApplyRetrieveRule</span>(Query *parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RewriteRule *rule,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> rt_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *activeRIRs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *rule_action;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; RowMarkClause *rc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numCols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(rule-&gt;actions) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;expected just one rule action&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rule-&gt;qual != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot handle qualified ON SELECT rule&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rt_index == parsetree-&gt;resultRelation)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have a view as the result relation of the query, and it wasn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rewritten by <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> rule.&nbsp; This case is supported if there is an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * INSTEAD OF <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> that will trap attempts to insert/update/delete<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * view rows.&nbsp; The executor will check that; for the moment just plow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ahead.&nbsp; We have two cases:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For INSERT, we needn't do anything.&nbsp; The unmodified RTE will serve<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fine as the result relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For UPDATE/DELETE/MERGE, we need to expand the view so as to have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * source data for the operation.&nbsp; But we also need an unmodified RTE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to serve as the target.&nbsp; So, copy the RTE and add the copy to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rangetable.&nbsp; Note that the copy does not get added to the jointree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also note that there's a hack in <a href="#L1994" title="rewrite/rewriteHandler.c:1994">fireRIRrules</a> to avoid calling this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function again when it arrives at the copied RTE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;commandType == CMD_INSERT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> parsetree;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (parsetree-&gt;commandType == CMD_UPDATE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parsetree-&gt;commandType == CMD_DELETE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parsetree-&gt;commandType == CMD_MERGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *newrte;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte = rt_fetch(rt_index, parsetree-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newrte = copyObject(rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;rtable = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(parsetree-&gt;rtable, newrte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;resultRelation = list_length(parsetree-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* parsetree-&gt;mergeTargetRelation unchanged (use expanded view) */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For the most part, Vars referencing the view should remain as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they are, meaning that they implicitly represent OLD <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * But in the RETURNING list if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, we want such Vars to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * represent NEW <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, so change them to reference the new RTE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since <a href="rewriteManip.c.html#L674" title="rewrite/rewriteManip.c:674">ChangeVarNodes</a> scribbles on the tree in-place, copy the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RETURNING list first for safety.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;returningList = copyObject(parsetree-&gt;returningList);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rewriteManip.c.html#L674" title="rewrite/rewriteManip.c:674">ChangeVarNodes</a>((Node *) parsetree-&gt;returningList, rt_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parsetree-&gt;resultRelation, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To allow the executor to compute the original view row to pass<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the INSTEAD OF <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>, we add a resjunk whole-row Var<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * referencing the original RTE.&nbsp; This will later get expanded<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * into a RowExpr computing all the OLD <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of the view row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var = <a href="../nodes/makefuncs.c.html#L135" title="nodes/makefuncs.c:135">makeWholeRowVar</a>(rte, rt_index, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(parsetree-&gt;targetList) + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;wholerow&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;targetList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(parsetree-&gt;targetList, tle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now, continue with expanding the original view RTE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized commandType: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) parsetree-&gt;commandType);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if there's a FOR [<a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>] UPDATE/SHARE clause applying to this view.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we needn't explicitly consider <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such clauses appearing in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ancestor query levels; their effects have already been pushed down to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here by <a href="#L1899" title="rewrite/rewriteHandler.c:1899">markQueryForLocking</a>, and will be reflected in &quot;rc&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rc = <a href="../parser/parse_relation.c.html#L3459" title="parser/parse_relation.c:3459">get_parse_rowmark</a>(parsetree, rt_index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make a modifiable copy of the view query, and acquire needed locks on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the relations it mentions.&nbsp; Force at least RowShareLock for all such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rels if there's a FOR [<a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>] UPDATE/SHARE clause affecting this view.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rule_action = copyObject(linitial(rule-&gt;actions));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L140" title="rewrite/rewriteHandler.c:140">AcquireRewriteLocks</a>(rule_action, <span class="Constant">true</span>, (rc != <span class="Constant">NULL</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If FOR [<a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>] UPDATE/SHARE of view, mark all the contained tables as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implicit FOR [<a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>] UPDATE/SHARE, the same as the parser would have done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the view's subquery had been written out explicitly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1899" title="rewrite/rewriteHandler.c:1899">markQueryForLocking</a>(rule_action, (Node *) rule_action-&gt;jointree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc-&gt;strength, rc-&gt;waitPolicy, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recursively expand <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> view references inside the view.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rule_action = <a href="#L1994" title="rewrite/rewriteHandler.c:1994">fireRIRrules</a>(rule_action, activeRIRs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now, plug the view query in as a subselect, converting the relation's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * original RTE to a subquery RTE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rte = rt_fetch(rt_index, parsetree-&gt;rtable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rte-&gt;rtekind = RTE_SUBQUERY;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;subquery = rule_action;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;security_barrier = RelationIsSecurityView(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clear fields that should not be set in a subquery RTE.&nbsp; Note that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leave the relid, relkind, rellockmode, and perminfoindex fields set, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the view relation can be appropriately locked <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> execution and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its permissions checked.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rte-&gt;tablesample = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; rte-&gt;inh = <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must not be set for a subquery */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we allow CREATE OR REPLACE VIEW to add columns to a view, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rule_action might emit more columns than we expected when the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query was parsed.&nbsp; Various places expect rte-&gt;eref-&gt;colnames to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consistent with the non-junk output columns of the subquery, so patch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * things up if necessary by adding some dummy column names.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; numCols = <a href="../executor/execUtils.c.html#L1119" title="executor/execUtils.c:1119">ExecCleanTargetListLength</a>(rule_action-&gt;targetList);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (list_length(rte-&gt;eref-&gt;colnames) &lt; numCols)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;eref-&gt;colnames = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rte-&gt;eref-&gt;colnames,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(<a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<span class="Constant">&quot;?column?&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> parsetree;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recursively mark all relations used by a view as FOR [<a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>] UPDATE/SHARE.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This may generate an invalid query, eg if some sub-query uses an<br/></li>
<li></span><span class="Comment"> * aggregate.&nbsp; We leave it to the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> to detect that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this must agree with the parser's <a href="../parser/analyze.c.html#L3302" title="parser/analyze.c:3302">transformLockingClause</a>() routine.<br/></li>
<li></span><span class="Comment"> * However, we used to have to avoid marking a view's OLD and NEW rels for<br/></li>
<li></span><span class="Comment"> * updating, which motivated scanning the jointree to determine which rels<br/></li>
<li></span><span class="Comment"> * are used.&nbsp; Possibly that could <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be simplified into just scanning the<br/></li>
<li></span><span class="Comment"> * rangetable as the parser does.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1899">&#x200c;</a></span><span class="linkable">markQueryForLocking</span>(Query *qry, Node *jtnode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LockClauseStrength strength, LockWaitPolicy waitPolicy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> pushedDown)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (jtnode == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(jtnode, RangeTblRef))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rti = ((RangeTblRef *) jtnode)-&gt;rtindex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = rt_fetch(rti, qry-&gt;rtable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTEPermissionInfo *perminfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../parser/analyze.c.html#L3529" title="parser/analyze.c:3529">applyLockingClause</a>(qry, rti, strength, waitPolicy, pushedDown);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perminfo = <a href="../parser/parse_relation.c.html#L3903" title="parser/parse_relation.c:3903">getRTEPermissionInfo</a>(qry-&gt;rteperminfos, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perminfo-&gt;requiredPerms |= ACL_SELECT_FOR_UPDATE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rte-&gt;rtekind == RTE_SUBQUERY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../parser/analyze.c.html#L3529" title="parser/analyze.c:3529">applyLockingClause</a>(qry, rti, strength, waitPolicy, pushedDown);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FOR UPDATE/SHARE of subquery is propagated to subquery's rels */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1899" title="rewrite/rewriteHandler.c:1899">markQueryForLocking</a>(rte-&gt;subquery, (Node *) rte-&gt;subquery-&gt;jointree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strength, waitPolicy, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* other RTE types are unaffected by FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(jtnode, FromExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FromExpr&nbsp;&nbsp; *f = (FromExpr *) jtnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, f-&gt;fromlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1899" title="rewrite/rewriteHandler.c:1899">markQueryForLocking</a>(qry, lfirst(l), strength, waitPolicy, pushedDown);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(jtnode, JoinExpr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; JoinExpr&nbsp;&nbsp; *j = (JoinExpr *) jtnode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1899" title="rewrite/rewriteHandler.c:1899">markQueryForLocking</a>(qry, j-&gt;larg, strength, waitPolicy, pushedDown);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1899" title="rewrite/rewriteHandler.c:1899">markQueryForLocking</a>(qry, j-&gt;rarg, strength, waitPolicy, pushedDown);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(jtnode));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1963" title="rewrite/rewriteHandler.c:1963">fireRIRonSubLink</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Apply <a href="#L1994" title="rewrite/rewriteHandler.c:1994">fireRIRrules</a>() to each SubLink (subselect in expression) found<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; in the given tree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: although this has the form of a walker, we cheat and modify the<br/></li>
<li></span><span class="Comment"> * SubLink nodes in-place.&nbsp; It is caller's responsibility to ensure that<br/></li>
<li></span><span class="Comment"> * no unwanted side-effects occur!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is unlike most of the other routines that recurse into subselects,<br/></li>
<li></span><span class="Comment"> * because we must take control at the SubLink node in order to replace<br/></li>
<li></span><span class="Comment"> * the SubLink's subselect link with the possibly-rewritten subquery.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1963">&#x200c;</a></span><span class="linkable">fireRIRonSubLink</span>(Node *node, List *activeRIRs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(node, SubLink))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SubLink&nbsp; &nbsp; *sub = (SubLink *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do what we came for */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sub-&gt;subselect = (Node *) <a href="#L1994" title="rewrite/rewriteHandler.c:1994">fireRIRrules</a>((Query *) sub-&gt;subselect,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; activeRIRs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fall through to process lefthand args of SubLink */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do NOT recurse into Query nodes, because <a href="#L1994" title="rewrite/rewriteHandler.c:1994">fireRIRrules</a> already processed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subselects of subselects for us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> expression_tree_walker(node, <a href="#L1963" title="rewrite/rewriteHandler.c:1963">fireRIRonSubLink</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span> *) activeRIRs);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1994" title="rewrite/rewriteHandler.c:1994">fireRIRrules</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Apply all RIR rules on each rangetable entry in the given query<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * activeRIRs is a list of the OIDs of views we're already processing RIR<br/></li>
<li></span><span class="Comment"> * rules for, used to detect/reject recursion.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Query *<br/></li>
<li><a id="L1994">&#x200c;</a><span class="linkable">fireRIRrules</span>(Query *parsetree, List *activeRIRs)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origResultRelation = parsetree-&gt;resultRelation;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rt_index;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Expand SEARCH and CYCLE clauses in CTEs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is just a convenient place to do this, since we are already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * looking at each Query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, parsetree-&gt;cteList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CommonTableExpr *cte = lfirst_node(CommonTableExpr, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;search_clause || cte-&gt;cycle_clause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte = <a href="rewriteSearchCycle.c.html#L203" title="rewrite/rewriteSearchCycle.c:203">rewriteSearchAndCycle</a>(cte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lfirst(lc) = cte;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't try to convert this into a foreach loop, because rtable list can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get changed each time through...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rt_index = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (rt_index &lt; list_length(parsetree-&gt;rtable))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *locks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RuleLock&nbsp;&nbsp; *rules;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RewriteRule *rule;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ++rt_index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rte = rt_fetch(rt_index, parsetree-&gt;rtable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A subquery RTE can't have associated rules, so there's nothing to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do to this level of the query, but we must recurse into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subquery to expand <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> rule references in it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_SUBQUERY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;subquery = <a href="#L1994" title="rewrite/rewriteHandler.c:1994">fireRIRrules</a>(rte-&gt;subquery, activeRIRs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Joins and other non-relation RTEs can be ignored completely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind != RTE_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Always ignore RIR rules for materialized views referenced in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * queries.&nbsp; (This does not prevent refreshing MVs, since they aren't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * referenced in their own query definitions.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: in the future we might want to allow MVs to be conditionally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expanded as if they were regular views, if they are not scannable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In that case this test would need to be postponed till after we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * opened the rel, so that we could check its state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;relkind == RELKIND_MATVIEW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In INSERT ... ON CONFLICT, ignore the EXCLUDED pseudo-relation;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * even if it points to a view, we needn't expand it, and should not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because we want the RTE to remain of RTE_RELATION type.&nbsp; Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it would get changed to RTE_SUBQUERY type, which is an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * untested/unsupported situation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;onConflict &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rt_index == parsetree-&gt;onConflict-&gt;exclRelIndex)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the table is not referenced in the query, then we ignore it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This prevents infinite expansion loop due to new rtable entries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inserted by expansion of a rule. A table is referenced if it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * part of the join set (a source table), or is referenced by <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Var<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nodes, or is the result table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rt_index != parsetree-&gt;resultRelation &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="rewriteManip.c.html#L966" title="rewrite/rewriteManip.c:966">rangeTableEntry_used</a>((Node *) parsetree, rt_index, <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, if this is a new result relation introduced by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1733" title="rewrite/rewriteHandler.c:1733">ApplyRetrieveRule</a>, we don't want to do anything more with it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rt_index == parsetree-&gt;resultRelation &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rt_index != origResultRelation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can use NoLock here since either the parser or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L140" title="rewrite/rewriteHandler.c:140">AcquireRewriteLocks</a> should have locked the rel already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(rte-&gt;relid, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Collect the RIR rules that we must apply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rules = rel-&gt;rd_rules;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rules != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locks = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; rules-&gt;numLocks; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rule = rules-&gt;rules[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rule-&gt;event != CMD_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locks = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(locks, rule);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we found <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, apply them --- but first check for recursion!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (locks != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(activeRIRs, RelationGetRelid(rel)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;infinite recursion detected in rules for relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; activeRIRs = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(activeRIRs, RelationGetRelid(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(l, locks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rule = lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree = <a href="#L1733" title="rewrite/rewriteHandler.c:1733">ApplyRetrieveRule</a>(parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rule,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rt_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; activeRIRs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; activeRIRs = <a href="../nodes/list.c.html#L957" title="nodes/list.c:957">list_delete_last</a>(activeRIRs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recurse into subqueries in WITH */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, parsetree-&gt;cteList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CommonTableExpr *cte = (CommonTableExpr *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;ctequery = (Node *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1994" title="rewrite/rewriteHandler.c:1994">fireRIRrules</a>((Query *) cte-&gt;ctequery, activeRIRs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recurse into sublink subqueries, too.&nbsp; But we already did the ones in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the rtable and cteList.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;hasSubLinks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query_tree_walker(parsetree, <a href="#L1963" title="rewrite/rewriteHandler.c:1963">fireRIRonSubLink</a>, (<span class="Type">void</span> *) activeRIRs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QTW_IGNORE_RC_SUBQUERIES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Apply <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> row-level security policies.&nbsp; We do this last because it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requires special recursion detection if the new quals have sublink<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subqueries, and if we did it in the loop above query_tree_walker would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then recurse into those quals a second time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rt_index = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, parsetree-&gt;rtable)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = (RangeTblEntry *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *securityQuals;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *withCheckOptions;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasRowSecurity;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasSubLinks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ++rt_index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Only normal relations can have RLS policies */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind != RTE_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (rte-&gt;relkind != RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rte-&gt;relkind != RELKIND_PARTITIONED_TABLE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(rte-&gt;relid, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fetch <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new security quals that must be applied to this RTE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="rowsecurity.c.html#L98" title="rewrite/rowsecurity.c:98">get_row_security_policies</a>(parsetree, rte, rt_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;securityQuals, &amp;withCheckOptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hasRowSecurity, &amp;hasSubLinks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (securityQuals != NIL || withCheckOptions != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hasSubLinks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L56" title="rewrite/rewriteHandler.c:56">acquireLocksOnSubLinks_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Recursively process the new quals, checking for infinite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recursion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(activeRIRs, RelationGetRelid(rel)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;infinite recursion detected in policy for relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; activeRIRs = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(activeRIRs, RelationGetRelid(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="rowsecurity.c.html#L98" title="rewrite/rowsecurity.c:98">get_row_security_policies</a> just passed back securityQuals<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and/or withCheckOptions, and there were SubLinks, make sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we lock <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relations which are referenced.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These locks would normally be acquired by the parser, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * securityQuals and withCheckOptions are added post-parsing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.for_execute = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L302" title="rewrite/rewriteHandler.c:302">acquireLocksOnSubLinks</a>((Node *) securityQuals, &amp;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L302" title="rewrite/rewriteHandler.c:302">acquireLocksOnSubLinks</a>((Node *) withCheckOptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now that we have the locks on anything added by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="rowsecurity.c.html#L98" title="rewrite/rowsecurity.c:98">get_row_security_policies</a>, fire <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> RIR rules for them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expression_tree_walker((Node *) securityQuals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1963" title="rewrite/rewriteHandler.c:1963">fireRIRonSubLink</a>, (<span class="Type">void</span> *) activeRIRs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expression_tree_walker((Node *) withCheckOptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1963" title="rewrite/rewriteHandler.c:1963">fireRIRonSubLink</a>, (<span class="Type">void</span> *) activeRIRs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; activeRIRs = <a href="../nodes/list.c.html#L957" title="nodes/list.c:957">list_delete_last</a>(activeRIRs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add the new security barrier quals to the start of the RTE's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list so that they get applied <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing barrier quals<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (which would have come from a security-barrier view, and should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * get <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> priority than RLS conditions on the table itself).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte-&gt;securityQuals = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(securityQuals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rte-&gt;securityQuals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;withCheckOptions = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(withCheckOptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;withCheckOptions);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure the query is marked correctly if row-level security<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * applies, or if the new quals had sublinks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hasRowSecurity)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;hasRowSecurity = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hasSubLinks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;hasSubLinks = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> parsetree;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Modify the given query by adding 'AND rule_qual IS NOT TRUE' to its<br/></li>
<li></span><span class="Comment"> * qualification.&nbsp; This is used to generate suitable &quot;else clauses&quot; for<br/></li>
<li></span><span class="Comment"> * conditional INSTEAD rules.&nbsp; (Unfortunately we must use &quot;x IS NOT TRUE&quot;,<br/></li>
<li></span><span class="Comment"> * not just &quot;NOT x&quot; which the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> is much smarter about, else we will<br/></li>
<li></span><span class="Comment"> * do the wrong thing when the qual evaluates to NULL.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The rule_qual may contain references to OLD or NEW.&nbsp; OLD references are<br/></li>
<li></span><span class="Comment"> * replaced by references to the specified rt_index (the relation that the<br/></li>
<li></span><span class="Comment"> * rule applies to).&nbsp; NEW references are only possible for INSERT and UPDATE<br/></li>
<li></span><span class="Comment"> * queries on the relation itself, and so they should be replaced by copies<br/></li>
<li></span><span class="Comment"> * of the related entries in the query's own targetlist.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Query *<br/></li>
<li><a id="L2286">&#x200c;</a><span class="linkable">CopyAndAddInvertedQual</span>(Query *parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *rule_qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> rt_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CmdType event)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't scribble on the passed qual (it's in the relcache!) */<br/></li>
<li></span>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *new_qual = copyObject(rule_qual);<br/></li>
<li>&nbsp; &nbsp; <a href="#L56" title="rewrite/rewriteHandler.c:56">acquireLocksOnSubLinks_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context.for_execute = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In case there are subqueries in the qual, acquire necessary locks and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fix <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> deleted JOIN RTE entries.&nbsp; (This is somewhat redundant with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L343" title="rewrite/rewriteHandler.c:343">rewriteRuleAction</a>, but not entirely ... consider restructuring so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we only need to process the qual this way once.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L302" title="rewrite/rewriteHandler.c:302">acquireLocksOnSubLinks</a>(new_qual, &amp;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fix references to OLD */<br/></li>
<li></span>&nbsp; &nbsp; <a href="rewriteManip.c.html#L674" title="rewrite/rewriteManip.c:674">ChangeVarNodes</a>(new_qual, PRS2_OLD_VARNO, rt_index, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fix references to NEW */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (event == CMD_INSERT || event == CMD_UPDATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_qual = <a href="rewriteManip.c.html#L1769" title="rewrite/rewriteManip.c:1769">ReplaceVarsFromTargetList</a>(new_qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PRS2_NEW_VARNO,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rt_fetch(rt_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;rtable),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parsetree-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (event == CMD_UPDATE) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; REPLACEVARS_CHANGE_VARNO :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; REPLACEVARS_SUBSTITUTE_NULL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rt_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;parsetree-&gt;hasSubLinks);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And attach the fixed qual */<br/></li>
<li></span>&nbsp; &nbsp; <a href="rewriteManip.c.html#L1124" title="rewrite/rewriteManip.c:1124">AddInvertedQual</a>(parsetree, new_qual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> parsetree;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2356" title="rewrite/rewriteHandler.c:2356">fireRules</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; Iterate through rule locks applying rules.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input arguments:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; parsetree - original query<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; rt_index - RT index of result relation in original query<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; event - type of rule event<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; locks - list of rules to fire<br/></li>
<li></span><span class="Comment"> * Output arguments:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *instead_flag - set true if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unqualified INSTEAD rule is found<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (must be initialized to false)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *returning_flag - set true if we rewrite RETURNING clause in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> rule<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (must be initialized to false)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *qual_product - filled with modified original query if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> qualified<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTEAD rule is found (must be initialized to NULL)<br/></li>
<li></span><span class="Comment"> * Return value:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; list of rule actions adjusted for use with this query<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Qualified INSTEAD rules generate their action with the qualification<br/></li>
<li></span><span class="Comment"> * condition added.&nbsp; They also generate a modified version of the original<br/></li>
<li></span><span class="Comment"> * query with the negated qualification added, so that it will run only for<br/></li>
<li></span><span class="Comment"> * rows that the qualified action doesn't act on.&nbsp; (If there are multiple<br/></li>
<li></span><span class="Comment"> * qualified INSTEAD rules, we AND all the negated quals onto a single<br/></li>
<li></span><span class="Comment"> * modified original query.)&nbsp; We won't execute the original, unmodified<br/></li>
<li></span><span class="Comment"> * query if we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> either qualified or unqualified INSTEAD rules.&nbsp; If<br/></li>
<li></span><span class="Comment"> * we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> both, the modified original query is discarded too.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L2356">&#x200c;</a><span class="linkable">fireRules</span>(Query *parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> rt_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CmdType event,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *locks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *instead_flag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *returning_flag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query **qual_product)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *results = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, locks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RewriteRule *rule_lock = (RewriteRule *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *event_qual = rule_lock-&gt;qual;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *actions = rule_lock-&gt;actions;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QuerySource qsrc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Determine correct QuerySource value for actions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rule_lock-&gt;isInstead)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (event_qual != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qsrc = QSRC_QUAL_INSTEAD_RULE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qsrc = QSRC_INSTEAD_RULE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *instead_flag = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* report unqualified INSTEAD */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qsrc = QSRC_NON_INSTEAD_RULE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qsrc == QSRC_QUAL_INSTEAD_RULE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there are INSTEAD rules with qualifications, the original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query is still performed. But all the negated rule<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * qualifications of the INSTEAD rules are added so it does its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actions only in cases where the rule quals of all INSTEAD rules<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are false. Think of it as the default action in a case. We save<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this in *qual_product so <a href="#L3825" title="rewrite/rewriteHandler.c:3825">RewriteQuery</a>() can add it to the query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list after we mangled it up enough.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have already found an unqualified INSTEAD rule, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * *qual_product won't be used, so don't bother building it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!*instead_flag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*qual_product == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *qual_product = copyObject(parsetree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *qual_product = <a href="#L2286" title="rewrite/rewriteHandler.c:2286">CopyAndAddInvertedQual</a>(*qual_product,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; event_qual,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rt_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; event);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now process the rule's actions and add them to the result list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(r, actions)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *rule_action = lfirst(r);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rule_action-&gt;commandType == CMD_NOTHING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rule_action = <a href="#L343" title="rewrite/rewriteHandler.c:343">rewriteRuleAction</a>(parsetree, rule_action,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; event_qual, rt_index, event,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returning_flag);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rule_action-&gt;querySource = qsrc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rule_action-&gt;canSetTag = <span class="Constant">false</span>; <span class="Comment">/* might change later */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; results = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(results, rule_action);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> results;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2447" title="rewrite/rewriteHandler.c:2447">get_view_query</a> - get the Query from a view's _RETURN rule.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller should have verified that the relation is a view, and therefore<br/></li>
<li></span><span class="Comment"> * we should <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an ON SELECT action.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the pointer returned is into the relcache and therefore must<br/></li>
<li></span><span class="Comment"> * be treated as read-only to the caller and not modified or scribbled on.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Query *<br/></li>
<li><a id="L2447">&#x200c;</a><span class="linkable">get_view_query</span>(Relation view)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(view-&gt;rd_rel-&gt;relkind == RELKIND_VIEW);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; view-&gt;rd_rules-&gt;numLocks; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RewriteRule *rule = view-&gt;rd_rules-&gt;rules[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rule-&gt;event == CMD_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A _RETURN rule should have only one action */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(rule-&gt;actions) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid _RETURN rule action specification&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Query *) linitial(rule-&gt;actions);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> _RETURN rule for view&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2486" title="rewrite/rewriteHandler.c:2486">view_has_instead_trigger</a> - does view have an INSTEAD OF <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> for event?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If it does, we don't want to treat it as auto-updatable.&nbsp; This test can't<br/></li>
<li></span><span class="Comment"> * be folded into <a href="#L2598" title="rewrite/rewriteHandler.c:2598">view_query_is_auto_updatable</a> because it's not an error<br/></li>
<li></span><span class="Comment"> * condition.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For MERGE, this will return true if there is an INSTEAD OF <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> for<br/></li>
<li></span><span class="Comment"> * every action in mergeActionList, and false if there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> actions that<br/></li>
<li></span><span class="Comment"> * lack an INSTEAD OF <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.&nbsp; If there are no data-modifying MERGE actions<br/></li>
<li></span><span class="Comment"> * (only DO NOTHING actions), true is returned so that the view is treated<br/></li>
<li></span><span class="Comment"> * as <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-updatable, rather than erroring out if it's not auto-updatable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2486">&#x200c;</a></span><span class="linkable">view_has_instead_trigger</span>(Relation view, CmdType event, List *mergeActionList)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TriggerDesc *trigDesc = view-&gt;trigdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (event)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trigDesc &amp;&amp; trigDesc-&gt;trig_insert_instead_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trigDesc &amp;&amp; trigDesc-&gt;trig_update_instead_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trigDesc &amp;&amp; trigDesc-&gt;trig_delete_instead_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_MERGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach_node(MergeAction, action, mergeActionList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (action-&gt;commandType)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!trigDesc || !trigDesc-&gt;trig_insert_instead_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!trigDesc || !trigDesc-&gt;trig_update_instead_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!trigDesc || !trigDesc-&gt;trig_delete_instead_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_NOTHING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> required */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized commandType: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, action-&gt;commandType);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no actions without an INSTEAD OF <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized CmdType: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) event);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2550" title="rewrite/rewriteHandler.c:2550">view_col_is_auto_updatable</a> - test whether the specified column of a view<br/></li>
<li></span><span class="Comment"> * is auto-updatable. Returns NULL (if the column can be updated) or a message<br/></li>
<li></span><span class="Comment"> * string giving the reason that it cannot be.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned string has not been translated; if it is shown as an error<br/></li>
<li></span><span class="Comment"> * message, the caller should apply <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>() to <a href="../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the checks performed here are local to this view. We do not check<br/></li>
<li></span><span class="Comment"> * whether the referenced column of the underlying base relation is updatable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2550">&#x200c;</a><span class="linkable">view_col_is_auto_updatable</span>(RangeTblRef *rtr, TargetEntry *tle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) tle-&gt;expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, the only updatable columns we support are those that are Vars<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * referring to user columns of the underlying base relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The view targetlist may contain resjunk columns (e.g., a view defined<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * like &quot;SELECT * FROM t ORDER BY a+b&quot; is auto-updatable) but such columns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are not auto-updatable, and in fact should never appear in the outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query's targetlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gettext_noop(<span class="Constant">&quot;Junk view columns are not updatable.&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(var, Var) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varno != rtr-&gt;rtindex ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varlevelsup != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gettext_noop(<span class="Constant">&quot;View columns that are not columns of their base relation are not updatable.&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varattno &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gettext_noop(<span class="Constant">&quot;View columns that refer to system columns are not updatable.&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (var-&gt;varattno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gettext_noop(<span class="Constant">&quot;View columns that return whole-row references are not updatable.&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the view column is updatable */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2598" title="rewrite/rewriteHandler.c:2598">view_query_is_auto_updatable</a> - test whether the specified view definition<br/></li>
<li></span><span class="Comment"> * represents an auto-updatable view. Returns NULL (if the view can be updated)<br/></li>
<li></span><span class="Comment"> * or a message string giving the reason that it cannot be.<br/></li>
<li></span><br/></li>
<li><span class="Comment"> * The returned string has not been translated; if it is shown as an error<br/></li>
<li></span><span class="Comment"> * message, the caller should apply <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>() to <a href="../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If check_cols is true, the view is required to have at least one updatable<br/></li>
<li></span><span class="Comment"> * column (necessary for INSERT/UPDATE). Otherwise the view's columns are not<br/></li>
<li></span><span class="Comment"> * checked for updatability. See also <a href="#L2746" title="rewrite/rewriteHandler.c:2746">view_cols_are_auto_updatable</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the checks performed here are only based on the view definition.<br/></li>
<li></span><span class="Comment"> * We do not check whether <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> base relations referred to by the view are<br/></li>
<li></span><span class="Comment"> * updatable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2598">&#x200c;</a><span class="linkable">view_query_is_auto_updatable</span>(Query *viewquery, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> check_cols)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeTblRef *rtr;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *base_rte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if the view is simply updatable.&nbsp; According to SQL-92 this means:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; - No DISTINCT clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; - Each TLE is a column reference, and each column appears at most once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; - FROM contains exactly one base relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; - No GROUP BY or HAVING clauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; - No set operations (UNION, INTERSECT or EXCEPT).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; - No sub-queries in the WHERE clause that reference the target table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We ignore that last restriction since it would be complex to enforce<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and there isn't <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> actual benefit to disallowing sub-queries.&nbsp; (The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * semantic issues that the standard is presumably concerned about don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arise in Postgres, since <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such sub-query will not see <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> updates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * executed by the outer query anyway, thanks to MVCC snapshotting.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We also relax the second restriction by supporting part of SQL:1999<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * feature T111, which allows for a mix of updatable and non-updatable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * columns, provided that an INSERT or UPDATE doesn't attempt to assign to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a non-updatable column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In addition we impose these constraints, involving features that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not part of SQL-92:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; - No CTEs (WITH clauses).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; - No OFFSET or LIMIT clauses (this matches a SQL:2008 restriction).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; - No system columns (including whole-row references) in the tlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; - No window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in the tlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; - No set-returning <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in the tlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we do these checks without recursively expanding the view.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the base relation is a view, we'll recursively deal with it later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (viewquery-&gt;distinctClause != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gettext_noop(<span class="Constant">&quot;Views containing DISTINCT are not automatically updatable.&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (viewquery-&gt;groupClause != NIL || viewquery-&gt;groupingSets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gettext_noop(<span class="Constant">&quot;Views containing GROUP BY are not automatically updatable.&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (viewquery-&gt;havingQual != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gettext_noop(<span class="Constant">&quot;Views containing HAVING are not automatically updatable.&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (viewquery-&gt;setOperations != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gettext_noop(<span class="Constant">&quot;Views containing UNION, INTERSECT, or EXCEPT are not automatically updatable.&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (viewquery-&gt;cteList != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gettext_noop(<span class="Constant">&quot;Views containing WITH are not automatically updatable.&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (viewquery-&gt;limitOffset != <span class="Constant">NULL</span> || viewquery-&gt;limitCount != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gettext_noop(<span class="Constant">&quot;Views containing LIMIT or OFFSET are not automatically updatable.&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must not allow window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> or set returning <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * targetlist. Otherwise we might end up inserting them into the quals of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> query. We must also check for aggregates in the targetlist in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case they appear without a GROUP BY.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These restrictions ensure that each row of the view corresponds to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unique row in the underlying base relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (viewquery-&gt;hasAggs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gettext_noop(<span class="Constant">&quot;Views that return aggregate <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are not automatically updatable.&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (viewquery-&gt;hasWindowFuncs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gettext_noop(<span class="Constant">&quot;Views that return window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are not automatically updatable.&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (viewquery-&gt;hasTargetSRFs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gettext_noop(<span class="Constant">&quot;Views that return set-returning <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are not automatically updatable.&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The view query should <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> from a single base relation, which must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a table or another view.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(viewquery-&gt;jointree-&gt;fromlist) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gettext_noop(<span class="Constant">&quot;Views that do not <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> from a single table or view are not automatically updatable.&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rtr = (RangeTblRef *) linitial(viewquery-&gt;jointree-&gt;fromlist);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(rtr, RangeTblRef))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gettext_noop(<span class="Constant">&quot;Views that do not <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> from a single table or view are not automatically updatable.&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; base_rte = rt_fetch(rtr-&gt;rtindex, viewquery-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (base_rte-&gt;rtekind != RTE_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (base_rte-&gt;relkind != RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; base_rte-&gt;relkind != RELKIND_FOREIGN_TABLE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; base_rte-&gt;relkind != RELKIND_VIEW &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; base_rte-&gt;relkind != RELKIND_PARTITIONED_TABLE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gettext_noop(<span class="Constant">&quot;Views that do not <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> from a single table or view are not automatically updatable.&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (base_rte-&gt;tablesample)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gettext_noop(<span class="Constant">&quot;Views containing TABLESAMPLE are not automatically updatable.&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that the view has at least one updatable column. This is required<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for INSERT/UPDATE but not for DELETE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (check_cols)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(cell, viewquery-&gt;targetList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(cell);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2550" title="rewrite/rewriteHandler.c:2550">view_col_is_auto_updatable</a>(rtr, tle) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gettext_noop(<span class="Constant">&quot;Views that have no updatable columns are not automatically updatable.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the view is updatable */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2746" title="rewrite/rewriteHandler.c:2746">view_cols_are_auto_updatable</a> - test whether all of the required columns of<br/></li>
<li></span><span class="Comment"> * an auto-updatable view are actually updatable. Returns NULL (if all the<br/></li>
<li></span><span class="Comment"> * required columns can be updated) or a message string giving the reason that<br/></li>
<li></span><span class="Comment"> * they cannot be.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned string has not been translated; if it is shown as an error<br/></li>
<li></span><span class="Comment"> * message, the caller should apply <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>() to <a href="../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be used for INSERT/UPDATE to ensure that we don't attempt to<br/></li>
<li></span><span class="Comment"> * assign to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-updatable columns.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Additionally it may be used to retrieve the set of updatable columns in the<br/></li>
<li></span><span class="Comment"> * view, or if one or more of the required columns is not updatable, the name<br/></li>
<li></span><span class="Comment"> * of the first offending non-updatable column.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must have already verified that this is an auto-updatable view<br/></li>
<li></span><span class="Comment"> * using <a href="#L2598" title="rewrite/rewriteHandler.c:2598">view_query_is_auto_updatable</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the checks performed here are only based on the view definition.<br/></li>
<li></span><span class="Comment"> * We do not check whether the referenced columns of the base relation are<br/></li>
<li></span><span class="Comment"> * updatable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2746">&#x200c;</a><span class="linkable">view_cols_are_auto_updatable</span>(Query *viewquery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Bitmapset *required_cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Bitmapset **updatable_cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> **non_updatable_col)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeTblRef *rtr;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; col;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The caller should have verified that this view is auto-updatable and so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there should be a single base relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(list_length(viewquery-&gt;jointree-&gt;fromlist) == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; rtr = linitial_node(RangeTblRef, viewquery-&gt;jointree-&gt;fromlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the optional return <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (updatable_cols != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *updatable_cols = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (non_updatable_col != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *non_updatable_col = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Test each view column for updatability */<br/></li>
<li></span>&nbsp; &nbsp; col = -FirstLowInvalidHeapAttributeNumber;<br/></li>
<li>&nbsp; &nbsp; foreach(cell, viewquery-&gt;targetList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *col_update_detail;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; col++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; col_update_detail = <a href="#L2550" title="rewrite/rewriteHandler.c:2550">view_col_is_auto_updatable</a>(rtr, tle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (col_update_detail == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The column is updatable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (updatable_cols != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *updatable_cols = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(*updatable_cols, col);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(col, required_cols))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The required column is not updatable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (non_updatable_col != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *non_updatable_col = tle-&gt;resname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> col_update_detail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all the required view columns are updatable */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2829" title="rewrite/rewriteHandler.c:2829">relation_is_updatable</a> - determine which update events the specified<br/></li>
<li></span><span class="Comment"> * relation supports.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that views may contain a mix of updatable and non-updatable columns.<br/></li>
<li></span><span class="Comment"> * For a view to support INSERT/UPDATE it must have at least one updatable<br/></li>
<li></span><span class="Comment"> * column, but there is no such restriction for DELETE. If include_cols is<br/></li>
<li></span><span class="Comment"> * non-NULL, then only the specified columns are considered when testing for<br/></li>
<li></span><span class="Comment"> * updatability.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike the preceding <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, this does recurse to look at a view's<br/></li>
<li></span><span class="Comment"> * base relations, so it needs to detect recursion.&nbsp; To do that, we pass<br/></li>
<li></span><span class="Comment"> * a list of currently-considered outer relations.&nbsp; External callers need<br/></li>
<li></span><span class="Comment"> * only pass NIL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used for the information_schema views, which have separate concepts<br/></li>
<li></span><span class="Comment"> * of &quot;updatable&quot; and &quot;<a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> updatable&quot;.&nbsp; A relation is &quot;updatable&quot; if it<br/></li>
<li></span><span class="Comment"> * can be updated without the need for triggers (either because it has a<br/></li>
<li></span><span class="Comment"> * suitable RULE, or because it is simple enough to be automatically updated).<br/></li>
<li></span><span class="Comment"> * A relation is &quot;<a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> updatable&quot; if it has a suitable INSTEAD OF <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.<br/></li>
<li></span><span class="Comment"> * The SQL standard regards this as not necessarily updatable, presumably<br/></li>
<li></span><span class="Comment"> * because there is no way of knowing what the <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> will actually do.<br/></li>
<li></span><span class="Comment"> * The information_schema views therefore call this function with<br/></li>
<li></span><span class="Comment"> * include_triggers = false.&nbsp; However, other callers might only care whether<br/></li>
<li></span><span class="Comment"> * data-modifying SQL will work, so they can pass include_triggers = true<br/></li>
<li></span><span class="Comment"> * to have <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> updatability included in the result.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The return value is a bitmask of rule event numbers indicating which of<br/></li>
<li></span><span class="Comment"> * the INSERT, UPDATE and DELETE operations are supported.&nbsp; (We do it this way<br/></li>
<li></span><span class="Comment"> * so that we can test for UPDATE plus DELETE support in a single call.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2829">&#x200c;</a></span><span class="linkable">relation_is_updatable</span>(Oid reloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *outer_reloids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> include_triggers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset *include_cols)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; events = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; RuleLock&nbsp;&nbsp; *rulelocks;<br/></li>
<li><br/></li>
<li><a id="L2838">&#x200c;</a><span class="PreProc">#define <span class="linkable">ALL_EVENTS</span> ((</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; CMD_INSERT) | (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; CMD_UPDATE) | (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; CMD_DELETE))<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Since this function recurses, it could be driven to stack overflow */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel = <a href="../access/common/relation.c.html#L88" title="access/common/relation.c:88">try_relation_open</a>(reloid, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the relation doesn't exist, return zero rather than throwing an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error.&nbsp; This is helpful since scanning an information_schema view under<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MVCC rules can result in referencing rels that have actually been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deleted already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we detect a recursive view, report that it is not updatable */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(outer_reloids, RelationGetRelid(rel)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the relation is a table, it is always updatable */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2838" title="rewrite/rewriteHandler.c:2838">ALL_EVENTS</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look for unconditional DO INSTEAD rules, and note supported events */<br/></li>
<li></span>&nbsp; &nbsp; rulelocks = rel-&gt;rd_rules;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rulelocks != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; rulelocks-&gt;numLocks; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rulelocks-&gt;rules[i]-&gt;isInstead &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rulelocks-&gt;rules[i]-&gt;qual == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; events |= ((<span class="Constant">1</span> &lt;&lt; rulelocks-&gt;rules[i]-&gt;event) &amp; <a href="#L2838" title="rewrite/rewriteHandler.c:2838">ALL_EVENTS</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we have rules for all events, we're done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (events == <a href="#L2838" title="rewrite/rewriteHandler.c:2838">ALL_EVENTS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> events;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Similarly look for INSTEAD OF triggers, if they are to be included */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (include_triggers)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TriggerDesc *trigDesc = rel-&gt;trigdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trigDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trigDesc-&gt;trig_insert_instead_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; events |= (<span class="Constant">1</span> &lt;&lt; CMD_INSERT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trigDesc-&gt;trig_update_instead_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; events |= (<span class="Constant">1</span> &lt;&lt; CMD_UPDATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (trigDesc-&gt;trig_delete_instead_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; events |= (<span class="Constant">1</span> &lt;&lt; CMD_DELETE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we have triggers for all events, we're done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (events == <a href="#L2838" title="rewrite/rewriteHandler.c:2838">ALL_EVENTS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> events;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If this is a foreign table, check which update events it supports */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_FOREIGN_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FdwRoutine *fdwroutine = <a href="../foreign/foreign.c.html#L432" title="foreign/foreign.c:432">GetFdwRoutineForRelation</a>(rel, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fdwroutine-&gt;IsForeignRelUpdatable != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; events |= fdwroutine-&gt;IsForeignRelUpdatable(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assume presence of executor <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> is sufficient */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fdwroutine-&gt;ExecForeignInsert != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; events |= (<span class="Constant">1</span> &lt;&lt; CMD_INSERT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fdwroutine-&gt;ExecForeignUpdate != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; events |= (<span class="Constant">1</span> &lt;&lt; CMD_UPDATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fdwroutine-&gt;ExecForeignDelete != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; events |= (<span class="Constant">1</span> &lt;&lt; CMD_DELETE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> events;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if this is an automatically updatable view */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_VIEW)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *viewquery = <a href="#L2447" title="rewrite/rewriteHandler.c:2447">get_view_query</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2598" title="rewrite/rewriteHandler.c:2598">view_query_is_auto_updatable</a>(viewquery, <span class="Constant">false</span>) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *updatable_cols;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; auto_events;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblRef *rtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *base_rte;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; baseoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine which of the view's columns are updatable. If there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> within the set of columns we are looking at, then the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * view doesn't support INSERT/UPDATE, but it may still support<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * DELETE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2746" title="rewrite/rewriteHandler.c:2746">view_cols_are_auto_updatable</a>(viewquery, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;updatable_cols, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (include_cols != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updatable_cols = <a href="../nodes/bitmapset.c.html#L1109" title="nodes/bitmapset.c:1109">bms_int_members</a>(updatable_cols, include_cols);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bms_is_empty(updatable_cols))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; auto_events = (<span class="Constant">1</span> &lt;&lt; CMD_DELETE);&nbsp; &nbsp; <span class="Comment">/* May support DELETE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; auto_events = <a href="#L2838" title="rewrite/rewriteHandler.c:2838">ALL_EVENTS</a>;&nbsp; &nbsp; <span class="Comment">/* May support all events */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The base relation must also support these update commands.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Tables are always updatable, but for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other kind of base<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation we must do a recursive check limited to the columns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * referenced by the locally updatable columns in this view.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtr = (RangeTblRef *) linitial(viewquery-&gt;jointree-&gt;fromlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base_rte = rt_fetch(rtr-&gt;rtindex, viewquery-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(base_rte-&gt;rtekind == RTE_RELATION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (base_rte-&gt;relkind != RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base_rte-&gt;relkind != RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; baseoid = base_rte-&gt;relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_reloids = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(outer_reloids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; include_cols = <a href="#L3010" title="rewrite/rewriteHandler.c:3010">adjust_view_column_set</a>(updatable_cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; viewquery-&gt;targetList);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; auto_events &amp;= <a href="#L2829" title="rewrite/rewriteHandler.c:2829">relation_is_updatable</a>(baseoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; outer_reloids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; include_triggers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; include_cols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_reloids = <a href="../nodes/list.c.html#L957" title="nodes/list.c:957">list_delete_last</a>(outer_reloids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; events |= auto_events;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we reach here, the relation may support some update commands */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> events;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3010" title="rewrite/rewriteHandler.c:3010">adjust_view_column_set</a> - map a set of column numbers according to targetlist<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used with simply-updatable views to map column-permissions sets for<br/></li>
<li></span><span class="Comment"> * the view columns onto the matching columns in the underlying base relation.<br/></li>
<li></span><span class="Comment"> * The targetlist is expected to be a list of plain Vars of the underlying<br/></li>
<li></span><span class="Comment"> * relation (as per the checks above in <a href="#L2598" title="rewrite/rewriteHandler.c:2598">view_query_is_auto_updatable</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Bitmapset *<br/></li>
<li><a id="L3010">&#x200c;</a><span class="linkable">adjust_view_column_set</span>(Bitmapset *cols, List *targetlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *result = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; col = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((col = <a href="../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(cols, col)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> numbers are offset by FirstLowInvalidHeapAttributeNumber */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno = col + FirstLowInvalidHeapAttributeNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attno == InvalidAttrNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's a whole-row reference to the view.&nbsp; For permissions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * purposes, treat it as a reference to each column available from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the view.&nbsp; (We should *not* convert this to a whole-row<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reference to the base relation, since the view may not touch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all columns of the base relation.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, targetlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = lfirst_node(TargetEntry, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var = castNode(Var, tle-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varattno - FirstLowInvalidHeapAttributeNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Views do not have system columns, so we do not expect to see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other system attnos here.&nbsp; If we do <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one, the error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case will apply.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = <a href="../parser/parse_relation.c.html#L3439" title="parser/parse_relation.c:3439">get_tle_by_resno</a>(targetlist, attno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle != <span class="Constant">NULL</span> &amp;&amp; !tle-&gt;resjunk &amp;&amp; IsA(tle-&gt;expr, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) tle-&gt;expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;varattno - FirstLowInvalidHeapAttributeNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;attribute number </span><span class="Special">%d</span><span class="Constant"> not found in view targetlist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3084" title="rewrite/rewriteHandler.c:3084">error_view_not_updatable</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Report an error due to an attempt to update a non-updatable view.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Generally this is expected to be called from the rewriter, with suitable<br/></li>
<li></span><span class="Comment"> * error detail explaining why the view is not updatable.&nbsp; Note, however, that<br/></li>
<li></span><span class="Comment"> * the executor also performs a just-in-case check that the target view is<br/></li>
<li></span><span class="Comment"> * updatable.&nbsp; That check is expected to never fail, but if it does, it will<br/></li>
<li></span><span class="Comment"> * call this function with NULL error detail --- see <a href="../executor/execMain.c.html#L1026" title="executor/execMain.c:1026">CheckValidResultRel</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: for MERGE, at least one of the actions in mergeActionList is expected<br/></li>
<li></span><span class="Comment"> * to lack a suitable INSTEAD OF <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> --- see <a href="#L2486" title="rewrite/rewriteHandler.c:2486">view_has_instead_trigger</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3084">&#x200c;</a></span><span class="linkable">error_view_not_updatable</span>(Relation view,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CmdType command,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *mergeActionList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *detail)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TriggerDesc *trigDesc = view-&gt;trigdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (command)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot insert into view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(view)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; detail ? <a href="../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(detail)) : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;To enable inserting into the view, provide an INSTEAD OF INSERT <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> or an unconditional ON INSERT DO INSTEAD rule.&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot update view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(view)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; detail ? <a href="../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(detail)) : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;To enable updating the view, provide an INSTEAD OF UPDATE <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> or an unconditional ON UPDATE DO INSTEAD rule.&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot delete from view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(view)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; detail ? <a href="../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(detail)) : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;To enable deleting from the view, provide an INSTEAD OF DELETE <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> or an unconditional ON DELETE DO INSTEAD rule.&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_MERGE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that the error hints here differ from above, since MERGE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doesn't support rules.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach_node(MergeAction, action, mergeActionList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (action-&gt;commandType)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!trigDesc || !trigDesc-&gt;trig_insert_instead_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot insert into view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(view)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; detail ? <a href="../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(detail)) : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;To enable inserting into the view using MERGE, provide an INSTEAD OF INSERT <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!trigDesc || !trigDesc-&gt;trig_update_instead_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot update view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(view)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; detail ? <a href="../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(detail)) : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;To enable updating the view using MERGE, provide an INSTEAD OF UPDATE <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!trigDesc || !trigDesc-&gt;trig_delete_instead_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot delete from view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(view)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; detail ? <a href="../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(detail)) : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;To enable deleting from the view using MERGE, provide an INSTEAD OF DELETE <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_NOTHING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized commandType: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, action-&gt;commandType);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized CmdType: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) command);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3179" title="rewrite/rewriteHandler.c:3179">rewriteTargetView</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Attempt to rewrite a query where the target relation is a view, so that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the view's base relation becomes the target relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the base relation here may itself be a view, which may or may not<br/></li>
<li></span><span class="Comment"> * have INSTEAD OF triggers or rules to handle the update.&nbsp; That is handled by<br/></li>
<li></span><span class="Comment"> * the recursion in <a href="#L3825" title="rewrite/rewriteHandler.c:3825">RewriteQuery</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Query *<br/></li>
<li><a id="L3179">&#x200c;</a><span class="linkable">rewriteTargetView</span>(Query *parsetree, Relation view)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *viewquery;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; insert_or_update;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *auto_update_detail;<br/></li>
<li>&nbsp; &nbsp; RangeTblRef *rtr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; base_rt_index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_rt_index;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *base_rte;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *view_rte;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *new_rte;<br/></li>
<li>&nbsp; &nbsp; RTEPermissionInfo *base_perminfo;<br/></li>
<li>&nbsp; &nbsp; RTEPermissionInfo *view_perminfo;<br/></li>
<li>&nbsp; &nbsp; RTEPermissionInfo *new_perminfo;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; base_rel;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *view_targetlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the Query from the view's ON SELECT rule.&nbsp; We're going to munge the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Query to change the view's base relation into the target relation,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * along with various other changes along the way, so we need to make a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copy of it (<a href="#L2447" title="rewrite/rewriteHandler.c:2447">get_view_query</a>() returns a pointer into the relcache, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have to treat it as read-only).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; viewquery = copyObject(<a href="#L2447" title="rewrite/rewriteHandler.c:2447">get_view_query</a>(view));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Are we doing INSERT/UPDATE, or MERGE containing INSERT/UPDATE?&nbsp; If so,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * various additional checks on the view columns need to be applied, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> view CHECK OPTIONs need to be enforced.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; insert_or_update =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (parsetree-&gt;commandType == CMD_INSERT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parsetree-&gt;commandType == CMD_UPDATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;commandType == CMD_MERGE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach_node(MergeAction, action, parsetree-&gt;mergeActionList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (action-&gt;commandType == CMD_INSERT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action-&gt;commandType == CMD_UPDATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insert_or_update = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The view must be updatable, else fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are doing INSERT/UPDATE (or MERGE containing INSERT/UPDATE), we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also check that there is at least one updatable column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; auto_update_detail =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2598" title="rewrite/rewriteHandler.c:2598">view_query_is_auto_updatable</a>(viewquery, insert_or_update);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (auto_update_detail)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3084" title="rewrite/rewriteHandler.c:3084">error_view_not_updatable</a>(view,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parsetree-&gt;commandType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parsetree-&gt;mergeActionList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; auto_update_detail);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For INSERT/UPDATE (or MERGE containing INSERT/UPDATE) the modified<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * columns must all be updatable. Note that we get the modified columns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the query's targetlist, not from the result RTE's insertedCols<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and/or updatedCols set, since <a href="#L758" title="rewrite/rewriteHandler.c:758">rewriteTargetListIU</a> may have added<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * additional targetlist entries for view defaults, and these must also be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * updatable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (insert_or_update)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *modified_cols = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *non_updatable_col;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, parsetree-&gt;targetList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modified_cols = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(modified_cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tle-&gt;resno - FirstLowInvalidHeapAttributeNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;onConflict)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, parsetree-&gt;onConflict-&gt;onConflictSet)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modified_cols = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(modified_cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tle-&gt;resno - FirstLowInvalidHeapAttributeNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach_node(MergeAction, action, parsetree-&gt;mergeActionList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (action-&gt;commandType == CMD_INSERT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action-&gt;commandType == CMD_UPDATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach_node(TargetEntry, tle, action-&gt;targetList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modified_cols = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(modified_cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tle-&gt;resno - FirstLowInvalidHeapAttributeNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; auto_update_detail = <a href="#L2746" title="rewrite/rewriteHandler.c:2746">view_cols_are_auto_updatable</a>(viewquery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modified_cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;non_updatable_col);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (auto_update_detail)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is a different error, caused by an attempt to update a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-updatable column in an otherwise updatable view.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (parsetree-&gt;commandType)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot insert into column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; non_updatable_col,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(view)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(auto_update_detail))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot update column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; non_updatable_col,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(view)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(auto_update_detail))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_MERGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> into column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; non_updatable_col,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(view)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(auto_update_detail))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized CmdType: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) parsetree-&gt;commandType);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For MERGE, there must not be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> INSTEAD OF triggers on an otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * updatable view.&nbsp; The caller already checked that there isn't a full set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of INSTEAD OF triggers, so this is to guard against having a partial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set (mixing auto-update and <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-update actions in a single command<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * isn't supported).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;commandType == CMD_MERGE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach_node(MergeAction, action, parsetree-&gt;mergeActionList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (action-&gt;commandType != CMD_NOTHING &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2486" title="rewrite/rewriteHandler.c:2486">view_has_instead_trigger</a>(view, action-&gt;commandType, NIL))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> into view </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(view)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;MERGE is not supported for views with INSTEAD OF triggers for some actions, but not others.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;To enable merging into the view, either provide a full set of INSTEAD OF triggers or drop the existing INSTEAD OF triggers.&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Locate RTE describing the view in the outer query */<br/></li>
<li></span>&nbsp; &nbsp; view_rte = rt_fetch(parsetree-&gt;resultRelation, parsetree-&gt;rtable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we get here, <a href="#L2598" title="rewrite/rewriteHandler.c:2598">view_query_is_auto_updatable</a>() has verified that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * view contains a single base relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(list_length(viewquery-&gt;jointree-&gt;fromlist) == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; rtr = linitial_node(RangeTblRef, viewquery-&gt;jointree-&gt;fromlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; base_rt_index = rtr-&gt;rtindex;<br/></li>
<li>&nbsp; &nbsp; base_rte = rt_fetch(base_rt_index, viewquery-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; Assert(base_rte-&gt;rtekind == RTE_RELATION);<br/></li>
<li>&nbsp; &nbsp; base_perminfo = <a href="../parser/parse_relation.c.html#L3903" title="parser/parse_relation.c:3903">getRTEPermissionInfo</a>(viewquery-&gt;rteperminfos, base_rte);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Up to <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, the base relation hasn't been touched at all in our query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to acquire lock on it <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we try to do anything with it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (The subsequent recursive call of <a href="#L3825" title="rewrite/rewriteHandler.c:3825">RewriteQuery</a> will suppose that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already have the right lock!)&nbsp; Since it will become the query target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation, RowExclusiveLock is always the right thing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; base_rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(base_rte-&gt;relid, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * While we have the relation open, update the RTE's relkind, just in case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it changed since this view was made (cf. <a href="#L140" title="rewrite/rewriteHandler.c:140">AcquireRewriteLocks</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; base_rte-&gt;relkind = base_rel-&gt;rd_rel-&gt;relkind;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the view query contains <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sublink subqueries then we need to also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * acquire locks on <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relations they refer to.&nbsp; We know that there won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subqueries in the <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> table or CTEs, so we can <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> those, as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="#L140" title="rewrite/rewriteHandler.c:140">AcquireRewriteLocks</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (viewquery-&gt;hasSubLinks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L56" title="rewrite/rewriteHandler.c:56">acquireLocksOnSubLinks_context</a> context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context.for_execute = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query_tree_walker(viewquery, <a href="#L302" title="rewrite/rewriteHandler.c:302">acquireLocksOnSubLinks</a>, &amp;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QTW_IGNORE_RC_SUBQUERIES);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a new target RTE describing the base relation, and add it to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outer query's rangetable.&nbsp; (What's happening in the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> few steps is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * very much like what the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> would do to &quot;<a href="../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> up&quot; the view into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outer query.&nbsp; Perhaps someday we should refactor things enough so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can share code with the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Be sure to set rellockmode to the correct thing for the target table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we copied the whole viewquery above, we can just scribble on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * base_rte instead of copying it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; new_rte = base_rte;<br/></li>
<li>&nbsp; &nbsp; new_rte-&gt;rellockmode = RowExclusiveLock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; parsetree-&gt;rtable = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(parsetree-&gt;rtable, new_rte);<br/></li>
<li>&nbsp; &nbsp; new_rt_index = list_length(parsetree-&gt;rtable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * INSERTs never inherit.&nbsp; For UPDATE/DELETE/MERGE, we use the view<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query's inheritance flag for the base relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;commandType == CMD_INSERT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_rte-&gt;inh = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adjust the view's targetlist Vars to reference the new target RTE, ie<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * make their varnos be new_rt_index instead of base_rt_index.&nbsp; There can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be no Vars for other rels in the tlist, so this is sufficient to <a href="../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up the tlist expressions for use in the outer query.&nbsp; The tlist will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * provide the replacement expressions used by <a href="rewriteManip.c.html#L1769" title="rewrite/rewriteManip.c:1769">ReplaceVarsFromTargetList</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; view_targetlist = viewquery-&gt;targetList;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="rewriteManip.c.html#L674" title="rewrite/rewriteManip.c:674">ChangeVarNodes</a>((Node *) view_targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; base_rt_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_rt_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the view has &quot;security_invoker&quot; set, mark the new target relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the permissions checks that we want to enforce against the query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caller. Otherwise we want to enforce them against the view owner.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At the relation level, require the same INSERT/UPDATE/DELETE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * permissions that the query caller needs against the view.&nbsp; We drop the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ACL_SELECT <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> that is presumably in new_perminfo-&gt;requiredPerms<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initially.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: the original view's RTEPermissionInfo remains in the query's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rteperminfos so that the executor still performs appropriate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * permissions checks for the query caller's use of the view.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; view_perminfo = <a href="../parser/parse_relation.c.html#L3903" title="parser/parse_relation.c:3903">getRTEPermissionInfo</a>(parsetree-&gt;rteperminfos, view_rte);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Disregard the perminfo in viewquery-&gt;rteperminfos that the base_rte<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would currently be pointing at, because we'd like it to point <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new one that will be filled below.&nbsp; Must set perminfoindex to 0 to not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trip over the Assert in <a href="../parser/parse_relation.c.html#L3874" title="parser/parse_relation.c:3874">addRTEPermissionInfo</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; new_rte-&gt;perminfoindex = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; new_perminfo = <a href="../parser/parse_relation.c.html#L3874" title="parser/parse_relation.c:3874">addRTEPermissionInfo</a>(&amp;parsetree-&gt;rteperminfos, new_rte);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelationHasSecurityInvoker(view))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_perminfo-&gt;checkAsUser = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; new_perminfo-&gt;checkAsUser = view-&gt;rd_rel-&gt;relowner;<br/></li>
<li>&nbsp; &nbsp; new_perminfo-&gt;requiredPerms = view_perminfo-&gt;requiredPerms;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now for the per-column permissions bits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initially, new_perminfo (base_perminfo) contains selectedCols<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * permission check bits for all base-rel columns referenced by the view,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but since the view is a SELECT query its insertedCols/updatedCols is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * empty.&nbsp; We set insertedCols and updatedCols to include all the columns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the outer query is trying to modify, adjusting the column numbers as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needed.&nbsp; But we leave selectedCols as-is, so the view owner must have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read permission for all columns used in the view definition, even if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some of them are not read by the outer query.&nbsp; We could try to limit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selectedCols to only columns used in the transformed query, but that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * does not correspond to what happens in ordinary SELECT usage of a view:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all referenced columns must have read permission, even if optimization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * finds that some of them can be discarded during query transformation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The flattening we're doing here is an optional optimization, too.&nbsp; (If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * you are unpersuaded and want to change this, note that applying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L3010" title="rewrite/rewriteHandler.c:3010">adjust_view_column_set</a> to view_perminfo-&gt;selectedCols is clearly *not*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the right answer, since that neglects base-rel columns used in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * view's WHERE quals.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This step needs the modified view targetlist, so we have to do things<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in this order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(bms_is_empty(new_perminfo-&gt;insertedCols) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bms_is_empty(new_perminfo-&gt;updatedCols));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; new_perminfo-&gt;selectedCols = base_perminfo-&gt;selectedCols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; new_perminfo-&gt;insertedCols =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3010" title="rewrite/rewriteHandler.c:3010">adjust_view_column_set</a>(view_perminfo-&gt;insertedCols, view_targetlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; new_perminfo-&gt;updatedCols =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3010" title="rewrite/rewriteHandler.c:3010">adjust_view_column_set</a>(view_perminfo-&gt;updatedCols, view_targetlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Move <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> security barrier quals from the view RTE onto the new target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RTE.&nbsp; Any such quals should <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> apply to the new target RTE and will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not reference the original view RTE in the rewritten query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; new_rte-&gt;securityQuals = view_rte-&gt;securityQuals;<br/></li>
<li>&nbsp; &nbsp; view_rte-&gt;securityQuals = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now update all Vars in the outer query that reference the view to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reference the appropriate column of the base relation instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; parsetree = (Query *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="rewriteManip.c.html#L1769" title="rewrite/rewriteManip.c:1769">ReplaceVarsFromTargetList</a>((Node *) parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;resultRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; view_rte,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; view_targetlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; REPLACEVARS_REPORT_ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update all other RTI references in the query that point to the view<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (for example, parsetree-&gt;resultRelation itself) to point to the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * base relation instead.&nbsp; Vars will not be affected since <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reference parsetree-&gt;resultRelation <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> longer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="rewriteManip.c.html#L674" title="rewrite/rewriteManip.c:674">ChangeVarNodes</a>((Node *) parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parsetree-&gt;resultRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_rt_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(parsetree-&gt;resultRelation == new_rt_index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For INSERT/UPDATE we must also update resnos in the targetlist to refer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to columns of the base relation, since those indicate the target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * columns to be affected.&nbsp; Similarly, for MERGE we must update the resnos<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> action targetlists of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> INSERT/UPDATE actions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that this destroys the resno ordering of the targetlists, but that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be fixed when we recurse through <a href="#L3825" title="rewrite/rewriteHandler.c:3825">RewriteQuery</a>, which will invoke<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L758" title="rewrite/rewriteHandler.c:758">rewriteTargetListIU</a> again on the updated targetlists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;commandType != CMD_DELETE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, parsetree-&gt;targetList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *view_tle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; view_tle = <a href="../parser/parse_relation.c.html#L3439" title="parser/parse_relation.c:3439">get_tle_by_resno</a>(view_targetlist, tle-&gt;resno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (view_tle != <span class="Constant">NULL</span> &amp;&amp; !view_tle-&gt;resjunk &amp;&amp; IsA(view_tle-&gt;expr, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;resno = ((Var *) view_tle-&gt;expr)-&gt;varattno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;attribute number </span><span class="Special">%d</span><span class="Constant"> not found in view targetlist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tle-&gt;resno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach_node(MergeAction, action, parsetree-&gt;mergeActionList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (action-&gt;commandType == CMD_INSERT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action-&gt;commandType == CMD_UPDATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach_node(TargetEntry, tle, action-&gt;targetList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *view_tle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; view_tle = <a href="../parser/parse_relation.c.html#L3439" title="parser/parse_relation.c:3439">get_tle_by_resno</a>(view_targetlist, tle-&gt;resno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (view_tle != <span class="Constant">NULL</span> &amp;&amp; !view_tle-&gt;resjunk &amp;&amp; IsA(view_tle-&gt;expr, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;resno = ((Var *) view_tle-&gt;expr)-&gt;varattno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;attribute number </span><span class="Special">%d</span><span class="Constant"> not found in view targetlist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tle-&gt;resno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For INSERT .. ON CONFLICT .. DO UPDATE, we must also update assorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stuff in the onConflict data structure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;onConflict &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;onConflict-&gt;action == ONCONFLICT_UPDATE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; old_exclRelIndex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_exclRelIndex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ParseNamespaceItem *new_exclNSItem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *new_exclRte;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tmp_tlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Like the INSERT/UPDATE code above, update the resnos in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * auxiliary UPDATE targetlist to refer to columns of the base<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, parsetree-&gt;onConflict-&gt;onConflictSet)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *view_tle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; view_tle = <a href="../parser/parse_relation.c.html#L3439" title="parser/parse_relation.c:3439">get_tle_by_resno</a>(view_targetlist, tle-&gt;resno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (view_tle != <span class="Constant">NULL</span> &amp;&amp; !view_tle-&gt;resjunk &amp;&amp; IsA(view_tle-&gt;expr, Var))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;resno = ((Var *) view_tle-&gt;expr)-&gt;varattno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;attribute number </span><span class="Special">%d</span><span class="Constant"> not found in view targetlist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tle-&gt;resno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, create a new RTE for the EXCLUDED pseudo-relation, using the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query's new base rel (which may well have a different column list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from the view, hence we need a new column alias list).&nbsp; This should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * match <a href="../parser/analyze.c.html#L1118" title="parser/analyze.c:1118">transformOnConflictClause</a>.&nbsp; In particular, note that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relkind is set to composite to signal that we're not dealing with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an actual relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; old_exclRelIndex = parsetree-&gt;onConflict-&gt;exclRelIndex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_exclNSItem = <a href="../parser/parse_relation.c.html#L1567" title="parser/parse_relation.c:1567">addRangeTableEntryForRelation</a>(<a href="../parser/parse_node.c.html#L39" title="parser/parse_node.c:39">make_parsestate</a>(<span class="Constant">NULL</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; base_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RowExclusiveLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/makefuncs.c.html#L389" title="nodes/makefuncs.c:389">makeAlias</a>(<span class="Constant">&quot;excluded&quot;</span>, NIL),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_exclRte = new_exclNSItem-&gt;p_rte;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_exclRte-&gt;relkind = RELKIND_COMPOSITE_TYPE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore the RTEPermissionInfo that would've been added. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; new_exclRte-&gt;perminfoindex = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;rtable = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(parsetree-&gt;rtable, new_exclRte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_exclRelIndex = parsetree-&gt;onConflict-&gt;exclRelIndex =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(parsetree-&gt;rtable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Replace the targetlist for the EXCLUDED pseudo-relation with a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one, representing the columns from the new base relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;onConflict-&gt;exclRelTlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../parser/analyze.c.html#L1225" title="parser/analyze.c:1225">BuildOnConflictExcludedTargetlist</a>(base_rel, new_exclRelIndex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update all Vars in the ON CONFLICT clause that refer to the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * EXCLUDED pseudo-relation.&nbsp; We want to use the column mappings<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * defined in the view targetlist, but we need the outputs to refer to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the new EXCLUDED pseudo-relation rather than the new target RTE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also notice that &quot;EXCLUDED.*&quot; will be expanded using the view's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rowtype, which seems correct.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tmp_tlist = copyObject(view_targetlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="rewriteManip.c.html#L674" title="rewrite/rewriteManip.c:674">ChangeVarNodes</a>((Node *) tmp_tlist, new_rt_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_exclRelIndex, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;onConflict = (OnConflictExpr *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rewriteManip.c.html#L1769" title="rewrite/rewriteManip.c:1769">ReplaceVarsFromTargetList</a>((Node *) parsetree-&gt;onConflict,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_exclRelIndex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; view_rte,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp_tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; REPLACEVARS_REPORT_ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;parsetree-&gt;hasSubLinks);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For UPDATE/DELETE/MERGE, <a href="../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> up <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WHERE quals from the view.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * know that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Vars in the quals must reference the one base relation,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so we need only adjust their varnos to reference the new target (just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same as we did with the view targetlist).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's a security-barrier view, its WHERE quals must be applied <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * quals from the outer query, so we attach them to the RTE as security<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * barrier quals rather than adding them to the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> WHERE clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For INSERT, the view's quals can be ignored in the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;commandType != CMD_INSERT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; viewquery-&gt;jointree-&gt;quals != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *viewqual = (Node *) viewquery-&gt;jointree-&gt;quals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Even though we copied viewquery already at the top of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function, we must duplicate the viewqual again here, because we may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to use the quals again below for a WithCheckOption clause.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; viewqual = copyObject(viewqual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="rewriteManip.c.html#L674" title="rewrite/rewriteManip.c:674">ChangeVarNodes</a>(viewqual, base_rt_index, new_rt_index, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationIsSecurityView(view))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The view's quals go in front of existing barrier quals: those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would have come from an outer level of security-barrier view,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and so must get evaluated later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: the parsetree has been mutated, so the new_rte pointer is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stale and needs to be re-computed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_rte = rt_fetch(new_rt_index, parsetree-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_rte-&gt;securityQuals = <a href="../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(viewqual, new_rte-&gt;securityQuals);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do not set parsetree-&gt;hasRowSecurity, because these aren't RLS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * conditions (they aren't affected by enabling/disabling RLS).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure that the query is marked correctly if the added qual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has sublinks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!parsetree-&gt;hasSubLinks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;hasSubLinks = <a href="rewriteManip.c.html#L295" title="rewrite/rewriteManip.c:295">checkExprHasSubLink</a>(viewqual);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rewriteManip.c.html#L1056" title="rewrite/rewriteManip.c:1056">AddQual</a>(parsetree, (Node *) viewqual);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For INSERT/UPDATE (or MERGE containing INSERT/UPDATE), if the view has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the WITH CHECK OPTION, or <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parent view specified WITH CASCADED CHECK<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OPTION, add the quals from the view to the query's withCheckOptions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (insert_or_update)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_wco = RelationHasCheckOption(view);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; cascaded = RelationHasCascadedCheckOption(view);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the parent view has a cascaded check option, treat this view as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if it also had a cascaded check option.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * New WithCheckOptions are added to the start of the list, so if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there is a cascaded check option, it will be the first item in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;withCheckOptions != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WithCheckOption *parent_wco =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (WithCheckOption *) linitial(parsetree-&gt;withCheckOptions);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent_wco-&gt;cascaded)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_wco = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cascaded = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add the new WithCheckOption to the start of the list, so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checks on inner views are run <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> checks on outer views, as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * required by the SQL standard.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the new check is CASCADED, we need to add it even if this view<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has no quals, since there may be quals on child views.&nbsp; A LOCAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check can be omitted if this view has no quals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (has_wco &amp;&amp; (cascaded || viewquery-&gt;jointree-&gt;quals != <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WithCheckOption *wco;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wco = makeNode(WithCheckOption);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wco-&gt;kind = WCO_VIEW_CHECK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wco-&gt;relname = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(RelationGetRelationName(view));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wco-&gt;polname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wco-&gt;qual = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wco-&gt;cascaded = cascaded;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;withCheckOptions = <a href="../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(wco,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;withCheckOptions);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (viewquery-&gt;jointree-&gt;quals != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wco-&gt;qual = (Node *) viewquery-&gt;jointree-&gt;quals;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rewriteManip.c.html#L674" title="rewrite/rewriteManip.c:674">ChangeVarNodes</a>(wco-&gt;qual, base_rt_index, new_rt_index, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For INSERT, make sure that the query is marked correctly if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the added qual has sublinks.&nbsp; This can be skipped for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * UPDATE/MERGE, since the same qual will have already been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * added above, and the check will already have been done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!parsetree-&gt;hasSubLinks &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;commandType == CMD_INSERT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;hasSubLinks = <a href="rewriteManip.c.html#L295" title="rewrite/rewriteManip.c:295">checkExprHasSubLink</a>(wco-&gt;qual);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(base_rel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> parsetree;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3825" title="rewrite/rewriteHandler.c:3825">RewriteQuery</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; rewrites the query and apply the rules again on the queries rewritten<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * rewrite_events is a list of open query-rewrite actions, so we can detect<br/></li>
<li></span><span class="Comment"> * infinite recursion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * orig_rt_length is the length of the originating query's rtable, for product<br/></li>
<li></span><span class="Comment"> * queries created by <a href="#L2356" title="rewrite/rewriteHandler.c:2356">fireRules</a>(), and 0 otherwise.&nbsp; This is used to <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * already-processed VALUES RTEs from the original query.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L3825">&#x200c;</a><span class="linkable">RewriteQuery</span>(Query *parsetree, List *rewrite_events, <span class="Type">int</span> orig_rt_length)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CmdType&nbsp; &nbsp; &nbsp; &nbsp; event = parsetree-&gt;commandType;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; instead = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; returning = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; updatableview = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *qual_product = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rewritten = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, recursively process <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> insert/update/delete/<a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> statements in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WITH clauses.&nbsp; (We have to do this first because the WITH clauses may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get copied into rule actions below.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc1, parsetree-&gt;cteList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CommonTableExpr *cte = lfirst_node(CommonTableExpr, lc1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *ctequery = castNode(Query, cte-&gt;ctequery);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newstuff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ctequery-&gt;commandType == CMD_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newstuff = <a href="#L3825" title="rewrite/rewriteHandler.c:3825">RewriteQuery</a>(ctequery, rewrite_events, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Currently we can only handle unconditional, single-statement DO<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * INSTEAD rules correctly; we have to get exactly one non-utility<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Query out of the rewrite operation to stuff back into the CTE node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(newstuff) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must check it's not a utility command */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctequery = linitial_node(Query, newstuff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(ctequery-&gt;commandType == CMD_SELECT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctequery-&gt;commandType == CMD_UPDATE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctequery-&gt;commandType == CMD_INSERT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctequery-&gt;commandType == CMD_DELETE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctequery-&gt;commandType == CMD_MERGE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Currently it could only be NOTIFY; this error message will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need work if we ever allow other utility commands in rules.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;DO INSTEAD NOTIFY rules are not supported for data-modifying statements in WITH&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WITH queries should never be canSetTag */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!ctequery-&gt;canSetTag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Push the single Query back into the CTE node */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;ctequery = (Node *) ctequery;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (newstuff == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;DO INSTEAD NOTHING rules are not supported for data-modifying statements in WITH&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* examine queries to determine which error message to issue */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, newstuff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *q = (Query *) lfirst(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (q-&gt;querySource == QSRC_QUAL_INSTEAD_RULE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conditional DO INSTEAD rules are not supported for data-modifying statements in WITH&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (q-&gt;querySource == QSRC_NON_INSTEAD_RULE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;DO ALSO rules are not supported for data-modifying statements in WITH&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;multi-statement DO INSTEAD rules are not supported for data-modifying statements in WITH&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the statement is an insert, update, delete, or <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>, adjust its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * targetlist as needed, and then fire INSERT/UPDATE/DELETE rules on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SELECT rules are handled later when we have all the queries that should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get executed.&nbsp; Also, utilities aren't rewritten at all (do we still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need that check?)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (event != CMD_SELECT &amp;&amp; event != CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_relation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rt_entry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rt_entry_relation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *locks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; product_orig_rt_length;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *product_queries;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasUpdate = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; values_rte_index = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; defaults_remaining = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result_relation = parsetree-&gt;resultRelation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(result_relation != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rt_entry = rt_fetch(result_relation, parsetree-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rt_entry-&gt;rtekind == RTE_RELATION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can use NoLock here since either the parser or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L140" title="rewrite/rewriteHandler.c:140">AcquireRewriteLocks</a> should have locked the rel already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rt_entry_relation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(rt_entry-&gt;relid, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Rewrite the targetlist as needed for the command type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (event == CMD_INSERT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *values_rte = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Test if it's a multi-row INSERT ... VALUES (...), (...), ... by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * looking for a VALUES RTE in the fromlist.&nbsp; For product queries,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we must ignore <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> already-processed VALUES RTEs from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original query.&nbsp; These appear at the start of the rangetable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, parsetree-&gt;jointree-&gt;fromlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblRef *rtr = (RangeTblRef *) lfirst(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(rtr, RangeTblRef) &amp;&amp; rtr-&gt;rtindex &gt; orig_rt_length)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = rt_fetch(rtr-&gt;rtindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;rtable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_VALUES)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> more than one VALUES RTE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (values_rte != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;more than one VALUES RTE found&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; values_rte = rte;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; values_rte_index = rtr-&gt;rtindex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (values_rte)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *unused_values_attrnos = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> targetlist ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;targetList = <a href="#L758" title="rewrite/rewriteHandler.c:758">rewriteTargetListIU</a>(parsetree-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;commandType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;override,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rt_entry_relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; values_rte,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; values_rte_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;unused_values_attrnos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and the VALUES expression lists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1425" title="rewrite/rewriteHandler.c:1425">rewriteValuesRTE</a>(parsetree, values_rte, values_rte_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rt_entry_relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unused_values_attrnos))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defaults_remaining = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process just the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> targetlist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;targetList =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L758" title="rewrite/rewriteHandler.c:758">rewriteTargetListIU</a>(parsetree-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;commandType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;override,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rt_entry_relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;onConflict &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;onConflict-&gt;action == ONCONFLICT_UPDATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;onConflict-&gt;onConflictSet =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L758" title="rewrite/rewriteHandler.c:758">rewriteTargetListIU</a>(parsetree-&gt;onConflict-&gt;onConflictSet,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CMD_UPDATE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;override,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rt_entry_relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (event == CMD_UPDATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(parsetree-&gt;override == OVERRIDING_NOT_SET);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;targetList =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L758" title="rewrite/rewriteHandler.c:758">rewriteTargetListIU</a>(parsetree-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;commandType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;override,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rt_entry_relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (event == CMD_MERGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(parsetree-&gt;override == OVERRIDING_NOT_SET);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Rewrite each action targetlist separately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc1, parsetree-&gt;mergeActionList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MergeAction *action = (MergeAction *) lfirst(lc1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (action-&gt;commandType)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_NOTHING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_DELETE:&nbsp; &nbsp; <span class="Comment">/* Nothing to do here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_INSERT:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * MERGE actions do not permit multi-row INSERTs, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there is no VALUES RTE to deal with here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action-&gt;targetList =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L758" title="rewrite/rewriteHandler.c:758">rewriteTargetListIU</a>(action-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action-&gt;commandType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; action-&gt;override,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rt_entry_relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized commandType: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, action-&gt;commandType);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (event == CMD_DELETE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nothing to do here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized commandType: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) event);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Collect and apply the appropriate rules.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; locks = <a href="#L1658" title="rewrite/rewriteHandler.c:1658">matchLocks</a>(event, rt_entry_relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result_relation, parsetree, &amp;hasUpdate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; product_orig_rt_length = list_length(parsetree-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; product_queries = <a href="#L2356" title="rewrite/rewriteHandler.c:2356">fireRules</a>(parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; event,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;instead,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;returning,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;qual_product);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have a VALUES RTE with <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining untouched DEFAULT items,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and we got <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> product queries, finalize the VALUES RTE for each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * product query (replacing the remaining DEFAULT items with NULLs).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't do this for the original query, because we know that it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must be an auto-insert on a view, and so should use the base<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation's defaults for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining DEFAULT items.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (defaults_remaining &amp;&amp; product_queries != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Each product query has its own copy of the VALUES RTE at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same index in the rangetable, so we must finalize each one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that if the product query is an INSERT ... SELECT, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the VALUES RTE will be at the same index in the SELECT part of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the product query rather than the top-level product query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(n, product_queries)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *pt = (Query *) lfirst(n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *values_rte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pt-&gt;commandType == CMD_INSERT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pt-&gt;jointree &amp;&amp; IsA(pt-&gt;jointree, FromExpr) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(pt-&gt;jointree-&gt;fromlist) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *jtnode = (Node *) linitial(pt-&gt;jointree-&gt;fromlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(jtnode, RangeTblRef))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtindex = ((RangeTblRef *) jtnode)-&gt;rtindex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *src_rte = rt_fetch(rtindex, pt-&gt;rtable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (src_rte-&gt;rtekind == RTE_SUBQUERY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_rte-&gt;subquery &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IsA(src_rte-&gt;subquery, Query) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src_rte-&gt;subquery-&gt;commandType == CMD_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pt = src_rte-&gt;subquery;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; values_rte = rt_fetch(values_rte_index, pt-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (values_rte-&gt;rtekind != RTE_VALUES)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> VALUES RTE in product query&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1620" title="rewrite/rewriteHandler.c:1620">rewriteValuesRTEToNulls</a>(pt, values_rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there was no unqualified INSTEAD rule, and the target relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is a view without <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> INSTEAD OF triggers, see if the view can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * automatically updated.&nbsp; If so, we perform the necessary query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transformation here and add the resulting query to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * product_queries list, so that it gets recursively rewritten if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * necessary.&nbsp; For MERGE, the view must be automatically updatable if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> actions lack a corresponding INSTEAD OF <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the view cannot be automatically updated, we throw an error here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which is OK since the query would fail at runtime anyway.&nbsp; Throwing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the error here is preferable to the executor check since we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more detailed information available about why the view isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * updatable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!instead &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rt_entry_relation-&gt;rd_rel-&gt;relkind == RELKIND_VIEW &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L2486" title="rewrite/rewriteHandler.c:2486">view_has_instead_trigger</a>(rt_entry_relation, event,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;mergeActionList))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there were <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> qualified INSTEAD rules, don't allow the view<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to be automatically updated (an unqualified INSTEAD rule or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * INSTEAD OF <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> is required).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qual_product != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3084" title="rewrite/rewriteHandler.c:3084">error_view_not_updatable</a>(rt_entry_relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parsetree-&gt;commandType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parsetree-&gt;mergeActionList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gettext_noop(<span class="Constant">&quot;Views with conditional DO INSTEAD rules are not automatically updatable.&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Attempt to rewrite the query to automatically update the view.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This throws an error if the view can't be automatically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * updated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree = <a href="#L3179" title="rewrite/rewriteHandler.c:3179">rewriteTargetView</a>(parsetree, rt_entry_relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point product_queries contains <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> DO ALSO rule<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actions. Add the rewritten query <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> or after those.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must match the handling the original query would have gotten<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * below, if we allowed it to be included again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;commandType == CMD_INSERT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; product_queries = <a href="../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(parsetree, product_queries);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; product_queries = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(product_queries, parsetree);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set the &quot;instead&quot; flag, as if there had been an unqualified<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * INSTEAD, to prevent the original query from being included a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * second time below.&nbsp; The transformation will have rewritten <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RETURNING list, so we can also set &quot;returning&quot; to forestall<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * throwing an error below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instead = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; returning = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updatableview = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we got <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> product queries, recursively rewrite them --- but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first check for recursion!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (product_queries != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *n;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L50" title="rewrite/rewriteHandler.c:50">rewrite_event</a> *rev;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(n, rewrite_events)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rev = (<a href="#L50" title="rewrite/rewriteHandler.c:50">rewrite_event</a> *) lfirst(n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rev-&gt;relation == RelationGetRelid(rt_entry_relation) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rev-&gt;event == event)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;infinite recursion detected in rules for relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rt_entry_relation))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rev = (<a href="#L50" title="rewrite/rewriteHandler.c:50">rewrite_event</a> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L50" title="rewrite/rewriteHandler.c:50">rewrite_event</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rev-&gt;relation = RelationGetRelid(rt_entry_relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rev-&gt;event = event;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rewrite_events = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rewrite_events, rev);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(n, product_queries)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *pt = (Query *) lfirst(n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newstuff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For an updatable view, pt might be the rewritten version of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the original query, in which case we pass on orig_rt_length<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to finish processing <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> VALUES RTE it contained.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, we have a product query created by <a href="#L2356" title="rewrite/rewriteHandler.c:2356">fireRules</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Any VALUES RTEs from the original query have been fully<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processed, and must be skipped when we recurse.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newstuff = <a href="#L3825" title="rewrite/rewriteHandler.c:3825">RewriteQuery</a>(pt, rewrite_events,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pt == parsetree ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_rt_length :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; product_orig_rt_length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rewritten = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(rewritten, newstuff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rewrite_events = <a href="../nodes/list.c.html#L957" title="nodes/list.c:957">list_delete_last</a>(rewrite_events);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there is an INSTEAD, and the original query has a RETURNING, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to have found a RETURNING in the rule(s), else fail. (Because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="rewriteDefine.c.html#L224" title="rewrite/rewriteDefine.c:224">DefineQueryRewrite</a> only allows RETURNING in unconditional INSTEAD<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rules, there's no need to worry whether the substituted RETURNING<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will actually be executed --- it must be.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((instead || qual_product != <span class="Constant">NULL</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsetree-&gt;returningList &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !returning)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (event)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot perform INSERT RETURNING on relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rt_entry_relation)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You need an unconditional ON INSERT DO INSTEAD rule with a RETURNING clause.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot perform UPDATE RETURNING on relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rt_entry_relation)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You need an unconditional ON UPDATE DO INSTEAD rule with a RETURNING clause.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot perform DELETE RETURNING on relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rt_entry_relation)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You need an unconditional ON DELETE DO INSTEAD rule with a RETURNING clause.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized commandType: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) event);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Updatable views are supported by ON CONFLICT, so don't prevent that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case from proceeding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;onConflict &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (product_queries != NIL || hasUpdate) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !updatableview)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;INSERT with ON CONFLICT clause cannot be used with table that has INSERT or UPDATE rules&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rt_entry_relation, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For INSERTs, the original query is done first; for UPDATE/DELETE, it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done last.&nbsp; This is needed because update and delete rule actions might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not do anything if they are invoked after the update or delete is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * performed. The command counter increment between the query executions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * makes the deleted (and maybe the updated) tuples disappear so the scans<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for them in the rule actions cannot <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we found <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unqualified INSTEAD, the original query is not done at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all, in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> form.&nbsp; Otherwise, we add the modified form if qualified<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * INSTEADs were found, else the unmodified form.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!instead)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;commandType == CMD_INSERT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qual_product != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rewritten = <a href="../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(qual_product, rewritten);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rewritten = <a href="../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(parsetree, rewritten);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qual_product != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rewritten = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rewritten, qual_product);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rewritten = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rewritten, parsetree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the original query has a CTE list, and we generated more than one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-utility result query, we have to fail because we'll have copied the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CTE list into each result query.&nbsp; That would break the expectation of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * single evaluation of CTEs.&nbsp; This could possibly be fixed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restructuring so that a CTE list can be shared across multiple Query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and PlannableStatement nodes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parsetree-&gt;cteList != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qcount = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc1, rewritten)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *q = (Query *) lfirst(lc1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (q-&gt;commandType != CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qcount++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qcount &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;WITH cannot be used in a query that is rewritten by rules into multiple queries&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rewritten;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4371" title="rewrite/rewriteHandler.c:4371">QueryRewrite</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Primary entry point to the query rewriter.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Rewrite one query via query rewrite system, possibly returning 0<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; or many queries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: the parsetree must either have come straight from the parser,<br/></li>
<li></span><span class="Comment"> * or have been scanned by <a href="#L140" title="rewrite/rewriteHandler.c:140">AcquireRewriteLocks</a> to acquire suitable locks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L4371">&#x200c;</a><span class="linkable">QueryRewrite</span>(Query *parsetree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; input_query_id = parsetree-&gt;queryId;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *querylist;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *results;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; CmdType&nbsp; &nbsp; &nbsp; &nbsp; origCmdType;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; foundOriginalQuery;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *lastInstead;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This function is only applied to top-level original queries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(parsetree-&gt;querySource == QSRC_ORIGINAL);<br/></li>
<li>&nbsp; &nbsp; Assert(parsetree-&gt;canSetTag);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Step 1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Apply all non-SELECT rules possibly getting 0 or many queries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; querylist = <a href="#L3825" title="rewrite/rewriteHandler.c:3825">RewriteQuery</a>(parsetree, NIL, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Step 2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Apply all the RIR rules on each query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is also a handy place to mark each query with the original queryId<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; results = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(l, querylist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query = (Query *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query = <a href="#L1994" title="rewrite/rewriteHandler.c:1994">fireRIRrules</a>(query, NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query-&gt;queryId = input_query_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; results = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(results, query);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Step 3<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine which, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, of the resulting queries is supposed to set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the command-result tag; and update the canSetTag fields accordingly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the original query is still in the list, it sets the command tag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, the last INSTEAD query of the same kind as the original is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allowed to set the tag.&nbsp; (Note these rules can leave us with no query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * setting the tag.&nbsp; The tcop code has to cope with this by setting up a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * default tag based on the original un-rewritten query.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The Asserts verify that at most one query in the result list is marked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * canSetTag.&nbsp; If we aren't checking asserts, we can fall out of the loop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as soon as we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the original query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; origCmdType = parsetree-&gt;commandType;<br/></li>
<li>&nbsp; &nbsp; foundOriginalQuery = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; lastInstead = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, results)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query = (Query *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;querySource == QSRC_ORIGINAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(query-&gt;canSetTag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!foundOriginalQuery);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foundOriginalQuery = <span class="Constant">true</span>;<br/></li>
<li><span class="PreProc">#ifndef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!query-&gt;canSetTag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;commandType == origCmdType &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (query-&gt;querySource == QSRC_INSTEAD_RULE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; query-&gt;querySource == QSRC_QUAL_INSTEAD_RULE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastInstead = query;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!foundOriginalQuery &amp;&amp; lastInstead != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lastInstead-&gt;canSetTag = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> results;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
