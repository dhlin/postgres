<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>rewrite/rewriteSearchCycle.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>rewrite/rewriteSearchCycle.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L180">make_path_cat_expr</a></li>
<li><a href="#L159">make_path_initial_array</a></li>
<li><a href="#L117">make_path_rowexpr</a></li>
<li><a href="#L203">rewriteSearchAndCycle</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * rewriteSearchCycle.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Support for rewriting SEARCH and CYCLE clauses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/rewrite/rewriteSearchCycle.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_operator_d.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type_d.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/parsenodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/pg_list.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/primnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/<a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parsetree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteManip.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteSearchCycle.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------<br/></li>
<li></span><span class="Comment"> * Rewrite a CTE with SEARCH or CYCLE clause<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Consider a CTE like<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * WITH RECURSIVE ctename (col1, col2, col3) AS (<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; query1<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; UNION [ALL]<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; SELECT trosl FROM ctename<br/></li>
<li></span><span class="Comment"> * )<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * With a search clause<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * SEARCH BREADTH FIRST BY col1, col2 <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> sqc<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * the CTE is rewritten to<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * WITH RECURSIVE ctename (col1, col2, col3, sqc) AS (<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; SELECT col1, col2, col3,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -- original WITH column list<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ROW(0, col1, col2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- initial row of search columns<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; FROM (query1) &quot;*TLOCRN*&quot; (col1, col2, col3)<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; UNION [ALL]<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; SELECT col1, col2, col3,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -- same as above<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ROW(sqc.depth + 1, col1, col2)&nbsp; -- count depth<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; FROM (SELECT trosl, ctename.sqc FROM ctename) &quot;*TROCRN*&quot; (col1, col2, col3, sqc)<br/></li>
<li></span><span class="Comment"> * )<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (This isn't quite legal SQL: sqc.depth is meant to refer to the first<br/></li>
<li></span><span class="Comment"> * column of sqc, which has a row type, but the field names are not defined<br/></li>
<li></span><span class="Comment"> * here.&nbsp; Representing this properly in SQL would be more complicated (and the<br/></li>
<li></span><span class="Comment"> * SQL standard actually does it in that more complicated way), but the<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> representation allows us to construct it this way.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * With a search clause<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * SEARCH DEPTH FIRST BY col1, col2 <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> sqc<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * the CTE is rewritten to<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * WITH RECURSIVE ctename (col1, col2, col3, sqc) AS (<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; SELECT col1, col2, col3,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -- original WITH column list<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARRAY[ROW(col1, col2)]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- initial row of search columns<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; FROM (query1) &quot;*TLOCRN*&quot; (col1, col2, col3)<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; UNION [ALL]<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; SELECT col1, col2, col3,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -- same as above<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sqc || ARRAY[ROW(col1, col2)]&nbsp;&nbsp; -- record rows seen<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; FROM (SELECT trosl, ctename.sqc FROM ctename) &quot;*TROCRN*&quot; (col1, col2, col3, sqc)<br/></li>
<li></span><span class="Comment"> * )<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * With a cycle clause<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * CYCLE col1, col2 <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> cmc TO 'Y' DEFAULT 'N' USING cpa<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (cmc = cycle mark column, cpa = cycle path) the CTE is rewritten to<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * WITH RECURSIVE ctename (col1, col2, col3, cmc, cpa) AS (<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; SELECT col1, col2, col3,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -- original WITH column list<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'N',&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- cycle mark default<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARRAY[ROW(col1, col2)]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -- initial row of cycle columns<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; FROM (query1) &quot;*TLOCRN*&quot; (col1, col2, col3)<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; UNION [ALL]<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; SELECT col1, col2, col3,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -- same as above<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CASE WHEN ROW(col1, col2) = ANY (ARRAY[cpa]) THEN 'Y' ELSE 'N' <a href="../regex/regcomp.c.html#L336" title="regex/regcomp.c:336">END</a>,&nbsp; -- compute cycle mark column<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cpa || ARRAY[ROW(col1, col2)]&nbsp;&nbsp; -- record rows seen<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; FROM (SELECT trosl, ctename.cmc, ctename.cpa FROM ctename) &quot;*TROCRN*&quot; (col1, col2, col3, cmc, cpa)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; WHERE cmc &lt;&gt; 'Y'<br/></li>
<li></span><span class="Comment"> * )<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The expression to compute the cycle mark column in the right-hand query is<br/></li>
<li></span><span class="Comment"> * written as<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * CASE WHEN ROW(col1, col2) IN (SELECT p.* FROM TABLE(cpa) p) THEN cmv ELSE cmd <a href="../regex/regcomp.c.html#L336" title="regex/regcomp.c:336">END</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * in the SQL standard, but in PostgreSQL we can use the scalar-array operator<br/></li>
<li></span><span class="Comment"> * expression shown above.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also, in some of the cases where operators are shown above we actually<br/></li>
<li></span><span class="Comment"> * directly produce the underlying function call.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If both a search clause and a cycle clause is specified, then the search<br/></li>
<li></span><span class="Comment"> * clause column is added <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the cycle clause columns.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make a RowExpr from the specified column names, which have to be among the<br/></li>
<li></span><span class="Comment"> * output columns of the CTE.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> RowExpr *<br/></li>
<li><a id="L117">&#x200c;</a><span class="linkable">make_path_rowexpr</span>(<span class="Type">const</span> CommonTableExpr *cte, <span class="Type">const</span> List *col_list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RowExpr&nbsp; &nbsp; *rowexpr;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rowexpr = makeNode(RowExpr);<br/></li>
<li>&nbsp; &nbsp; rowexpr-&gt;row_typeid = RECORDOID;<br/></li>
<li>&nbsp; &nbsp; rowexpr-&gt;row_format = COERCE_IMPLICIT_CAST;<br/></li>
<li>&nbsp; &nbsp; rowexpr-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, col_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *colname = strVal(lfirst(lc));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; list_length(cte-&gt;ctecolnames); i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *colname2 = strVal(list_nth(cte-&gt;ctecolnames, i));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(colname, colname2) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var = <a href="../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(<span class="Constant">1</span>, i + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_nth_oid(cte-&gt;ctecoltypes, i),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_nth_int(cte-&gt;ctecoltypmods, i),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_nth_oid(cte-&gt;ctecolcollations, i),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowexpr-&gt;args = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rowexpr-&gt;args, var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rowexpr-&gt;colnames = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rowexpr-&gt;colnames, <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(colname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rowexpr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wrap a RowExpr in an ArrayExpr, for the initial search depth first or cycle<br/></li>
<li></span><span class="Comment"> * row.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Expr *<br/></li>
<li><a id="L159">&#x200c;</a><span class="linkable">make_path_initial_array</span>(RowExpr *rowexpr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayExpr&nbsp; *arr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; arr = makeNode(ArrayExpr);<br/></li>
<li>&nbsp; &nbsp; arr-&gt;array_typeid = RECORDARRAYOID;<br/></li>
<li>&nbsp; &nbsp; arr-&gt;element_typeid = RECORDOID;<br/></li>
<li>&nbsp; &nbsp; arr-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; arr-&gt;elements = list_make1(rowexpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Expr *) arr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make an array catenation expression like<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * cpa || ARRAY[ROW(cols)]<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * where the varattno of cpa is provided as path_varattno.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Expr *<br/></li>
<li><a id="L180">&#x200c;</a><span class="linkable">make_path_cat_expr</span>(RowExpr *rowexpr, AttrNumber path_varattno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArrayExpr&nbsp; *arr;<br/></li>
<li>&nbsp; &nbsp; FuncExpr&nbsp;&nbsp; *fexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; arr = makeNode(ArrayExpr);<br/></li>
<li>&nbsp; &nbsp; arr-&gt;array_typeid = RECORDARRAYOID;<br/></li>
<li>&nbsp; &nbsp; arr-&gt;element_typeid = RECORDOID;<br/></li>
<li>&nbsp; &nbsp; arr-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; arr-&gt;elements = list_make1(rowexpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fexpr = <a href="../nodes/makefuncs.c.html#L521" title="nodes/makefuncs.c:521">makeFuncExpr</a>(F_ARRAY_CAT, RECORDARRAYOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_make2(<a href="../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(<span class="Constant">1</span>, path_varattno, RECORDARRAYOID, -<span class="Constant">1</span>, <span class="Constant">0</span>, <span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, InvalidOid, COERCE_EXPLICIT_CALL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Expr *) fexpr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The real work happens here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>CommonTableExpr *<br/></li>
<li><a id="L203">&#x200c;</a><span class="linkable">rewriteSearchAndCycle</span>(CommonTableExpr *cte)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *ctequery;<br/></li>
<li>&nbsp; &nbsp; SetOperationStmt *sos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rti1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rti2;<br/></li>
<li>&nbsp; &nbsp; RangeTblEntry *rte1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *rte2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newrte;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *newq1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newq2;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *newsubquery;<br/></li>
<li>&nbsp; &nbsp; RangeTblRef *rtr;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; search_seq_type = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; sqc_attno = InvalidAttrNumber;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; cmc_attno = InvalidAttrNumber;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; cpa_attno = InvalidAttrNumber;<br/></li>
<li>&nbsp; &nbsp; TargetEntry *tle;<br/></li>
<li>&nbsp; &nbsp; RowExpr&nbsp; &nbsp; *cycle_col_rowexpr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; RowExpr&nbsp; &nbsp; *search_col_rowexpr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *ewcl;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte_rtindex = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(cte-&gt;search_clause || cte-&gt;cycle_clause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cte = copyObject(cte);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ctequery = castNode(Query, cte-&gt;ctequery);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The top level of the CTE's query should be a UNION.&nbsp; Find the two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subqueries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ctequery-&gt;setOperations);<br/></li>
<li>&nbsp; &nbsp; sos = castNode(SetOperationStmt, ctequery-&gt;setOperations);<br/></li>
<li>&nbsp; &nbsp; Assert(sos-&gt;op == SETOP_UNION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rti1 = castNode(RangeTblRef, sos-&gt;larg)-&gt;rtindex;<br/></li>
<li>&nbsp; &nbsp; rti2 = castNode(RangeTblRef, sos-&gt;rarg)-&gt;rtindex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rte1 = rt_fetch(rti1, ctequery-&gt;rtable);<br/></li>
<li>&nbsp; &nbsp; rte2 = rt_fetch(rti2, ctequery-&gt;rtable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(rte1-&gt;rtekind == RTE_SUBQUERY);<br/></li>
<li>&nbsp; &nbsp; Assert(rte2-&gt;rtekind == RTE_SUBQUERY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We'll need this a few times later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;search_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;search_clause-&gt;search_breadth_first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; search_seq_type = RECORDOID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; search_seq_type = RECORDARRAYOID;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Attribute numbers of the added columns in the CTE's column list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;search_clause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sqc_attno = list_length(cte-&gt;ctecolnames) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;cycle_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmc_attno = list_length(cte-&gt;ctecolnames) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cpa_attno = list_length(cte-&gt;ctecolnames) + <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;search_clause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmc_attno++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cpa_attno++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make new left subquery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newq1 = makeNode(Query);<br/></li>
<li>&nbsp; &nbsp; newq1-&gt;commandType = CMD_SELECT;<br/></li>
<li>&nbsp; &nbsp; newq1-&gt;canSetTag = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newrte = makeNode(RangeTblEntry);<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;rtekind = RTE_SUBQUERY;<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;alias = <a href="../nodes/makefuncs.c.html#L389" title="nodes/makefuncs.c:389">makeAlias</a>(<span class="Constant">&quot;*TLOCRN*&quot;</span>, cte-&gt;ctecolnames);<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;eref = newrte-&gt;alias;<br/></li>
<li>&nbsp; &nbsp; newsubquery = copyObject(rte1-&gt;subquery);<br/></li>
<li>&nbsp; &nbsp; <a href="rewriteManip.c.html#L849" title="rewrite/rewriteManip.c:849">IncrementVarSublevelsUp</a>((Node *) newsubquery, <span class="Constant">1</span>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;subquery = newsubquery;<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;inFromCl = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; newq1-&gt;rtable = list_make1(newrte);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rtr = makeNode(RangeTblRef);<br/></li>
<li>&nbsp; &nbsp; rtr-&gt;rtindex = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; newq1-&gt;jointree = <a href="../nodes/makefuncs.c.html#L287" title="nodes/makefuncs.c:287">makeFromExpr</a>(list_make1(rtr), <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make target list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; list_length(cte-&gt;ctecolnames); i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var = <a href="../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(<span class="Constant">1</span>, i + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_nth_oid(cte-&gt;ctecoltypes, i),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_nth_int(cte-&gt;ctecoltypmods, i),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_nth_oid(cte-&gt;ctecolcollations, i),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) var, i + <span class="Constant">1</span>, strVal(list_nth(cte-&gt;ctecolnames, i)), <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;resorigtbl = list_nth_node(TargetEntry, rte1-&gt;subquery-&gt;targetList, i)-&gt;resorigtbl;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;resorigcol = list_nth_node(TargetEntry, rte1-&gt;subquery-&gt;targetList, i)-&gt;resorigcol;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newq1-&gt;targetList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newq1-&gt;targetList, tle);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;search_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *texpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; search_col_rowexpr = <a href="#L117" title="rewrite/rewriteSearchCycle.c:117">make_path_rowexpr</a>(cte, cte-&gt;search_clause-&gt;search_col_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;search_clause-&gt;search_breadth_first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; search_col_rowexpr-&gt;args = <a href="../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(<a href="../nodes/makefuncs.c.html#L301" title="nodes/makefuncs.c:301">makeConst</a>(INT8OID, -<span class="Constant">1</span>, InvalidOid, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(<span class="Constant">0</span>), <span class="Constant">false</span>, FLOAT8PASSBYVAL),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; search_col_rowexpr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; search_col_rowexpr-&gt;colnames = <a href="../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(<a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(<span class="Constant">&quot;*DEPTH*&quot;</span>), search_col_rowexpr-&gt;colnames);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; texpr = (Expr *) search_col_rowexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; texpr = <a href="#L159" title="rewrite/rewriteSearchCycle.c:159">make_path_initial_array</a>(search_col_rowexpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>(texpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(newq1-&gt;targetList) + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;search_clause-&gt;search_seq_column,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newq1-&gt;targetList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newq1-&gt;targetList, tle);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;cycle_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) cte-&gt;cycle_clause-&gt;cycle_mark_default,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(newq1-&gt;targetList) + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;cycle_clause-&gt;cycle_mark_column,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newq1-&gt;targetList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newq1-&gt;targetList, tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cycle_col_rowexpr = <a href="#L117" title="rewrite/rewriteSearchCycle.c:117">make_path_rowexpr</a>(cte, cte-&gt;cycle_clause-&gt;cycle_col_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>(<a href="#L159" title="rewrite/rewriteSearchCycle.c:159">make_path_initial_array</a>(cycle_col_rowexpr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(newq1-&gt;targetList) + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;cycle_clause-&gt;cycle_path_column,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newq1-&gt;targetList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newq1-&gt;targetList, tle);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rte1-&gt;subquery = newq1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;search_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rte1-&gt;eref-&gt;colnames = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rte1-&gt;eref-&gt;colnames, <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(cte-&gt;search_clause-&gt;search_seq_column));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;cycle_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rte1-&gt;eref-&gt;colnames = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rte1-&gt;eref-&gt;colnames, <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(cte-&gt;cycle_clause-&gt;cycle_mark_column));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rte1-&gt;eref-&gt;colnames = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rte1-&gt;eref-&gt;colnames, <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(cte-&gt;cycle_clause-&gt;cycle_path_column));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make new right subquery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newq2 = makeNode(Query);<br/></li>
<li>&nbsp; &nbsp; newq2-&gt;commandType = CMD_SELECT;<br/></li>
<li>&nbsp; &nbsp; newq2-&gt;canSetTag = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newrte = makeNode(RangeTblEntry);<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;rtekind = RTE_SUBQUERY;<br/></li>
<li>&nbsp; &nbsp; ewcl = copyObject(cte-&gt;ctecolnames);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;search_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ewcl = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(ewcl, <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(cte-&gt;search_clause-&gt;search_seq_column));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;cycle_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ewcl = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(ewcl, <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(cte-&gt;cycle_clause-&gt;cycle_mark_column));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ewcl = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(ewcl, <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(cte-&gt;cycle_clause-&gt;cycle_path_column));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;alias = <a href="../nodes/makefuncs.c.html#L389" title="nodes/makefuncs.c:389">makeAlias</a>(<span class="Constant">&quot;*TROCRN*&quot;</span>, ewcl);<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;eref = newrte-&gt;alias;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find the reference to the recursive CTE in the right UNION subquery's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> table.&nbsp; We expect it to be two levels up from the UNION subquery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (and must check that to avoid being fooled by sub-WITHs with the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CTE name).&nbsp; There will not be more than one such reference, because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parser would have rejected that (see <a href="../parser/parse_cte.c.html#L849" title="parser/parse_cte.c:849">checkWellFormedRecursion</a>() in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parse_cte.c).&nbsp; However, the parser doesn't insist that the reference<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appear in the UNION subquery's topmost <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> table, so we might fail to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it at all.&nbsp; That's an unimplemented case for the moment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> rti = <span class="Constant">1</span>; rti &lt;= list_length(rte2-&gt;subquery-&gt;rtable); rti++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *e = rt_fetch(rti, rte2-&gt;subquery-&gt;rtable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (e-&gt;rtekind == RTE_CTE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(cte-&gt;ctename, e-&gt;ctename) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e-&gt;ctelevelsup == <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte_rtindex = rti;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cte_rtindex &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;with a SEARCH or CYCLE clause, the recursive reference to WITH query </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be at the top level of its right-hand SELECT&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;ctename)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newsubquery = copyObject(rte2-&gt;subquery);<br/></li>
<li>&nbsp; &nbsp; <a href="rewriteManip.c.html#L849" title="rewrite/rewriteManip.c:849">IncrementVarSublevelsUp</a>((Node *) newsubquery, <span class="Constant">1</span>, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add extra columns to target list of subquery of right subquery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;search_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ctename.sqc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; var = <a href="../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(cte_rtindex, sqc_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; search_seq_type, -<span class="Constant">1</span>, InvalidOid, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(newsubquery-&gt;targetList) + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;search_clause-&gt;search_seq_column,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newsubquery-&gt;targetList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newsubquery-&gt;targetList, tle);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;cycle_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ctename.cmc */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; var = <a href="../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(cte_rtindex, cmc_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;cycle_clause-&gt;cycle_mark_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;cycle_clause-&gt;cycle_mark_typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;cycle_clause-&gt;cycle_mark_collation, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(newsubquery-&gt;targetList) + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;cycle_clause-&gt;cycle_mark_column,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newsubquery-&gt;targetList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newsubquery-&gt;targetList, tle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ctename.cpa */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; var = <a href="../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(cte_rtindex, cpa_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RECORDARRAYOID, -<span class="Constant">1</span>, InvalidOid, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(newsubquery-&gt;targetList) + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;cycle_clause-&gt;cycle_path_column,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newsubquery-&gt;targetList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newsubquery-&gt;targetList, tle);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newrte-&gt;subquery = newsubquery;<br/></li>
<li>&nbsp; &nbsp; newrte-&gt;inFromCl = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; newq2-&gt;rtable = list_make1(newrte);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rtr = makeNode(RangeTblRef);<br/></li>
<li>&nbsp; &nbsp; rtr-&gt;rtindex = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;cycle_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add cmc &lt;&gt; cmv condition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; expr = <a href="../nodes/makefuncs.c.html#L628" title="nodes/makefuncs.c:628">make_opclause</a>(cte-&gt;cycle_clause-&gt;cycle_mark_neop, BOOLOID, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) <a href="../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(<span class="Constant">1</span>, cmc_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;cycle_clause-&gt;cycle_mark_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;cycle_clause-&gt;cycle_mark_typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;cycle_clause-&gt;cycle_mark_collation, <span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Expr *) cte-&gt;cycle_clause-&gt;cycle_mark_value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cte-&gt;cycle_clause-&gt;cycle_mark_collation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newq2-&gt;jointree = <a href="../nodes/makefuncs.c.html#L287" title="nodes/makefuncs.c:287">makeFromExpr</a>(list_make1(rtr), (Node *) expr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newq2-&gt;jointree = <a href="../nodes/makefuncs.c.html#L287" title="nodes/makefuncs.c:287">makeFromExpr</a>(list_make1(rtr), <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make target list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; list_length(cte-&gt;ctecolnames); i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var = <a href="../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(<span class="Constant">1</span>, i + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_nth_oid(cte-&gt;ctecoltypes, i),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_nth_int(cte-&gt;ctecoltypmods, i),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_nth_oid(cte-&gt;ctecolcollations, i),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) var, i + <span class="Constant">1</span>, strVal(list_nth(cte-&gt;ctecolnames, i)), <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;resorigtbl = list_nth_node(TargetEntry, rte2-&gt;subquery-&gt;targetList, i)-&gt;resorigtbl;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;resorigcol = list_nth_node(TargetEntry, rte2-&gt;subquery-&gt;targetList, i)-&gt;resorigcol;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newq2-&gt;targetList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newq2-&gt;targetList, tle);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;search_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *texpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;search_clause-&gt;search_breadth_first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FieldSelect *fs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FuncExpr&nbsp;&nbsp; *fexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ROW(sqc.depth + 1, cols)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; search_col_rowexpr = copyObject(search_col_rowexpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fs = makeNode(FieldSelect);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fs-&gt;arg = (Expr *) <a href="../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(<span class="Constant">1</span>, sqc_attno, RECORDOID, -<span class="Constant">1</span>, <span class="Constant">0</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fs-&gt;fieldnum = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fs-&gt;resulttype = INT8OID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fs-&gt;resulttypmod = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fexpr = <a href="../nodes/makefuncs.c.html#L521" title="nodes/makefuncs.c:521">makeFuncExpr</a>(F_INT8INC, INT8OID, list_make1(fs), InvalidOid, InvalidOid, COERCE_EXPLICIT_CALL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linitial(search_col_rowexpr-&gt;args) = fexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; texpr = (Expr *) search_col_rowexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sqc || ARRAY[ROW(cols)]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; texpr = <a href="#L180" title="rewrite/rewriteSearchCycle.c:180">make_path_cat_expr</a>(search_col_rowexpr, sqc_attno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>(texpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(newq2-&gt;targetList) + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;search_clause-&gt;search_seq_column,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newq2-&gt;targetList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newq2-&gt;targetList, tle);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;cycle_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScalarArrayOpExpr *saoe;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CaseExpr&nbsp;&nbsp; *caseexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CaseWhen&nbsp;&nbsp; *casewhen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CASE WHEN ROW(cols) = ANY (ARRAY[cpa]) THEN cmv ELSE cmd <a href="../regex/regcomp.c.html#L336" title="regex/regcomp.c:336">END</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; saoe = makeNode(ScalarArrayOpExpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; saoe-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; saoe-&gt;opno = RECORD_EQ_OP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; saoe-&gt;useOr = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; saoe-&gt;args = list_make2(cycle_col_rowexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(<span class="Constant">1</span>, cpa_attno, RECORDARRAYOID, -<span class="Constant">1</span>, <span class="Constant">0</span>, <span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; caseexpr = makeNode(CaseExpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; caseexpr-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; caseexpr-&gt;casetype = cte-&gt;cycle_clause-&gt;cycle_mark_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; caseexpr-&gt;casecollid = cte-&gt;cycle_clause-&gt;cycle_mark_collation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; casewhen = makeNode(CaseWhen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; casewhen-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; casewhen-&gt;expr = (Expr *) saoe;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; casewhen-&gt;result = (Expr *) cte-&gt;cycle_clause-&gt;cycle_mark_value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; caseexpr-&gt;args = list_make1(casewhen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; caseexpr-&gt;defresult = (Expr *) cte-&gt;cycle_clause-&gt;cycle_mark_default;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) caseexpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(newq2-&gt;targetList) + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;cycle_clause-&gt;cycle_mark_column,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newq2-&gt;targetList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newq2-&gt;targetList, tle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cpa || ARRAY[ROW(cols)]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>(<a href="#L180" title="rewrite/rewriteSearchCycle.c:180">make_path_cat_expr</a>(cycle_col_rowexpr, cpa_attno),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(newq2-&gt;targetList) + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;cycle_clause-&gt;cycle_path_column,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newq2-&gt;targetList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newq2-&gt;targetList, tle);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rte2-&gt;subquery = newq2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;search_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rte2-&gt;eref-&gt;colnames = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rte2-&gt;eref-&gt;colnames, <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(cte-&gt;search_clause-&gt;search_seq_column));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;cycle_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rte2-&gt;eref-&gt;colnames = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rte2-&gt;eref-&gt;colnames, <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(cte-&gt;cycle_clause-&gt;cycle_mark_column));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rte2-&gt;eref-&gt;colnames = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(rte2-&gt;eref-&gt;colnames, <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(cte-&gt;cycle_clause-&gt;cycle_path_column));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add the additional columns to the SetOperationStmt<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;search_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sos-&gt;colTypes = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(sos-&gt;colTypes, search_seq_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sos-&gt;colTypmods = <a href="../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(sos-&gt;colTypmods, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sos-&gt;colCollations = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(sos-&gt;colCollations, InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!sos-&gt;all)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sos-&gt;groupClauses = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(sos-&gt;groupClauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../parser/analyze.c.html#L1956" title="parser/analyze.c:1956">makeSortGroupClauseForSetOp</a>(search_seq_type, <span class="Constant">true</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;cycle_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sos-&gt;colTypes = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(sos-&gt;colTypes, cte-&gt;cycle_clause-&gt;cycle_mark_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sos-&gt;colTypmods = <a href="../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(sos-&gt;colTypmods, cte-&gt;cycle_clause-&gt;cycle_mark_typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sos-&gt;colCollations = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(sos-&gt;colCollations, cte-&gt;cycle_clause-&gt;cycle_mark_collation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!sos-&gt;all)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sos-&gt;groupClauses = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(sos-&gt;groupClauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../parser/analyze.c.html#L1956" title="parser/analyze.c:1956">makeSortGroupClauseForSetOp</a>(cte-&gt;cycle_clause-&gt;cycle_mark_type, <span class="Constant">true</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sos-&gt;colTypes = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(sos-&gt;colTypes, RECORDARRAYOID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sos-&gt;colTypmods = <a href="../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(sos-&gt;colTypmods, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sos-&gt;colCollations = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(sos-&gt;colCollations, InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!sos-&gt;all)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sos-&gt;groupClauses = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(sos-&gt;groupClauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../parser/analyze.c.html#L1956" title="parser/analyze.c:1956">makeSortGroupClauseForSetOp</a>(RECORDARRAYOID, <span class="Constant">true</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add the additional columns to the CTE query's target list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;search_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctequery-&gt;targetList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(ctequery-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) <a href="../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(<span class="Constant">1</span>, sqc_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; search_seq_type, -<span class="Constant">1</span>, InvalidOid, <span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length(ctequery-&gt;targetList) + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cte-&gt;search_clause-&gt;search_seq_column,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;cycle_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctequery-&gt;targetList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(ctequery-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) <a href="../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(<span class="Constant">1</span>, cmc_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;cycle_clause-&gt;cycle_mark_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;cycle_clause-&gt;cycle_mark_typmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;cycle_clause-&gt;cycle_mark_collation, <span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length(ctequery-&gt;targetList) + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cte-&gt;cycle_clause-&gt;cycle_mark_column,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctequery-&gt;targetList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(ctequery-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) <a href="../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(<span class="Constant">1</span>, cpa_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RECORDARRAYOID, -<span class="Constant">1</span>, InvalidOid, <span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length(ctequery-&gt;targetList) + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cte-&gt;cycle_clause-&gt;cycle_path_column,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add the additional columns to the CTE's output columns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cte-&gt;ctecolnames = ewcl;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;search_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;ctecoltypes = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(cte-&gt;ctecoltypes, search_seq_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;ctecoltypmods = <a href="../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(cte-&gt;ctecoltypmods, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;ctecolcollations = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(cte-&gt;ctecolcollations, InvalidOid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cte-&gt;cycle_clause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;ctecoltypes = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(cte-&gt;ctecoltypes, cte-&gt;cycle_clause-&gt;cycle_mark_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;ctecoltypmods = <a href="../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(cte-&gt;ctecoltypmods, cte-&gt;cycle_clause-&gt;cycle_mark_typmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;ctecolcollations = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(cte-&gt;ctecolcollations, cte-&gt;cycle_clause-&gt;cycle_mark_collation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;ctecoltypes = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(cte-&gt;ctecoltypes, RECORDARRAYOID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;ctecoltypmods = <a href="../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(cte-&gt;ctecoltypmods, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cte-&gt;ctecolcollations = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(cte-&gt;ctecolcollations, InvalidOid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cte;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
