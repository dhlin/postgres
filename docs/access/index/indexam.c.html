<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/index/indexam.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/index/indexam.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L256">index_beginscan</a></li>
<li><a href="#L287">index_beginscan_bitmap</a></li>
<li><a href="#L310">index_beginscan_internal</a></li>
<li><a href="#L541">index_beginscan_parallel</a></li>
<li><a href="#L748">index_bulk_delete</a></li>
<li><a href="#L788">index_can_return</a></li>
<li><a href="#L177">index_close</a></li>
<li><a href="#L378">index_endscan</a></li>
<li><a href="#L632">index_fetch_heap</a></li>
<li><a href="#L718">index_getbitmap</a></li>
<li><a href="#L673">index_getnext_slot</a></li>
<li><a href="#L574">index_getnext_tid</a></li>
<li><a href="#L826">index_getprocid</a></li>
<li><a href="#L860">index_getprocinfo</a></li>
<li><a href="#L213">index_insert</a></li>
<li><a href="#L241">index_insert_cleanup</a></li>
<li><a href="#L408">index_markpos</a></li>
<li><a href="#L996">index_opclass_options</a></li>
<li><a href="#L133">index_open</a></li>
<li><a href="#L523">index_parallelrescan</a></li>
<li><a href="#L453">index_parallelscan_estimate</a></li>
<li><a href="#L490">index_parallelscan_initialize</a></li>
<li><a href="#L352">index_rescan</a></li>
<li><a href="#L432">index_restrpos</a></li>
<li><a href="#L928">index_store_float8_orderby_distances</a></li>
<li><a href="#L769">index_vacuum_cleanup</a></li>
<li><a href="#L152">try_index_open</a></li>
<li><a href="#L197">validate_relation_kind</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L93">CHECK_REL_PROCEDURE</a></li>
<li><a href="#L100">CHECK_SCAN_PROCEDURE</a></li>
<li><a href="#L75">RELATION_CHECKS</a></li>
<li><a href="#L86">SCAN_CHECKS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * indexam.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; general index access method routines<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/index/indexam.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * INTERFACE ROUTINES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L133" title="access/index/indexam.c:133">index_open</a>&nbsp; &nbsp; &nbsp; &nbsp; - open an index relation by relation OID<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L177" title="access/index/indexam.c:177">index_close</a>&nbsp; &nbsp; &nbsp; &nbsp; - close an index relation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L256" title="access/index/indexam.c:256">index_beginscan</a> - start a scan of an index with amgettuple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L287" title="access/index/indexam.c:287">index_beginscan_bitmap</a> - start a scan of an index with amgetbitmap<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L352" title="access/index/indexam.c:352">index_rescan</a>&nbsp; &nbsp; - restart a scan of an index<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L378" title="access/index/indexam.c:378">index_endscan</a>&nbsp; &nbsp; - end a scan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L213" title="access/index/indexam.c:213">index_insert</a>&nbsp; &nbsp; - insert an index tuple into a relation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L408" title="access/index/indexam.c:408">index_markpos</a>&nbsp; &nbsp; - mark a scan position<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L432" title="access/index/indexam.c:432">index_restrpos</a>&nbsp; &nbsp; - restore a scan position<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L453" title="access/index/indexam.c:453">index_parallelscan_estimate</a> - estimate shared memory for parallel scan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L490" title="access/index/indexam.c:490">index_parallelscan_initialize</a> - <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> parallel scan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L523" title="access/index/indexam.c:523">index_parallelrescan</a>&nbsp; - (re)start a parallel scan of an index<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L541" title="access/index/indexam.c:541">index_beginscan_parallel</a> - join parallel index scan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L574" title="access/index/indexam.c:574">index_getnext_tid</a>&nbsp; &nbsp; - get the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> TID from a scan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L632" title="access/index/indexam.c:632">index_fetch_heap</a>&nbsp; &nbsp; &nbsp; &nbsp; - get the scan's <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> heap tuple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L673" title="access/index/indexam.c:673">index_getnext_slot</a>&nbsp; &nbsp; - get the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple from a scan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L718" title="access/index/indexam.c:718">index_getbitmap</a> - get all tuples from a scan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L748" title="access/index/indexam.c:748">index_bulk_delete</a>&nbsp; &nbsp; - bulk deletion of index tuples<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L769" title="access/index/indexam.c:769">index_vacuum_cleanup</a>&nbsp; &nbsp; - post-deletion <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> of an index<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L788" title="access/index/indexam.c:788">index_can_return</a>&nbsp; &nbsp; - does index support index-only scans?<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L826" title="access/index/indexam.c:826">index_getprocid</a> - get a support procedure OID<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L860" title="access/index/indexam.c:860">index_getprocinfo</a> - get a support procedure's lookup info<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This file contains the index_ routines which used<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to be a scattered collection of stuff in access/genam.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/amapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/reloptions.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/index.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/execnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ruleutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; macros used in index_ routines<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the <a href="../../catalog/index.c.html#L4076" title="catalog/index.c:4076">ReindexIsProcessingIndex</a>() check in <a href="#L75" title="access/index/indexam.c:75">RELATION_CHECKS</a> is there<br/></li>
<li></span><span class="Comment"> * to check that we don't try to scan or do retail insertions into an index<br/></li>
<li></span><span class="Comment"> * that is currently being rebuilt or pending rebuild.&nbsp; This helps to catch<br/></li>
<li></span><span class="Comment"> * things that don't work when reindexing system catalogs, as well as prevent<br/></li>
<li></span><span class="Comment"> * user errors like index expressions that access their own tables.&nbsp; The check<br/></li>
<li></span><span class="Comment"> * doesn't prevent the actual rebuild because we don't use <a href="#L75" title="access/index/indexam.c:75">RELATION_CHECKS</a><br/></li>
<li></span><span class="Comment"> * when calling the index AM's ambuild routine, and there is no reason for<br/></li>
<li></span><span class="Comment"> * ambuild to call its subsidiary routines through this file.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L75">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RELATION_CHECKS</span> \<br/></li>
<li></span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; Assert(RelationIsValid(indexRelation)); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; Assert(PointerIsValid(indexRelation-&gt;rd_indam)); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (unlikely(<a href="../../catalog/index.c.html#L4076" title="catalog/index.c:4076">ReindexIsProcessingIndex</a>(RelationGetRelid(indexRelation)))) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(</span><span class="Constant">&quot;cannot access index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> while it is being reindexed&quot;</span><span class="PreProc">, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(indexRelation)))); \<br/></li>
<li></span><span class="PreProc">} </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L86">&#x200c;</a><span class="PreProc">#define <span class="linkable">SCAN_CHECKS</span> \<br/></li>
<li></span><span class="PreProc">( \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; AssertMacro(IndexScanIsValid(scan)), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; AssertMacro(RelationIsValid(scan-&gt;indexRelation)), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; AssertMacro(PointerIsValid(scan-&gt;indexRelation-&gt;rd_indam)) \<br/></li>
<li></span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L93">&#x200c;</a><span class="PreProc">#define <span class="linkable">CHECK_REL_PROCEDURE</span>(pname) \<br/></li>
<li></span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (indexRelation-&gt;rd_indam-&gt;pname == </span><span class="Constant">NULL</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, </span><span class="Constant">&quot;function </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not defined for index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span><span class="PreProc">, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CppAsString(pname), RelationGetRelationName(indexRelation)); \<br/></li>
<li></span><span class="PreProc">} </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L100">&#x200c;</a><span class="PreProc">#define <span class="linkable">CHECK_SCAN_PROCEDURE</span>(pname) \<br/></li>
<li></span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (scan-&gt;indexRelation-&gt;rd_indam-&gt;pname == </span><span class="Constant">NULL</span><span class="PreProc">) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, </span><span class="Constant">&quot;function </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not defined for index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span><span class="PreProc">, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CppAsString(pname), RelationGetRelationName(scan-&gt;indexRelation)); \<br/></li>
<li></span><span class="PreProc">} </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> IndexScanDesc <a href="#L310" title="access/index/indexam.c:310">index_beginscan_internal</a>(Relation indexRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nkeys, <span class="Type">int</span> norderbys, Snapshot snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParallelIndexScanDesc pscan, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> temp_snap);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L197" title="access/index/indexam.c:197">validate_relation_kind</a>(Relation r);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index_ interface <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L133" title="access/index/indexam.c:133">index_open</a> - open an index relation by relation OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If lockmode is not &quot;NoLock&quot;, the specified kind of lock is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; obtained on the index.&nbsp; (Generally, NoLock should only be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; used if the caller knows it has some appropriate lock on the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; index already.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; An error is raised if the index does not exist.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is a convenience routine adapted for indexscan use.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Some callers may prefer to use <a href="../common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a> directly.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Relation<br/></li>
<li><a id="L133">&#x200c;</a><span class="linkable">index_open</span>(Oid relationId, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; r = <a href="../common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(relationId, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L197" title="access/index/indexam.c:197">validate_relation_kind</a>(r);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> r;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L152" title="access/index/indexam.c:152">try_index_open</a> - open an index relation by relation OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Same as <a href="#L133" title="access/index/indexam.c:133">index_open</a>, except return NULL instead of failing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; if the relation does not exist.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Relation<br/></li>
<li><a id="L152">&#x200c;</a><span class="linkable">try_index_open</span>(Oid relationId, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; r = <a href="../common/relation.c.html#L88" title="access/common/relation.c:88">try_relation_open</a>(relationId, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* leave if index does not exist */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!r)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L197" title="access/index/indexam.c:197">validate_relation_kind</a>(r);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> r;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L177" title="access/index/indexam.c:177">index_close</a> - close an index relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If lockmode is not &quot;NoLock&quot;, we then release the specified lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Note that it is often sensible to hold a lock beyond <a href="#L177" title="access/index/indexam.c:177">index_close</a>;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; in that case, the lock is released automatically at xact end.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L177">&#x200c;</a></span><span class="linkable">index_close</span>(Relation relation, LOCKMODE lockmode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LockRelId&nbsp; &nbsp; relid = relation-&gt;rd_lockInfo.lockRelId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(lockmode &gt;= NoLock &amp;&amp; lockmode &lt; MAX_LOCKMODES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The relcache does the real work... */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L2193" title="utils/cache/relcache.c:2193">RelationClose</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lockmode != NoLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L212" title="storage/lmgr/lmgr.c:212">UnlockRelationId</a>(&amp;relid, lockmode);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L197" title="access/index/indexam.c:197">validate_relation_kind</a> - check the relation's kind<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Make sure relkind is an index or a partitioned index.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L197">&#x200c;</a></span><span class="linkable">validate_relation_kind</span>(Relation r)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (r-&gt;rd_rel-&gt;relkind != RELKIND_INDEX &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_INDEX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not an index&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(r))));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L213" title="access/index/indexam.c:213">index_insert</a> - insert an index tuple into a relation<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L213">&#x200c;</a></span><span class="linkable">index_insert</span>(Relation indexRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointer heap_t_ctid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexUniqueCheck checkUnique,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> indexUnchanged,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexInfo *indexInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L75" title="access/index/indexam.c:75">RELATION_CHECKS</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L93" title="access/index/indexam.c:93">CHECK_REL_PROCEDURE</a>(aminsert);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(indexRelation-&gt;rd_indam-&gt;ampredlocks))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L4321" title="storage/lmgr/predicate.c:4321">CheckForSerializableConflictIn</a>(indexRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (ItemPointer) <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidBlockNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> indexRelation-&gt;rd_indam-&gt;aminsert(indexRelation, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; heap_t_ctid, heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; checkUnique, indexUnchanged,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexInfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* -------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L241" title="access/index/indexam.c:241">index_insert_cleanup</a> - clean up after all index inserts are done<br/></li>
<li></span><span class="Comment"> * -------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L241">&#x200c;</a></span><span class="linkable">index_insert_cleanup</span>(Relation indexRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexInfo *indexInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L75" title="access/index/indexam.c:75">RELATION_CHECKS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (indexRelation-&gt;rd_indam-&gt;aminsertcleanup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexRelation-&gt;rd_indam-&gt;aminsertcleanup(indexRelation, indexInfo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L256" title="access/index/indexam.c:256">index_beginscan</a> - start a scan of an index with amgettuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must be holding suitable locks on the heap and the index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexScanDesc<br/></li>
<li><a id="L256">&#x200c;</a><span class="linkable">index_beginscan</span>(Relation heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation indexRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Snapshot snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nkeys, <span class="Type">int</span> norderbys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexScanDesc scan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(snapshot != InvalidSnapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan = <a href="#L310" title="access/index/indexam.c:310">index_beginscan_internal</a>(indexRelation, nkeys, norderbys, snapshot, <span class="Constant">NULL</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save additional parameters into the scandesc.&nbsp; Everything else was set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up by <a href="genam.c.html#L78" title="access/index/genam.c:78">RelationGetIndexScan</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; scan-&gt;heapRelation = heapRelation;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;xs_snapshot = snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prepare to fetch index matches from table */<br/></li>
<li></span>&nbsp; &nbsp; scan-&gt;xs_heapfetch = table_index_fetch_begin(heapRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L287" title="access/index/indexam.c:287">index_beginscan_bitmap</a> - start a scan of an index with amgetbitmap<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, caller had better be holding some lock on the parent heap<br/></li>
<li></span><span class="Comment"> * relation, even though it's not explicitly mentioned here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexScanDesc<br/></li>
<li><a id="L287">&#x200c;</a><span class="linkable">index_beginscan_bitmap</span>(Relation indexRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Snapshot snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nkeys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexScanDesc scan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(snapshot != InvalidSnapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan = <a href="#L310" title="access/index/indexam.c:310">index_beginscan_internal</a>(indexRelation, nkeys, <span class="Constant">0</span>, snapshot, <span class="Constant">NULL</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save additional parameters into the scandesc.&nbsp; Everything else was set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up by <a href="genam.c.html#L78" title="access/index/genam.c:78">RelationGetIndexScan</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; scan-&gt;xs_snapshot = snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L310" title="access/index/indexam.c:310">index_beginscan_internal</a> --- common code for <a href="#L256" title="access/index/indexam.c:256">index_beginscan</a> variants<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> IndexScanDesc<br/></li>
<li><a id="L310">&#x200c;</a><span class="linkable">index_beginscan_internal</span>(Relation indexRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nkeys, <span class="Type">int</span> norderbys, Snapshot snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParallelIndexScanDesc pscan, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> temp_snap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexScanDesc scan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L75" title="access/index/indexam.c:75">RELATION_CHECKS</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L93" title="access/index/indexam.c:93">CHECK_REL_PROCEDURE</a>(ambeginscan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(indexRelation-&gt;rd_indam-&gt;ampredlocks))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L2561" title="storage/lmgr/predicate.c:2561">PredicateLockRelation</a>(indexRelation, snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We hold a reference count to the relcache entry throughout the scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L2160" title="utils/cache/relcache.c:2160">RelationIncrementReferenceCount</a>(indexRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Tell the AM to open a scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; scan = indexRelation-&gt;rd_indam-&gt;ambeginscan(indexRelation, nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; norderbys);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize information for parallel scan. */<br/></li>
<li></span>&nbsp; &nbsp; scan-&gt;parallel_scan = pscan;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;xs_temp_snap = temp_snap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L352" title="access/index/indexam.c:352">index_rescan</a>&nbsp; - (re)start a scan of an index<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * During a restart, the caller may specify a new set of scankeys and/or<br/></li>
<li></span><span class="Comment"> * orderbykeys; but the number of keys cannot differ from what <a href="#L256" title="access/index/indexam.c:256">index_beginscan</a><br/></li>
<li></span><span class="Comment"> * was told.&nbsp; (Later we might relax that to &quot;must not exceed&quot;, but currently<br/></li>
<li></span><span class="Comment"> * the index AMs tend to assume that scan-&gt;numberOfKeys is what to believe.)<br/></li>
<li></span><span class="Comment"> * To restart the scan without changing keys, pass NULL for the key arrays.<br/></li>
<li></span><span class="Comment"> * (Of course, keys *must* be passed on the first call, unless<br/></li>
<li></span><span class="Comment"> * scan-&gt;numberOfKeys is zero.)<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L352">&#x200c;</a></span><span class="linkable">index_rescan</span>(IndexScanDesc scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanKey keys, <span class="Type">int</span> nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanKey orderbys, <span class="Type">int</span> norderbys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L86" title="access/index/indexam.c:86">SCAN_CHECKS</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="access/index/indexam.c:100">CHECK_SCAN_PROCEDURE</a>(amrescan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(nkeys == scan-&gt;numberOfKeys);<br/></li>
<li>&nbsp; &nbsp; Assert(norderbys == scan-&gt;numberOfOrderBys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release resources (like buffer pins) from table accesses */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;xs_heapfetch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; table_index_fetch_reset(scan-&gt;xs_heapfetch);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan-&gt;kill_prior_tuple = <span class="Constant">false</span>; <span class="Comment">/* for safety */<br/></li>
<li></span>&nbsp; &nbsp; scan-&gt;xs_heap_continue = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan-&gt;indexRelation-&gt;rd_indam-&gt;amrescan(scan, keys, nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orderbys, norderbys);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L378" title="access/index/indexam.c:378">index_endscan</a> - end a scan<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L378">&#x200c;</a></span><span class="linkable">index_endscan</span>(IndexScanDesc scan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L86" title="access/index/indexam.c:86">SCAN_CHECKS</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="access/index/indexam.c:100">CHECK_SCAN_PROCEDURE</a>(amendscan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release resources (like buffer pins) from table accesses */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;xs_heapfetch)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; table_index_fetch_end(scan-&gt;xs_heapfetch);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;xs_heapfetch = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* End the AM's scan */<br/></li>
<li></span>&nbsp; &nbsp; scan-&gt;indexRelation-&gt;rd_indam-&gt;amendscan(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release index refcount acquired by <a href="#L256" title="access/index/indexam.c:256">index_beginscan</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L2173" title="utils/cache/relcache.c:2173">RelationDecrementReferenceCount</a>(scan-&gt;indexRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;xs_temp_snap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L836" title="utils/time/snapmgr.c:836">UnregisterSnapshot</a>(scan-&gt;xs_snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release the scan data structure itself */<br/></li>
<li></span>&nbsp; &nbsp; <a href="genam.c.html#L142" title="access/index/genam.c:142">IndexScanEnd</a>(scan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L408" title="access/index/indexam.c:408">index_markpos</a>&nbsp; - mark a scan position<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L408">&#x200c;</a></span><span class="linkable">index_markpos</span>(IndexScanDesc scan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L86" title="access/index/indexam.c:86">SCAN_CHECKS</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="access/index/indexam.c:100">CHECK_SCAN_PROCEDURE</a>(ammarkpos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan-&gt;indexRelation-&gt;rd_indam-&gt;ammarkpos(scan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L432" title="access/index/indexam.c:432">index_restrpos</a>&nbsp; &nbsp; - restore a scan position<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: this only restores the <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> scan state of the index AM.&nbsp; See<br/></li>
<li></span><span class="Comment"> * comments for <a href="../../executor/execAmi.c.html#L375" title="executor/execAmi.c:375">ExecRestrPos</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: For heap, in the presence of HOT chains, mark/restore only works<br/></li>
<li></span><span class="Comment"> * correctly if the scan's snapshot is MVCC-safe; that ensures that there's at<br/></li>
<li></span><span class="Comment"> * most one returnable tuple in each HOT chain, and so restoring the prior<br/></li>
<li></span><span class="Comment"> * state at the granularity of the index AM is sufficient.&nbsp; Since the only<br/></li>
<li></span><span class="Comment"> * current user of mark/restore functionality is nodeMergejoin.c, this<br/></li>
<li></span><span class="Comment"> * effectively means that <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>-join plans only work for MVCC snapshots.&nbsp; This<br/></li>
<li></span><span class="Comment"> * could be fixed if necessary, but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> it seems unimportant.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L432">&#x200c;</a></span><span class="linkable">index_restrpos</span>(IndexScanDesc scan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(IsMVCCSnapshot(scan-&gt;xs_snapshot));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L86" title="access/index/indexam.c:86">SCAN_CHECKS</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="access/index/indexam.c:100">CHECK_SCAN_PROCEDURE</a>(amrestrpos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release resources (like buffer pins) from table accesses */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;xs_heapfetch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; table_index_fetch_reset(scan-&gt;xs_heapfetch);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan-&gt;kill_prior_tuple = <span class="Constant">false</span>; <span class="Comment">/* for safety */<br/></li>
<li></span>&nbsp; &nbsp; scan-&gt;xs_heap_continue = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan-&gt;indexRelation-&gt;rd_indam-&gt;amrestrpos(scan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L453" title="access/index/indexam.c:453">index_parallelscan_estimate</a> - estimate shared memory for parallel scan<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L453">&#x200c;</a><span class="linkable">index_parallelscan_estimate</span>(Relation indexRelation, <span class="Type">int</span> nkeys, <span class="Type">int</span> norderbys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(snapshot != InvalidSnapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L75" title="access/index/indexam.c:75">RELATION_CHECKS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nbytes = offsetof(ParallelIndexScanDescData, ps_snapshot_data);<br/></li>
<li>&nbsp; &nbsp; nbytes = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(nbytes, <a href="../../utils/time/snapmgr.c.html#L1692" title="utils/time/snapmgr.c:1692">EstimateSnapshotSpace</a>(snapshot));<br/></li>
<li>&nbsp; &nbsp; nbytes = MAXALIGN(nbytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If amestimateparallelscan is not provided, assume there is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * AM-specific data needed.&nbsp; (It's hard to believe that could work, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's easy enough to cater to it here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexRelation-&gt;rd_indam-&gt;amestimateparallelscan != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbytes = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(nbytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexRelation-&gt;rd_indam-&gt;amestimateparallelscan(nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; norderbys));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nbytes;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L490" title="access/index/indexam.c:490">index_parallelscan_initialize</a> - <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> parallel scan<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> both the ParallelIndexScanDesc proper and the AM-specific<br/></li>
<li></span><span class="Comment"> * information which follows it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function calls access method specific initialization routine to<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> am specific information.&nbsp; Call this just once in the leader<br/></li>
<li></span><span class="Comment"> * process; then, individual workers attach via <a href="#L541" title="access/index/indexam.c:541">index_beginscan_parallel</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L490">&#x200c;</a></span><span class="linkable">index_parallelscan_initialize</span>(Relation heapRelation, Relation indexRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Snapshot snapshot, ParallelIndexScanDesc target)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(snapshot != InvalidSnapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L75" title="access/index/indexam.c:75">RELATION_CHECKS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; offset = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(offsetof(ParallelIndexScanDescData, ps_snapshot_data),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L1692" title="utils/time/snapmgr.c:1692">EstimateSnapshotSpace</a>(snapshot));<br/></li>
<li>&nbsp; &nbsp; offset = MAXALIGN(offset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; target-&gt;ps_relid = RelationGetRelid(heapRelation);<br/></li>
<li>&nbsp; &nbsp; target-&gt;ps_indexid = RelationGetRelid(indexRelation);<br/></li>
<li>&nbsp; &nbsp; target-&gt;ps_offset = offset;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L1716" title="utils/time/snapmgr.c:1716">SerializeSnapshot</a>(snapshot, target-&gt;ps_snapshot_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* aminitparallelscan is optional; assume no-op if not provided by AM */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexRelation-&gt;rd_indam-&gt;aminitparallelscan != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *amtarget;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; amtarget = OffsetToPointer(target, offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexRelation-&gt;rd_indam-&gt;aminitparallelscan(amtarget);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L523" title="access/index/indexam.c:523">index_parallelrescan</a>&nbsp; - (re)start a parallel scan of an index<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L523">&#x200c;</a></span><span class="linkable">index_parallelrescan</span>(IndexScanDesc scan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L86" title="access/index/indexam.c:86">SCAN_CHECKS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;xs_heapfetch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; table_index_fetch_reset(scan-&gt;xs_heapfetch);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* amparallelrescan is optional; assume no-op if not provided by AM */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;indexRelation-&gt;rd_indam-&gt;amparallelrescan != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;indexRelation-&gt;rd_indam-&gt;amparallelrescan(scan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L541" title="access/index/indexam.c:541">index_beginscan_parallel</a> - join parallel index scan<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must be holding suitable locks on the heap and the index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexScanDesc<br/></li>
<li><a id="L541">&#x200c;</a><span class="linkable">index_beginscan_parallel</span>(Relation heaprel, Relation indexrel, <span class="Type">int</span> nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> norderbys, ParallelIndexScanDesc pscan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot;<br/></li>
<li>&nbsp; &nbsp; IndexScanDesc scan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(RelationGetRelid(heaprel) == pscan-&gt;ps_relid);<br/></li>
<li>&nbsp; &nbsp; snapshot = <a href="../../utils/time/snapmgr.c.html#L1775" title="utils/time/snapmgr.c:1775">RestoreSnapshot</a>(pscan-&gt;ps_snapshot_data);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L794" title="utils/time/snapmgr.c:794">RegisterSnapshot</a>(snapshot);<br/></li>
<li>&nbsp; &nbsp; scan = <a href="#L310" title="access/index/indexam.c:310">index_beginscan_internal</a>(indexrel, nkeys, norderbys, snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pscan, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save additional parameters into the scandesc.&nbsp; Everything else was set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up by <a href="#L310" title="access/index/indexam.c:310">index_beginscan_internal</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; scan-&gt;heapRelation = heaprel;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;xs_snapshot = snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prepare to fetch index matches from table */<br/></li>
<li></span>&nbsp; &nbsp; scan-&gt;xs_heapfetch = table_index_fetch_begin(heaprel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> * <a href="#L574" title="access/index/indexam.c:574">index_getnext_tid</a> - get the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> TID from a scan<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> TID satisfying the scan keys,<br/></li>
<li></span><span class="Comment"> * or NULL if no more matching tuples exist.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ItemPointer<br/></li>
<li><a id="L574">&#x200c;</a><span class="linkable">index_getnext_tid</span>(IndexScanDesc scan, ScanDirection direction)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L86" title="access/index/indexam.c:86">SCAN_CHECKS</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="access/index/indexam.c:100">CHECK_SCAN_PROCEDURE</a>(amgettuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment">: we should assert that a snapshot is pushed or registered */<br/></li>
<li></span>&nbsp; &nbsp; Assert(TransactionIdIsValid(<a href="../../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The AM's amgettuple proc finds the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> index entry matching the scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keys, and puts the TID into scan-&gt;xs_heaptid.&nbsp; It should also set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan-&gt;xs_recheck and possibly scan-&gt;xs_itup/scan-&gt;xs_hitup, though we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pay no attention to those fields here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; found = scan-&gt;indexRelation-&gt;rd_indam-&gt;amgettuple(scan, direction);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset kill flag immediately for safety */<br/></li>
<li></span>&nbsp; &nbsp; scan-&gt;kill_prior_tuple = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;xs_heap_continue = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we're out of index entries, we're done */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* release resources (like buffer pins) from table accesses */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;xs_heapfetch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; table_index_fetch_reset(scan-&gt;xs_heapfetch);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(ItemPointerIsValid(&amp;scan-&gt;xs_heaptid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_count_index_tuples(scan-&gt;indexRelation, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return the TID of the tuple we found. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> &amp;scan-&gt;xs_heaptid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L632" title="access/index/indexam.c:632">index_fetch_heap</a> - get the scan's <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> heap tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is a visible heap tuple associated with the index TID most<br/></li>
<li></span><span class="Comment"> * recently fetched by <a href="#L574" title="access/index/indexam.c:574">index_getnext_tid</a>, or NULL if no more matching tuples<br/></li>
<li></span><span class="Comment"> * exist.&nbsp; (There can be more than one matching tuple because of HOT chains,<br/></li>
<li></span><span class="Comment"> * although when using an MVCC snapshot it should be impossible for more than<br/></li>
<li></span><span class="Comment"> * one such tuple to exist.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On success, the buffer containing the heap tup is pinned (the pin will be<br/></li>
<li></span><span class="Comment"> * dropped in a future <a href="#L574" title="access/index/indexam.c:574">index_getnext_tid</a>, <a href="#L632" title="access/index/indexam.c:632">index_fetch_heap</a> or <a href="#L378" title="access/index/indexam.c:378">index_endscan</a><br/></li>
<li></span><span class="Comment"> * call).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: caller must check scan-&gt;xs_recheck, and perform rechecking of the<br/></li>
<li></span><span class="Comment"> * scan keys if required.&nbsp; We do not do that here because we don't have<br/></li>
<li></span><span class="Comment"> * enough information to do it efficiently in the general case.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L632">&#x200c;</a></span><span class="linkable">index_fetch_heap</span>(IndexScanDesc scan, TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; all_dead = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; found = table_index_fetch_tuple(scan-&gt;xs_heapfetch, &amp;scan-&gt;xs_heaptid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;xs_snapshot, slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;scan-&gt;xs_heap_continue, &amp;all_dead);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_count_heap_fetch(scan-&gt;indexRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we scanned a whole HOT chain and found only dead tuples, tell index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * AM to kill its entry for that TID (this will take effect in the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * amgettuple call, in <a href="#L574" title="access/index/indexam.c:574">index_getnext_tid</a>).&nbsp; We do not do this when in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery because it may violate MVCC to do so.&nbsp; See comments in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="genam.c.html#L78" title="access/index/genam.c:78">RelationGetIndexScan</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!scan-&gt;xactStartedInRecovery)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;kill_prior_tuple = all_dead;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> found;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L673" title="access/index/indexam.c:673">index_getnext_slot</a> - get the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple from a scan<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is true if a tuple satisfying the scan keys and the snapshot was<br/></li>
<li></span><span class="Comment"> * found, false otherwise.&nbsp; The tuple is stored in the specified slot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On success, resources (like buffer pins) are likely to be held, and will be<br/></li>
<li></span><span class="Comment"> * dropped by a future <a href="#L574" title="access/index/indexam.c:574">index_getnext_tid</a>, <a href="#L632" title="access/index/indexam.c:632">index_fetch_heap</a> or <a href="#L378" title="access/index/indexam.c:378">index_endscan</a><br/></li>
<li></span><span class="Comment"> * call).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: caller must check scan-&gt;xs_recheck, and perform rechecking of the<br/></li>
<li></span><span class="Comment"> * scan keys if required.&nbsp; We do not do that here because we don't have<br/></li>
<li></span><span class="Comment"> * enough information to do it efficiently in the general case.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L673">&#x200c;</a></span><span class="linkable">index_getnext_slot</span>(IndexScanDesc scan, ScanDirection direction, TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!scan-&gt;xs_heap_continue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer tid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Time to fetch the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> TID from the index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tid = <a href="#L574" title="access/index/indexam.c:574">index_getnext_tid</a>(scan, direction);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we're out of index entries, we're done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tid == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(tid, &amp;scan-&gt;xs_heaptid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fetch the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> (or only) visible heap tuple for this index entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we don't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> anything, loop around and grab the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> TID from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemPointerIsValid(&amp;scan-&gt;xs_heaptid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L632" title="access/index/indexam.c:632">index_fetch_heap</a>(scan, slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L718" title="access/index/indexam.c:718">index_getbitmap</a> - get all tuples at once from an index scan<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Adds the TIDs of all heap tuples satisfying the scan keys to a bitmap.<br/></li>
<li></span><span class="Comment"> * Since there's no interlock between the index scan and the eventual heap<br/></li>
<li></span><span class="Comment"> * access, this is only safe to use with MVCC-based snapshots: the heap<br/></li>
<li></span><span class="Comment"> * item slot could have been replaced by a newer tuple by the time we get<br/></li>
<li></span><span class="Comment"> * to it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the number of matching tuples found.&nbsp; (Note: this might be only<br/></li>
<li></span><span class="Comment"> * approximate, so it should only be used for statistical purposes.)<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>int64<br/></li>
<li><a id="L718">&#x200c;</a><span class="linkable">index_getbitmap</span>(IndexScanDesc scan, <a href="../../nodes/tidbitmap.c.html#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *bitmap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; ntids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L86" title="access/index/indexam.c:86">SCAN_CHECKS</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="access/index/indexam.c:100">CHECK_SCAN_PROCEDURE</a>(amgetbitmap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* just make sure this is false... */<br/></li>
<li></span>&nbsp; &nbsp; scan-&gt;kill_prior_tuple = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have the am's getbitmap proc do all the work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ntids = scan-&gt;indexRelation-&gt;rd_indam-&gt;amgetbitmap(scan, bitmap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_count_index_tuples(scan-&gt;indexRelation, ntids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ntids;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L748" title="access/index/indexam.c:748">index_bulk_delete</a> - do mass deletion of index entries<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; callback routine tells whether a given <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a>-heap tuple is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to be deleted<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; return value is an optional <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d struct of statistics<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexBulkDeleteResult *<br/></li>
<li><a id="L748">&#x200c;</a><span class="linkable">index_bulk_delete</span>(IndexVacuumInfo *info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexBulkDeleteResult *istat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexBulkDeleteCallback callback,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *callback_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; indexRelation = info-&gt;index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L75" title="access/index/indexam.c:75">RELATION_CHECKS</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L93" title="access/index/indexam.c:93">CHECK_REL_PROCEDURE</a>(ambulkdelete);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> indexRelation-&gt;rd_indam-&gt;ambulkdelete(info, istat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; callback, callback_state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L769" title="access/index/indexam.c:769">index_vacuum_cleanup</a> - do post-deletion <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> of an index<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; return value is an optional <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d struct of statistics<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexBulkDeleteResult *<br/></li>
<li><a id="L769">&#x200c;</a><span class="linkable">index_vacuum_cleanup</span>(IndexVacuumInfo *info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexBulkDeleteResult *istat)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; indexRelation = info-&gt;index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L75" title="access/index/indexam.c:75">RELATION_CHECKS</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L93" title="access/index/indexam.c:93">CHECK_REL_PROCEDURE</a>(amvacuumcleanup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> indexRelation-&gt;rd_indam-&gt;amvacuumcleanup(info, istat);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L788" title="access/index/indexam.c:788">index_can_return</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Does the index access method support index-only scans for the given<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; column?<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L788">&#x200c;</a></span><span class="linkable">index_can_return</span>(Relation indexRelation, <span class="Type">int</span> attno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L75" title="access/index/indexam.c:75">RELATION_CHECKS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* amcanreturn is optional; assume false if not provided by AM */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexRelation-&gt;rd_indam-&gt;amcanreturn == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> indexRelation-&gt;rd_indam-&gt;amcanreturn(indexRelation, attno);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L826" title="access/index/indexam.c:826">index_getprocid</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Index access methods typically require support routines that are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; not directly the implementation of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WHERE-clause query operator<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and so cannot be kept in pg_amop.&nbsp; Instead, such routines are kept<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; in pg_amproc.&nbsp; These registered procedure OIDs are assigned numbers<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; according to a convention established by the access method.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The general index code doesn't know anything about the routines<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; involved; it just builds an ordered list of them for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; each attribute on which an index is defined.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; As of Postgres 8.3, support routines within an operator family<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; are further subdivided by the &quot;left type&quot; and &quot;right type&quot; of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; query operator(s) that they support.&nbsp; The &quot;default&quot; <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; particular indexed attribute are those with both types <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the index opclass' opcintype (note that this is subtly different<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; from the indexed attribute's own type: it may be a binary-compatible<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; type instead).&nbsp; Only the default <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are stored in relcache<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; entries --- access methods can use the syscache to look up non-default<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This routine returns the requested default procedure OID for a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; particular indexed attribute.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RegProcedure<br/></li>
<li><a id="L826">&#x200c;</a><span class="linkable">index_getprocid</span>(Relation irel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16 procnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RegProcedure *loc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nproc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procindex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nproc = irel-&gt;rd_indam-&gt;amsupport;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(procnum &gt; <span class="Constant">0</span> &amp;&amp; procnum &lt;= (uint16) nproc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; procindex = (nproc * (attnum - <span class="Constant">1</span>)) + (procnum - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; loc = irel-&gt;rd_support;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(loc != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> loc[procindex];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L860" title="access/index/indexam.c:860">index_getprocinfo</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This routine allows index AMs to keep fmgr lookup info for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; support procs in the relcache.&nbsp; As above, only the &quot;default&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> particular indexed attribute are cached.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the return value points into cached data that will be lost during<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relcache rebuild!&nbsp; Therefore, either use the callinfo right away,<br/></li>
<li></span><span class="Comment"> * or save it only after having acquired some type of lock on the index rel.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>FmgrInfo *<br/></li>
<li><a id="L860">&#x200c;</a><span class="linkable">index_getprocinfo</span>(Relation irel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16 procnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *locinfo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nproc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; optsproc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procindex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nproc = irel-&gt;rd_indam-&gt;amsupport;<br/></li>
<li>&nbsp; &nbsp; optsproc = irel-&gt;rd_indam-&gt;amoptsprocnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(procnum &gt; <span class="Constant">0</span> &amp;&amp; procnum &lt;= (uint16) nproc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; procindex = (nproc * (attnum - <span class="Constant">1</span>)) + (procnum - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; locinfo = irel-&gt;rd_supportinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(locinfo != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; locinfo += procindex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the lookup info if first time through */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (locinfo-&gt;fn_oid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RegProcedure *loc = irel-&gt;rd_support;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RegProcedure procId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(loc != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; procId = loc[procindex];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Complain if function was not found during <a href="../../utils/cache/relcache.c.html#L1596" title="utils/cache/relcache.c:1596">IndexSupportInitialize</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This should not happen unless the system tables contain bogus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entries for the index opclass.&nbsp; (If an AM wants to allow a support<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function to be optional, it can use <a href="#L826" title="access/index/indexam.c:826">index_getprocid</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RegProcedureIsValid(procId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing support function </span><span class="Special">%d</span><span class="Constant"> for attribute </span><span class="Special">%d</span><span class="Constant"> of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; procnum, attnum, RelationGetRelationName(irel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(procId, locinfo, irel-&gt;rd_indexcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (procnum != optsproc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize locinfo-&gt;fn_expr with opclass options Const */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp; **attoptions = <a href="../../utils/cache/relcache.c.html#L5884" title="utils/cache/relcache.c:5884">RelationGetIndexAttOptions</a>(irel, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcxt = MemoryContextSwitchTo(irel-&gt;rd_indexcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L2070" title="utils/fmgr/fmgr.c:2070">set_fn_opclass_options</a>(locinfo, attoptions[attnum - <span class="Constant">1</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> locinfo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L928" title="access/index/indexam.c:928">index_store_float8_orderby_distances</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Convert AM distance function's results (that can be inexact)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to ORDER BY types and save them into xs_orderbyvals/xs_orderbynulls<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; for a possible recheck.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L928">&#x200c;</a></span><span class="linkable">index_store_float8_orderby_distances</span>(IndexScanDesc scan, Oid *orderByTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexOrderByDistance *distances,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recheckOrderBy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(distances || !recheckOrderBy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan-&gt;xs_recheckorderby = recheckOrderBy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; scan-&gt;numberOfOrderBys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (orderByTypes[i] == FLOAT8OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifndef USE_FLOAT8_BYVAL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must free <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> old value to avoid memory leakage */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!scan-&gt;xs_orderbynulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(scan-&gt;xs_orderbyvals[i]));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (distances &amp;&amp; !distances[i].isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;xs_orderbyvals[i] = <a href="../../utils/fmgr/fmgr.c.html#L1816" title="utils/fmgr/fmgr.c:1816">Float8GetDatum</a>(distances[i].value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;xs_orderbynulls[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;xs_orderbyvals[i] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;xs_orderbynulls[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (orderByTypes[i] == FLOAT4OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* convert distance function's result to ORDER BY type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (distances &amp;&amp; !distances[i].isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;xs_orderbyvals[i] = Float4GetDatum((float4) distances[i].value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;xs_orderbynulls[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;xs_orderbyvals[i] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;xs_orderbynulls[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the ordering operator's return value is anything else, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't know how to convert the float8 bound calculated by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * distance function to that.&nbsp; The executor won't actually need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the order by <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> we return here, if there are no lossy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * results, so only insist on converting if the *recheck flag is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;xs_recheckorderby)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;ORDER BY operator must return float8 or float4 if the distance function is lossy&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;xs_orderbynulls[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="#L996" title="access/index/indexam.c:996">index_opclass_options</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Parse opclass-specific options for index column.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>bytea *<br/></li>
<li><a id="L996">&#x200c;</a><span class="linkable">index_opclass_options</span>(Relation indrel, AttrNumber attnum, Datum attoptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> validate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; amoptsprocnum = indrel-&gt;rd_indam-&gt;amoptsprocnum;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *procinfo;<br/></li>
<li>&nbsp; &nbsp; local_relopts relopts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch options support procedure if specified */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (amoptsprocnum != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; procid = <a href="#L826" title="access/index/indexam.c:826">index_getprocid</a>(indrel, attnum, amoptsprocnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(procid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; indclassDatum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oidvector&nbsp; *indclass;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!DatumGetPointer(attoptions))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ok, no options, no procedure */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Report an error if the opclass's options-parsing procedure does not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exist but the opclass options are specified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; indclassDatum = <a href="../../utils/cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(INDEXRELID, indrel-&gt;rd_indextuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Anum_pg_index_indclass);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indclass = (oidvector *) DatumGetPointer(indclassDatum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opclass = indclass-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[attnum - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;operator class </span><span class="Special">%s</span><span class="Constant"> has no options&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/ruleutils.c.html#L12493" title="utils/adt/ruleutils.c:12493">generate_opclass_name</a>(opclass))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../common/reloptions.c.html#L734" title="access/common/reloptions.c:734">init_local_reloptions</a>(&amp;relopts, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; procinfo = <a href="#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(indrel, attnum, amoptsprocnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) FunctionCall1(procinfo, PointerGetDatum(&amp;relopts));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../common/reloptions.c.html#L1945" title="access/common/reloptions.c:1945">build_local_reloptions</a>(&amp;relopts, attoptions, validate);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
