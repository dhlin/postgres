<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/index/amvalidate.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/index/amvalidate.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L206">check_amop_signature</a></li>
<li><a href="#L192">check_amoptsproc_signature</a></li>
<li><a href="#L152">check_amproc_signature</a></li>
<li><a href="#L43">identify_opfamily_groups</a></li>
<li><a href="#L236">opclass_for_family_datatype</a></li>
<li><a href="#L271">opfamily_can_sort_type</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="amapi.c.html#L114" title="access/index/amapi.c:114">amvalidate</a>.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Support routines for index access methods' <a href="amapi.c.html#L114" title="access/index/amapi.c:114">amvalidate</a> and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; amadjustmembers <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2016-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/index/<a href="amapi.c.html#L114" title="access/index/amapi.c:114">amvalidate</a>.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/<a href="amapi.c.html#L114" title="access/index/amapi.c:114">amvalidate</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_am.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_amop.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_amproc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_opclass.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_operator.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_coerce.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L43" title="access/index/amvalidate.c:43">identify_opfamily_groups</a>() returns a List of OpFamilyOpFuncGroup structs,<br/></li>
<li></span><span class="Comment"> * one for each combination of lefttype/righttype present in the family's<br/></li>
<li></span><span class="Comment"> * operator and support function lists.&nbsp; If amopstrategy K is present for<br/></li>
<li></span><span class="Comment"> * this datatype combination, we set <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> 1 &lt;&lt; K in operatorset, and similarly<br/></li>
<li></span><span class="Comment"> * for the support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; With uint64 fields we can handle operator and<br/></li>
<li></span><span class="Comment"> * function numbers up to 63, which is plenty for the foreseeable future.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The given CatCLists are expected to represent a single opfamily fetched<br/></li>
<li></span><span class="Comment"> * from the AMOPSTRATEGY and AMPROCNUM caches, so that they will be in<br/></li>
<li></span><span class="Comment"> * order by those caches' second and third cache keys, namely the datatypes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L43">&#x200c;</a><span class="linkable">identify_opfamily_groups</span>(CatCList *oprlist, CatCList *proclist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; OpFamilyOpFuncGroup *thisgroup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_amop oprform;<br/></li>
<li>&nbsp; &nbsp; Form_pg_amproc procform;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ip;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need the lists to be ordered; should be true in normal operation */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!oprlist-&gt;ordered || !proclist-&gt;ordered)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot validate operator family without ordered data&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advance through the lists concurrently.&nbsp; Thanks to the ordering, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should see all operators and <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> of a given datatype pair<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consecutively.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; thisgroup = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; io = ip = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (io &lt; oprlist-&gt;n_members)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oprform = (Form_pg_amop) GETSTRUCT(&amp;oprlist-&gt;members[io]-&gt;tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oprform = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ip &lt; proclist-&gt;n_members)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; procform = (Form_pg_amproc) GETSTRUCT(&amp;proclist-&gt;members[ip]-&gt;tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ip++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; procform = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (oprform || procform)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oprform &amp;&amp; thisgroup &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oprform-&gt;amoplefttype == thisgroup-&gt;lefttype &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oprform-&gt;amoprighttype == thisgroup-&gt;righttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Operator belongs to current group; include it and advance */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore strategy numbers outside supported <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oprform-&gt;amopstrategy &gt; <span class="Constant">0</span> &amp;&amp; oprform-&gt;amopstrategy &lt; <span class="Constant">64</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisgroup-&gt;operatorset |= ((uint64) <span class="Constant">1</span>) &lt;&lt; oprform-&gt;amopstrategy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (io &lt; oprlist-&gt;n_members)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oprform = (Form_pg_amop) GETSTRUCT(&amp;oprlist-&gt;members[io]-&gt;tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oprform = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (procform &amp;&amp; thisgroup &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procform-&gt;amproclefttype == thisgroup-&gt;lefttype &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procform-&gt;amprocrighttype == thisgroup-&gt;righttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Procedure belongs to current group; include it and advance */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore function numbers outside supported <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (procform-&gt;amprocnum &gt; <span class="Constant">0</span> &amp;&amp; procform-&gt;amprocnum &lt; <span class="Constant">64</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisgroup-&gt;functionset |= ((uint64) <span class="Constant">1</span>) &lt;&lt; procform-&gt;amprocnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ip &lt; proclist-&gt;n_members)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procform = (Form_pg_amproc) GETSTRUCT(&amp;proclist-&gt;members[ip]-&gt;tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ip++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procform = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Time for a new group */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; thisgroup = (OpFamilyOpFuncGroup *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OpFamilyOpFuncGroup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oprform &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (!procform ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (oprform-&gt;amoplefttype &lt; procform-&gt;amproclefttype ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (oprform-&gt;amoplefttype == procform-&gt;amproclefttype &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oprform-&gt;amoprighttype &lt; procform-&gt;amprocrighttype))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisgroup-&gt;lefttype = oprform-&gt;amoplefttype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisgroup-&gt;righttype = oprform-&gt;amoprighttype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisgroup-&gt;lefttype = procform-&gt;amproclefttype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisgroup-&gt;righttype = procform-&gt;amprocrighttype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; thisgroup-&gt;operatorset = thisgroup-&gt;functionset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, thisgroup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Validate the signature (argument and result types) of an opclass support<br/></li>
<li></span><span class="Comment"> * function.&nbsp; Return true if OK, false if not.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The &quot;...&quot; represents maxargs argument-type OIDs.&nbsp; If &quot;exact&quot; is true, they<br/></li>
<li></span><span class="Comment"> * must match the function arg types exactly, else only binary-coercibly.<br/></li>
<li></span><span class="Comment"> * In <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case the function result type must match restype exactly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L152">&#x200c;</a></span><span class="linkable">check_amproc_signature</span>(Oid funcid, Oid restype, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> exact,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> minargs, <span class="Type">int</span> maxargs,...)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_proc procform;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">va_list</span>&nbsp; &nbsp; &nbsp; &nbsp; ap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="../../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(funcid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for function </span><span class="Special">%u</span><span class="Constant">&quot;</span>, funcid);<br/></li>
<li>&nbsp; &nbsp; procform = (Form_pg_proc) GETSTRUCT(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (procform-&gt;prorettype != restype || procform-&gt;proretset ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; procform-&gt;pronargs &lt; minargs || procform-&gt;pronargs &gt; maxargs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; va_start(ap, maxargs);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; maxargs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argtype = va_arg(ap, Oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= procform-&gt;pronargs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (exact ? (argtype != procform-&gt;proargtypes.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../parser/parse_coerce.c.html#L2995" title="parser/parse_coerce.c:2995">IsBinaryCoercible</a>(argtype, procform-&gt;proargtypes.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; va_end(ap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Validate the signature of an opclass options support function, that should<br/></li>
<li></span><span class="Comment"> * be 'void(<a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>)'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L192">&#x200c;</a></span><span class="linkable">check_amoptsproc_signature</span>(Oid funcid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L152" title="access/index/amvalidate.c:152">check_amproc_signature</a>(funcid, VOIDOID, <span class="Constant">true</span>, <span class="Constant">1</span>, <span class="Constant">1</span>, INTERNALOID);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Validate the signature (argument and result types) of an opclass operator.<br/></li>
<li></span><span class="Comment"> * Return true if OK, false if not.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently, we can hard-wire this as accepting only binary operators.&nbsp; Also,<br/></li>
<li></span><span class="Comment"> * we can insist on exact type matches, since the given lefttype/righttype<br/></li>
<li></span><span class="Comment"> * come from pg_amop and should always match the operator exactly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L206">&#x200c;</a></span><span class="linkable">check_amop_signature</span>(Oid opno, Oid restype, Oid lefttype, Oid righttype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_operator opform;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = <a href="../../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(OPEROID, ObjectIdGetDatum(opno));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))&nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for operator </span><span class="Special">%u</span><span class="Constant">&quot;</span>, opno);<br/></li>
<li>&nbsp; &nbsp; opform = (Form_pg_operator) GETSTRUCT(tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (opform-&gt;oprresult != restype || opform-&gt;oprkind != <span class="Constant">'b'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opform-&gt;oprleft != lefttype || opform-&gt;oprright != righttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the OID of the opclass belonging to an opfamily and accepting<br/></li>
<li></span><span class="Comment"> * the specified type as input type.&nbsp; Returns InvalidOid if no such opclass.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there is more than one such opclass, you get a random one of them.<br/></li>
<li></span><span class="Comment"> * Since that shouldn't happen, we don't waste cycles checking.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We could look up the AM's OID from the opfamily, but all existing callers<br/></li>
<li></span><span class="Comment"> * know that or can get it without an extra lookup, so we make them pass it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L236">&#x200c;</a><span class="linkable">opclass_for_family_datatype</span>(Oid amoid, Oid opfamilyoid, Oid datatypeoid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; CatCList&nbsp;&nbsp; *opclist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We search through all the AM's opclasses to see if one matches.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> inefficient but there is no better index available.&nbsp; It also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * saves making an explicit check that the opfamily belongs to the AM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; opclist = SearchSysCacheList1(CLAAMNAMENSP, ObjectIdGetDatum(amoid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; opclist-&gt;n_members; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; classtup = &amp;opclist-&gt;members[i]-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_opclass classform = (Form_pg_opclass) GETSTRUCT(classtup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (classform-&gt;opcfamily == opfamilyoid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classform-&gt;opcintype == datatypeoid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = classform-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/cache/catcache.c.html#L1986" title="utils/cache/catcache.c:1986">ReleaseCatCacheList</a>(opclist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Is the datatype a legitimate input type for the btree opfamily?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L271">&#x200c;</a></span><span class="linkable">opfamily_can_sort_type</span>(Oid opfamilyoid, Oid datatypeoid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> OidIsValid(<a href="#L236" title="access/index/amvalidate.c:236">opclass_for_family_datatype</a>(BTREE_AM_OID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamilyoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datatypeoid));<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
