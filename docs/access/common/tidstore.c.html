<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/common/tidstore.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/common/tidstore.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L44">BlocktableEntry</a></li>
<li><a href="#L77">BlocktableEntry</a></li>
<li><a href="#L114">TidStore</a></li>
<li><a href="#L135">TidStoreIter</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L255">TidStoreAttach</a></li>
<li><a href="#L482">TidStoreBeginIterate</a></li>
<li><a href="#L165">TidStoreCreateLocal</a></li>
<li><a href="#L213">TidStoreCreateShared</a></li>
<li><a href="#L328">TidStoreDestroy</a></li>
<li><a href="#L280">TidStoreDetach</a></li>
<li><a href="#L536">TidStoreEndIterate</a></li>
<li><a href="#L563">TidStoreGetDSA</a></li>
<li><a href="#L571">TidStoreGetHandle</a></li>
<li><a href="#L432">TidStoreIsMember</a></li>
<li><a href="#L511">TidStoreIterateNext</a></li>
<li><a href="#L298">TidStoreLockExclusive</a></li>
<li><a href="#L305">TidStoreLockShare</a></li>
<li><a href="#L551">TidStoreMemoryUsage</a></li>
<li><a href="#L356">TidStoreSetBlockOffsets</a></li>
<li><a href="#L312">TidStoreUnlock</a></li>
<li><a href="#L580">tidstore_iter_extract_tids</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L32">BITNUM</a></li>
<li><a href="#L84">MAX_OFFSET_IN_BITMAP</a></li>
<li><a href="#L86">MaxBlocktableEntrySize</a></li>
<li><a href="#L38">NUM_FULL_OFFSETS</a></li>
<li><a href="#L92">RT_DECLARE</a></li>
<li><a href="#L104">RT_DECLARE</a></li>
<li><a href="#L93">RT_DEFINE</a></li>
<li><a href="#L105">RT_DEFINE</a></li>
<li><a href="#L90">RT_PREFIX</a></li>
<li><a href="#L101">RT_PREFIX</a></li>
<li><a href="#L98">RT_RUNTIME_EMBEDDABLE_VALUE</a></li>
<li><a href="#L110">RT_RUNTIME_EMBEDDABLE_VALUE</a></li>
<li><a href="#L91">RT_SCOPE</a></li>
<li><a href="#L103">RT_SCOPE</a></li>
<li><a href="#L102">RT_SHMEM</a></li>
<li><a href="#L94">RT_VALUE_TYPE</a></li>
<li><a href="#L106">RT_VALUE_TYPE</a></li>
<li><a href="#L95">RT_VARLEN_VALUE_SIZE</a></li>
<li><a href="#L107">RT_VARLEN_VALUE_SIZE</a></li>
<li><a href="#L132">TidStoreIsShared</a></li>
<li><a href="#L31">WORDNUM</a></li>
<li><a href="#L35">WORDS_PER_PAGE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tidstore.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; TID (ItemPointerData) storage implementation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L114" title="access/common/tidstore.c:114">TidStore</a> is a in-memory data structure to store TIDs (ItemPointerData).<br/></li>
<li></span><span class="Comment"> * Internally it uses a radix tree as the storage for TIDs. The key is the<br/></li>
<li></span><span class="Comment"> * BlockNumber and the value is a bitmap of offsets, <a href="#L44" title="access/common/tidstore.c:44">BlocktableEntry</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L114" title="access/common/tidstore.c:114">TidStore</a> can be shared among parallel worker processes by using<br/></li>
<li></span><span class="Comment"> * <a href="#L213" title="access/common/tidstore.c:213">TidStoreCreateShared</a>(). Other backends can attach to the shared <a href="#L114" title="access/common/tidstore.c:114">TidStore</a><br/></li>
<li></span><span class="Comment"> * by <a href="#L255" title="access/common/tidstore.c:255">TidStoreAttach</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/common/tidstore.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/tidstore.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/bitmapset.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lwlock.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/dsa.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L31">&#x200c;</a><span class="PreProc">#define <span class="linkable">WORDNUM</span>(x)&nbsp; &nbsp; ((x) / BITS_PER_BITMAPWORD)<br/></li>
<li><a id="L32">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BITNUM</span>(x)&nbsp; &nbsp; ((x) % BITS_PER_BITMAPWORD)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* number of active words for a page: */<br/></li>
<li><a id="L35">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WORDS_PER_PAGE</span>(n) ((n) / BITS_PER_BITMAPWORD + </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* number of offsets we can store in the header of a <a href="#L44" title="access/common/tidstore.c:44">BlocktableEntry</a> */<br/></li>
<li><a id="L38">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUM_FULL_OFFSETS</span> ((</span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(</span><span class="Type">uintptr_t</span><span class="PreProc">) - </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(uint8) - </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(int8)) / </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(OffsetNumber))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This is named similarly to <a href="../../nodes/tidbitmap.c.html#L100" title="nodes/tidbitmap.c:100">PagetableEntry</a> in tidbitmap.c<br/></li>
<li></span><span class="Comment"> * because the two have a similar function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L44">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BlocktableEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifndef WORDS_BIGENDIAN<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to position this member to reserve space for the backing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * radix tree to tag the lowest <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> when struct 'header' is stored<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inside a pointer or DSA pointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int8&nbsp; &nbsp; &nbsp; &nbsp; nwords;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can store a small number of offsets here to avoid wasting space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with a sparse bitmap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber full_offsets[<a href="#L38" title="access/common/tidstore.c:38">NUM_FULL_OFFSETS</a>];<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WORDS_BIGENDIAN<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; int8&nbsp; &nbsp; &nbsp; &nbsp; nwords;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; header;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't expect <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> padding space here, but to be cautious, code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * creating new entries should zero out space up to 'words'.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; bitmapword&nbsp; &nbsp; words[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L77">&#x200c;</a>} <span class="linkable">BlocktableEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The type of 'nwords' limits the max number of words in the 'words' array.<br/></li>
<li></span><span class="Comment"> * This computes the max offset we can actually store in the bitmap. In<br/></li>
<li></span><span class="Comment"> * practice, it's almost always the same as MaxOffsetNumber.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L84">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_OFFSET_IN_BITMAP</span> <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(BITS_PER_BITMAPWORD * PG_INT8_MAX - </span><span class="Constant">1</span><span class="PreProc">, MaxOffsetNumber)<br/></li>
<li></span><br/></li>
<li><a id="L86">&#x200c;</a><span class="PreProc">#define <span class="linkable">MaxBlocktableEntrySize</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; offsetof(<a href="#L44" title="access/common/tidstore.c:44">BlocktableEntry</a>, words) + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; (</span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(bitmapword) * <a href="#L35" title="access/common/tidstore.c:35">WORDS_PER_PAGE</a>(<a href="#L84" title="access/common/tidstore.c:84">MAX_OFFSET_IN_BITMAP</a>))<br/></li>
<li></span><br/></li>
<li><a id="L90">&#x200c;</a><span class="PreProc">#define <span class="linkable">RT_PREFIX</span> local_ts<br/></li>
<li><a id="L91">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RT_SCOPE</span> </span><span class="Type">static<br/></li>
<li><a id="L92">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RT_DECLARE</span><br/></li>
<li><a id="L93">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RT_DEFINE</span><br/></li>
<li><a id="L94">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RT_VALUE_TYPE</span> <a href="#L44" title="access/common/tidstore.c:44">BlocktableEntry</a><br/></li>
<li><a id="L95">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RT_VARLEN_VALUE_SIZE</span>(page) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (offsetof(<a href="#L44" title="access/common/tidstore.c:44">BlocktableEntry</a>, words) + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(bitmapword) * (page)-&gt;header.nwords)<br/></li>
<li><a id="L98">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RT_RUNTIME_EMBEDDABLE_VALUE</span><br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/radixtree.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L101">&#x200c;</a><span class="PreProc">#define <span class="linkable">RT_PREFIX</span> shared_ts<br/></li>
<li><a id="L102">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RT_SHMEM</span><br/></li>
<li><a id="L103">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RT_SCOPE</span> </span><span class="Type">static<br/></li>
<li><a id="L104">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RT_DECLARE</span><br/></li>
<li><a id="L105">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RT_DEFINE</span><br/></li>
<li><a id="L106">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RT_VALUE_TYPE</span> <a href="#L44" title="access/common/tidstore.c:44">BlocktableEntry</a><br/></li>
<li><a id="L107">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RT_VARLEN_VALUE_SIZE</span>(page) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (offsetof(<a href="#L44" title="access/common/tidstore.c:44">BlocktableEntry</a>, words) + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(bitmapword) * (page)-&gt;header.nwords)<br/></li>
<li><a id="L110">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RT_RUNTIME_EMBEDDABLE_VALUE</span><br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/radixtree.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Per-backend state for a <a href="#L114" title="access/common/tidstore.c:114">TidStore</a> */<br/></li>
<li><a id="L114">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">TidStore</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* MemoryContext where the <a href="#L114" title="access/common/tidstore.c:114">TidStore</a> is allocated */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* MemoryContext that the radix tree uses */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext rt_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Storage for TIDs. Use either one depending on <a href="#L132" title="access/common/tidstore.c:132">TidStoreIsShared</a>() */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">union<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_ts_radix_tree *local;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared_ts_radix_tree *shared;<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tree;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* DSA area for <a href="#L114" title="access/common/tidstore.c:114">TidStore</a> if using shared memory */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a>&nbsp;&nbsp; *area;<br/></li>
<li>};<br/></li>
<li><a id="L132">&#x200c;</a><span class="PreProc">#define <span class="linkable">TidStoreIsShared</span>(ts) ((ts)-&gt;area != </span><span class="Constant">NULL</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Iterator for <a href="#L114" title="access/common/tidstore.c:114">TidStore</a> */<br/></li>
<li><a id="L135">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">TidStoreIter</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L114" title="access/common/tidstore.c:114">TidStore</a>&nbsp;&nbsp; *ts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* iterator of radix tree. Use either one depending on <a href="#L132" title="access/common/tidstore.c:132">TidStoreIsShared</a>() */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">union<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared_ts_iter *shared;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; local_ts_iter *local;<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tree_iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* output for the caller */<br/></li>
<li></span>&nbsp; &nbsp; TidStoreIterResult output;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L580" title="access/common/tidstore.c:580">tidstore_iter_extract_tids</a>(<a href="#L135" title="access/common/tidstore.c:135">TidStoreIter</a> *iter, BlockNumber blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L44" title="access/common/tidstore.c:44">BlocktableEntry</a> *page);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a <a href="#L114" title="access/common/tidstore.c:114">TidStore</a>. The <a href="#L114" title="access/common/tidstore.c:114">TidStore</a> will live in the memory context that is<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> at the time of this call. The TID storage, backed<br/></li>
<li></span><span class="Comment"> * by a radix tree, will live in its child memory context, rt_context.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;max_bytes&quot; is not an internally-enforced limit; it is used only as a<br/></li>
<li></span><span class="Comment"> * hint to cap the memory block size of the memory context for TID storage.<br/></li>
<li></span><span class="Comment"> * This reduces space wastage due to over-allocation. If the caller wants to<br/></li>
<li></span><span class="Comment"> * monitor memory usage, it must <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> its limit with the value reported<br/></li>
<li></span><span class="Comment"> * by <a href="#L551" title="access/common/tidstore.c:551">TidStoreMemoryUsage</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L114" title="access/common/tidstore.c:114">TidStore</a> *<br/></li>
<li><a id="L165">&#x200c;</a><span class="linkable">TidStoreCreateLocal</span>(<span class="Type">size_t</span> max_bytes, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> insert_only)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L114" title="access/common/tidstore.c:114">TidStore</a>&nbsp;&nbsp; *ts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; initBlockSize = ALLOCSET_DEFAULT_INITSIZE;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; minContextSize = ALLOCSET_DEFAULT_MINSIZE;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; maxBlockSize = ALLOCSET_DEFAULT_MAXSIZE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ts = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L114" title="access/common/tidstore.c:114">TidStore</a>));<br/></li>
<li>&nbsp; &nbsp; ts-&gt;context = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* choose the maxBlockSize to be no larger than 1/16 of max_bytes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">16</span> * maxBlockSize &gt; max_bytes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxBlockSize &gt;&gt;= <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (maxBlockSize &lt; ALLOCSET_DEFAULT_INITSIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxBlockSize = ALLOCSET_DEFAULT_INITSIZE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a memory context for the TID storage */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (insert_only)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ts-&gt;rt_context = <a href="../../utils/mmgr/bump.c.html#L131" title="utils/mmgr/bump.c:131">BumpContextCreate</a>(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;TID storage&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; minContextSize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; initBlockSize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; maxBlockSize);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ts-&gt;rt_context = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;TID storage&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; minContextSize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; initBlockSize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; maxBlockSize);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ts-&gt;tree.local = local_ts_create(ts-&gt;rt_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ts;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Similar to <a href="#L165" title="access/common/tidstore.c:165">TidStoreCreateLocal</a>() but create a shared <a href="#L114" title="access/common/tidstore.c:114">TidStore</a> on a<br/></li>
<li></span><span class="Comment"> * DSA area. The TID storage will live in the DSA area, and the memory<br/></li>
<li></span><span class="Comment"> * context rt_context will have only meta data of the radix tree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned object is allocated in backend-local memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L114" title="access/common/tidstore.c:114">TidStore</a> *<br/></li>
<li><a id="L213">&#x200c;</a><span class="linkable">TidStoreCreateShared</span>(<span class="Type">size_t</span> max_bytes, <span class="Type">int</span> tranche_id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L114" title="access/common/tidstore.c:114">TidStore</a>&nbsp;&nbsp; *ts;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a>&nbsp;&nbsp; *area;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; dsa_init_size = DSA_DEFAULT_INIT_SEGMENT_SIZE;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; dsa_max_size = DSA_MAX_SEGMENT_SIZE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ts = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L114" title="access/common/tidstore.c:114">TidStore</a>));<br/></li>
<li>&nbsp; &nbsp; ts-&gt;context = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ts-&gt;rt_context = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;TID storage meta data&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Choose the initial and maximum DSA segment sizes to be no longer than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 1/8 of max_bytes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">8</span> * dsa_max_size &gt; max_bytes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dsa_max_size &gt;&gt;= <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dsa_max_size &lt; DSA_MIN_SEGMENT_SIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dsa_max_size = DSA_MIN_SEGMENT_SIZE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dsa_init_size &gt; dsa_max_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dsa_init_size = dsa_max_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; area = <a href="../../utils/mmgr/dsa.c.html#L421" title="utils/mmgr/dsa.c:421">dsa_create_ext</a>(tranche_id, dsa_init_size, dsa_max_size);<br/></li>
<li>&nbsp; &nbsp; ts-&gt;tree.shared = shared_ts_create(ts-&gt;rt_context, area,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tranche_id);<br/></li>
<li>&nbsp; &nbsp; ts-&gt;area = area;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ts;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attach to the shared <a href="#L114" title="access/common/tidstore.c:114">TidStore</a>. 'area_handle' is the DSA handle where<br/></li>
<li></span><span class="Comment"> * the <a href="#L114" title="access/common/tidstore.c:114">TidStore</a> is created. 'handle' is the dsa_pointer returned by<br/></li>
<li></span><span class="Comment"> * <a href="#L571" title="access/common/tidstore.c:571">TidStoreGetHandle</a>(). The returned object is allocated in backend-local<br/></li>
<li></span><span class="Comment"> * memory using the <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L114" title="access/common/tidstore.c:114">TidStore</a> *<br/></li>
<li><a id="L255">&#x200c;</a><span class="linkable">TidStoreAttach</span>(dsa_handle area_handle, dsa_pointer handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L114" title="access/common/tidstore.c:114">TidStore</a>&nbsp;&nbsp; *ts;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a>&nbsp;&nbsp; *area;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(area_handle != DSA_HANDLE_INVALID);<br/></li>
<li>&nbsp; &nbsp; Assert(DsaPointerIsValid(handle));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* create per-backend state */<br/></li>
<li></span>&nbsp; &nbsp; ts = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L114" title="access/common/tidstore.c:114">TidStore</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; area = <a href="../../utils/mmgr/dsa.c.html#L510" title="utils/mmgr/dsa.c:510">dsa_attach</a>(area_handle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the shared the shared radix tree */<br/></li>
<li></span>&nbsp; &nbsp; ts-&gt;tree.shared = shared_ts_attach(area, handle);<br/></li>
<li>&nbsp; &nbsp; ts-&gt;area = area;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ts;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Detach from a <a href="#L114" title="access/common/tidstore.c:114">TidStore</a>. This also detaches from radix tree and frees<br/></li>
<li></span><span class="Comment"> * the backend-local resources.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L280">&#x200c;</a></span><span class="linkable">TidStoreDetach</span>(<a href="#L114" title="access/common/tidstore.c:114">TidStore</a> *ts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L132" title="access/common/tidstore.c:132">TidStoreIsShared</a>(ts));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; shared_ts_detach(ts-&gt;tree.shared);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/dsa.c.html#L1952" title="utils/mmgr/dsa.c:1952">dsa_detach</a>(ts-&gt;area);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Lock support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can use the radix tree's lock for shared <a href="#L114" title="access/common/tidstore.c:114">TidStore</a> as the data we<br/></li>
<li></span><span class="Comment"> * need to protect is only the shared radix tree.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L298">&#x200c;</a></span><span class="linkable">TidStoreLockExclusive</span>(<a href="#L114" title="access/common/tidstore.c:114">TidStore</a> *ts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L132" title="access/common/tidstore.c:132">TidStoreIsShared</a>(ts))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared_ts_lock_exclusive(ts-&gt;tree.shared);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L305">&#x200c;</a></span><span class="linkable">TidStoreLockShare</span>(<a href="#L114" title="access/common/tidstore.c:114">TidStore</a> *ts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L132" title="access/common/tidstore.c:132">TidStoreIsShared</a>(ts))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared_ts_lock_share(ts-&gt;tree.shared);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L312">&#x200c;</a></span><span class="linkable">TidStoreUnlock</span>(<a href="#L114" title="access/common/tidstore.c:114">TidStore</a> *ts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L132" title="access/common/tidstore.c:132">TidStoreIsShared</a>(ts))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared_ts_unlock(ts-&gt;tree.shared);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Destroy a <a href="#L114" title="access/common/tidstore.c:114">TidStore</a>, returning all memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the caller must be certain that no other backend will attempt to<br/></li>
<li></span><span class="Comment"> * access the <a href="#L114" title="access/common/tidstore.c:114">TidStore</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling this function. Other backend must<br/></li>
<li></span><span class="Comment"> * explicitly call <a href="#L280" title="access/common/tidstore.c:280">TidStoreDetach</a>() to free up backend-local memory associated<br/></li>
<li></span><span class="Comment"> * with the <a href="#L114" title="access/common/tidstore.c:114">TidStore</a>. The backend that calls <a href="#L328" title="access/common/tidstore.c:328">TidStoreDestroy</a>() must not call<br/></li>
<li></span><span class="Comment"> * <a href="#L280" title="access/common/tidstore.c:280">TidStoreDetach</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L328">&#x200c;</a></span><span class="linkable">TidStoreDestroy</span>(<a href="#L114" title="access/common/tidstore.c:114">TidStore</a> *ts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Destroy underlying radix tree */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L132" title="access/common/tidstore.c:132">TidStoreIsShared</a>(ts))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared_ts_free(ts-&gt;tree.shared);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/dsa.c.html#L1952" title="utils/mmgr/dsa.c:1952">dsa_detach</a>(ts-&gt;area);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; local_ts_free(ts-&gt;tree.local);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(ts-&gt;rt_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create or replace an entry for the given block and array of offsets.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: This function is designed and optimized for <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>'s heap scanning<br/></li>
<li></span><span class="Comment"> * phase, so has some limitations:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * - The offset numbers &quot;offsets&quot; must be sorted in ascending order.<br/></li>
<li></span><span class="Comment"> * - If the block number already exists, the entry will be replaced --<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; there is no way to add or remove offsets from an entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L356">&#x200c;</a></span><span class="linkable">TidStoreSetBlockOffsets</span>(<a href="#L114" title="access/common/tidstore.c:114">TidStore</a> *ts, BlockNumber blkno, OffsetNumber *offsets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> num_offsets)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">union<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; data[<a href="#L86" title="access/common/tidstore.c:86">MaxBlocktableEntrySize</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="access/common/tidstore.c:44">BlocktableEntry</a> force_align_entry;<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L44" title="access/common/tidstore.c:44">BlocktableEntry</a> *page = (<a href="#L44" title="access/common/tidstore.c:44">BlocktableEntry</a> *) data.data;<br/></li>
<li>&nbsp; &nbsp; bitmapword&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_word_threshold;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(num_offsets &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if the given offset numbers are ordered */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">1</span>; i &lt; num_offsets; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(offsets[i] &gt; offsets[i - <span class="Constant">1</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(page, <span class="Constant">0</span>, offsetof(<a href="#L44" title="access/common/tidstore.c:44">BlocktableEntry</a>, words));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (num_offsets &lt;= <a href="#L38" title="access/common/tidstore.c:38">NUM_FULL_OFFSETS</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; num_offsets; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber off = offsets[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* safety check to ensure we don't overrun <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> array bounds */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (off == InvalidOffsetNumber || off &gt; <a href="#L84" title="access/common/tidstore.c:84">MAX_OFFSET_IN_BITMAP</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;tuple offset out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">%u</span><span class="Constant">&quot;</span>, off);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page-&gt;header.full_offsets[i] = off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page-&gt;header.nwords = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (wordnum = <span class="Constant">0</span>, next_word_threshold = BITS_PER_BITMAPWORD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wordnum &lt;= <a href="#L31" title="access/common/tidstore.c:31">WORDNUM</a>(offsets[num_offsets - <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wordnum++, next_word_threshold += BITS_PER_BITMAPWORD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (idx &lt; num_offsets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber off = offsets[idx];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* safety check to ensure we don't overrun <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> array bounds */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (off == InvalidOffsetNumber || off &gt; <a href="#L84" title="access/common/tidstore.c:84">MAX_OFFSET_IN_BITMAP</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;tuple offset out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">%u</span><span class="Constant">&quot;</span>, off);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (off &gt;= next_word_threshold)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> |= ((bitmapword) <span class="Constant">1</span> &lt;&lt; <a href="#L32" title="access/common/tidstore.c:32">BITNUM</a>(off));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* write out offset bitmap for this wordnum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page-&gt;words[wordnum] = <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page-&gt;header.nwords = wordnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(page-&gt;header.nwords == <a href="#L35" title="access/common/tidstore.c:35">WORDS_PER_PAGE</a>(offsets[num_offsets - <span class="Constant">1</span>]));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L132" title="access/common/tidstore.c:132">TidStoreIsShared</a>(ts))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared_ts_set(ts-&gt;tree.shared, blkno, page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; local_ts_set(ts-&gt;tree.local, blkno, page);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Return true if the given TID is present in the <a href="#L114" title="access/common/tidstore.c:114">TidStore</a> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L432">&#x200c;</a></span><span class="linkable">TidStoreIsMember</span>(<a href="#L114" title="access/common/tidstore.c:114">TidStore</a> *ts, ItemPointer tid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitnum;<br/></li>
<li>&nbsp; &nbsp; <a href="#L44" title="access/common/tidstore.c:44">BlocktableEntry</a> *page;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blk = ItemPointerGetBlockNumber(tid);<br/></li>
<li>&nbsp; &nbsp; OffsetNumber off = ItemPointerGetOffsetNumber(tid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L132" title="access/common/tidstore.c:132">TidStoreIsShared</a>(ts))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = shared_ts_find(ts-&gt;tree.shared, blk);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; page = local_ts_find(ts-&gt;tree.local, blk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no entry for the blk */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (page == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (page-&gt;header.nwords == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we have offsets in the header */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="#L38" title="access/common/tidstore.c:38">NUM_FULL_OFFSETS</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (page-&gt;header.full_offsets[i] == off)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wordnum = <a href="#L31" title="access/common/tidstore.c:31">WORDNUM</a>(off);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitnum = <a href="#L32" title="access/common/tidstore.c:32">BITNUM</a>(off);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no bitmap for the off */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wordnum &gt;= page-&gt;header.nwords)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (page-&gt;words[wordnum] &amp; ((bitmapword) <span class="Constant">1</span> &lt;&lt; bitnum)) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare to iterate through a <a href="#L114" title="access/common/tidstore.c:114">TidStore</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="#L135" title="access/common/tidstore.c:135">TidStoreIter</a> struct is created in the caller's memory context, and it<br/></li>
<li></span><span class="Comment"> * will be freed in <a href="#L536" title="access/common/tidstore.c:536">TidStoreEndIterate</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller is responsible for locking <a href="#L114" title="access/common/tidstore.c:114">TidStore</a> until the iteration is<br/></li>
<li></span><span class="Comment"> * finished.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L135" title="access/common/tidstore.c:135">TidStoreIter</a> *<br/></li>
<li><a id="L482">&#x200c;</a><span class="linkable">TidStoreBeginIterate</span>(<a href="#L114" title="access/common/tidstore.c:114">TidStore</a> *ts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L135" title="access/common/tidstore.c:135">TidStoreIter</a> *iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; iter = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L135" title="access/common/tidstore.c:135">TidStoreIter</a>));<br/></li>
<li>&nbsp; &nbsp; iter-&gt;ts = ts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We start with an array large enough to contain at least the offsets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from one completely full bitmap <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; iter-&gt;output.max_offset = <span class="Constant">2</span> * BITS_PER_BITMAPWORD;<br/></li>
<li>&nbsp; &nbsp; iter-&gt;output.offsets = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber) * iter-&gt;output.max_offset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L132" title="access/common/tidstore.c:132">TidStoreIsShared</a>(ts))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iter-&gt;tree_iter.shared = shared_ts_begin_iterate(ts-&gt;tree.shared);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; iter-&gt;tree_iter.local = local_ts_begin_iterate(ts-&gt;tree.local);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> iter;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Scan the <a href="#L114" title="access/common/tidstore.c:114">TidStore</a> and return the TIDs of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block. The offsets in<br/></li>
<li></span><span class="Comment"> * each iteration result are ordered, as are the block numbers over all<br/></li>
<li></span><span class="Comment"> * iterations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TidStoreIterResult *<br/></li>
<li><a id="L511">&#x200c;</a><span class="linkable">TidStoreIterateNext</span>(<a href="#L135" title="access/common/tidstore.c:135">TidStoreIter</a> *iter)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; key;<br/></li>
<li>&nbsp; &nbsp; <a href="#L44" title="access/common/tidstore.c:44">BlocktableEntry</a> *page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L132" title="access/common/tidstore.c:132">TidStoreIsShared</a>(iter-&gt;ts))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = shared_ts_iterate_next(iter-&gt;tree_iter.shared, &amp;key);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; page = local_ts_iterate_next(iter-&gt;tree_iter.local, &amp;key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (page == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Collect TIDs from the key-value pair */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L580" title="access/common/tidstore.c:580">tidstore_iter_extract_tids</a>(iter, (BlockNumber) key, page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;(iter-&gt;output);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Finish the iteration on <a href="#L114" title="access/common/tidstore.c:114">TidStore</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller is responsible for releasing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> locks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L536">&#x200c;</a></span><span class="linkable">TidStoreEndIterate</span>(<a href="#L135" title="access/common/tidstore.c:135">TidStoreIter</a> *iter)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L132" title="access/common/tidstore.c:132">TidStoreIsShared</a>(iter-&gt;ts))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared_ts_end_iterate(iter-&gt;tree_iter.shared);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; local_ts_end_iterate(iter-&gt;tree_iter.local);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(iter-&gt;output.offsets);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(iter);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the memory usage of <a href="#L114" title="access/common/tidstore.c:114">TidStore</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">size_t<br/></li>
<li><a id="L551">&#x200c;</a></span><span class="linkable">TidStoreMemoryUsage</span>(<a href="#L114" title="access/common/tidstore.c:114">TidStore</a> *ts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L132" title="access/common/tidstore.c:132">TidStoreIsShared</a>(ts))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> shared_ts_memory_usage(ts-&gt;tree.shared);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> local_ts_memory_usage(ts-&gt;tree.local);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the DSA area where the <a href="#L114" title="access/common/tidstore.c:114">TidStore</a> lives.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="../../utils/mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *<br/></li>
<li><a id="L563">&#x200c;</a><span class="linkable">TidStoreGetDSA</span>(<a href="#L114" title="access/common/tidstore.c:114">TidStore</a> *ts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L132" title="access/common/tidstore.c:132">TidStoreIsShared</a>(ts));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ts-&gt;area;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>dsa_pointer<br/></li>
<li><a id="L571">&#x200c;</a><span class="linkable">TidStoreGetHandle</span>(<a href="#L114" title="access/common/tidstore.c:114">TidStore</a> *ts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L132" title="access/common/tidstore.c:132">TidStoreIsShared</a>(ts));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (dsa_pointer) shared_ts_get_handle(ts-&gt;tree.shared);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Extract TIDs from the given key-value pair */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L580">&#x200c;</a></span><span class="linkable">tidstore_iter_extract_tids</span>(<a href="#L135" title="access/common/tidstore.c:135">TidStoreIter</a> *iter, BlockNumber blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L44" title="access/common/tidstore.c:44">BlocktableEntry</a> *page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TidStoreIterResult *result = (&amp;iter-&gt;output);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wordnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;num_offsets = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;blkno = blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (page-&gt;header.nwords == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we have offsets in the header */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="#L38" title="access/common/tidstore.c:38">NUM_FULL_OFFSETS</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (page-&gt;header.full_offsets[i] != InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;offsets[result-&gt;num_offsets++] = page-&gt;header.full_offsets[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (wordnum = <span class="Constant">0</span>; wordnum &lt; page-&gt;header.nwords; wordnum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmapword&nbsp; &nbsp; w = page-&gt;words[wordnum];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off = wordnum * BITS_PER_BITMAPWORD;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure there is enough space to add offsets */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((result-&gt;num_offsets + BITS_PER_BITMAPWORD) &gt; result-&gt;max_offset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;max_offset *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;offsets = <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(result-&gt;offsets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber) * result-&gt;max_offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (w != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (w &amp; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;offsets[result-&gt;num_offsets++] = (OffsetNumber) off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w &gt;&gt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
