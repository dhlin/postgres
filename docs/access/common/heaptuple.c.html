<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/common/heaptuple.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/common/heaptuple.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L97">missing_cache</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L95">missing_cache_key</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L828">expand_tuple</a></li>
<li><a href="#L271">fill_val</a></li>
<li><a href="#L147">getmissingattr</a></li>
<li><a href="#L455">heap_attisnull</a></li>
<li><a href="#L215">heap_compute_data_size</a></li>
<li><a href="#L1535">heap_copy_minimal_tuple</a></li>
<li><a href="#L1080">heap_copy_tuple_as_datum</a></li>
<li><a href="#L776">heap_copytuple</a></li>
<li><a href="#L802">heap_copytuple_with_tuple</a></li>
<li><a href="#L1345">heap_deform_tuple</a></li>
<li><a href="#L1065">heap_expand_tuple</a></li>
<li><a href="#L400">heap_fill_tuple</a></li>
<li><a href="#L1452">heap_form_minimal_tuple</a></li>
<li><a href="#L1116">heap_form_tuple</a></li>
<li><a href="#L1523">heap_free_minimal_tuple</a></li>
<li><a href="#L1434">heap_freetuple</a></li>
<li><a href="#L723">heap_getsysattr</a></li>
<li><a href="#L1209">heap_modify_tuple</a></li>
<li><a href="#L1277">heap_modify_tuple_by_cols</a></li>
<li><a href="#L1554">heap_tuple_from_minimal_tuple</a></li>
<li><a href="#L122">init_missing_cache</a></li>
<li><a href="#L1053">minimal_expand_tuple</a></li>
<li><a href="#L1576">minimal_tuple_from_heap_tuple</a></li>
<li><a href="#L100">missing_hash</a></li>
<li><a href="#L108">missing_match</a></li>
<li><a href="#L519">nocachegetattr</a></li>
<li><a href="#L1594">varsize_any</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L80">ATT_IS_PACKABLE</a></li>
<li><a href="#L83">VARLENA_ATT_IS_PACKABLE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * heaptuple.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This file contains heap tuple accessor and mutator routines, as well<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; as various tuple utilities.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Some notes about varlenas and this code:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Before Postgres 8.3 varlenas always had a 4-byte length header, and<br/></li>
<li></span><span class="Comment"> * therefore always needed 4-byte alignment (at least).&nbsp; This wasted space<br/></li>
<li></span><span class="Comment"> * for short varlenas, for example CHAR(1) took 5 bytes and could need up to<br/></li>
<li></span><span class="Comment"> * 3 additional padding bytes for alignment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Now, a short varlena (up to 126 data bytes) is reduced to a 1-byte header<br/></li>
<li></span><span class="Comment"> * and we don't align it.&nbsp; To hide this from datatype-specific <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that<br/></li>
<li></span><span class="Comment"> * don't want to deal with it, such a datum is considered &quot;toasted&quot; and will<br/></li>
<li></span><span class="Comment"> * be expanded back to the normal 4-byte-header format by <a href="../../utils/fmgr/fmgr.c.html#L1832" title="utils/fmgr/fmgr.c:1832">pg_detoast_datum</a>.<br/></li>
<li></span><span class="Comment"> * (In performance-critical code paths we can use <a href="../../utils/fmgr/fmgr.c.html#L1864" title="utils/fmgr/fmgr.c:1864">pg_detoast_datum_packed</a><br/></li>
<li></span><span class="Comment"> * and the appropriate access macros to avoid that overhead.)&nbsp; Note that this<br/></li>
<li></span><span class="Comment"> * conversion is performed directly in <a href="#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>, without invoking<br/></li>
<li></span><span class="Comment"> * heaptoast.c.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This change will break <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> code that assumes it needn't detoast <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * that have been put into a tuple but never sent to disk.&nbsp; Hopefully there<br/></li>
<li></span><span class="Comment"> * are few such places.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Varlenas still have alignment INT (or DOUBLE) in pg_type/pg_attribute, since<br/></li>
<li></span><span class="Comment"> * that's the normal requirement for the untoasted format.&nbsp; But we ignore that<br/></li>
<li></span><span class="Comment"> * for the 1-byte-header format.&nbsp; This means that the actual start position<br/></li>
<li></span><span class="Comment"> * of a varlena datum may vary depending on which format it has.&nbsp; To determine<br/></li>
<li></span><span class="Comment"> * what is stored, we have to require that alignment padding bytes be zero.<br/></li>
<li></span><span class="Comment"> * (Postgres actually has always zeroed them, but <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> it's required!)&nbsp; Since<br/></li>
<li></span><span class="Comment"> * the first byte of a 1-byte-header varlena can never be zero, we can examine<br/></li>
<li></span><span class="Comment"> * the first byte after the previous datum to tell if it's a pad byte or the<br/></li>
<li></span><span class="Comment"> * start of a 1-byte-header varlena.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that while formerly we could rely on the first varlena column of a<br/></li>
<li></span><span class="Comment"> * system catalog to be at the offset suggested by the C struct for the<br/></li>
<li></span><span class="Comment"> * catalog, this is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> risky: it's only safe if the preceding field is<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>-aligned, so that there will never be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> padding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't pack varlenas whose attstorage is <a href="../../regex/regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a>, since the data type<br/></li>
<li></span><span class="Comment"> * isn't expecting to have to detoast <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; This is used in particular<br/></li>
<li></span><span class="Comment"> * by oidvector and int2vector, which are used in the system catalogs<br/></li>
<li></span><span class="Comment"> * and we'd like to still refer to them via C struct offsets.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/common/heaptuple.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/heaptoast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/sysattr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tupdesc_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/expandeddatum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/hsearch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Does att's datatype allow packing into the 1-byte-header varlena format?<br/></li>
<li></span><span class="Comment"> * While <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that use TupleDescAttr() and assign attstorage =<br/></li>
<li></span><span class="Comment"> * TYPSTORAGE_PLAIN cannot use packed varlena headers, <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that call<br/></li>
<li></span><span class="Comment"> * <a href="tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>() use typeForm-&gt;typstorage (TYPSTORAGE_EXTENDED) and<br/></li>
<li></span><span class="Comment"> * can use packed varlena headers, e.g.:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; CREATE TABLE test(a VARCHAR(10000) STORAGE <a href="../../regex/regcomp.c.html#L330" title="regex/regcomp.c:330">PLAIN</a>);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; INSERT INTO test VALUES (<a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a>('A',10));<br/></li>
<li></span><span class="Comment"> * This can be verified with pageinspect.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L80">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ATT_IS_PACKABLE</span>(att) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((att)-&gt;attlen == -</span><span class="Constant">1</span><span class="PreProc"> &amp;&amp; (att)-&gt;attstorage != TYPSTORAGE_PLAIN)<br/></li>
<li></span><span class="Comment">/* Use this if it's already known varlena */<br/></li>
<li><a id="L83">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">VARLENA_ATT_IS_PACKABLE</span>(att) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((att)-&gt;attstorage != TYPSTORAGE_PLAIN)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Setup for caching pass-by-ref missing attributes in a way that survives<br/></li>
<li></span><span class="Comment"> * tupleDesc destruction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value;<br/></li>
<li><a id="L95">&#x200c;</a>} <span class="linkable">missing_cache_key</span>;<br/></li>
<li><br/></li>
<li><a id="L97">&#x200c;</a><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">missing_cache</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> uint32<br/></li>
<li><a id="L100">&#x200c;</a><span class="linkable">missing_hash</span>(<span class="Type">const</span> <span class="Type">void</span> *key, Size keysize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L95" title="access/common/heaptuple.c:95">missing_cache_key</a> *entry = (<a href="#L95" title="access/common/heaptuple.c:95">missing_cache_key</a> *) key;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hash_bytes((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span> *) entry-&gt;value, entry-&gt;len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L108">&#x200c;</a></span><span class="linkable">missing_match</span>(<span class="Type">const</span> <span class="Type">void</span> *key1, <span class="Type">const</span> <span class="Type">void</span> *key2, Size keysize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L95" title="access/common/heaptuple.c:95">missing_cache_key</a> *entry1 = (<a href="#L95" title="access/common/heaptuple.c:95">missing_cache_key</a> *) key1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L95" title="access/common/heaptuple.c:95">missing_cache_key</a> *entry2 = (<a href="#L95" title="access/common/heaptuple.c:95">missing_cache_key</a> *) key2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry1-&gt;len != entry2-&gt;len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> entry1-&gt;len &gt; entry2-&gt;len ? <span class="Constant">1</span> : -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> memcmp(DatumGetPointer(entry1-&gt;value),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetPointer(entry2-&gt;value),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry1-&gt;len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L122">&#x200c;</a></span><span class="linkable">init_missing_cache</span>()<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hash_ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L95" title="access/common/heaptuple.c:95">missing_cache_key</a>);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L95" title="access/common/heaptuple.c:95">missing_cache_key</a>);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.hcxt = <a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; hash_ctl.<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = <a href="#L100" title="access/common/heaptuple.c:100">missing_hash</a>;<br/></li>
<li>&nbsp; &nbsp; hash_ctl.match = <a href="#L108" title="access/common/heaptuple.c:108">missing_match</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="access/common/heaptuple.c:97">missing_cache</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Missing Values Cache&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">32</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_CONTEXT | HASH_FUNCTION | HASH_COMPARE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; misc support routines<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the missing value of an attribute, or NULL if there isn't one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L147">&#x200c;</a><span class="linkable">getmissingattr</span>(TupleDesc tupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> attnum, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute att;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(attnum &lt;= tupleDesc-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; Assert(attnum &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; att = TupleDescAttr(tupleDesc, attnum - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;atthasmissing)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrMissing *attrmiss;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tupleDesc-&gt;constr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tupleDesc-&gt;constr-&gt;missing);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attrmiss = tupleDesc-&gt;constr-&gt;missing + (attnum - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attrmiss-&gt;am_present)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L95" title="access/common/heaptuple.c:95">missing_cache_key</a> key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L95" title="access/common/heaptuple.c:95">missing_cache_key</a> *entry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no&nbsp; need to cache by-value attributes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attbyval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> attrmiss-&gt;am_value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set up cache if required */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L97" title="access/common/heaptuple.c:97">missing_cache</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L122" title="access/common/heaptuple.c:122">init_missing_cache</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check if there's a cache entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(att-&gt;attlen &gt; <span class="Constant">0</span> || att-&gt;attlen == -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key.len = att-&gt;attlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key.len = VARSIZE_ANY(attrmiss-&gt;am_value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key.value = attrmiss-&gt;am_value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry = <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L97" title="access/common/heaptuple.c:97">missing_cache</a>, &amp;key, HASH_ENTER, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cache <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a>, so we need a non-transient copy of the datum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldctx = MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;value =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(attrmiss-&gt;am_value, <span class="Constant">false</span>, att-&gt;attlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> entry-&gt;value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L215" title="access/common/heaptuple.c:215">heap_compute_data_size</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determine size of the data area of a tuple to be constructed<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L215">&#x200c;</a><span class="linkable">heap_compute_data_size</span>(TupleDesc tupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; data_length = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numberOfAttributes = tupleDesc-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numberOfAttributes; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute atti;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val = <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atti = TupleDescAttr(tupleDesc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L80" title="access/common/heaptuple.c:80">ATT_IS_PACKABLE</a>(atti) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARATT_CAN_MAKE_SHORT(DatumGetPointer(val)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're anticipating converting to a short varlena header, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * adjust length and don't count <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> alignment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_length += VARATT_CONVERTED_SHORT_SIZE(DatumGetPointer(val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (atti-&gt;attlen == -<span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARATT_IS_EXTERNAL_EXPANDED(DatumGetPointer(val)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we want to flatten the expanded value so that the constructed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple doesn't depend on it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_length = att_align_nominal(data_length, atti-&gt;attalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_length += <a href="../../utils/adt/expandeddatum.c.html#L75" title="utils/adt/expandeddatum.c:75">EOH_get_flat_size</a>(<a href="../../utils/adt/expandeddatum.c.html#L29" title="utils/adt/expandeddatum.c:29">DatumGetEOHP</a>(val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_length = att_align_datum(data_length, atti-&gt;attalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atti-&gt;attlen, val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_length = att_addlength_datum(data_length, atti-&gt;attlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> data_length;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Per-attribute helper for <a href="#L400" title="access/common/heaptuple.c:400">heap_fill_tuple</a> and other routines building tuples.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Fill in either a data value or a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in the null bitmask<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L271">&#x200c;</a></span><span class="linkable">fill_val</span>(Form_pg_attribute att,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bits8 **<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *bitmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> **dataP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint16 *infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum datum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; data_length;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *data = *dataP;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're building a null bitmap, set the appropriate <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current column value here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*bitmask != HIGHBIT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *bitmask &lt;&lt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; **<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> = <span class="Constant">0x0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *bitmask = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *infomask |= HEAP_HASNULL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; **<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> |= *bitmask;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> we use the att_align macros on the pointer value itself, not on an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * offset.&nbsp; This is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of a hack.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attbyval)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pass-by-value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; data = (<span class="Type">char</span> *) att_align_nominal(data, att-&gt;attalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; store_att_byval(data, datum, att-&gt;attlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data_length = att-&gt;attlen;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (att-&gt;attlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* varlena */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Pointer&nbsp; &nbsp; &nbsp; &nbsp; val = DatumGetPointer(datum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *infomask |= HEAP_HASVARWIDTH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXTERNAL(val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXTERNAL_EXPANDED(val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we want to flatten the expanded value so that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constructed tuple doesn't depend on it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExpandedObjectHeader *eoh = <a href="../../utils/adt/expandeddatum.c.html#L29" title="utils/adt/expandeddatum.c:29">DatumGetEOHP</a>(datum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data = (<span class="Type">char</span> *) att_align_nominal(data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_length = <a href="../../utils/adt/expandeddatum.c.html#L75" title="utils/adt/expandeddatum.c:75">EOH_get_flat_size</a>(eoh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/expandeddatum.c.html#L81" title="utils/adt/expandeddatum.c:81">EOH_flatten_into</a>(eoh, data, data_length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *infomask |= HEAP_HASEXTERNAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no alignment, since it's short by definition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_length = VARSIZE_EXTERNAL(val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(data, val, data_length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_SHORT(val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no alignment for short varlenas */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_length = VARSIZE_SHORT(val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(data, val, data_length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L83" title="access/common/heaptuple.c:83">VARLENA_ATT_IS_PACKABLE</a>(att) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARATT_CAN_MAKE_SHORT(val))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* convert to short varlena -- no alignment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_length = VARATT_CONVERTED_SHORT_SIZE(val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE_SHORT(data, data_length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(data + <span class="Constant">1</span>, VARDATA(val), data_length - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* full 4-byte header varlena */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data = (<span class="Type">char</span> *) att_align_nominal(data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_length = VARSIZE(val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(data, val, data_length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (att-&gt;attlen == -<span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cstring ... never needs alignment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *infomask |= HEAP_HASVARWIDTH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(att-&gt;attalign == TYPALIGN_CHAR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data_length = strlen(DatumGetCString(datum)) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(data, DatumGetPointer(datum), data_length);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fixed-length pass-by-reference */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; data = (<span class="Type">char</span> *) att_align_nominal(data, att-&gt;attalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(att-&gt;attlen &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data_length = att-&gt;attlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(data, DatumGetPointer(datum), data_length);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; data += data_length;<br/></li>
<li>&nbsp; &nbsp; *dataP = data;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L400" title="access/common/heaptuple.c:400">heap_fill_tuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Load data portion of a tuple from <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>/isnull arrays<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also fill the null bitmap (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) and set the infomask bits<br/></li>
<li></span><span class="Comment"> * that reflect the tuple's data contents.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: it is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> REQUIRED that the caller have pre-zeroed the data area.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L400">&#x200c;</a></span><span class="linkable">heap_fill_tuple</span>(TupleDesc tupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Type">const</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> *data, Size data_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16 *infomask, bits8 *<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *bitP;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmask;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numberOfAttributes = tupleDesc-&gt;natts;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *start = data;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitP = &amp;<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>[-<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmask = HIGHBIT;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just to keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; bitP = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitmask = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *infomask &amp;= ~(HEAP_HASNULL | HEAP_HASVARWIDTH | HEAP_HASEXTERNAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numberOfAttributes; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(tupleDesc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L271" title="access/common/heaptuple.c:271">fill_val</a>(attr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bitP ? &amp;bitP : <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;bitmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> ? <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] : PointerGetDatum(<span class="Constant">NULL</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isnull ? isnull[i] : <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert((data - start) == data_size);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heap tuple interface<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L455" title="access/common/heaptuple.c:455">heap_attisnull</a>&nbsp; &nbsp; - returns true iff tuple attribute is not present<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L455">&#x200c;</a></span><span class="linkable">heap_attisnull</span>(HeapTuple tup, <span class="Type">int</span> attnum, TupleDesc tupleDesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We allow a NULL tupledesc for relations not expected to have missing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, such as catalog relations and indexes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!tupleDesc || attnum &lt;= tupleDesc-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &gt; (<span class="Type">int</span>) HeapTupleHeaderGetNatts(tup-&gt;t_data))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tupleDesc &amp;&amp; TupleDescAttr(tupleDesc, attnum - <span class="Constant">1</span>)-&gt;atthasmissing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attnum &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleNoNulls(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> att_isnull(attnum - <span class="Constant">1</span>, tup-&gt;t_data-&gt;t_bits);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (attnum)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TableOidAttributeNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SelfItemPointerAttributeNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MinTransactionIdAttributeNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MinCommandIdAttributeNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MaxTransactionIdAttributeNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MaxCommandIdAttributeNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* these are never null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid attnum: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, attnum);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L519" title="access/common/heaptuple.c:519">nocachegetattr</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This only gets called from fastgetattr() macro, in cases where<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; we can't use a cacheoffset and the value is not null.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This caches attribute offsets in the attribute descriptor.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; An alternative way to speed things up would be to cache offsets<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; with the tuple, but that seems more difficult unless you take<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the storage hit of actually putting those offsets into the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; tuple you <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> to disk.&nbsp; Yuck.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This scheme will be slightly slower than that, but should<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; perform well for queries which hit large #'s of tuples.&nbsp; After<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; you cache the offsets once, examining all the other tuples using<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the same attribute descriptor will go much quicker. -cim 5/4/91<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: if you need to change this code, see also <a href="#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Also see <a href="indextuple.c.html#L241" title="access/common/indextuple.c:241">nocache_index_getattr</a>, which is the same code for index<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; tuples.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L519">&#x200c;</a><span class="linkable">nocachegetattr</span>(HeapTuple tup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleDesc tupleDesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader td = tup-&gt;t_data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ptr to data part of tuple */<br/></li>
<li></span>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *bp = td-&gt;t_bits;&nbsp; &nbsp; <span class="Comment">/* ptr to null bitmap in tuple */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; slow = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* do we have to walk attrs? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current offset within data */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; Three cases:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; 1: No nulls and no variable-width attributes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; 2: Has a null or a var-width AFTER att.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; 3: Has nulls or var-widths BEFORE att.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ----------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; attnum--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleNoNulls(tup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there's a null somewhere in the tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check to see if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> preceding bits are null...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byte = attnum &gt;&gt; <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finalbit = attnum &amp; <span class="Constant">0x07</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for nulls &quot;<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>&quot; final <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of last byte */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((~bp[byte]) &amp; ((<span class="Constant">1</span> &lt;&lt; finalbit) - <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slow = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for nulls in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> &quot;earlier&quot; bytes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; byte; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bp[i] != <span class="Constant">0xFF</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slow = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = (<span class="Type">char</span> *) td + td-&gt;t_hoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!slow)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we get here, there are no nulls up to and including the target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attribute.&nbsp; If we have a cached offset, we can use it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; att = TupleDescAttr(tupleDesc, attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attcacheoff &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> fetchatt(att, tp + att-&gt;attcacheoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, check for non-fixed-length attrs up to and including<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * target.&nbsp; If there aren't <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, it's safe to cheaply <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cached offsets for these attrs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleHasVarWidth(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt;= attnum; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupleDescAttr(tupleDesc, j)-&gt;attlen &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slow = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!slow)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts = tupleDesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we get here, we have a tuple with no nulls or var-widths up to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and including the target attribute, so we can use the cached offset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ... only we don't have it yet, or we'd not have got here.&nbsp; Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's cheap to compute offsets for fixed-width columns, we take the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * opportunity to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the cached offsets for *all* the leading<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fixed-width columns, in hope of avoiding future visits to this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * routine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TupleDescAttr(tupleDesc, <span class="Constant">0</span>)-&gt;attcacheoff = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we might have set some offsets in the slow path previously */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (j &lt; natts &amp;&amp; TupleDescAttr(tupleDesc, j)-&gt;attcacheoff &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; off = TupleDescAttr(tupleDesc, j - <span class="Constant">1</span>)-&gt;attcacheoff +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDescAttr(tupleDesc, j - <span class="Constant">1</span>)-&gt;attlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; j &lt; natts; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(tupleDesc, j);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attlen &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off = att_align_nominal(off, att-&gt;attalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attcacheoff = off;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off += att-&gt;attlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(j &gt; attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; off = TupleDescAttr(tupleDesc, attnum)-&gt;attcacheoff;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; usecache = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now we know that we have to walk the tuple CAREFULLY.&nbsp; But we still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might be able to cache some offsets for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note - This loop is a little tricky.&nbsp; For each non-null attribute,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we have to first account for alignment padding <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the attr,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then advance over the attr based on its length.&nbsp; <a href="../../bootstrap/bootstrap.c.html#L153" title="bootstrap/bootstrap.c:153">Nulls</a> have no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * storage and no alignment padding either.&nbsp; We can use/set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attcacheoff until we reach either a null or a var-width attribute.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; off = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>;; i++)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* loop exit is at &quot;break&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(tupleDesc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleHasNulls(tup) &amp;&amp; att_isnull(i, bp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usecache = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this cannot be the target att */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we know the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> offset, we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the rest */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (usecache &amp;&amp; att-&gt;attcacheoff &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off = att-&gt;attcacheoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (att-&gt;attlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can only cache the offset for a varlena attribute if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * offset is already suitably aligned, so that there would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no pad bytes in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case: then the offset will be valid for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either an aligned or unaligned value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (usecache &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off == att_align_nominal(off, att-&gt;attalign))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attcacheoff = off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off = att_align_pointer(off, att-&gt;attalign, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tp + off);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usecache = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not varlena, so safe to use att_align_nominal */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off = att_align_nominal(off, att-&gt;attalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (usecache)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attcacheoff = off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == attnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off = att_addlength_pointer(off, att-&gt;attlen, tp + off);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (usecache &amp;&amp; att-&gt;attlen &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usecache = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> fetchatt(TupleDescAttr(tupleDesc, attnum), tp + off);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L723" title="access/common/heaptuple.c:723">heap_getsysattr</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Fetch the value of a system attribute for a tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a support routine for the heap_getattr macro.&nbsp; The macro<br/></li>
<li></span><span class="Comment"> * has already determined that the attnum refers to a system attribute.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L723">&#x200c;</a><span class="linkable">heap_getsysattr</span>(HeapTuple tup, <span class="Type">int</span> attnum, TupleDesc tupleDesc, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Currently, no sys attribute ever reads as NULL. */<br/></li>
<li></span>&nbsp; &nbsp; *isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (attnum)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SelfItemPointerAttributeNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pass-by-reference datatype */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = PointerGetDatum(&amp;(tup-&gt;t_self));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MinTransactionIdAttributeNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TransactionIdGetDatum(HeapTupleHeaderGetRawXmin(tup-&gt;t_data));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MaxTransactionIdAttributeNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TransactionIdGetDatum(HeapTupleHeaderGetRawXmax(tup-&gt;t_data));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MinCommandIdAttributeNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MaxCommandIdAttributeNumber:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cmin and cmax are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> both aliases for the same field, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can in fact also be a combo command id.&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> perhaps we should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * return the &quot;real&quot; cmin or cmax if possible, that is if we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inside the originating transaction?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = CommandIdGetDatum(HeapTupleHeaderGetRawCommandId(tup-&gt;t_data));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TableOidAttributeNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = ObjectIdGetDatum(tup-&gt;t_tableOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid attnum: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L776" title="access/common/heaptuple.c:776">heap_copytuple</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returns a copy of an entire tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The HeapTuple struct, tuple header, and tuple data are all allocated<br/></li>
<li></span><span class="Comment"> * as a single <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>() block.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L776">&#x200c;</a><span class="linkable">heap_copytuple</span>(HeapTuple tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; newTuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple) || tuple-&gt;t_data == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newTuple = (HeapTuple) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(HEAPTUPLESIZE + tuple-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; newTuple-&gt;t_len = tuple-&gt;t_len;<br/></li>
<li>&nbsp; &nbsp; newTuple-&gt;t_self = tuple-&gt;t_self;<br/></li>
<li>&nbsp; &nbsp; newTuple-&gt;t_tableOid = tuple-&gt;t_tableOid;<br/></li>
<li>&nbsp; &nbsp; newTuple-&gt;t_data = (HeapTupleHeader) ((<span class="Type">char</span> *) newTuple + HEAPTUPLESIZE);<br/></li>
<li>&nbsp; &nbsp; memcpy((<span class="Type">char</span> *) newTuple-&gt;t_data, (<span class="Type">char</span> *) tuple-&gt;t_data, tuple-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newTuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L802" title="access/common/heaptuple.c:802">heap_copytuple_with_tuple</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; copy a tuple into a caller-supplied HeapTuple management struct<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that after calling this function, the &quot;dest&quot; HeapTuple will not be<br/></li>
<li></span><span class="Comment"> * allocated as a single <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>() block (unlike with <a href="#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>()).<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L802">&#x200c;</a></span><span class="linkable">heap_copytuple_with_tuple</span>(HeapTuple src, HeapTuple dest)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(src) || src-&gt;t_data == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dest-&gt;t_data = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dest-&gt;t_len = src-&gt;t_len;<br/></li>
<li>&nbsp; &nbsp; dest-&gt;t_self = src-&gt;t_self;<br/></li>
<li>&nbsp; &nbsp; dest-&gt;t_tableOid = src-&gt;t_tableOid;<br/></li>
<li>&nbsp; &nbsp; dest-&gt;t_data = (HeapTupleHeader) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(src-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; memcpy((<span class="Type">char</span> *) dest-&gt;t_data, (<span class="Type">char</span> *) src-&gt;t_data, src-&gt;t_len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Expand a tuple which has fewer attributes than required. For each attribute<br/></li>
<li></span><span class="Comment"> * not present in the sourceTuple, if there is a missing value that will be<br/></li>
<li></span><span class="Comment"> * used. Otherwise the attribute will be set to NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The source tuple must have fewer attributes than the required number.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Only one of targetHeapTuple and targetMinimalTuple may be supplied. The<br/></li>
<li></span><span class="Comment"> * other argument must be NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L828">&#x200c;</a></span><span class="linkable">expand_tuple</span>(HeapTuple *targetHeapTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MinimalTuple *targetMinimalTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTuple sourceTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleDesc tupleDesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AttrMissing *attrmiss = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstmissingnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasNulls = HeapTupleHasNulls(sourceTuple);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader targetTHeader;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader sourceTHeader = sourceTuple-&gt;t_data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sourceNatts = HeapTupleHeaderGetNatts(sourceTHeader);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts = tupleDesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sourceNullLen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetNullLen;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; sourceDataLen = sourceTuple-&gt;t_len - sourceTHeader-&gt;t_hoff;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; targetDataLen;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hoff;<br/></li>
<li>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *nullBits = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitMask = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *targetData;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp;&nbsp; *infoMask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert((targetHeapTuple &amp;&amp; !targetMinimalTuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; || (!targetHeapTuple &amp;&amp; targetMinimalTuple));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(sourceNatts &lt; natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sourceNullLen = (hasNulls ? BITMAPLEN(sourceNatts) : <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; targetDataLen = sourceDataLen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tupleDesc-&gt;constr &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupleDesc-&gt;constr-&gt;missing)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there are missing <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> we want to put them into the tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before that we have to compute the extra length for the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * array and the variable length data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; attrmiss = tupleDesc-&gt;constr-&gt;missing;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find the first item in attrmiss for which we don't have a value in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the source. We can ignore all the missing entries <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (firstmissingnum = sourceNatts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; firstmissingnum &lt; natts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; firstmissingnum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attrmiss[firstmissingnum].am_present)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasNulls = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now walk the missing attributes. If there is a missing value make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * space for it. Otherwise, it's going to be NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (attnum = firstmissingnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attnum &lt; natts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attnum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attrmiss[attnum].am_present)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(tupleDesc, attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetDataLen = att_align_datum(targetDataLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrmiss[attnum].am_value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetDataLen = att_addlength_pointer(targetDataLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrmiss[attnum].am_value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no missing value, so it must be null */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasNulls = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end if have missing <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there are no missing <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> at all then NULLS must be allowed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since some of the attributes are known to be absent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hasNulls = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hasNulls)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targetNullLen = BITMAPLEN(natts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len += targetNullLen;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; targetNullLen = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate and zero the space needed.&nbsp; Note that the tuple body and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * HeapTupleData management structure are allocated in one chunk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (targetHeapTuple)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len += offsetof(HeapTupleHeaderData, t_bits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hoff = len = MAXALIGN(len); <span class="Comment">/* align user data safely */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; len += targetDataLen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *targetHeapTuple = (HeapTuple) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(HEAPTUPLESIZE + len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*targetHeapTuple)-&gt;t_data<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = targetTHeader<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = (HeapTupleHeader) ((<span class="Type">char</span> *) *targetHeapTuple + HEAPTUPLESIZE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*targetHeapTuple)-&gt;t_len = len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*targetHeapTuple)-&gt;t_tableOid = sourceTuple-&gt;t_tableOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*targetHeapTuple)-&gt;t_self = sourceTuple-&gt;t_self;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targetTHeader-&gt;t_infomask = sourceTHeader-&gt;t_infomask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targetTHeader-&gt;t_hoff = hoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetNatts(targetTHeader, natts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetDatumLength(targetTHeader, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetTypeId(targetTHeader, tupleDesc-&gt;tdtypeid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetTypMod(targetTHeader, tupleDesc-&gt;tdtypmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We also make sure that t_ctid is invalid unless explicitly set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSetInvalid(&amp;(targetTHeader-&gt;t_ctid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (targetNullLen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullBits = (bits8 *) ((<span class="Type">char</span> *) (*targetHeapTuple)-&gt;t_data<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + offsetof(HeapTupleHeaderData, t_bits));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targetData = (<span class="Type">char</span> *) (*targetHeapTuple)-&gt;t_data + hoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; infoMask = &amp;(targetTHeader-&gt;t_infomask);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len += SizeofMinimalTupleHeader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hoff = len = MAXALIGN(len); <span class="Comment">/* align user data safely */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; len += targetDataLen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *targetMinimalTuple = (MinimalTuple) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*targetMinimalTuple)-&gt;t_len = len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*targetMinimalTuple)-&gt;t_hoff = hoff + MINIMAL_TUPLE_OFFSET;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*targetMinimalTuple)-&gt;t_infomask = sourceTHeader-&gt;t_infomask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Same macro works for MinimalTuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetNatts(*targetMinimalTuple, natts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (targetNullLen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullBits = (bits8 *) ((<span class="Type">char</span> *) *targetMinimalTuple<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + offsetof(MinimalTupleData, t_bits));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targetData = (<span class="Type">char</span> *) *targetMinimalTuple + hoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; infoMask = &amp;((*targetMinimalTuple)-&gt;t_infomask);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (targetNullLen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sourceNullLen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if bitmap pre-existed copy in - all is set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(nullBits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((<span class="Type">char</span> *) sourceTHeader)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; + offsetof(HeapTupleHeaderData, t_bits),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sourceNullLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullBits += sourceNullLen - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sourceNullLen = BITMAPLEN(sourceNatts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set NOT NULL for all existing attributes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(nullBits, <span class="Constant">0xff</span>, sourceNullLen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullBits += sourceNullLen - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sourceNatts &amp; <span class="Constant">0x07</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* build the mask (inverted!) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitMask = <span class="Constant">0xff</span> &lt;&lt; (sourceNatts &amp; <span class="Constant">0x07</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Voila */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *nullBits = ~bitMask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bitMask = (<span class="Constant">1</span> &lt;&lt; ((sourceNatts - <span class="Constant">1</span>) &amp; <span class="Constant">0x07</span>));<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* End if have null bitmap */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; memcpy(targetData,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((<span class="Type">char</span> *) sourceTuple-&gt;t_data) + sourceTHeader-&gt;t_hoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sourceDataLen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; targetData += sourceDataLen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now fill in the missing <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (attnum = sourceNatts; attnum &lt; natts; attnum++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(tupleDesc, attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attrmiss &amp;&amp; attrmiss[attnum].am_present)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L271" title="access/common/heaptuple.c:271">fill_val</a>(attr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nullBits ? &amp;nullBits : <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;bitMask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;targetData,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; infoMask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attrmiss[attnum].am_value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L271" title="access/common/heaptuple.c:271">fill_val</a>(attr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;nullBits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;bitMask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;targetData,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; infoMask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end loop over missing attributes */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fill in the missing <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for a minimal HeapTuple<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MinimalTuple<br/></li>
<li><a id="L1053">&#x200c;</a><span class="linkable">minimal_expand_tuple</span>(HeapTuple sourceTuple, TupleDesc tupleDesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTuple minimalTuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L828" title="access/common/heaptuple.c:828">expand_tuple</a>(<span class="Constant">NULL</span>, &amp;minimalTuple, sourceTuple, tupleDesc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> minimalTuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fill in the missing <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for an ordinary HeapTuple<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L1065">&#x200c;</a><span class="linkable">heap_expand_tuple</span>(HeapTuple sourceTuple, TupleDesc tupleDesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; heapTuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L828" title="access/common/heaptuple.c:828">expand_tuple</a>(&amp;heapTuple, <span class="Constant">NULL</span>, sourceTuple, tupleDesc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> heapTuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1080" title="access/common/heaptuple.c:1080">heap_copy_tuple_as_datum</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; copy a tuple as a composite-type Datum<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1080">&#x200c;</a><span class="linkable">heap_copy_tuple_as_datum</span>(HeapTuple tuple, TupleDesc tupleDesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader td;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the tuple contains <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> external TOAST pointers, we have to inline<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those fields to meet the conventions for composite-type Datums.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleHasExternal(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../heap/heaptoast.c.html#L449" title="access/heap/heaptoast.c:449">toast_flatten_tuple_to_datum</a>(tuple-&gt;t_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple-&gt;t_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupleDesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fast path for easy case: just make a <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d copy and insert the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * correct composite-Datum header fields (since those may not be set if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the given tuple came from disk, rather than from <a href="#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; td = (HeapTupleHeader) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(tuple-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; memcpy((<span class="Type">char</span> *) td, (<span class="Type">char</span> *) tuple-&gt;t_data, tuple-&gt;t_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetDatumLength(td, tuple-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetTypeId(td, tupleDesc-&gt;tdtypeid);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetTypMod(td, tupleDesc-&gt;tdtypmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(td);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; construct a tuple from the given <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[] and isnull[] arrays,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; which are of the length indicated by tupleDescriptor-&gt;natts<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is allocated in the current memory context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L1116">&#x200c;</a><span class="linkable">heap_form_tuple</span>(TupleDesc tupleDescriptor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return tuple */<br/></li>
<li></span>&nbsp; &nbsp; HeapTupleHeader td;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tuple data */<br/></li>
<li></span>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hoff;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numberOfAttributes = tupleDescriptor-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numberOfAttributes &gt; MaxTupleAttributeNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_TOO_MANY_COLUMNS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;number of columns (</span><span class="Special">%d</span><span class="Constant">) exceeds limit (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numberOfAttributes, MaxTupleAttributeNumber)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for nulls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numberOfAttributes; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine total space needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; len = offsetof(HeapTupleHeaderData, t_bits);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hasnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len += BITMAPLEN(numberOfAttributes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hoff = len = MAXALIGN(len); <span class="Comment">/* align user data safely */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; data_len = <a href="#L215" title="access/common/heaptuple.c:215">heap_compute_data_size</a>(tupleDescriptor, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len += data_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate and zero the space needed.&nbsp; Note that the tuple body and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * HeapTupleData management structure are allocated in one chunk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tuple = (HeapTuple) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(HEAPTUPLESIZE + len);<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_data = td = (HeapTupleHeader) ((<span class="Type">char</span> *) tuple + HEAPTUPLESIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And fill in the information.&nbsp; Note we fill the Datum fields even though<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this tuple may never become a Datum.&nbsp; This lets <a href="../../executor/execTuples.c.html#L2311" title="executor/execTuples.c:2311">HeapTupleHeaderGetDatum</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * identify the tuple type if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tuple-&gt;t_len = len;<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tuple-&gt;t_self));<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_tableOid = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetDatumLength(td, len);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetTypeId(td, tupleDescriptor-&gt;tdtypeid);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetTypMod(td, tupleDescriptor-&gt;tdtypmod);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We also make sure that t_ctid is invalid unless explicitly set */<br/></li>
<li></span>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(td-&gt;t_ctid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetNatts(td, numberOfAttributes);<br/></li>
<li>&nbsp; &nbsp; td-&gt;t_hoff = hoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L400" title="access/common/heaptuple.c:400">heap_fill_tuple</a>(tupleDescriptor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">char</span> *) td + hoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;td-&gt;t_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (hasnull ? td-&gt;t_bits : <span class="Constant">NULL</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1209" title="access/common/heaptuple.c:1209">heap_modify_tuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; form a new tuple from an old tuple and a set of replacement <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The replValues, replIsnull, and doReplace arrays must be of the length<br/></li>
<li></span><span class="Comment"> * indicated by tupleDesc-&gt;natts.&nbsp; The new tuple is constructed using the data<br/></li>
<li></span><span class="Comment"> * from replValues/replIsnull at columns where doReplace is true, and using<br/></li>
<li></span><span class="Comment"> * the data from the old tuple at columns where doReplace is false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is allocated in the current memory context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L1209">&#x200c;</a><span class="linkable">heap_modify_tuple</span>(HeapTuple tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDesc tupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> Datum *replValues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *replIsnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *doReplace)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numberOfAttributes = tupleDesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attoff;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *isnull;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; newTuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate and fill <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and isnull arrays from either the tuple or the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * repl information, as appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: it's debatable whether to use <a href="#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>() here or just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * heap_getattr() only the non-replaced columns.&nbsp; The latter could win if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there are many replaced columns and few non-replaced ones. However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a> costs only O(N) while the heap_getattr way would cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * O(N^2) if there are many non-replaced columns, so it seems better to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * err on the side of linear cost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = (Datum *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numberOfAttributes * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; isnull = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numberOfAttributes * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(tuple, tupleDesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (attoff = <span class="Constant">0</span>; attoff &lt; numberOfAttributes; attoff++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (doReplace[attoff])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[attoff] = replValues[attoff];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull[attoff] = replIsnull[attoff];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create a new tuple from the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and isnull arrays<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newTuple = <a href="#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(tupleDesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copy the identification info of the old tuple: t_ctid, t_self<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newTuple-&gt;t_data-&gt;t_ctid = tuple-&gt;t_data-&gt;t_ctid;<br/></li>
<li>&nbsp; &nbsp; newTuple-&gt;t_self = tuple-&gt;t_self;<br/></li>
<li>&nbsp; &nbsp; newTuple-&gt;t_tableOid = tuple-&gt;t_tableOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newTuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1277" title="access/common/heaptuple.c:1277">heap_modify_tuple_by_cols</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; form a new tuple from an old tuple and a set of replacement <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is like <a href="#L1209" title="access/common/heaptuple.c:1209">heap_modify_tuple</a>, except that instead of specifying which<br/></li>
<li></span><span class="Comment"> * column(s) to replace by a boolean map, an array of target column numbers<br/></li>
<li></span><span class="Comment"> * is used.&nbsp; This is often more convenient when a fixed number of columns<br/></li>
<li></span><span class="Comment"> * are to be replaced.&nbsp; The replCols, replValues, and replIsnull arrays must<br/></li>
<li></span><span class="Comment"> * be of length nCols.&nbsp; Target column numbers are indexed from 1.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is allocated in the current memory context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L1277">&#x200c;</a><span class="linkable">heap_modify_tuple_by_cols</span>(HeapTuple tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDesc tupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">int</span> *replCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> Datum *replValues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *replIsnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numberOfAttributes = tupleDesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *isnull;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; newTuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate and fill <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and isnull arrays from the tuple, then replace<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selected columns from the input arrays.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = (Datum *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numberOfAttributes * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; isnull = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numberOfAttributes * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(tuple, tupleDesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nCols; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = replCols[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt;= <span class="Constant">0</span> || attnum &gt; numberOfAttributes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid column number </span><span class="Special">%d</span><span class="Constant">&quot;</span>, attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[attnum - <span class="Constant">1</span>] = replValues[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isnull[attnum - <span class="Constant">1</span>] = replIsnull[i];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create a new tuple from the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and isnull arrays<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newTuple = <a href="#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(tupleDesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copy the identification info of the old tuple: t_ctid, t_self<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newTuple-&gt;t_data-&gt;t_ctid = tuple-&gt;t_data-&gt;t_ctid;<br/></li>
<li>&nbsp; &nbsp; newTuple-&gt;t_self = tuple-&gt;t_self;<br/></li>
<li>&nbsp; &nbsp; newTuple-&gt;t_tableOid = tuple-&gt;t_tableOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newTuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given a tuple, extract data into <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>/isnull arrays; this is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the inverse of <a href="#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Storage for the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>/isnull arrays is provided by the caller;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; it should be sized according to tupleDesc-&gt;natts not<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderGetNatts(tuple-&gt;t_data).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Note that for pass-by-reference datatypes, the pointer placed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; in the Datum will point into the given tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; When all or most of a tuple's fields need to be extracted,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; this routine will be significantly quicker than a loop around<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; heap_getattr; the loop will become O(N^2) as soon as <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; noncacheable attribute offsets are involved.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1345">&#x200c;</a></span><span class="linkable">heap_deform_tuple</span>(HeapTuple tuple, TupleDesc tupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader tup = tuple-&gt;t_data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasnulls = HeapTupleHasNulls(tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tdesc_natts = tupleDesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of atts to extract */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ptr to tuple data */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; off;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* offset in tuple data */<br/></li>
<li></span>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *bp = tup-&gt;t_bits;&nbsp; &nbsp; <span class="Comment">/* ptr to null bitmap in tuple */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; slow = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* can we use/set attcacheoff? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; natts = HeapTupleHeaderGetNatts(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In inheritance situations, it is possible that the given tuple actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has more fields than the caller is expecting.&nbsp; Don't run off the end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the caller's arrays.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; natts = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(natts, tdesc_natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = (<span class="Type">char</span> *) tup + tup-&gt;t_hoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; off = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (attnum = <span class="Constant">0</span>; attnum &lt; natts; attnum++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute thisatt = TupleDescAttr(tupleDesc, attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hasnulls &amp;&amp; att_isnull(attnum, bp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[attnum] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull[attnum] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slow = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't use attcacheoff anymore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isnull[attnum] = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!slow &amp;&amp; thisatt-&gt;attcacheoff &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off = thisatt-&gt;attcacheoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (thisatt-&gt;attlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can only cache the offset for a varlena attribute if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * offset is already suitably aligned, so that there would be no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pad bytes in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case: then the offset will be valid for either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an aligned or unaligned value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!slow &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off == att_align_nominal(off, thisatt-&gt;attalign))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisatt-&gt;attcacheoff = off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off = att_align_pointer(off, thisatt-&gt;attalign, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tp + off);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slow = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not varlena, so safe to use att_align_nominal */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off = att_align_nominal(off, thisatt-&gt;attalign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!slow)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisatt-&gt;attcacheoff = off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[attnum] = fetchatt(thisatt, tp + off);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; off = att_addlength_pointer(off, thisatt-&gt;attlen, tp + off);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (thisatt-&gt;attlen &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slow = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't use attcacheoff anymore */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If tuple doesn't have all the atts indicated by tupleDesc, read the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rest as nulls or missing <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> as appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (; attnum &lt; tdesc_natts; attnum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[attnum] = <a href="#L147" title="access/common/heaptuple.c:147">getmissingattr</a>(tupleDesc, attnum + <span class="Constant">1</span>, &amp;isnull[attnum]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1434">&#x200c;</a></span><span class="linkable">heap_freetuple</span>(HeapTuple htup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(htup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1452" title="access/common/heaptuple.c:1452">heap_form_minimal_tuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; construct a MinimalTuple from the given <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[] and isnull[] arrays,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; which are of the length indicated by tupleDescriptor-&gt;natts<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exactly like <a href="#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>() except that the result is a<br/></li>
<li></span><span class="Comment"> * &quot;minimal&quot; tuple lacking a HeapTupleData header as well as room for system<br/></li>
<li></span><span class="Comment"> * columns.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is allocated in the current memory context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MinimalTuple<br/></li>
<li><a id="L1452">&#x200c;</a><span class="linkable">heap_form_minimal_tuple</span>(TupleDesc tupleDescriptor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTuple tuple;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return tuple */<br/></li>
<li></span>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hoff;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numberOfAttributes = tupleDescriptor-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numberOfAttributes &gt; MaxTupleAttributeNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_TOO_MANY_COLUMNS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;number of columns (</span><span class="Special">%d</span><span class="Constant">) exceeds limit (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numberOfAttributes, MaxTupleAttributeNumber)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for nulls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numberOfAttributes; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnull[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine total space needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; len = SizeofMinimalTupleHeader;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hasnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len += BITMAPLEN(numberOfAttributes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hoff = len = MAXALIGN(len); <span class="Comment">/* align user data safely */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; data_len = <a href="#L215" title="access/common/heaptuple.c:215">heap_compute_data_size</a>(tupleDescriptor, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len += data_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate and zero the space needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tuple = (MinimalTuple) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And fill in the information.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tuple-&gt;t_len = len;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetNatts(tuple, numberOfAttributes);<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_hoff = hoff + MINIMAL_TUPLE_OFFSET;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L400" title="access/common/heaptuple.c:400">heap_fill_tuple</a>(tupleDescriptor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">char</span> *) tuple + hoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tuple-&gt;t_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (hasnull ? tuple-&gt;t_bits : <span class="Constant">NULL</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1523" title="access/common/heaptuple.c:1523">heap_free_minimal_tuple</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1523">&#x200c;</a></span><span class="linkable">heap_free_minimal_tuple</span>(MinimalTuple mtup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(mtup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1535" title="access/common/heaptuple.c:1535">heap_copy_minimal_tuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; copy a MinimalTuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is allocated in the current memory context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MinimalTuple<br/></li>
<li><a id="L1535">&#x200c;</a><span class="linkable">heap_copy_minimal_tuple</span>(MinimalTuple mtup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTuple result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (MinimalTuple) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(mtup-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; memcpy(result, mtup, mtup-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1554" title="access/common/heaptuple.c:1554">heap_tuple_from_minimal_tuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; create a HeapTuple by copying from a MinimalTuple;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; system columns are filled with zeroes<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is allocated in the current memory context.<br/></li>
<li></span><span class="Comment"> * The HeapTuple struct, tuple header, and tuple data are all allocated<br/></li>
<li></span><span class="Comment"> * as a single <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>() block.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L1554">&#x200c;</a><span class="linkable">heap_tuple_from_minimal_tuple</span>(MinimalTuple mtup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; len = mtup-&gt;t_len + MINIMAL_TUPLE_OFFSET;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (HeapTuple) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(HEAPTUPLESIZE + len);<br/></li>
<li>&nbsp; &nbsp; result-&gt;t_len = len;<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(result-&gt;t_self));<br/></li>
<li>&nbsp; &nbsp; result-&gt;t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; result-&gt;t_data = (HeapTupleHeader) ((<span class="Type">char</span> *) result + HEAPTUPLESIZE);<br/></li>
<li>&nbsp; &nbsp; memcpy((<span class="Type">char</span> *) result-&gt;t_data + MINIMAL_TUPLE_OFFSET, mtup, mtup-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; memset(result-&gt;t_data, <span class="Constant">0</span>, offsetof(HeapTupleHeaderData, t_infomask2));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1576" title="access/common/heaptuple.c:1576">minimal_tuple_from_heap_tuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; create a MinimalTuple by copying from a HeapTuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is allocated in the current memory context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MinimalTuple<br/></li>
<li><a id="L1576">&#x200c;</a><span class="linkable">minimal_tuple_from_heap_tuple</span>(HeapTuple htup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MinimalTuple result;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(htup-&gt;t_len &gt; MINIMAL_TUPLE_OFFSET);<br/></li>
<li>&nbsp; &nbsp; len = htup-&gt;t_len - MINIMAL_TUPLE_OFFSET;<br/></li>
<li>&nbsp; &nbsp; result = (MinimalTuple) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li>&nbsp; &nbsp; memcpy(result, (<span class="Type">char</span> *) htup-&gt;t_data + MINIMAL_TUPLE_OFFSET, len);<br/></li>
<li>&nbsp; &nbsp; result-&gt;t_len = len;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This mainly exists so JIT can inline the definition, but it's also<br/></li>
<li></span><span class="Comment"> * sometimes useful in debugging sessions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">size_t<br/></li>
<li><a id="L1594">&#x200c;</a></span><span class="linkable">varsize_any</span>(<span class="Type">void</span> *p)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> VARSIZE_ANY(p);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
