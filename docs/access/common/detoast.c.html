<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/common/detoast.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/common/detoast.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L116">detoast_attr</a></li>
<li><a href="#L205">detoast_attr_slice</a></li>
<li><a href="#L45">detoast_external_attr</a></li>
<li><a href="#L601">toast_datum_size</a></li>
<li><a href="#L471">toast_decompress_datum</a></li>
<li><a href="#L503">toast_decompress_datum_slice</a></li>
<li><a href="#L343">toast_fetch_datum</a></li>
<li><a href="#L396">toast_fetch_datum_slice</a></li>
<li><a href="#L545">toast_raw_datum_size</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * detoast.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Retrieve compressed or external variable size attributes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2000-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/common/detoast.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/detoast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/toast_internals.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/pg_lzcompress.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/expandeddatum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> varlena *<a href="#L343" title="access/common/detoast.c:343">toast_fetch_datum</a>(<span class="Type">struct</span> varlena *attr);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> varlena *<a href="#L396" title="access/common/detoast.c:396">toast_fetch_datum_slice</a>(<span class="Type">struct</span> varlena *attr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int32 sliceoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int32 slicelength);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> varlena *<a href="#L471" title="access/common/detoast.c:471">toast_decompress_datum</a>(<span class="Type">struct</span> varlena *attr);<br/></li>
<li><span class="Type">static</span> <span class="Type">struct</span> varlena *<a href="#L503" title="access/common/detoast.c:503">toast_decompress_datum_slice</a>(<span class="Type">struct</span> varlena *attr, int32 slicelength);<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L45" title="access/common/detoast.c:45">detoast_external_attr</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Public entry point to get back a toasted value from<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; external source (possibly still in compressed format).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This will return a datum that contains all the data internally, ie, not<br/></li>
<li></span><span class="Comment"> * relying on external storage or memory, but it can still be compressed or<br/></li>
<li></span><span class="Comment"> * have a short header.&nbsp; Note some callers assume that if the input is an<br/></li>
<li></span><span class="Comment"> * EXTERNAL datum, the result will be a <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'able chunk.<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">struct</span> varlena *<br/></li>
<li><a id="L45">&#x200c;</a><span class="linkable">detoast_external_attr</span>(<span class="Type">struct</span> varlena *attr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> varlena *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXTERNAL_ONDISK(attr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is an external stored plain value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L343" title="access/common/detoast.c:343">toast_fetch_datum</a>(attr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_EXTERNAL_INDIRECT(attr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is an indirect pointer --- dereference it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varatt_indirect redirect;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VARATT_EXTERNAL_GET_POINTER(redirect, attr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attr = (<span class="Type">struct</span> varlena *) redirect.pointer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nested indirect Datums aren't allowed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!VARATT_IS_EXTERNAL_INDIRECT(attr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recurse if value is still external in some other way */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXTERNAL(attr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L45" title="access/common/detoast.c:45">detoast_external_attr</a>(attr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy into the caller's memory context, in case caller tries to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> the result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">struct</span> varlena *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARSIZE_ANY(attr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(result, attr, VARSIZE_ANY(attr));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_EXTERNAL_EXPANDED(attr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is an expanded-object pointer --- get flat format<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ExpandedObjectHeader *eoh;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; resultsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eoh = <a href="../../utils/adt/expandeddatum.c.html#L29" title="utils/adt/expandeddatum.c:29">DatumGetEOHP</a>(PointerGetDatum(attr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resultsize = <a href="../../utils/adt/expandeddatum.c.html#L75" title="utils/adt/expandeddatum.c:75">EOH_get_flat_size</a>(eoh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">struct</span> varlena *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(resultsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/expandeddatum.c.html#L81" title="utils/adt/expandeddatum.c:81">EOH_flatten_into</a>(eoh, (<span class="Type">void</span> *) result, resultsize);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is a plain value inside of the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> tuple - why am I called?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = attr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L116" title="access/common/detoast.c:116">detoast_attr</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Public entry point to get back a toasted value from compression<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; or external storage.&nbsp; The result is always non-extended varlena form.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note some callers assume that if the input is an EXTERNAL or COMPRESSED<br/></li>
<li></span><span class="Comment"> * datum, the result will be a <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'able chunk.<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">struct</span> varlena *<br/></li>
<li><a id="L116">&#x200c;</a><span class="linkable">detoast_attr</span>(<span class="Type">struct</span> varlena *attr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXTERNAL_ONDISK(attr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is an externally stored datum --- fetch it back from there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; attr = <a href="#L343" title="access/common/detoast.c:343">toast_fetch_datum</a>(attr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's compressed, decompress it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_COMPRESSED(attr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varlena *tmp = attr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attr = <a href="#L471" title="access/common/detoast.c:471">toast_decompress_datum</a>(tmp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tmp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_EXTERNAL_INDIRECT(attr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is an indirect pointer --- dereference it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varatt_indirect redirect;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VARATT_EXTERNAL_GET_POINTER(redirect, attr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attr = (<span class="Type">struct</span> varlena *) redirect.pointer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nested indirect Datums aren't allowed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!VARATT_IS_EXTERNAL_INDIRECT(attr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recurse in case value is still extended in some other way */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; attr = <a href="#L116" title="access/common/detoast.c:116">detoast_attr</a>(attr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if it isn't, we'd better copy it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attr == (<span class="Type">struct</span> varlena *) redirect.pointer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varlena *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (<span class="Type">struct</span> varlena *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARSIZE_ANY(attr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(result, attr, VARSIZE_ANY(attr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attr = result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_EXTERNAL_EXPANDED(attr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is an expanded-object pointer --- get flat format<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; attr = <a href="#L45" title="access/common/detoast.c:45">detoast_external_attr</a>(attr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* flatteners are not allowed to produce compressed/short output */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!VARATT_IS_EXTENDED(attr));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_COMPRESSED(attr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is a compressed value inside of the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; attr = <a href="#L471" title="access/common/detoast.c:471">toast_decompress_datum</a>(attr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_SHORT(attr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is a short-header varlena --- convert to 4-byte header format<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; data_size = VARSIZE_SHORT(attr) - VARHDRSZ_SHORT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; new_size = data_size + VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varlena *new_attr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_attr = (<span class="Type">struct</span> varlena *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(new_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(new_attr, new_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(VARDATA(new_attr), VARDATA_SHORT(attr), data_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attr = new_attr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> attr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L205" title="access/common/detoast.c:205">detoast_attr_slice</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Public entry point to get back part of a toasted value<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; from compression or external storage.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * sliceoffset is where to start (zero or more)<br/></li>
<li></span><span class="Comment"> * If slicelength &lt; 0, return everything beyond sliceoffset<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">struct</span> varlena *<br/></li>
<li><a id="L205">&#x200c;</a><span class="linkable">detoast_attr_slice</span>(<span class="Type">struct</span> varlena *attr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int32 sliceoffset, int32 slicelength)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> varlena *preslice;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> varlena *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *attrdata;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; slicelimit;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; attrsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sliceoffset &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid sliceoffset: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, sliceoffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute slicelimit = offset + length, or -1 if we must fetch all of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value.&nbsp; In case of integer overflow, we must fetch all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (slicelength &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slicelimit = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pg_add_s32_overflow(sliceoffset, slicelength, &amp;slicelimit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slicelength = slicelimit = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXTERNAL_ONDISK(attr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varatt_external toast_pointer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VARATT_EXTERNAL_GET_POINTER(toast_pointer, attr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fast path for non-compressed external datums */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!VARATT_EXTERNAL_IS_COMPRESSED(toast_pointer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L396" title="access/common/detoast.c:396">toast_fetch_datum_slice</a>(attr, sliceoffset, slicelength);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For compressed <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, we need to fetch enough slices to decompress<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at least the requested part (when a prefix is requested).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, just fetch all slices.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slicelimit &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; max_size = VARATT_EXTERNAL_GET_EXTSIZE(toast_pointer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine maximum amount of compressed data needed for a prefix<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of a given length (after decompression).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At least for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, if it's LZ4 data, we'll have to fetch the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whole thing, because there doesn't seem to be an API call to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * determine how much compressed data we need to be sure of being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * able to decompress the required slice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VARATT_EXTERNAL_GET_COMPRESS_METHOD(toast_pointer) ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TOAST_PGLZ_COMPRESSION_ID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_size = pglz_maximum_compressed_size(slicelimit, max_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fetch enough compressed slices (compressed marker will get set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * automatically).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; preslice = <a href="#L396" title="access/common/detoast.c:396">toast_fetch_datum_slice</a>(attr, <span class="Constant">0</span>, max_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; preslice = <a href="#L343" title="access/common/detoast.c:343">toast_fetch_datum</a>(attr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_EXTERNAL_INDIRECT(attr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varatt_indirect redirect;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VARATT_EXTERNAL_GET_POINTER(redirect, attr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nested indirect Datums aren't allowed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!VARATT_IS_EXTERNAL_INDIRECT(redirect.pointer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L205" title="access/common/detoast.c:205">detoast_attr_slice</a>(redirect.pointer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sliceoffset, slicelength);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_EXTERNAL_EXPANDED(attr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pass it off to <a href="#L45" title="access/common/detoast.c:45">detoast_external_attr</a> to flatten */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; preslice = <a href="#L45" title="access/common/detoast.c:45">detoast_external_attr</a>(attr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; preslice = attr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!VARATT_IS_EXTERNAL(preslice));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_COMPRESSED(preslice))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varlena *tmp = preslice;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Decompress enough to encompass the slice and the offset */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slicelimit &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; preslice = <a href="#L503" title="access/common/detoast.c:503">toast_decompress_datum_slice</a>(tmp, slicelimit);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; preslice = <a href="#L471" title="access/common/detoast.c:471">toast_decompress_datum</a>(tmp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tmp != attr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tmp);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_SHORT(preslice))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attrdata = VARDATA_SHORT(preslice);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attrsize = VARSIZE_SHORT(preslice) - VARHDRSZ_SHORT;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attrdata = VARDATA(preslice);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attrsize = VARSIZE(preslice) - VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* slicing of datum for compressed cases and plain value */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sliceoffset &gt;= attrsize)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sliceoffset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slicelength = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (slicelength &lt; <span class="Constant">0</span> || slicelimit &gt; attrsize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slicelength = attrsize - sliceoffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<span class="Type">struct</span> varlena *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(slicelength + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(result, slicelength + VARHDRSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(VARDATA(result), attrdata + sliceoffset, slicelength);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (preslice != attr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(preslice);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L343" title="access/common/detoast.c:343">toast_fetch_datum</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Reconstruct an in memory Datum from the chunks saved<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; in the toast relation<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> varlena *<br/></li>
<li><a id="L343">&#x200c;</a><span class="linkable">toast_fetch_datum</span>(<span class="Type">struct</span> varlena *attr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; toastrel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> varlena *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> varatt_external toast_pointer;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; attrsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!VARATT_IS_EXTERNAL_ONDISK(attr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L343" title="access/common/detoast.c:343">toast_fetch_datum</a> shouldn't be called for non-ondisk datums&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must copy to access aligned fields */<br/></li>
<li></span>&nbsp; &nbsp; VARATT_EXTERNAL_GET_POINTER(toast_pointer, attr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrsize = VARATT_EXTERNAL_GET_EXTSIZE(toast_pointer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<span class="Type">struct</span> varlena *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(attrsize + VARHDRSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (VARATT_EXTERNAL_IS_COMPRESSED(toast_pointer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE_COMPRESSED(result, attrsize + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(result, attrsize + VARHDRSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attrsize == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Probably shouldn't happen, but just in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open the toast relation and its indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; toastrel = <a href="../table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(toast_pointer.va_toastrelid, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch all chunks */<br/></li>
<li></span>&nbsp; &nbsp; table_relation_fetch_toast_slice(toastrel, toast_pointer.va_valueid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attrsize, <span class="Constant">0</span>, attrsize, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close toast table */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(toastrel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L396" title="access/common/detoast.c:396">toast_fetch_datum_slice</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Reconstruct a segment of a Datum from the chunks saved<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; in the toast relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Note that this function supports non-compressed external datums<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; and compressed external datums (in which case the requested slice<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; has to be a prefix, i.e. sliceoffset has to be 0).<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> varlena *<br/></li>
<li><a id="L396">&#x200c;</a><span class="linkable">toast_fetch_datum_slice</span>(<span class="Type">struct</span> varlena *attr, int32 sliceoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32 slicelength)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; toastrel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> varlena *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> varatt_external toast_pointer;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; attrsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!VARATT_IS_EXTERNAL_ONDISK(attr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L396" title="access/common/detoast.c:396">toast_fetch_datum_slice</a> shouldn't be called for non-ondisk datums&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must copy to access aligned fields */<br/></li>
<li></span>&nbsp; &nbsp; VARATT_EXTERNAL_GET_POINTER(toast_pointer, attr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's nonsense to fetch slices of a compressed datum unless when it's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prefix -- this isn't lo_* we can't return a compressed datum which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * meaningful to toast later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!VARATT_EXTERNAL_IS_COMPRESSED(toast_pointer) || <span class="Constant">0</span> == sliceoffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrsize = VARATT_EXTERNAL_GET_EXTSIZE(toast_pointer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sliceoffset &gt;= attrsize)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sliceoffset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slicelength = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When fetching a prefix of a compressed external datum, account for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space required by va_tcinfo, which is stored at the beginning as an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * int32 value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (VARATT_EXTERNAL_IS_COMPRESSED(toast_pointer) &amp;&amp; slicelength &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slicelength = slicelength + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adjust length request if needed.&nbsp; (Note: our sole caller,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L205" title="access/common/detoast.c:205">detoast_attr_slice</a>, protects us against sliceoffset + slicelength<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overflowing.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (((sliceoffset + slicelength) &gt; attrsize) || slicelength &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slicelength = attrsize - sliceoffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<span class="Type">struct</span> varlena *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(slicelength + VARHDRSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (VARATT_EXTERNAL_IS_COMPRESSED(toast_pointer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE_COMPRESSED(result, slicelength + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(result, slicelength + VARHDRSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (slicelength == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can save a lot of work at this point! */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open the toast relation */<br/></li>
<li></span>&nbsp; &nbsp; toastrel = <a href="../table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(toast_pointer.va_toastrelid, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch all chunks */<br/></li>
<li></span>&nbsp; &nbsp; table_relation_fetch_toast_slice(toastrel, toast_pointer.va_valueid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attrsize, sliceoffset, slicelength,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close toast table */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(toastrel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L471" title="access/common/detoast.c:471">toast_decompress_datum</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Decompress a compressed version of a varlena datum<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> varlena *<br/></li>
<li><a id="L471">&#x200c;</a><span class="linkable">toast_decompress_datum</span>(<span class="Type">struct</span> varlena *attr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ToastCompressionId cmid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(VARATT_IS_COMPRESSED(attr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch the compression method id stored in the compression header and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decompress the data using the appropriate decompression routine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cmid = TOAST_COMPRESS_METHOD(attr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (cmid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TOAST_PGLZ_COMPRESSION_ID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="toast_compression.c.html#L82" title="access/common/toast_compression.c:82">pglz_decompress_datum</a>(attr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TOAST_LZ4_COMPRESSION_ID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="toast_compression.c.html#L182" title="access/common/toast_compression.c:182">lz4_decompress_datum</a>(attr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid compression method id </span><span class="Special">%d</span><span class="Constant">&quot;</span>, cmid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L503" title="access/common/detoast.c:503">toast_decompress_datum_slice</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Decompress the front of a compressed version of a varlena datum.<br/></li>
<li></span><span class="Comment"> * offset handling happens in <a href="#L205" title="access/common/detoast.c:205">detoast_attr_slice</a>.<br/></li>
<li></span><span class="Comment"> * Here we just decompress a slice from the front.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">struct</span> varlena *<br/></li>
<li><a id="L503">&#x200c;</a><span class="linkable">toast_decompress_datum_slice</span>(<span class="Type">struct</span> varlena *attr, int32 slicelength)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ToastCompressionId cmid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(VARATT_IS_COMPRESSED(attr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some callers may pass a slicelength that's more than the actual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decompressed size.&nbsp; If so, just decompress normally.&nbsp; This avoids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibly allocating a larger-than-necessary result object, and may be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * faster and/or more robust as well.&nbsp; Notably, some versions of liblz4<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have been seen to give wrong results if passed an output size that is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more than the data's true decompressed size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((uint32) slicelength &gt;= TOAST_COMPRESS_EXTSIZE(attr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L471" title="access/common/detoast.c:471">toast_decompress_datum</a>(attr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch the compression method id stored in the compression header and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decompress the data slice using the appropriate decompression routine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cmid = TOAST_COMPRESS_METHOD(attr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (cmid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TOAST_PGLZ_COMPRESSION_ID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="toast_compression.c.html#L109" title="access/common/toast_compression.c:109">pglz_decompress_datum_slice</a>(attr, slicelength);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TOAST_LZ4_COMPRESSION_ID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="toast_compression.c.html#L215" title="access/common/toast_compression.c:215">lz4_decompress_datum_slice</a>(attr, slicelength);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid compression method id </span><span class="Special">%d</span><span class="Constant">&quot;</span>, cmid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L545" title="access/common/detoast.c:545">toast_raw_datum_size</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Return the raw (detoasted) size of a varlena datum<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (including the VARHDRSZ header)<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L545">&#x200c;</a><span class="linkable">toast_raw_datum_size</span>(Datum value)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> varlena *attr = (<span class="Type">struct</span> varlena *) DatumGetPointer(value);<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXTERNAL_ONDISK(attr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* va_rawsize is the size of the original datum -- including header */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varatt_external toast_pointer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VARATT_EXTERNAL_GET_POINTER(toast_pointer, attr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = toast_pointer.va_rawsize;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_EXTERNAL_INDIRECT(attr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varatt_indirect toast_pointer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VARATT_EXTERNAL_GET_POINTER(toast_pointer, attr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nested indirect Datums aren't allowed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!VARATT_IS_EXTERNAL_INDIRECT(toast_pointer.pointer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L545" title="access/common/detoast.c:545">toast_raw_datum_size</a>(PointerGetDatum(toast_pointer.pointer));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_EXTERNAL_EXPANDED(attr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/adt/expandeddatum.c.html#L75" title="utils/adt/expandeddatum.c:75">EOH_get_flat_size</a>(<a href="../../utils/adt/expandeddatum.c.html#L29" title="utils/adt/expandeddatum.c:29">DatumGetEOHP</a>(value));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_COMPRESSED(attr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* here, va_rawsize is just the payload size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = VARDATA_COMPRESSED_GET_EXTSIZE(attr) + VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_SHORT(attr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we have to normalize the header length to VARHDRSZ or else the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * callers of this function will be confused.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = VARSIZE_SHORT(attr) - VARHDRSZ_SHORT + VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* plain untoasted datum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = VARSIZE(attr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L601" title="access/common/detoast.c:601">toast_datum_size</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Return the physical storage size (possibly compressed) of a varlena datum<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L601">&#x200c;</a><span class="linkable">toast_datum_size</span>(Datum value)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> varlena *attr = (<span class="Type">struct</span> varlena *) DatumGetPointer(value);<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXTERNAL_ONDISK(attr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Attribute is stored externally - return the extsize whether<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * compressed or not.&nbsp; We do not count the size of the toast pointer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ... should we?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varatt_external toast_pointer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VARATT_EXTERNAL_GET_POINTER(toast_pointer, attr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = VARATT_EXTERNAL_GET_EXTSIZE(toast_pointer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_EXTERNAL_INDIRECT(attr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varatt_indirect toast_pointer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VARATT_EXTERNAL_GET_POINTER(toast_pointer, attr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nested indirect Datums aren't allowed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!VARATT_IS_EXTERNAL_INDIRECT(attr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L601" title="access/common/detoast.c:601">toast_datum_size</a>(PointerGetDatum(toast_pointer.pointer));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_EXTERNAL_EXPANDED(attr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/adt/expandeddatum.c.html#L75" title="utils/adt/expandeddatum.c:75">EOH_get_flat_size</a>(<a href="../../utils/adt/expandeddatum.c.html#L29" title="utils/adt/expandeddatum.c:29">DatumGetEOHP</a>(value));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_SHORT(attr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = VARSIZE_SHORT(attr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Attribute is stored inline either compressed or not, just calculate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the size of the datum in either case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = VARSIZE(attr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
