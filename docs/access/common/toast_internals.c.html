<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/common/toast_internals.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/common/toast_internals.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L641">init_toast_snapshot</a></li>
<li><a href="#L623">toast_close_indexes</a></li>
<li><a href="#L46">toast_compress_datum</a></li>
<li><a href="#L385">toast_delete_datum</a></li>
<li><a href="#L530">toast_get_valid_index</a></li>
<li><a href="#L564">toast_open_indexes</a></li>
<li><a href="#L119">toast_save_datum</a></li>
<li><a href="#L509">toastid_valueid_exists</a></li>
<li><a href="#L461">toastrel_valueid_exists</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * toast_internals.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Functions for <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> use by the TOAST system.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2000-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/common/toast_internals.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/detoast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heaptoast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/toast_internals.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/catalog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L461" title="access/common/toast_internals.c:461">toastrel_valueid_exists</a>(Relation toastrel, Oid valueid);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L509" title="access/common/toast_internals.c:509">toastid_valueid_exists</a>(Oid toastrelid, Oid valueid);<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L46" title="access/common/toast_internals.c:46">toast_compress_datum</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Create a compressed version of a varlena datum<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If we fail (ie, compressed result is actually bigger than original)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; then return NULL.&nbsp; We must not use compressed data if it'd expand<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the tuple!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We use VAR{SIZE,DATA}_ANY so we can handle short varlenas here without<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; copying them.&nbsp; But we can't handle external or compressed datums.<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L46">&#x200c;</a><span class="linkable">toast_compress_datum</span>(Datum value, <span class="Type">char</span> cmethod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> varlena *tmp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; valsize;<br/></li>
<li>&nbsp; &nbsp; ToastCompressionId cmid = TOAST_INVALID_COMPRESSION_ID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!VARATT_IS_EXTERNAL(DatumGetPointer(value)));<br/></li>
<li>&nbsp; &nbsp; Assert(!VARATT_IS_COMPRESSED(DatumGetPointer(value)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; valsize = VARSIZE_ANY_EXHDR(DatumGetPointer(value));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the compression method is not valid, use the current default */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!CompressionMethodIsValid(cmethod))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmethod = <a href="toast_compression.c.html#L26" title="access/common/toast_compression.c:26">default_toast_compression</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call appropriate compression routine for the compression method.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (cmethod)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TOAST_PGLZ_COMPRESSION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <a href="toast_compression.c.html#L40" title="access/common/toast_compression.c:40">pglz_compress_datum</a>((<span class="Type">const</span> <span class="Type">struct</span> varlena *) value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmid = TOAST_PGLZ_COMPRESSION_ID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TOAST_LZ4_COMPRESSION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <a href="toast_compression.c.html#L139" title="access/common/toast_compression.c:139">lz4_compress_datum</a>((<span class="Type">const</span> <span class="Type">struct</span> varlena *) value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmid = TOAST_LZ4_COMPRESSION_ID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid compression method </span><span class="Special">%c</span><span class="Constant">&quot;</span>, cmethod);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tmp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We recheck the actual size even if compression reports success, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it might be satisfied with having saved as little as one byte in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compressed data --- which could turn into a net loss once you consider<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * header and alignment padding.&nbsp; Worst case, the compressed format might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * require three padding bytes (plus header, which is included in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * VARSIZE(tmp)), whereas the uncompressed format would take only one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * header byte and no padding if the value is short enough.&nbsp; So we insist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on a savings of more than 2 bytes to ensure we have a gain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (VARSIZE(tmp) &lt; valsize - <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* successful compression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(cmid != TOAST_INVALID_COMPRESSION_ID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TOAST_COMPRESS_SET_SIZE_AND_COMPRESS_METHOD(tmp, valsize, cmid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(tmp);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* incompressible data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tmp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L119" title="access/common/toast_internals.c:119">toast_save_datum</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Save one single datum into the secondary relation and return<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; a Datum reference for it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * rel: the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> relation we're working with (not the toast rel!)<br/></li>
<li></span><span class="Comment"> * value: datum to be pushed to toast storage<br/></li>
<li></span><span class="Comment"> * oldexternal: if not NULL, toast pointer previously representing the datum<br/></li>
<li></span><span class="Comment"> * options: options to be passed to <a href="../heap/heapam.c.html#L1990" title="access/heap/heapam.c:1990">heap_insert</a>() for toast rows<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L119">&#x200c;</a><span class="linkable">toast_save_datum</span>(Relation rel, Datum value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> varlena *oldexternal, <span class="Type">int</span> options)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; toastrel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp;&nbsp; *toastidxs;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; toasttup;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; toasttupDesc;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; t_values[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; t_isnull[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; CommandId&nbsp; &nbsp; mycid = <a href="../transam/xact.c.html#L826" title="access/transam/xact.c:826">GetCurrentCommandId</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> varlena *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> varatt_external toast_pointer;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">union<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varlena hdr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this is to make the union big enough for a chunk: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; data[TOAST_MAX_CHUNK_SIZE + VARHDRSZ];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ensure union is aligned well enough: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; align_it;<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunk_data;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; chunk_size;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; chunk_seq = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *data_p;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; data_todo;<br/></li>
<li>&nbsp; &nbsp; Pointer&nbsp; &nbsp; &nbsp; &nbsp; dval = DatumGetPointer(value);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_indexes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; validIndex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!VARATT_IS_EXTERNAL(value));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open the toast relation and its indexes.&nbsp; We can use the index to check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * uniqueness of the OID we assign to the toasted item, even though it has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * additional columns besides OID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; toastrel = <a href="../table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(rel-&gt;rd_rel-&gt;reltoastrelid, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; toasttupDesc = toastrel-&gt;rd_att;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open all the toast indexes and look for the valid one */<br/></li>
<li></span>&nbsp; &nbsp; validIndex = <a href="#L564" title="access/common/toast_internals.c:564">toast_open_indexes</a>(toastrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RowExclusiveLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;toastidxs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;num_indexes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the data pointer and length, and compute va_rawsize and va_extinfo.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * va_rawsize is the size of the equivalent fully uncompressed datum, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we have to adjust for short headers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * va_extinfo stored the actual size of the data payload in the toast<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> and the compression method in first 2 bits if data is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compressed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_SHORT(dval))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data_p = VARDATA_SHORT(dval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data_todo = VARSIZE_SHORT(dval) - VARHDRSZ_SHORT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; toast_pointer.va_rawsize = data_todo + VARHDRSZ;&nbsp; &nbsp; <span class="Comment">/* as if not short */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; toast_pointer.va_extinfo = data_todo;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_COMPRESSED(dval))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data_p = VARDATA(dval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data_todo = VARSIZE(dval) - VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rawsize in a compressed datum is just the size of the payload */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; toast_pointer.va_rawsize = VARDATA_COMPRESSED_GET_EXTSIZE(dval) + VARHDRSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set external size and compression method */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; VARATT_EXTERNAL_SET_SIZE_AND_COMPRESS_METHOD(toast_pointer, data_todo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARDATA_COMPRESSED_GET_COMPRESS_METHOD(dval));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assert that the numbers look like it's compressed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(VARATT_EXTERNAL_IS_COMPRESSED(toast_pointer));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data_p = VARDATA(dval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data_todo = VARSIZE(dval) - VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; toast_pointer.va_rawsize = VARSIZE(dval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; toast_pointer.va_extinfo = data_todo;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> the correct table OID into the result TOAST pointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normally this is the actual OID of the target toast table, but during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table-rewriting operations such as CLUSTER, we have to insert the OID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the table's real permanent toast table instead.&nbsp; rd_toastoid is set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we have to substitute such an OID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(rel-&gt;rd_toastoid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; toast_pointer.va_toastrelid = rel-&gt;rd_toastoid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; toast_pointer.va_toastrelid = RelationGetRelid(toastrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Choose an OID to use as the value ID for this toast value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normally we just choose an unused OID within the toast table.&nbsp; But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during table-rewriting operations where we are preserving an existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * toast table OID, we want to preserve toast value OIDs too.&nbsp; So, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rd_toastoid is set and we had a prior external value from that same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * toast table, re-use its value ID.&nbsp; If we didn't have a prior external<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value (which is a corner case, but possible if the table's attstorage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * options have been changed), we have to pick a value ID that doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conflict with either new or existing toast value OIDs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(rel-&gt;rd_toastoid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* normal case: just choose an unused OID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; toast_pointer.va_valueid =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/catalog.c.html#L391" title="catalog/catalog.c:391">GetNewOidWithIndex</a>(toastrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(toastidxs[validIndex]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (AttrNumber) <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rewrite case: check to see if value was in old toast table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; toast_pointer.va_valueid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldexternal != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varatt_external old_toast_pointer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(VARATT_IS_EXTERNAL_ONDISK(oldexternal));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must copy to access aligned fields */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARATT_EXTERNAL_GET_POINTER(old_toast_pointer, oldexternal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_toast_pointer.va_toastrelid == rel-&gt;rd_toastoid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This value came from the old toast table; reuse its OID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_pointer.va_valueid = old_toast_pointer.va_valueid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is a corner case here: the table rewrite might have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to copy both live and recently-dead versions of a row, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * those versions could easily reference the same toast value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When we copy the second or later version of such a row,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reusing the OID will mean we <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> an OID that's already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the new toast table.&nbsp; Check for that, and if so, just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fall through without writing the data again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * While annoying and ugly-looking, this is a good thing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because it ensures that we wind up with only one copy of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the toast value when there is only one copy in the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * toast table.&nbsp; Before we detected this case, we'd have made<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple copies, wasting space; and what's worse, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * copies belonging to already-deleted heap tuples would not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be reclaimed by VACUUM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L461" title="access/common/toast_internals.c:461">toastrel_valueid_exists</a>(toastrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_pointer.va_valueid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Match, so short-circuit the data storage loop below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data_todo = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (toast_pointer.va_valueid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new value; must choose an OID that doesn't conflict in either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * old or new toast table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_pointer.va_valueid =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/catalog.c.html#L391" title="catalog/catalog.c:391">GetNewOidWithIndex</a>(toastrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(toastidxs[validIndex]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (AttrNumber) <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (<a href="#L509" title="access/common/toast_internals.c:509">toastid_valueid_exists</a>(rel-&gt;rd_toastoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_pointer.va_valueid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize constant parts of the tuple data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; t_values[<span class="Constant">0</span>] = ObjectIdGetDatum(toast_pointer.va_valueid);<br/></li>
<li>&nbsp; &nbsp; t_values[<span class="Constant">2</span>] = PointerGetDatum(&amp;chunk_data);<br/></li>
<li>&nbsp; &nbsp; t_isnull[<span class="Constant">0</span>] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; t_isnull[<span class="Constant">1</span>] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; t_isnull[<span class="Constant">2</span>] = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Split up the item into chunks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (data_todo &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Calculate the size of this chunk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; chunk_size = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(TOAST_MAX_CHUNK_SIZE, data_todo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Build a tuple and store it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; t_values[<span class="Constant">1</span>] = Int32GetDatum(chunk_seq++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(&amp;chunk_data, chunk_size + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(VARDATA(&amp;chunk_data), data_p, chunk_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; toasttup = <a href="heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(toasttupDesc, t_values, t_isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../heap/heapam.c.html#L1990" title="access/heap/heapam.c:1990">heap_insert</a>(toastrel, toasttup, mycid, options, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create the index entry.&nbsp; We cheat a little here by not using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../catalog/index.c.html#L2705" title="catalog/index.c:2705">FormIndexDatum</a>: this relies on the knowledge that the index columns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are the same as the initial columns of the table for all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indexes.&nbsp; We also cheat by not providing an IndexInfo: this is okay<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> because btree doesn't need one, but we might have to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more honest someday.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note also that there had better not be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> user-created index on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the TOAST table, since we don't bother to update anything else.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_indexes; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Only index relations marked as ready can be updated */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (toastidxs[i]-&gt;rd_index-&gt;indisready)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../index/indexam.c.html#L213" title="access/index/indexam.c:213">index_insert</a>(toastidxs[i], t_values, t_isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;(toasttup-&gt;t_self),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; toastrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; toastidxs[i]-&gt;rd_index-&gt;indisunique ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; UNIQUE_CHECK_YES : UNIQUE_CHECK_NO,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Free memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(toasttup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Move on to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> chunk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; data_todo -= chunk_size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data_p += chunk_size;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Done - close toast relation and its indexes but keep the lock until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit, so as a concurrent reindex done directly on the toast relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would be able to wait for this transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L623" title="access/common/toast_internals.c:623">toast_close_indexes</a>(toastidxs, num_indexes, NoLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(toastrel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the TOAST pointer value that we'll return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = (<span class="Type">struct</span> varlena *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(TOAST_POINTER_SIZE);<br/></li>
<li>&nbsp; &nbsp; SET_VARTAG_EXTERNAL(result, VARTAG_ONDISK);<br/></li>
<li>&nbsp; &nbsp; memcpy(VARDATA_EXTERNAL(result), &amp;toast_pointer, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(toast_pointer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L385" title="access/common/toast_internals.c:385">toast_delete_datum</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> a single external stored value.<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L385">&#x200c;</a></span><span class="linkable">toast_delete_datum</span>(Relation rel, Datum value, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_speculative)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> varlena *attr = (<span class="Type">struct</span> varlena *) DatumGetPointer(value);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> varatt_external toast_pointer;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; toastrel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp;&nbsp; *toastidxs;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData toastkey;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc toastscan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; toasttup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_indexes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; validIndex;<br/></li>
<li>&nbsp; &nbsp; SnapshotData SnapshotToast;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!VARATT_IS_EXTERNAL_ONDISK(attr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must copy to access aligned fields */<br/></li>
<li></span>&nbsp; &nbsp; VARATT_EXTERNAL_GET_POINTER(toast_pointer, attr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open the toast relation and its indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; toastrel = <a href="../table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(toast_pointer.va_toastrelid, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch valid relation used for process */<br/></li>
<li></span>&nbsp; &nbsp; validIndex = <a href="#L564" title="access/common/toast_internals.c:564">toast_open_indexes</a>(toastrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RowExclusiveLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;toastidxs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;num_indexes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Setup a scan key to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> chunks with matching va_valueid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;toastkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (AttrNumber) <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(toast_pointer.va_valueid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find all the chunks.&nbsp; (We don't actually care whether we see them in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sequence or not, but since we've already locked the index we might as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * well use <a href="../index/genam.c.html#L643" title="access/index/genam.c:643">systable_beginscan_ordered</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L641" title="access/common/toast_internals.c:641">init_toast_snapshot</a>(&amp;SnapshotToast);<br/></li>
<li>&nbsp; &nbsp; toastscan = <a href="../index/genam.c.html#L643" title="access/index/genam.c:643">systable_beginscan_ordered</a>(toastrel, toastidxs[validIndex],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;SnapshotToast, <span class="Constant">1</span>, &amp;toastkey);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((toasttup = <a href="../index/genam.c.html#L710" title="access/index/genam.c:710">systable_getnext_ordered</a>(toastscan, ForwardScanDirection)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Have a chunk, delete it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_speculative)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../heap/heapam.c.html#L5902" title="access/heap/heapam.c:5902">heap_abort_speculative</a>(toastrel, &amp;toasttup-&gt;t_self);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../heap/heapam.c.html#L3100" title="access/heap/heapam.c:3100">simple_heap_delete</a>(toastrel, &amp;toasttup-&gt;t_self);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * End scan and close relations but keep the lock until commit, so as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrent reindex done directly on the toast relation would be able to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wait for this transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../index/genam.c.html#L735" title="access/index/genam.c:735">systable_endscan_ordered</a>(toastscan);<br/></li>
<li>&nbsp; &nbsp; <a href="#L623" title="access/common/toast_internals.c:623">toast_close_indexes</a>(toastidxs, num_indexes, NoLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(toastrel, NoLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L461" title="access/common/toast_internals.c:461">toastrel_valueid_exists</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Test whether a toast value with the given ID exists in the toast relation.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; For safety, we consider a value to exist if there are either live or dead<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; toast rows with that ID; see notes for <a href="../../catalog/catalog.c.html#L391" title="catalog/catalog.c:391">GetNewOidWithIndex</a>().<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L461">&#x200c;</a></span><span class="linkable">toastrel_valueid_exists</span>(Relation toastrel, Oid valueid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData toastkey;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc toastscan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_indexes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; validIndex;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp;&nbsp; *toastidxs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch a valid index relation */<br/></li>
<li></span>&nbsp; &nbsp; validIndex = <a href="#L564" title="access/common/toast_internals.c:564">toast_open_indexes</a>(toastrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RowExclusiveLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;toastidxs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;num_indexes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Setup a scan key to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> chunks with matching va_valueid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;toastkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (AttrNumber) <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(valueid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Is there <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such chunk?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; toastscan = <a href="../index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(toastrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(toastidxs[validIndex]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, SnapshotAny, <span class="Constant">1</span>, &amp;toastkey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(toastscan) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(toastscan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L623" title="access/common/toast_internals.c:623">toast_close_indexes</a>(toastidxs, num_indexes, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L509" title="access/common/toast_internals.c:509">toastid_valueid_exists</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; As above, but work from toast rel's OID not an open relation<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L509">&#x200c;</a></span><span class="linkable">toastid_valueid_exists</span>(Oid toastrelid, Oid valueid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; toastrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; toastrel = <a href="../table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(toastrelid, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L461" title="access/common/toast_internals.c:461">toastrel_valueid_exists</a>(toastrel, valueid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(toastrel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L530" title="access/common/toast_internals.c:530">toast_get_valid_index</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Get OID of valid index associated to given toast relation. A toast<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; relation can have only one valid index at the same time.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L530">&#x200c;</a><span class="linkable">toast_get_valid_index</span>(Oid toastoid, LOCKMODE lock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_indexes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; validIndex;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; validIndexOid;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp;&nbsp; *toastidxs;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; toastrel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open the toast relation */<br/></li>
<li></span>&nbsp; &nbsp; toastrel = <a href="../table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(toastoid, lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look for the valid index of the toast relation */<br/></li>
<li></span>&nbsp; &nbsp; validIndex = <a href="#L564" title="access/common/toast_internals.c:564">toast_open_indexes</a>(toastrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;toastidxs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;num_indexes);<br/></li>
<li>&nbsp; &nbsp; validIndexOid = RelationGetRelid(toastidxs[validIndex]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close the toast relation and all its indexes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L623" title="access/common/toast_internals.c:623">toast_close_indexes</a>(toastidxs, num_indexes, NoLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(toastrel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> validIndexOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L564" title="access/common/toast_internals.c:564">toast_open_indexes</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Get an array of the indexes associated to the given toast relation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; and return as well the position of the valid index used by the toast<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; relation in this array. It is the responsibility of the caller of this<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; function to close the indexes as well as free them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L564">&#x200c;</a></span><span class="linkable">toast_open_indexes</span>(Relation toastrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOCKMODE lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation **toastidxs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *num_indexes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get index list of the toast relation */<br/></li>
<li></span>&nbsp; &nbsp; indexlist = <a href="../../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(toastrel);<br/></li>
<li>&nbsp; &nbsp; Assert(indexlist != NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *num_indexes = list_length(indexlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open all the index relations */<br/></li>
<li></span>&nbsp; &nbsp; *toastidxs = (Relation *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(*num_indexes * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Relation));<br/></li>
<li>&nbsp; &nbsp; foreach(lc, indexlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*toastidxs)[i++] = <a href="../index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(lfirst_oid(lc), lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch the first valid index in list */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; *num_indexes; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; toastidx = (*toastidxs)[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (toastidx-&gt;rd_index-&gt;indisvalid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Free index list, not necessary anymore as relations are opened and a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * valid index has been found.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(indexlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The toast relation should have one valid index, so something is going<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wrong if there is nothing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no valid index found for toast relation with Oid </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(toastrel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L623" title="access/common/toast_internals.c:623">toast_close_indexes</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Close an array of indexes for a toast relation and free it. This should<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; be called for a set of indexes opened previously with <a href="#L564" title="access/common/toast_internals.c:564">toast_open_indexes</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L623">&#x200c;</a></span><span class="linkable">toast_close_indexes</span>(Relation *toastidxs, <span class="Type">int</span> num_indexes, LOCKMODE lock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close relations and clean up things */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_indexes; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(toastidxs[i], lock);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(toastidxs);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L641" title="access/common/toast_internals.c:641">init_toast_snapshot</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Initialize an appropriate TOAST snapshot.&nbsp; We must use an MVCC snapshot<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the TOAST snapshot; since we don't know which one to use,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; just use the oldest one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L641">&#x200c;</a></span><span class="linkable">init_toast_snapshot</span>(Snapshot toast_snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot = <a href="../../utils/time/snapmgr.c.html#L323" title="utils/time/snapmgr.c:323">GetOldestSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/time/snapmgr.c.html#L323" title="utils/time/snapmgr.c:323">GetOldestSnapshot</a> returns NULL if the session has no active snapshots.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can get that if, for example, a procedure fetches a toasted value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into a local variable, commits, and then tries to detoast the value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Such coding is unsafe, because once we commit there is nothing to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prevent the toast data from being deleted.&nbsp; Detoasting *must* happen in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same transaction that originally fetched the toast pointer.&nbsp; Hence,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rather than trying to band-aid over the problem, throw an error.&nbsp; (This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is not very much protection, because in many scenarios the procedure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would have already created a new transaction snapshot, preventing us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from detecting the problem.&nbsp; But it's better than nothing, and for sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we shouldn't expend code on masking the problem more.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot fetch toast data without an active snapshot&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Catalog snapshots can be returned by <a href="../../utils/time/snapmgr.c.html#L323" title="utils/time/snapmgr.c:323">GetOldestSnapshot</a>() even if not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * registered or active. That easily hides bugs around not having a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot set up - most of the time there is a valid catalog snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * So additionally insist that the current snapshot is registered or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * active.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../utils/time/snapmgr.c.html#L1624" title="utils/time/snapmgr.c:1624">HaveRegisteredOrActiveSnapshot</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitToastSnapshot(*toast_snapshot, snapshot-&gt;lsn, snapshot-&gt;whenTaken);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
