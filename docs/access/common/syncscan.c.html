<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/common/syncscan.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/common/syncscan.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L115">scan_locations</a></li>
<li><a href="#L58">trace_syncscan</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L97">ss_lru_item_t</a></li>
<li><a href="#L102">ss_lru_item_t</a></li>
<li><a href="#L91">ss_scan_location_t</a></li>
<li><a href="#L95">ss_scan_location_t</a></li>
<li><a href="#L104">ss_scan_locations_t</a></li>
<li><a href="#L109">ss_scan_locations_t</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L135">SyncScanShmemInit</a></li>
<li><a href="#L126">SyncScanShmemSize</a></li>
<li><a href="#L254">ss_get_location</a></li>
<li><a href="#L289">ss_report_location</a></li>
<li><a href="#L191">ss_search</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L71">SYNC_SCAN_NELEM</a></li>
<li><a href="#L83">SYNC_SCAN_REPORT_INTERVAL</a></li>
<li><a href="#L111">SizeOfScanLocations</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * syncscan.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; scan synchronization support<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When multiple backends run a sequential scan on the same table, we try<br/></li>
<li></span><span class="Comment"> * to keep them synchronized to reduce the overall I/O needed.&nbsp; The goal is<br/></li>
<li></span><span class="Comment"> * to read each page into shared buffer cache only once, and let all backends<br/></li>
<li></span><span class="Comment"> * that take part in the shared scan process the page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it falls out of<br/></li>
<li></span><span class="Comment"> * the cache.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since the &quot;leader&quot; in a pack of backends doing a seqscan will have to wait<br/></li>
<li></span><span class="Comment"> * for I/O, while the &quot;followers&quot; don't, there is a strong self-synchronizing<br/></li>
<li></span><span class="Comment"> * effect once we can get the backends examining approximately the same part<br/></li>
<li></span><span class="Comment"> * of the table at the same time.&nbsp; Hence all that is really needed is to get<br/></li>
<li></span><span class="Comment"> * a new backend beginning a seqscan to begin it close to where other backends<br/></li>
<li></span><span class="Comment"> * are reading.&nbsp; We can scan the table circularly, from block X up to the<br/></li>
<li></span><span class="Comment"> * end and then from block 0 to X-1, to ensure we visit all rows while still<br/></li>
<li></span><span class="Comment"> * participating in the common scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To accomplish that, we keep track of the scan position of each table, and<br/></li>
<li></span><span class="Comment"> * start new scans close to where the previous scan(s) are.&nbsp; We don't try to<br/></li>
<li></span><span class="Comment"> * do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> extra synchronization to keep the scans together afterwards; some<br/></li>
<li></span><span class="Comment"> * scans might progress much more slowly than others, for example if the<br/></li>
<li></span><span class="Comment"> * results need to be transferred to the client over a slow network, and we<br/></li>
<li></span><span class="Comment"> * don't want such queries to slow down others.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There can realistically only be a few large sequential scans on different<br/></li>
<li></span><span class="Comment"> * tables in progress at <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> time.&nbsp; Therefore we just keep the scan positions<br/></li>
<li></span><span class="Comment"> * in a small LRU list which we scan every time we need to look up or update a<br/></li>
<li></span><span class="Comment"> * scan position.&nbsp; The whole mechanism is only applied for tables exceeding<br/></li>
<li></span><span class="Comment"> * a threshold size (but that is not the concern of this module).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * INTERFACE ROUTINES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L254" title="access/common/syncscan.c:254">ss_get_location</a>&nbsp; &nbsp; &nbsp; &nbsp; - return current scan location of a relation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L289" title="access/common/syncscan.c:289">ss_report_location</a>&nbsp; &nbsp; - update current scan location<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/common/syncscan.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/syncscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lwlock.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* GUC variables */<br/></li>
<li></span><span class="PreProc">#ifdef TRACE_SYNCSCAN<br/></li>
<li><a id="L58">&#x200c;</a></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">trace_syncscan</span> = <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Size of the LRU list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the code assumes that <a href="#L71" title="access/common/syncscan.c:71">SYNC_SCAN_NELEM</a> &gt; 1.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment">: What's a good value? It should be large enough to hold the<br/></li>
<li></span><span class="Comment"> * maximum number of large tables scanned simultaneously.&nbsp; But a larger value<br/></li>
<li></span><span class="Comment"> * means more traversing of the LRU list when starting a new scan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SYNC_SCAN_NELEM</span> </span><span class="Constant">20<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Interval between reports of the location of the current scan, in pages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: This should be smaller than the ring size (see buffer/freelist.c)<br/></li>
<li></span><span class="Comment"> * we use for bulk reads.&nbsp; Otherwise a scan joining other scans might start<br/></li>
<li></span><span class="Comment"> * from a page that's no longer in the buffer cache.&nbsp; This is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> fuzzy;<br/></li>
<li></span><span class="Comment"> * there's no guarantee that the new scan will read the page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it leaves<br/></li>
<li></span><span class="Comment"> * the buffer cache anyway, and on the other hand the page is most likely<br/></li>
<li></span><span class="Comment"> * still in the OS cache.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L83">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SYNC_SCAN_REPORT_INTERVAL</span> (</span><span class="Constant">128</span><span class="PreProc"> * </span><span class="Constant">1024</span><span class="PreProc"> / BLCKSZ)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The scan locations structure is essentially a doubly-linked LRU with head<br/></li>
<li></span><span class="Comment"> * and tail pointer, but designed to hold a fixed maximum number of elements in<br/></li>
<li></span><span class="Comment"> * fixed-size shared memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L91">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ss_scan_location_t</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelFileLocator relfilelocator;&nbsp; &nbsp; <span class="Comment">/* identity of a relation */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber location;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* last-reported location in the relation */<br/></li>
<li><a id="L95">&#x200c;</a></span>} <span class="linkable">ss_scan_location_t</span>;<br/></li>
<li><br/></li>
<li><a id="L97">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ss_lru_item_t</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L97" title="access/common/syncscan.c:97">ss_lru_item_t</a> *prev;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L97" title="access/common/syncscan.c:97">ss_lru_item_t</a> *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L91" title="access/common/syncscan.c:91">ss_scan_location_t</a> location;<br/></li>
<li><a id="L102">&#x200c;</a>} <span class="linkable">ss_lru_item_t</span>;<br/></li>
<li><br/></li>
<li><a id="L104">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ss_scan_locations_t</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="access/common/syncscan.c:97">ss_lru_item_t</a> *head;<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="access/common/syncscan.c:97">ss_lru_item_t</a> *tail;<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="access/common/syncscan.c:97">ss_lru_item_t</a> items[FLEXIBLE_ARRAY_MEMBER]; <span class="Comment">/* <a href="#L71" title="access/common/syncscan.c:71">SYNC_SCAN_NELEM</a> items */<br/></li>
<li><a id="L109">&#x200c;</a></span>} <span class="linkable">ss_scan_locations_t</span>;<br/></li>
<li><br/></li>
<li><a id="L111">&#x200c;</a><span class="PreProc">#define <span class="linkable">SizeOfScanLocations</span>(N) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (offsetof(<a href="#L104" title="access/common/syncscan.c:104">ss_scan_locations_t</a>, items) + (N) * </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(<a href="#L97" title="access/common/syncscan.c:97">ss_lru_item_t</a>))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Pointer to struct in shared memory */<br/></li>
<li><a id="L115">&#x200c;</a></span><span class="Type">static</span> <a href="#L104" title="access/common/syncscan.c:104">ss_scan_locations_t</a> *<span class="linkable">scan_locations</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* prototypes for <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> BlockNumber <a href="#L191" title="access/common/syncscan.c:191">ss_search</a>(RelFileLocator relfilelocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber location, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> set);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L126" title="access/common/syncscan.c:126">SyncScanShmemSize</a> --- report amount of shared memory space needed<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L126">&#x200c;</a><span class="linkable">SyncScanShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L111" title="access/common/syncscan.c:111">SizeOfScanLocations</a>(<a href="#L71" title="access/common/syncscan.c:71">SYNC_SCAN_NELEM</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L135" title="access/common/syncscan.c:135">SyncScanShmemInit</a> --- <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> this module's shared memory<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L135">&#x200c;</a></span><span class="linkable">SyncScanShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L115" title="access/common/syncscan.c:115">scan_locations</a> = (<a href="#L104" title="access/common/syncscan.c:104">ss_scan_locations_t</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;Sync Scan Locations List&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L111" title="access/common/syncscan.c:111">SizeOfScanLocations</a>(<a href="#L71" title="access/common/syncscan.c:71">SYNC_SCAN_NELEM</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize shared memory area */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="access/common/syncscan.c:115">scan_locations</a>-&gt;head = &amp;<a href="#L115" title="access/common/syncscan.c:115">scan_locations</a>-&gt;items[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="access/common/syncscan.c:115">scan_locations</a>-&gt;tail = &amp;<a href="#L115" title="access/common/syncscan.c:115">scan_locations</a>-&gt;items[<a href="#L71" title="access/common/syncscan.c:71">SYNC_SCAN_NELEM</a> - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L71" title="access/common/syncscan.c:71">SYNC_SCAN_NELEM</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="access/common/syncscan.c:97">ss_lru_item_t</a> *item = &amp;<a href="#L115" title="access/common/syncscan.c:115">scan_locations</a>-&gt;items[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initialize all slots with invalid <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. As scans are started,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * these invalid entries will fall off the LRU list and get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * replaced with real entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;location.relfilelocator.spcOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;location.relfilelocator.dbOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;location.relfilelocator.relNumber = InvalidRelFileNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;location.location = InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;prev = (i &gt; <span class="Constant">0</span>) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (&amp;<a href="#L115" title="access/common/syncscan.c:115">scan_locations</a>-&gt;items[i - <span class="Constant">1</span>]) : <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = (i &lt; <a href="#L71" title="access/common/syncscan.c:71">SYNC_SCAN_NELEM</a> - <span class="Constant">1</span>) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (&amp;<a href="#L115" title="access/common/syncscan.c:115">scan_locations</a>-&gt;items[i + <span class="Constant">1</span>]) : <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L191" title="access/common/syncscan.c:191">ss_search</a> --- search the <a href="#L115" title="access/common/syncscan.c:115">scan_locations</a> structure for an entry with the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; given relfilelocator.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If &quot;set&quot; is true, the location is updated to the given location.&nbsp; If no<br/></li>
<li></span><span class="Comment"> * entry for the given relfilelocator is found, it will be created at the head<br/></li>
<li></span><span class="Comment"> * of the list with the given location, even if &quot;set&quot; is false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, the location after possible update is returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller is responsible for having acquired suitable lock on the shared<br/></li>
<li></span><span class="Comment"> * data structure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BlockNumber<br/></li>
<li><a id="L191">&#x200c;</a><span class="linkable">ss_search</span>(RelFileLocator relfilelocator, BlockNumber location, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> set)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="access/common/syncscan.c:97">ss_lru_item_t</a> *item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; item = <a href="#L115" title="access/common/syncscan.c:115">scan_locations</a>-&gt;head;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; match;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; match = RelFileLocatorEquals(item-&gt;location.relfilelocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relfilelocator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (match || item-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we reached the end of list and no match was found, take over<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the last entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!match)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;location.relfilelocator = relfilelocator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;location.location = location;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (set)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;location.location = location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Move the entry to the front of the LRU list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item != <a href="#L115" title="access/common/syncscan.c:115">scan_locations</a>-&gt;head)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unlink */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item == <a href="#L115" title="access/common/syncscan.c:115">scan_locations</a>-&gt;tail)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="access/common/syncscan.c:115">scan_locations</a>-&gt;tail = item-&gt;prev;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;prev-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = item-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-&gt;prev = item-&gt;prev;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* link */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;prev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <a href="#L115" title="access/common/syncscan.c:115">scan_locations</a>-&gt;head;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="access/common/syncscan.c:115">scan_locations</a>-&gt;head-&gt;prev = item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="access/common/syncscan.c:115">scan_locations</a>-&gt;head = item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> item-&gt;location.location;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item = item-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not reached */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L254" title="access/common/syncscan.c:254">ss_get_location</a> --- get the optimal starting location for scan<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the last-reported location of a sequential scan on the<br/></li>
<li></span><span class="Comment"> * relation, or 0 if no valid location is found.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We expect the caller has just done RelationGetNumberOfBlocks(), and<br/></li>
<li></span><span class="Comment"> * so that number is passed in rather than computing it again.&nbsp; The result<br/></li>
<li></span><span class="Comment"> * is guaranteed less than relnblocks (assuming that's &gt; 0).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BlockNumber<br/></li>
<li><a id="L254">&#x200c;</a><span class="linkable">ss_get_location</span>(Relation rel, BlockNumber relnblocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber startloc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(SyncScanLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; startloc = <a href="#L191" title="access/common/syncscan.c:191">ss_search</a>(rel-&gt;rd_locator, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SyncScanLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the location is not a valid block number for this scan, start at 0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This can happen if for instance a VACUUM truncated the table since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * location was saved.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (startloc &gt;= relnblocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startloc = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_SYNCSCAN<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L58" title="access/common/syncscan.c:58">trace_syncscan</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;SYNC_SCAN: start </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> (size </span><span class="Special">%u</span><span class="Constant">) at </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel), relnblocks, startloc);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> startloc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L289" title="access/common/syncscan.c:289">ss_report_location</a> --- update the current scan location<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Writes an entry into the shared Sync Scan state of the form<br/></li>
<li></span><span class="Comment"> * (relfilelocator, blocknumber), overwriting <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing entry for the<br/></li>
<li></span><span class="Comment"> * same relfilelocator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L289">&#x200c;</a></span><span class="linkable">ss_report_location</span>(Relation rel, BlockNumber location)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef TRACE_SYNCSCAN<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L58" title="access/common/syncscan.c:58">trace_syncscan</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((location % <span class="Constant">1024</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;SYNC_SCAN: scanning </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> at </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel), location);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To reduce lock contention, only report scan progress every N pages. For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same reason, don't block if the lock isn't immediately available.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Missing a few updates isn't critical, it just means that a new scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that wants to join the pack will start a little <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> behind the head of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the scan.&nbsp; Hopefully the pages are still in OS cache and the scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catches up quickly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((location % <a href="#L83" title="access/common/syncscan.c:83">SYNC_SCAN_REPORT_INTERVAL</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/lmgr/lwlock.c.html#L1341" title="storage/lmgr/lwlock.c:1341">LWLockConditionalAcquire</a>(SyncScanLock, LW_EXCLUSIVE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L191" title="access/common/syncscan.c:191">ss_search</a>(rel-&gt;rd_locator, location, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SyncScanLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#ifdef TRACE_SYNCSCAN<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L58" title="access/common/syncscan.c:58">trace_syncscan</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;SYNC_SCAN: missed update for </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> at </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel), location);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
