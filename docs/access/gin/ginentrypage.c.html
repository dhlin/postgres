<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/gin/ginentrypage.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/gin/ginentrypage.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L201">GinFormInteriorTuple</a></li>
<li><a href="#L44">GinFormTuple</a></li>
<li><a href="#L527">entryBeginPlaceToPage</a></li>
<li><a href="#L554">entryExecPlaceToPage</a></li>
<li><a href="#L405">entryFindChildPtr</a></li>
<li><a href="#L446">entryGetLeftMostPage</a></li>
<li><a href="#L459">entryIsEnoughSpace</a></li>
<li><a href="#L243">entryIsMoveRight</a></li>
<li><a href="#L270">entryLocateEntry</a></li>
<li><a href="#L346">entryLocateLeafEntry</a></li>
<li><a href="#L702">entryPrepareDownlink</a></li>
<li><a href="#L490">entryPreparePage</a></li>
<li><a href="#L602">entrySplitPage</a></li>
<li><a href="#L235">getRightMostTuple</a></li>
<li><a href="#L723">ginEntryFillRoot</a></li>
<li><a href="#L747">ginPrepareEntryScan</a></li>
<li><a href="#L162">ginReadTuple</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ginentrypage.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; routines for handling GIN entry tree pages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src/backend/access/gin/ginentrypage.c<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/gin_private.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/ginxlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L602" title="access/gin/ginentrypage.c:602">entrySplitPage</a>(GinBtree btree, Buffer origbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GinBtreeStack *stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GinBtreeEntryInsertData *insertData,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber updateblkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Page *newlpage, Page *newrpage);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Form a tuple for entry tree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the tuple would be too big to be stored, function throws a suitable<br/></li>
<li></span><span class="Comment"> * error if errorTooBig is true, or returns NULL if errorTooBig is false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See src/backend/access/gin/README for a description of the index tuple<br/></li>
<li></span><span class="Comment"> * format that is being built here.&nbsp; We build on the assumption that we<br/></li>
<li></span><span class="Comment"> * are making a leaf-level key entry containing a posting list of nipd items.<br/></li>
<li></span><span class="Comment"> * If the caller is actually trying to make a posting-tree entry, non-leaf<br/></li>
<li></span><span class="Comment"> * entry, or pending-list entry, it should pass dataSize = 0 and then overwrite<br/></li>
<li></span><span class="Comment"> * the t_tid fields as necessary.&nbsp; In <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, 'data' can be NULL to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment"> * filling in the posting list; the caller is responsible for filling it<br/></li>
<li></span><span class="Comment"> * afterwards if data = NULL and nipd &gt; 0.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexTuple<br/></li>
<li><a id="L44">&#x200c;</a><span class="linkable">GinFormTuple</span>(GinState *ginstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber attnum, Datum key, GinNullCategory category,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Pointer data, Size dataSize, <span class="Type">int</span> nipd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> errorTooBig)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datums[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; newsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build the basic tuple: optional column number, plus key datum */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ginstate-&gt;oneCol)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datums[<span class="Constant">0</span>] = key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isnull[<span class="Constant">0</span>] = (category != GIN_CAT_NORM_KEY);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datums[<span class="Constant">0</span>] = UInt16GetDatum(attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isnull[<span class="Constant">0</span>] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datums[<span class="Constant">1</span>] = key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isnull[<span class="Constant">1</span>] = (category != GIN_CAT_NORM_KEY);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itup = <a href="../common/indextuple.c.html#L44" title="access/common/indextuple.c:44">index_form_tuple</a>(ginstate-&gt;tupdesc[attnum - <span class="Constant">1</span>], datums, isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine and store offset to the posting list, making sure there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * room for the category byte if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: because <a href="../common/indextuple.c.html#L44" title="access/common/indextuple.c:44">index_form_tuple</a> MAXALIGNs the tuple size, there may well<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be some wasted pad space.&nbsp; Is it worth recomputing the data length to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prevent that?&nbsp; That would also allow us to Assert that the real data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't overlap the GinNullCategory byte, which this code currently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * takes on faith.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newsize = IndexTupleSize(itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IndexTupleHasNulls(itup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; minsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(category != GIN_CAT_NORM_KEY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; minsize = GinCategoryOffset(itup, ginstate) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinNullCategory);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newsize = Max(newsize, minsize);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newsize = SHORTALIGN(newsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; GinSetPostingOffset(itup, newsize);<br/></li>
<li>&nbsp; &nbsp; GinSetNPosting(itup, nipd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add space needed for posting list, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; Then check that the tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * won't be too big to store.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newsize += dataSize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newsize = MAXALIGN(newsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newsize &gt; GinMaxItemSize)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errorTooBig)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index row size </span><span class="Special">%zu</span><span class="Constant"> exceeds maximum </span><span class="Special">%zu</span><span class="Constant"> for index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Size) newsize, (Size) GinMaxItemSize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(ginstate-&gt;index))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Resize tuple if needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newsize != IndexTupleSize(itup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(itup, newsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PostgreSQL 9.3 and earlier did not clear this new space, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> uninitialized padding when reading tuples from disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memset((<span class="Type">char</span> *) itup + IndexTupleSize(itup),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, newsize - IndexTupleSize(itup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set new size in tuple header */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itup-&gt;t_info &amp;= ~INDEX_SIZE_MASK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup-&gt;t_info |= newsize;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy in the posting list, if provided<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (data)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr = GinGetPosting(itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, data, dataSize);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> category byte, if needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (category != GIN_CAT_NORM_KEY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(IndexTupleHasNulls(itup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinSetNullCategory(itup, ginstate, category);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> itup;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read item pointers from leaf entry tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d array of ItemPointers. The number of items is returned<br/></li>
<li></span><span class="Comment"> * in *nitems.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ItemPointer<br/></li>
<li><a id="L162">&#x200c;</a><span class="linkable">ginReadTuple</span>(GinState *ginstate, OffsetNumber attnum, IndexTuple itup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *nitems)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Pointer&nbsp; &nbsp; &nbsp; &nbsp; ptr = GinGetPosting(itup);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nipd = GinGetNPosting(itup);<br/></li>
<li>&nbsp; &nbsp; ItemPointer ipd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndecoded;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (GinItupIsCompressed(itup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nipd &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ipd = <a href="ginpostinglist.c.html#L284" title="access/gin/ginpostinglist.c:284">ginPostingListDecode</a>((GinPostingList *) ptr, &amp;ndecoded);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nipd != ndecoded)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;number of items mismatch in GIN entry tuple, </span><span class="Special">%d</span><span class="Constant"> in tuple header, </span><span class="Special">%d</span><span class="Constant"> decoded&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nipd, ndecoded);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ipd = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ipd = (ItemPointer) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData) * nipd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ipd, ptr, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData) * nipd);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *nitems = nipd;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ipd;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Form a non-leaf entry tuple by copying the key data from the given tuple,<br/></li>
<li></span><span class="Comment"> * which can be either a leaf or non-leaf entry tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Any posting list in the source tuple is not copied.&nbsp; The specified child<br/></li>
<li></span><span class="Comment"> * block number is inserted into t_tid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> IndexTuple<br/></li>
<li><a id="L201">&#x200c;</a><span class="linkable">GinFormInteriorTuple</span>(IndexTuple itup, Page page, BlockNumber childblk)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; nitup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (GinPageIsLeaf(page) &amp;&amp; !GinIsPostingTree(itup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Tuple contains a posting list, just copy stuff <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> that */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; origsize = GinGetPostingOffset(itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; origsize = MAXALIGN(origsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nitup = (IndexTuple) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(origsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(nitup, itup, origsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... be sure to fix the size header field ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nitup-&gt;t_info &amp;= ~INDEX_SIZE_MASK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nitup-&gt;t_info |= origsize;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy the tuple as-is */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nitup = (IndexTuple) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(IndexTupleSize(itup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(nitup, itup, IndexTupleSize(itup));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now insert the correct downlink */<br/></li>
<li></span>&nbsp; &nbsp; GinSetDownlink(nitup, childblk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nitup;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Entry tree is a &quot;static&quot;, ie tuple never deletes from it,<br/></li>
<li></span><span class="Comment"> * so we don't use right bound, we use rightmost key instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> IndexTuple<br/></li>
<li><a id="L235">&#x200c;</a><span class="linkable">getRightMostTuple</span>(Page page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (IndexTuple) PageGetItem(page, PageGetItemId(page, maxoff));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L243">&#x200c;</a></span><span class="linkable">entryIsMoveRight</span>(GinBtree btree, Page page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber attnum;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; key;<br/></li>
<li>&nbsp; &nbsp; GinNullCategory category;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (GinPageRightMost(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itup = <a href="#L235" title="access/gin/ginentrypage.c:235">getRightMostTuple</a>(page);<br/></li>
<li>&nbsp; &nbsp; attnum = <a href="ginutil.c.html#L226" title="access/gin/ginutil.c:226">gintuple_get_attrnum</a>(btree-&gt;ginstate, itup);<br/></li>
<li>&nbsp; &nbsp; key = <a href="ginutil.c.html#L259" title="access/gin/ginutil.c:259">gintuple_get_key</a>(btree-&gt;ginstate, itup, &amp;category);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="ginutil.c.html#L410" title="access/gin/ginutil.c:410">ginCompareAttEntries</a>(btree-&gt;ginstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; btree-&gt;entryAttnum, btree-&gt;entryKey, btree-&gt;entryCategory,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attnum, key, category) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find correct tuple in non-leaf page. It supposed that<br/></li>
<li></span><span class="Comment"> * page correctly chosen and searching value SHOULD be on page<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BlockNumber<br/></li>
<li><a id="L270">&#x200c;</a><span class="linkable">entryLocateEntry</span>(GinBtree btree, GinBtreeStack *stack)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber low,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(stack-&gt;buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!GinPageIsLeaf(page));<br/></li>
<li>&nbsp; &nbsp; Assert(!GinPageIsData(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (btree-&gt;fullScan)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;off = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;predictNumber *= PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> btree-&gt;getLeftMostChild(btree, page);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; low = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; maxoff = high = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; Assert(high &gt;= low);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; high++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (high &gt; low)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber mid = low + ((high - low) / <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mid == maxoff &amp;&amp; GinPageRightMost(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Right infinity */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinNullCategory category;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, mid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = <a href="ginutil.c.html#L226" title="access/gin/ginutil.c:226">gintuple_get_attrnum</a>(btree-&gt;ginstate, itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key = <a href="ginutil.c.html#L259" title="access/gin/ginutil.c:259">gintuple_get_key</a>(btree-&gt;ginstate, itup, &amp;category);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="ginutil.c.html#L410" title="access/gin/ginutil.c:410">ginCompareAttEntries</a>(btree-&gt;ginstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; btree-&gt;entryAttnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; btree-&gt;entryKey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; btree-&gt;entryCategory,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum, key, category);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;off = mid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(GinGetDownlink(itup) != GIN_ROOT_BLKNO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> GinGetDownlink(itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (result &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = mid + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = mid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(high &gt;= FirstOffsetNumber &amp;&amp; high &lt;= maxoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stack-&gt;off = high;<br/></li>
<li>&nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, high));<br/></li>
<li>&nbsp; &nbsp; Assert(GinGetDownlink(itup) != GIN_ROOT_BLKNO);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> GinGetDownlink(itup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Searches correct position for value on leaf page.<br/></li>
<li></span><span class="Comment"> * Page should be correctly chosen.<br/></li>
<li></span><span class="Comment"> * Returns true if value found on page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L346">&#x200c;</a></span><span class="linkable">entryLocateLeafEntry</span>(GinBtree btree, GinBtreeStack *stack)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(stack-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; OffsetNumber low,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(GinPageIsLeaf(page));<br/></li>
<li>&nbsp; &nbsp; Assert(!GinPageIsData(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (btree-&gt;fullScan)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;off = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; low = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; high = PageGetMaxOffsetNumber(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (high &lt; low)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;off = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; high++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (high &gt; low)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber mid = low + ((high - low) / <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinNullCategory category;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, mid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attnum = <a href="ginutil.c.html#L226" title="access/gin/ginutil.c:226">gintuple_get_attrnum</a>(btree-&gt;ginstate, itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key = <a href="ginutil.c.html#L259" title="access/gin/ginutil.c:259">gintuple_get_key</a>(btree-&gt;ginstate, itup, &amp;category);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="ginutil.c.html#L410" title="access/gin/ginutil.c:410">ginCompareAttEntries</a>(btree-&gt;ginstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; btree-&gt;entryAttnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; btree-&gt;entryKey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; btree-&gt;entryCategory,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum, key, category);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;off = mid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (result &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = mid + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = mid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stack-&gt;off = high;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> OffsetNumber<br/></li>
<li><a id="L405">&#x200c;</a><span class="linkable">entryFindChildPtr</span>(GinBtree btree, Page page, BlockNumber blkno, OffsetNumber storedOff)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!GinPageIsLeaf(page));<br/></li>
<li>&nbsp; &nbsp; Assert(!GinPageIsData(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if page isn't changed, we returns storedOff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (storedOff &gt;= FirstOffsetNumber &amp;&amp; storedOff &lt;= maxoff)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, storedOff));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinGetDownlink(itup) == blkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> storedOff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we hope, that needed pointer goes to right. It's true if there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wasn't a deletion<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = storedOff + <span class="Constant">1</span>; i &lt;= maxoff; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, i));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinGetDownlink(itup) == blkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxoff = storedOff - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* last chance */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= maxoff; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, i));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinGetDownlink(itup) == blkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> i;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidOffsetNumber;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> BlockNumber<br/></li>
<li><a id="L446">&#x200c;</a><span class="linkable">entryGetLeftMostPage</span>(GinBtree btree, Page page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!GinPageIsLeaf(page));<br/></li>
<li>&nbsp; &nbsp; Assert(!GinPageIsData(page));<br/></li>
<li>&nbsp; &nbsp; Assert(PageGetMaxOffsetNumber(page) &gt;= FirstOffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, FirstOffsetNumber));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> GinGetDownlink(itup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L459">&#x200c;</a></span><span class="linkable">entryIsEnoughSpace</span>(GinBtree btree, Buffer buf, OffsetNumber off,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GinBtreeEntryInsertData *insertData)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; releasedsz = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; addedsz;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(insertData-&gt;entry);<br/></li>
<li>&nbsp; &nbsp; Assert(!GinPageIsData(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (insertData-&gt;isDelete)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, off));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; releasedsz = MAXALIGN(IndexTupleSize(itup)) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; addedsz = MAXALIGN(IndexTupleSize(insertData-&gt;entry)) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/page/bufpage.c.html#L907" title="storage/page/bufpage.c:907">PageGetFreeSpace</a>(page) + releasedsz &gt;= addedsz)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> tuple on leaf page if tuples existed and we<br/></li>
<li></span><span class="Comment"> * should update it, update old child blkno to new right page<br/></li>
<li></span><span class="Comment"> * if child split occurred<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L490">&#x200c;</a></span><span class="linkable">entryPreparePage</span>(GinBtree btree, Page page, OffsetNumber off,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GinBtreeEntryInsertData *insertData, BlockNumber updateblkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(insertData-&gt;entry);<br/></li>
<li>&nbsp; &nbsp; Assert(!GinPageIsData(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (insertData-&gt;isDelete)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(GinPageIsLeaf(page));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1052" title="storage/page/bufpage.c:1052">PageIndexTupleDelete</a>(page, off);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!GinPageIsLeaf(page) &amp;&amp; updateblkno != InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, off));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinSetDownlink(itup, updateblkno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare to insert data on an entry page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If it will fit, return GPTP_INSERT after doing whatever setup is needed<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we enter the insertion critical section.&nbsp; *ptp_workspace can be<br/></li>
<li></span><span class="Comment"> * set to pass information along to the execPlaceToPage function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If it won't fit, perform a page split and return two temporary page<br/></li>
<li></span><span class="Comment"> * images into *newlpage and *newrpage, with result GPTP_SPLIT.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In neither case should the given page buffer be modified here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: on insertion to an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> node, in addition to inserting the given<br/></li>
<li></span><span class="Comment"> * item, the downlink of the existing item at stack-&gt;off will be updated to<br/></li>
<li></span><span class="Comment"> * point to updateblkno.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> GinPlaceToPageRC<br/></li>
<li><a id="L527">&#x200c;</a><span class="linkable">entryBeginPlaceToPage</span>(GinBtree btree, Buffer buf, GinBtreeStack *stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *insertPayload, BlockNumber updateblkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> **ptp_workspace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page *newlpage, Page *newrpage)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GinBtreeEntryInsertData *insertData = insertPayload;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber off = stack-&gt;off;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it doesn't fit, deal with split case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L459" title="access/gin/ginentrypage.c:459">entryIsEnoughSpace</a>(btree, buf, off, insertData))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L602" title="access/gin/ginentrypage.c:602">entrySplitPage</a>(btree, buf, stack, insertData, updateblkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newlpage, newrpage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> GPTP_SPLIT;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else, we're ready to proceed with insertion */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> GPTP_INSERT;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform data insertion after beginPlaceToPage has decided it will fit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is invoked within a critical section, and XLOG record creation (if<br/></li>
<li></span><span class="Comment"> * needed) is already started.&nbsp; The target buffer is registered in slot 0.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L554">&#x200c;</a></span><span class="linkable">entryExecPlaceToPage</span>(GinBtree btree, Buffer buf, GinBtreeStack *stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *insertPayload, BlockNumber updateblkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *ptp_workspace)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GinBtreeEntryInsertData *insertData = insertPayload;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; OffsetNumber off = stack-&gt;off;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber placed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L490" title="access/gin/ginentrypage.c:490">entryPreparePage</a>(btree, page, off, insertData, updateblkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; placed = PageAddItem(page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Item) insertData-&gt;entry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTupleSize(insertData-&gt;entry),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; off, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (placed != off)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add item to index page in </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(btree-&gt;index));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(btree-&gt;index) &amp;&amp; !btree-&gt;isBuild)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This must be static, because it has to survive until <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and we can't <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> here.&nbsp; Ugly, but the <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a> infrastructure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * isn't reentrant anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">static</span> ginxlogInsertEntry data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data.isDelete = insertData-&gt;isDelete;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data.offset = off;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buf, REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) &amp;data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offsetof(ginxlogInsertEntry, tuple));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) insertData-&gt;entry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTupleSize(insertData-&gt;entry));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Split entry page and insert new data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns new temp pages to *newlpage and *newrpage.<br/></li>
<li></span><span class="Comment"> * The original buffer is left untouched.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L602">&#x200c;</a></span><span class="linkable">entrySplitPage</span>(GinBtree btree, Buffer origbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GinBtreeStack *stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GinBtreeEntryInsertData *insertData,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber updateblkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Page *newlpage, Page *newrpage)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber off = stack-&gt;off;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; separator = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; totalsize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; lsize = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; lpage = <a href="../../storage/page/bufpage.c.html#L382" title="storage/page/bufpage.c:382">PageGetTempPageCopy</a>(BufferGetPage(origbuf));<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; rpage = <a href="../../storage/page/bufpage.c.html#L382" title="storage/page/bufpage.c:382">PageGetTempPageCopy</a>(BufferGetPage(origbuf));<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; pageSize = PageGetPageSize(lpage);<br/></li>
<li>&nbsp; &nbsp; PGAlignedBlock tupstore[<span class="Constant">2</span>]; <span class="Comment">/* could need 2 pages' worth of tuples */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L490" title="access/gin/ginentrypage.c:490">entryPreparePage</a>(btree, lpage, off, insertData, updateblkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, append all the existing tuples and the new tuple we're inserting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one after another in a temporary workspace.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(lpage);<br/></li>
<li>&nbsp; &nbsp; ptr = tupstore[<span class="Constant">0</span>].data;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= maxoff; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == off)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size = MAXALIGN(IndexTupleSize(insertData-&gt;entry));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, insertData-&gt;entry, size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalsize += size + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(lpage, PageGetItemId(lpage, i));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size = MAXALIGN(IndexTupleSize(itup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, itup, size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; totalsize += size + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (off == maxoff + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size = MAXALIGN(IndexTupleSize(insertData-&gt;entry));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, insertData-&gt;entry, size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; totalsize += size + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the left and right pages, and copy all the tuples back to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="ginutil.c.html#L338" title="access/gin/ginutil.c:338">GinInitPage</a>(rpage, GinPageGetOpaque(lpage)-&gt;flags, pageSize);<br/></li>
<li>&nbsp; &nbsp; <a href="ginutil.c.html#L338" title="access/gin/ginutil.c:338">GinInitPage</a>(lpage, GinPageGetOpaque(rpage)-&gt;flags, pageSize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ptr = tupstore[<span class="Constant">0</span>].data;<br/></li>
<li>&nbsp; &nbsp; maxoff++;<br/></li>
<li>&nbsp; &nbsp; lsize = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = lpage;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= maxoff; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Decide where to split.&nbsp; We try to equalize the pages' total data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * size, not number of tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lsize &gt; totalsize / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (separator == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; separator = i - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = rpage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lsize += MAXALIGN(IndexTupleSize(itup)) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(page, (Item) itup, IndexTupleSize(itup), InvalidOffsetNumber, <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add item to index page in </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(btree-&gt;index));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += MAXALIGN(IndexTupleSize(itup));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* return temp pages to caller */<br/></li>
<li></span>&nbsp; &nbsp; *newlpage = lpage;<br/></li>
<li>&nbsp; &nbsp; *newrpage = rpage;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Construct insertion payload for inserting the downlink for given buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> *<br/></li>
<li><a id="L702">&#x200c;</a><span class="linkable">entryPrepareDownlink</span>(GinBtree btree, Buffer lbuf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GinBtreeEntryInsertData *insertData;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; lpage = BufferGetPage(lbuf);<br/></li>
<li>&nbsp; &nbsp; BlockNumber lblkno = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(lbuf);<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itup = <a href="#L235" title="access/gin/ginentrypage.c:235">getRightMostTuple</a>(lpage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; insertData = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinBtreeEntryInsertData));<br/></li>
<li>&nbsp; &nbsp; insertData-&gt;entry = <a href="#L201" title="access/gin/ginentrypage.c:201">GinFormInteriorTuple</a>(itup, lpage, lblkno);<br/></li>
<li>&nbsp; &nbsp; insertData-&gt;isDelete = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> insertData;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fills new root by rightest <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> from child.<br/></li>
<li></span><span class="Comment"> * Also called from ginxlog, should not use btree<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L723">&#x200c;</a></span><span class="linkable">ginEntryFillRoot</span>(GinBtree btree, Page root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber lblkno, Page lpage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber rblkno, Page rpage)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itup = <a href="#L201" title="access/gin/ginentrypage.c:201">GinFormInteriorTuple</a>(<a href="#L235" title="access/gin/ginentrypage.c:235">getRightMostTuple</a>(lpage), lpage, lblkno);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(root, (Item) itup, IndexTupleSize(itup), InvalidOffsetNumber, <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add item to index root page&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itup = <a href="#L201" title="access/gin/ginentrypage.c:201">GinFormInteriorTuple</a>(<a href="#L235" title="access/gin/ginentrypage.c:235">getRightMostTuple</a>(rpage), rpage, rblkno);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(root, (Item) itup, IndexTupleSize(itup), InvalidOffsetNumber, <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add item to index root page&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(itup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set up GinBtree for entry page access<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: during WAL recovery, there may be no valid data in ginstate<br/></li>
<li></span><span class="Comment"> * other than a faked-up Relation pointer; the key datum is bogus too.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L747">&#x200c;</a></span><span class="linkable">ginPrepareEntryScan</span>(GinBtree btree, OffsetNumber attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum key, GinNullCategory category,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinState *ginstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; memset(btree, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinBtreeData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; btree-&gt;index = ginstate-&gt;index;<br/></li>
<li>&nbsp; &nbsp; btree-&gt;rootBlkno = GIN_ROOT_BLKNO;<br/></li>
<li>&nbsp; &nbsp; btree-&gt;ginstate = ginstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; btree-&gt;findChildPage = <a href="#L270" title="access/gin/ginentrypage.c:270">entryLocateEntry</a>;<br/></li>
<li>&nbsp; &nbsp; btree-&gt;getLeftMostChild = <a href="#L446" title="access/gin/ginentrypage.c:446">entryGetLeftMostPage</a>;<br/></li>
<li>&nbsp; &nbsp; btree-&gt;isMoveRight = <a href="#L243" title="access/gin/ginentrypage.c:243">entryIsMoveRight</a>;<br/></li>
<li>&nbsp; &nbsp; btree-&gt;findItem = <a href="#L346" title="access/gin/ginentrypage.c:346">entryLocateLeafEntry</a>;<br/></li>
<li>&nbsp; &nbsp; btree-&gt;findChildPtr = <a href="#L405" title="access/gin/ginentrypage.c:405">entryFindChildPtr</a>;<br/></li>
<li>&nbsp; &nbsp; btree-&gt;beginPlaceToPage = <a href="#L527" title="access/gin/ginentrypage.c:527">entryBeginPlaceToPage</a>;<br/></li>
<li>&nbsp; &nbsp; btree-&gt;execPlaceToPage = <a href="#L554" title="access/gin/ginentrypage.c:554">entryExecPlaceToPage</a>;<br/></li>
<li>&nbsp; &nbsp; btree-&gt;fillRoot = <a href="#L723" title="access/gin/ginentrypage.c:723">ginEntryFillRoot</a>;<br/></li>
<li>&nbsp; &nbsp; btree-&gt;prepareDownlink = <a href="#L702" title="access/gin/ginentrypage.c:702">entryPrepareDownlink</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; btree-&gt;isData = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; btree-&gt;fullScan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; btree-&gt;isBuild = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; btree-&gt;entryAttnum = attnum;<br/></li>
<li>&nbsp; &nbsp; btree-&gt;entryKey = key;<br/></li>
<li>&nbsp; &nbsp; btree-&gt;entryCategory = category;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
