<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/gin/ginutil.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/gin/ginutil.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L440">cmpEntriesArg</a></li>
<li><a href="#L433">keyEntryData</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L350">GinInitBuffer</a></li>
<li><a href="#L356">GinInitMetabuffer</a></li>
<li><a href="#L338">GinInitPage</a></li>
<li><a href="#L300">GinNewBuffer</a></li>
<li><a href="#L443">cmpEntries</a></li>
<li><a href="#L410">ginCompareAttEntries</a></li>
<li><a href="#L388">ginCompareEntries</a></li>
<li><a href="#L483">ginExtractEntries</a></li>
<li><a href="#L623">ginGetStats</a></li>
<li><a href="#L650">ginUpdateStats</a></li>
<li><a href="#L37">ginhandler</a></li>
<li><a href="#L602">ginoptions</a></li>
<li><a href="#L226">gintuple_get_attrnum</a></li>
<li><a href="#L259">gintuple_get_key</a></li>
<li><a href="#L97">initGinState</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ginutil.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Utility routines for the Postgres inverted index access method.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src/backend/access/gin/ginutil.c<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/gin_private.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/ginxlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/reloptions.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_collation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/indexfsm.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/index_selfuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GIN handler function: return IndexAmRoutine with access method parameters<br/></li>
<li></span><span class="Comment"> * and callbacks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L37">&#x200c;</a><span class="linkable">ginhandler</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexAmRoutine *amroutine = makeNode(IndexAmRoutine);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amstrategies = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsupport = GINNProcs;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amoptsprocnum = GIN_OPTIONS_PROC;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanorder = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanorderbyop = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanbackward = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanunique = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanmulticol = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amoptionalkey = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsearcharray = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsearchnulls = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amstorage = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amclusterable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ampredlocks = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanparallel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanbuildparallel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcaninclude = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amusemaintenanceworkmem = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsummarizing = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amparallelvacuumoptions =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VACUUM_OPTION_PARALLEL_BULKDEL | VACUUM_OPTION_PARALLEL_CLEANUP;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amkeytype = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambuild = <a href="gininsert.c.html#L317" title="access/gin/gininsert.c:317">ginbuild</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambuildempty = <a href="gininsert.c.html#L434" title="access/gin/gininsert.c:434">ginbuildempty</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;aminsert = <a href="gininsert.c.html#L483" title="access/gin/gininsert.c:483">gininsert</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;aminsertcleanup = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambulkdelete = <a href="ginvacuum.c.html#L565" title="access/gin/ginvacuum.c:565">ginbulkdelete</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amvacuumcleanup = <a href="ginvacuum.c.html#L688" title="access/gin/ginvacuum.c:688">ginvacuumcleanup</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanreturn = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcostestimate = <a href="../../utils/adt/selfuncs.c.html#L7583" title="utils/adt/selfuncs.c:7583">gincostestimate</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amoptions = <a href="#L602" title="access/gin/ginutil.c:602">ginoptions</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amproperty = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambuildphasename = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;<a href="../index/amapi.c.html#L114" title="access/index/amapi.c:114">amvalidate</a> = <a href="ginvalidate.c.html#L31" title="access/gin/ginvalidate.c:31">ginvalidate</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amadjustmembers = <a href="ginvalidate.c.html#L277" title="access/gin/ginvalidate.c:277">ginadjustmembers</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambeginscan = <a href="ginscan.c.html#L25" title="access/gin/ginscan.c:25">ginbeginscan</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amrescan = <a href="ginscan.c.html#L442" title="access/gin/ginscan.c:442">ginrescan</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amgettuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amgetbitmap = <a href="ginget.c.html#L1914" title="access/gin/ginget.c:1914">gingetbitmap</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amendscan = <a href="ginscan.c.html#L458" title="access/gin/ginscan.c:458">ginendscan</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ammarkpos = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amrestrpos = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amestimateparallelscan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;aminitparallelscan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amparallelrescan = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(amroutine);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L97" title="access/gin/ginutil.c:97">initGinState</a>: fill in an empty GinState struct to describe the index<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: assorted subsidiary data is allocated in the <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L97">&#x200c;</a></span><span class="linkable">initGinState</span>(GinState *state, Relation index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; origTupdesc = RelationGetDescr(index);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemSet(state, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinState));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;index = index;<br/></li>
<li>&nbsp; &nbsp; state-&gt;oneCol = (origTupdesc-&gt;natts == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; state-&gt;origTupdesc = origTupdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; origTupdesc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(origTupdesc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;oneCol)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;tupdesc[i] = state-&gt;origTupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;tupdesc[i] = <a href="../common/tupdesc.c.html#L67" title="access/common/tupdesc.c:67">CreateTemplateTupleDesc</a>(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(state-&gt;tupdesc[i], (AttrNumber) <span class="Constant">1</span>, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INT2OID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(state-&gt;tupdesc[i], (AttrNumber) <span class="Constant">2</span>, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attr-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attr-&gt;atttypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attr-&gt;attndims);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/tupdesc.c.html#L833" title="access/common/tupdesc.c:833">TupleDescInitEntryCollation</a>(state-&gt;tupdesc[i], (AttrNumber) <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attr-&gt;attcollation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> proc isn't specified in the opclass definition, look<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up the index key type's default btree comparator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../index/indexam.c.html#L826" title="access/index/indexam.c:826">index_getprocid</a>(index, i + <span class="Constant">1</span>, GIN_COMPARE_PROC) != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L580" title="utils/fmgr/fmgr.c:580">fmgr_info_copy</a>(&amp;(state-&gt;compareFn[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(index, i + <span class="Constant">1</span>, GIN_COMPARE_PROC),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typentry = <a href="../../utils/cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(attr-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TYPECACHE_CMP_PROC_FINFO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typentry-&gt;cmp_proc_finfo.fn_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not identify a comparison function for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(attr-&gt;atttypid))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L580" title="utils/fmgr/fmgr.c:580">fmgr_info_copy</a>(&amp;(state-&gt;compareFn[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;(typentry-&gt;cmp_proc_finfo),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Opclass must always provide extract procs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L580" title="utils/fmgr/fmgr.c:580">fmgr_info_copy</a>(&amp;(state-&gt;extractValueFn[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(index, i + <span class="Constant">1</span>, GIN_EXTRACTVALUE_PROC),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L580" title="utils/fmgr/fmgr.c:580">fmgr_info_copy</a>(&amp;(state-&gt;extractQueryFn[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(index, i + <span class="Constant">1</span>, GIN_EXTRACTQUERY_PROC),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check opclass capability to do tri-state or binary logic consistent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../index/indexam.c.html#L826" title="access/index/indexam.c:826">index_getprocid</a>(index, i + <span class="Constant">1</span>, GIN_TRICONSISTENT_PROC) != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L580" title="utils/fmgr/fmgr.c:580">fmgr_info_copy</a>(&amp;(state-&gt;triConsistentFn[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(index, i + <span class="Constant">1</span>, GIN_TRICONSISTENT_PROC),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../index/indexam.c.html#L826" title="access/index/indexam.c:826">index_getprocid</a>(index, i + <span class="Constant">1</span>, GIN_CONSISTENT_PROC) != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L580" title="utils/fmgr/fmgr.c:580">fmgr_info_copy</a>(&amp;(state-&gt;consistentFn[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(index, i + <span class="Constant">1</span>, GIN_CONSISTENT_PROC),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;consistentFn[i].fn_oid == InvalidOid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;triConsistentFn[i].fn_oid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing GIN support function (</span><span class="Special">%d</span><span class="Constant"> or </span><span class="Special">%d</span><span class="Constant">) for attribute </span><span class="Special">%d</span><span class="Constant"> of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GIN_CONSISTENT_PROC, GIN_TRICONSISTENT_PROC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; i + <span class="Constant">1</span>, RelationGetRelationName(index));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check opclass capability to do partial match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../index/indexam.c.html#L826" title="access/index/indexam.c:826">index_getprocid</a>(index, i + <span class="Constant">1</span>, GIN_COMPARE_PARTIAL_PROC) != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L580" title="utils/fmgr/fmgr.c:580">fmgr_info_copy</a>(&amp;(state-&gt;comparePartialFn[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(index, i + <span class="Constant">1</span>, GIN_COMPARE_PARTIAL_PROC),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;canPartialMatch[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;canPartialMatch[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the index column has a specified collation, we should honor that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * while doing comparisons.&nbsp; However, we may have a collatable storage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * type for a noncollatable indexed data type (for instance, hstore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * uses text index entries).&nbsp; If there's no index collation then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * specify default collation in case the support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * collation.&nbsp; This is harmless if the support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> don't care<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about collation, so we just do it unconditionally.&nbsp; (We could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * alternatively call <a href="../../utils/cache/lsyscache.c.html#L3056" title="utils/cache/lsyscache.c:3056">get_typcollation</a>, but that seems like expensive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overkill --- there aren't going to be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cases where a GIN storage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * type has a nondefault collation.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(index-&gt;rd_indcollation[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;supportCollation[i] = index-&gt;rd_indcollation[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;supportCollation[i] = DEFAULT_COLLATION_OID;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract attribute (column) number of stored entry from GIN tuple<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>OffsetNumber<br/></li>
<li><a id="L226">&#x200c;</a><span class="linkable">gintuple_get_attrnum</span>(GinState *ginstate, IndexTuple tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber colN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ginstate-&gt;oneCol)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* column number is not stored explicitly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; colN = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First attribute is always int16, so we can safely use <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * descriptor to obtain first attribute of tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res = index_getattr(tuple, FirstOffsetNumber, ginstate-&gt;tupdesc[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; colN = DatumGetUInt16(res);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(colN &gt;= FirstOffsetNumber &amp;&amp; colN &lt;= ginstate-&gt;origTupdesc-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> colN;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract stored datum (and possible null category) from GIN tuple<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L259">&#x200c;</a><span class="linkable">gintuple_get_key</span>(GinState *ginstate, IndexTuple tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GinNullCategory *category)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ginstate-&gt;oneCol)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Single column index doesn't store attribute numbers in tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res = index_getattr(tuple, FirstOffsetNumber, ginstate-&gt;origTupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since the datum type depends on which index column it's from, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must be careful to use the right tuple descriptor here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber colN = <a href="#L226" title="access/gin/ginutil.c:226">gintuple_get_attrnum</a>(ginstate, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = index_getattr(tuple, OffsetNumberNext(FirstOffsetNumber),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ginstate-&gt;tupdesc[colN - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *category = GinGetNullCategory(tuple, ginstate);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *category = GIN_CAT_NORM_KEY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate a new page (either by recycling, or by extending the index file)<br/></li>
<li></span><span class="Comment"> * The returned buffer is already pinned and exclusive-locked<br/></li>
<li></span><span class="Comment"> * Caller is responsible for initializing the page by calling <a href="#L350" title="access/gin/ginutil.c:350">GinInitBuffer</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L300">&#x200c;</a><span class="linkable">GinNewBuffer</span>(Relation index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First, try to get a page from FSM */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno = <a href="../../storage/freespace/indexfsm.c.html#L38" title="storage/freespace/indexfsm.c:38">GetFreeIndexPage</a>(index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(index, blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to guard against the possibility that someone else already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recycled this page; the buffer may be locked if so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/buffer/bufmgr.c.html#L5111" title="storage/buffer/bufmgr.c:5111">ConditionalLockBuffer</a>(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="ginvacuum.c.html#L802" title="access/gin/ginvacuum.c:802">GinPageIsRecyclable</a>(BufferGetPage(buffer)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buffer;&nbsp; &nbsp; <span class="Comment">/* OK to use */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIN_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't use it, so release buffer and try again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must extend the file */<br/></li>
<li></span>&nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L845" title="storage/buffer/bufmgr.c:845">ExtendBufferedRel</a>(BMR_REL(index), MAIN_FORKNUM, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EB_LOCK_FIRST);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L338">&#x200c;</a></span><span class="linkable">GinInitPage</span>(Page page, uint32 f, Size pageSize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GinPageOpaque opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L42" title="storage/page/bufpage.c:42">PageInit</a>(page, pageSize, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinPageOpaqueData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opaque = GinPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; opaque-&gt;flags = f;<br/></li>
<li>&nbsp; &nbsp; opaque-&gt;rightlink = InvalidBlockNumber;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L350">&#x200c;</a></span><span class="linkable">GinInitBuffer</span>(Buffer b, uint32 f)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L338" title="access/gin/ginutil.c:338">GinInitPage</a>(BufferGetPage(b), f, BufferGetPageSize(b));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L356">&#x200c;</a></span><span class="linkable">GinInitMetabuffer</span>(Buffer b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GinMetaPageData *metadata;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(b);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L338" title="access/gin/ginutil.c:338">GinInitPage</a>(page, GIN_META, BufferGetPageSize(b));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metadata = GinPageGetMeta(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metadata-&gt;head = metadata-&gt;tail = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; metadata-&gt;tailFreeSize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; metadata-&gt;nPendingPages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; metadata-&gt;nPendingHeapTuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; metadata-&gt;nTotalPages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; metadata-&gt;nEntryPages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; metadata-&gt;nDataPages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; metadata-&gt;nEntries = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; metadata-&gt;ginVersion = GIN_CURRENT_VERSION;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set pd_lower just past the end of the metadata.&nbsp; This is essential,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because without doing so, metadata will be lost if xlog.c compresses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ((PageHeader) page)-&gt;pd_lower =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">char</span> *) metadata + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinMetaPageData)) - (<span class="Type">char</span> *) page;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compare two keys of the same index column<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L388">&#x200c;</a></span><span class="linkable">ginCompareEntries</span>(GinState *ginstate, OffsetNumber attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum a, GinNullCategory categorya,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum b, GinNullCategory categoryb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if not of same null category, sort by that first */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (categorya != categoryb)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (categorya &lt; categoryb) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* all null items in same category are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (categorya != GIN_CAT_NORM_KEY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* both not null, so safe to call the compareFn */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetInt32(<a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;ginstate-&gt;compareFn[attnum - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ginstate-&gt;supportCollation[attnum - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; a, b));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compare two keys of possibly different index columns<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L410">&#x200c;</a></span><span class="linkable">ginCompareAttEntries</span>(GinState *ginstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber attnuma, Datum a, GinNullCategory categorya,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber attnumb, Datum b, GinNullCategory categoryb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* attribute number is the first sort key */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attnuma != attnumb)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (attnuma &lt; attnumb) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L388" title="access/gin/ginutil.c:388">ginCompareEntries</a>(ginstate, attnuma, a, categorya, b, categoryb);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Support for sorting key datums in <a href="#L483" title="access/gin/ginutil.c:483">ginExtractEntries</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we only have to worry about null and not-null keys here;<br/></li>
<li></span><span class="Comment"> * <a href="#L483" title="access/gin/ginutil.c:483">ginExtractEntries</a> never generates more than one placeholder null,<br/></li>
<li></span><span class="Comment"> * so it doesn't have to sort those.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><a id="L433">&#x200c;</a>} <span class="linkable">keyEntryData</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *cmpDatumFunc;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; haveDups;<br/></li>
<li><a id="L440">&#x200c;</a>} <span class="linkable">cmpEntriesArg</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L443">&#x200c;</a></span><span class="linkable">cmpEntries</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L433" title="access/gin/ginutil.c:433">keyEntryData</a> *aa = (<span class="Type">const</span> <a href="#L433" title="access/gin/ginutil.c:433">keyEntryData</a> *) a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L433" title="access/gin/ginutil.c:433">keyEntryData</a> *bb = (<span class="Type">const</span> <a href="#L433" title="access/gin/ginutil.c:433">keyEntryData</a> *) b;<br/></li>
<li>&nbsp; &nbsp; <a href="#L440" title="access/gin/ginutil.c:440">cmpEntriesArg</a> *data = (<a href="#L440" title="access/gin/ginutil.c:440">cmpEntriesArg</a> *) arg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aa-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bb-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL &quot;=&quot; NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL &quot;&gt;&quot; not-NULL */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (bb-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not-NULL &quot;&lt;&quot; NULL */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res = DatumGetInt32(<a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(data-&gt;cmpDatumFunc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data-&gt;collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; aa-&gt;datum, bb-&gt;datum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Detect if we have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> duplicates.&nbsp; If there are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> keys, qsort must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> them at some point, else it wouldn't know whether one should go<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> or after the other.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (res == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data-&gt;haveDups = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract the index key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> from an indexable item<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The resulting key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are sorted, and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> duplicates are removed.<br/></li>
<li></span><span class="Comment"> * This avoids generating redundant index entries.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum *<br/></li>
<li><a id="L483">&#x200c;</a><span class="linkable">ginExtractEntries</span>(GinState *ginstate, OffsetNumber attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum value, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32 *nentries, GinNullCategory **categories)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *entries;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *nullFlags;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't call the extractValueFn on a null item.&nbsp; Instead generate a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * placeholder.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *nentries = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entries = (Datum *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entries[<span class="Constant">0</span>] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *categories = (GinNullCategory *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinNullCategory));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*categories)[<span class="Constant">0</span>] = GIN_CAT_NULL_ITEM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> entries;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, call the opclass's extractValueFn */<br/></li>
<li></span>&nbsp; &nbsp; nullFlags = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in case extractValue doesn't set it */<br/></li>
<li></span>&nbsp; &nbsp; entries = (Datum *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DatumGetPointer(<a href="../../utils/fmgr/fmgr.c.html#L1171" title="utils/fmgr/fmgr.c:1171">FunctionCall3Coll</a>(&amp;ginstate-&gt;extractValueFn[attnum - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ginstate-&gt;supportCollation[attnum - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(nentries),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(&amp;nullFlags)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate a placeholder if the item contained no keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (entries == <span class="Constant">NULL</span> || *nentries &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *nentries = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entries = (Datum *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entries[<span class="Constant">0</span>] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *categories = (GinNullCategory *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinNullCategory));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*categories)[<span class="Constant">0</span>] = GIN_CAT_EMPTY_ITEM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> entries;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the extractValueFn didn't create a nullFlags array, create one,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assuming that everything's non-null.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nullFlags == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nullFlags = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(*nentries * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's more than one key, sort and unique-ify.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Using qsort here is notationally painful, and the overhead is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pretty bad too.&nbsp; For small numbers of keys it'd likely be better to use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a simple insertion sort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*nentries &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L433" title="access/gin/ginutil.c:433">keyEntryData</a> *keydata;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L440" title="access/gin/ginutil.c:440">cmpEntriesArg</a> arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; keydata = (<a href="#L433" title="access/gin/ginutil.c:433">keyEntryData</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(*nentries * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L433" title="access/gin/ginutil.c:433">keyEntryData</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; *nentries; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keydata[i].datum = entries[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keydata[i].isnull = nullFlags[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arg.cmpDatumFunc = &amp;ginstate-&gt;compareFn[attnum - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arg.collation = ginstate-&gt;supportCollation[attnum - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arg.haveDups = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qsort_arg(keydata, *nentries, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L433" title="access/gin/ginutil.c:433">keyEntryData</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L443" title="access/gin/ginutil.c:443">cmpEntries</a>, &amp;arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arg.haveDups)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there are duplicates, must get rid of 'em */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entries[<span class="Constant">0</span>] = keydata[<span class="Constant">0</span>].datum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullFlags[<span class="Constant">0</span>] = keydata[<span class="Constant">0</span>].isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; *nentries; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L443" title="access/gin/ginutil.c:443">cmpEntries</a>(&amp;keydata[i - <span class="Constant">1</span>], &amp;keydata[i], &amp;arg) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entries[j] = keydata[i].datum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullFlags[j] = keydata[i].isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *nentries = j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* easy, no duplicates */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; *nentries; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entries[i] = keydata[i].datum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullFlags[i] = keydata[i].isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(keydata);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create GinNullCategory representation from nullFlags.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *categories = (GinNullCategory *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(*nentries * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinNullCategory));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; *nentries; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*categories)[i] = (nullFlags[i] ? GIN_CAT_NULL_KEY : GIN_CAT_NORM_KEY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> entries;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>bytea *<br/></li>
<li><a id="L602">&#x200c;</a><span class="linkable">ginoptions</span>(Datum reloptions, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> validate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> relopt_parse_elt tab[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<span class="Constant">&quot;fastupdate&quot;</span>, RELOPT_TYPE_BOOL, offsetof(GinOptions, useFastUpdate)},<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<span class="Constant">&quot;<a href="ginfast.c.html#L39" title="access/gin/ginfast.c:39">gin_pending_list_limit</a>&quot;</span>, RELOPT_TYPE_INT, offsetof(GinOptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingListCleanupSize)}<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (bytea *) <a href="../common/reloptions.c.html#L1908" title="access/common/reloptions.c:1908">build_reloptions</a>(reloptions, validate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RELOPT_KIND_GIN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinOptions),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab, lengthof(tab));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch index's statistical data into *stats<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: in the result, nPendingPages can be trusted to be up-to-date,<br/></li>
<li></span><span class="Comment"> * as can ginVersion; but the other fields are as of the last VACUUM.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L623">&#x200c;</a></span><span class="linkable">ginGetStats</span>(Relation index, GinStatsData *stats)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; metapage;<br/></li>
<li>&nbsp; &nbsp; GinMetaPageData *metadata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metabuffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(index, GIN_METAPAGE_BLKNO);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuffer, GIN_SHARE);<br/></li>
<li>&nbsp; &nbsp; metapage = BufferGetPage(metabuffer);<br/></li>
<li>&nbsp; &nbsp; metadata = GinPageGetMeta(metapage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stats-&gt;nPendingPages = metadata-&gt;nPendingPages;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;nTotalPages = metadata-&gt;nTotalPages;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;nEntryPages = metadata-&gt;nEntryPages;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;nDataPages = metadata-&gt;nDataPages;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;nEntries = metadata-&gt;nEntries;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;ginVersion = metadata-&gt;ginVersion;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(metabuffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write the given statistics to the index's metapage<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: nPendingPages and ginVersion are *not* copied over<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L650">&#x200c;</a></span><span class="linkable">ginUpdateStats</span>(Relation index, <span class="Type">const</span> GinStatsData *stats, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_build)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; metapage;<br/></li>
<li>&nbsp; &nbsp; GinMetaPageData *metadata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metabuffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(index, GIN_METAPAGE_BLKNO);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuffer, GIN_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; metapage = BufferGetPage(metabuffer);<br/></li>
<li>&nbsp; &nbsp; metadata = GinPageGetMeta(metapage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metadata-&gt;nTotalPages = stats-&gt;nTotalPages;<br/></li>
<li>&nbsp; &nbsp; metadata-&gt;nEntryPages = stats-&gt;nEntryPages;<br/></li>
<li>&nbsp; &nbsp; metadata-&gt;nDataPages = stats-&gt;nDataPages;<br/></li>
<li>&nbsp; &nbsp; metadata-&gt;nEntries = stats-&gt;nEntries;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set pd_lower just past the end of the metadata.&nbsp; This is essential,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because without doing so, metadata will be lost if xlog.c compresses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the page.&nbsp; (We must do this here because pre-v11 versions of PG did not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set the metapage's pd_lower correctly, so a pg_upgraded index might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contain the wrong value.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ((PageHeader) metapage)-&gt;pd_lower =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">char</span> *) metadata + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinMetaPageData)) - (<span class="Type">char</span> *) metapage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(metabuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(index) &amp;&amp; !is_build)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ginxlogUpdateMeta data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data.locator = index-&gt;rd_locator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data.ntuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data.newRightlink = data.prevTail = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;data.metadata, metadata, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinMetaPageData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;data, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ginxlogUpdateMeta));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, metabuffer, REGBUF_WILL_INIT | REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_GIN_ID, XLOG_GIN_UPDATE_META_PAGE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(metapage, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(metabuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
