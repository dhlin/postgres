<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/gin/ginvacuum.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/gin/ginvacuum.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L114">DataPageDeleteStack</a></li>
<li><a href="#L123">DataPageDeleteStack</a></li>
<li><a href="#L28">GinVacuumState</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L802">GinPageIsRecyclable</a></li>
<li><a href="#L130">ginDeletePage</a></li>
<li><a href="#L247">ginScanToDelete</a></li>
<li><a href="#L456">ginVacuumEntryPage</a></li>
<li><a href="#L48">ginVacuumItemPointers</a></li>
<li><a href="#L409">ginVacuumPostingTree</a></li>
<li><a href="#L346">ginVacuumPostingTreeLeaves</a></li>
<li><a href="#L565">ginbulkdelete</a></li>
<li><a href="#L688">ginvacuumcleanup</a></li>
<li><a href="#L90">xlogVacuumPage</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ginvacuum.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; delete &amp; <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> routines for the postgres GIN<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src/backend/access/gin/ginvacuum.c<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/gin_private.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/ginxlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/autovacuum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/indexfsm.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L28">&#x200c;</a><span class="Type">struct</span> <span class="linkable">GinVacuumState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; index;<br/></li>
<li>&nbsp; &nbsp; IndexBulkDeleteResult *result;<br/></li>
<li>&nbsp; &nbsp; IndexBulkDeleteCallback callback;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *callback_state;<br/></li>
<li>&nbsp; &nbsp; GinState&nbsp; &nbsp; ginstate;<br/></li>
<li>&nbsp; &nbsp; BufferAccessStrategy strategy;<br/></li>
<li>&nbsp; &nbsp; MemoryContext tmpCxt;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Vacuums an uncompressed posting list. The size of the must can be specified<br/></li>
<li></span><span class="Comment"> * in number of items (nitems).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the items need to be removed, returns NULL. Otherwise returns<br/></li>
<li></span><span class="Comment"> * a new <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d array with the remaining items. The number of remaining<br/></li>
<li></span><span class="Comment"> * items is returned in *nremaining.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ItemPointer<br/></li>
<li><a id="L48">&#x200c;</a><span class="linkable">ginVacuumItemPointers</span>(<a href="#L28" title="access/gin/ginvacuum.c:28">GinVacuumState</a> *gvs, ItemPointerData *items,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nitem, <span class="Type">int</span> *nremaining)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remaining = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ItemPointer tmpitems = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Iterate over TIDs array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitem; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gvs-&gt;callback(items + i, gvs-&gt;callback_state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gvs-&gt;result-&gt;tuples_removed += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tmpitems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First TID to be deleted: allocate memory to hold the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remaining items.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmpitems = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData) * nitem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(tmpitems, items, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData) * i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gvs-&gt;result-&gt;num_index_tuples += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tmpitems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmpitems[remaining] = items[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remaining++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *nremaining = remaining;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tmpitems;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a WAL record for vacuuming entry tree leaf page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L90">&#x200c;</a></span><span class="linkable">xlogVacuumPage</span>(Relation index, Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is only used for entry tree leaf pages. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!GinPageIsData(page));<br/></li>
<li>&nbsp; &nbsp; Assert(GinPageIsLeaf(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!RelationNeedsWAL(index))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Always create a full image, we don't track the changes on the page at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more fine-grained level. This could obviously be improved...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buffer, REGBUF_FORCE_IMAGE | REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_GIN_ID, XLOG_GIN_VACUUM_PAGE);<br/></li>
<li>&nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L114">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">DataPageDeleteStack</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L114" title="access/gin/ginvacuum.c:114">DataPageDeleteStack</a> *child;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L114" title="access/gin/ginvacuum.c:114">DataPageDeleteStack</a> *parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current block number */<br/></li>
<li></span>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; leftBuffer;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pinned and locked rightest non-deleted page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on left */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isRoot;<br/></li>
<li><a id="L123">&#x200c;</a>} <span class="linkable">DataPageDeleteStack</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> a posting tree page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L130">&#x200c;</a></span><span class="linkable">ginDeletePage</span>(<a href="#L28" title="access/gin/ginvacuum.c:28">GinVacuumState</a> *gvs, BlockNumber deleteBlkno, BlockNumber leftBlkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber parentBlkno, OffsetNumber myoff, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isParentRoot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; dBuffer;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; lBuffer;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; pBuffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentPage;<br/></li>
<li>&nbsp; &nbsp; BlockNumber rightlink;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This function MUST be called only if someone of parent pages hold<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exclusive <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock. This guarantees that no insertions currently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happen in this subtree. Caller also acquires Exclusive locks on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deletable, parent and left pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lBuffer = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(gvs-&gt;index, MAIN_FORKNUM, leftBlkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RBM_NORMAL, gvs-&gt;strategy);<br/></li>
<li>&nbsp; &nbsp; dBuffer = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(gvs-&gt;index, MAIN_FORKNUM, deleteBlkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RBM_NORMAL, gvs-&gt;strategy);<br/></li>
<li>&nbsp; &nbsp; pBuffer = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(gvs-&gt;index, MAIN_FORKNUM, parentBlkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RBM_NORMAL, gvs-&gt;strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(dBuffer);<br/></li>
<li>&nbsp; &nbsp; rightlink = GinPageGetOpaque(page)-&gt;rightlink;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Any insert which would have gone on the leaf block will <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> go to its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * right sibling.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L3214" title="storage/lmgr/predicate.c:3214">PredicateLockPageCombine</a>(gvs-&gt;index, deleteBlkno, rightlink);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unlink the page by changing left sibling's rightlink */<br/></li>
<li></span>&nbsp; &nbsp; page = BufferGetPage(lBuffer);<br/></li>
<li>&nbsp; &nbsp; GinPageGetOpaque(page)-&gt;rightlink = rightlink;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> downlink from parent */<br/></li>
<li></span>&nbsp; &nbsp; parentPage = BufferGetPage(pBuffer);<br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PostingItem *tod = GinDataPageGetPostingItem(parentPage, myoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(PostingItemGetBlockNumber(tod) == deleteBlkno);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (<span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <a href="gindatapage.c.html#L417" title="access/gin/gindatapage.c:417">GinPageDeletePostingItem</a>(parentPage, myoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(dBuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we shouldn't change rightlink field to save workability of running<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * search scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark page as deleted, and remember last xid which could know its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * address.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; GinPageSetDeleted(page);<br/></li>
<li>&nbsp; &nbsp; GinPageSetDeleteXid(page, ReadNextTransactionId());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(pBuffer);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(lBuffer);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(dBuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(gvs-&gt;index))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ginxlogDeletePage data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't pass REGBUF_STANDARD for the deleted page, because we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * didn't set pd_lower on pre-9.4 versions. The page might've been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * binary-upgraded from an older version, and hence not have pd_lower<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set correctly. Ditto for the left page, but removing the item from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the parent updated its pd_lower, so we know that's OK at this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, dBuffer, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">1</span>, pBuffer, REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">2</span>, lBuffer, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data.parentOffset = myoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data.rightLink = GinPageGetOpaque(page)-&gt;rightlink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data.deleteXid = GinPageGetDeleteXid(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;data, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ginxlogDeletePage));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_GIN_ID, XLOG_GIN_DELETE_PAGE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(parentPage, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(BufferGetPage(lBuffer), recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(pBuffer);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(lBuffer);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(dBuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gvs-&gt;result-&gt;pages_newly_deleted++;<br/></li>
<li>&nbsp; &nbsp; gvs-&gt;result-&gt;pages_deleted++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Scans posting tree and deletes empty pages.&nbsp; Caller must lock root page for<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.&nbsp; During scan path from root to current page is kept exclusively<br/></li>
<li></span><span class="Comment"> * locked.&nbsp; Also keep left page exclusively locked, because <a href="#L130" title="access/gin/ginvacuum.c:130">ginDeletePage</a>()<br/></li>
<li></span><span class="Comment"> * needs it.&nbsp; If we try to relock left page later, it could deadlock with<br/></li>
<li></span><span class="Comment"> * <a href="ginbtree.c.html#L177" title="access/gin/ginbtree.c:177">ginStepRight</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L247">&#x200c;</a></span><span class="linkable">ginScanToDelete</span>(<a href="#L28" title="access/gin/ginvacuum.c:28">GinVacuumState</a> *gvs, BlockNumber blkno, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isRoot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L114" title="access/gin/ginvacuum.c:114">DataPageDeleteStack</a> *parent, OffsetNumber myoff)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L114" title="access/gin/ginvacuum.c:114">DataPageDeleteStack</a> *me;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; meDelete = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isempty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isRoot)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; me = parent;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!parent-&gt;child)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; me = (<a href="#L114" title="access/gin/ginvacuum.c:114">DataPageDeleteStack</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L114" title="access/gin/ginvacuum.c:114">DataPageDeleteStack</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; me-&gt;parent = parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;child = me;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; me-&gt;leftBuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; me = parent-&gt;child;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(gvs-&gt;index, MAIN_FORKNUM, blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RBM_NORMAL, gvs-&gt;strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isRoot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIN_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(GinPageIsData(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!GinPageIsLeaf(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; me-&gt;blkno = blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= GinPageGetOpaque(page)-&gt;maxoff; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PostingItem *pitem = GinDataPageGetPostingItem(page, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L247" title="access/gin/ginvacuum.c:247">ginScanToDelete</a>(gvs, PostingItemGetBlockNumber(pitem), <span class="Constant">false</span>, me, i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinPageRightMost(page) &amp;&amp; BufferIsValid(me-&gt;child-&gt;leftBuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(me-&gt;child-&gt;leftBuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; me-&gt;child-&gt;leftBuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (GinPageIsLeaf(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isempty = GinDataLeafPageIsEmpty(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; isempty = GinPageGetOpaque(page)-&gt;maxoff &lt; FirstOffsetNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isempty)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we never delete the left- or rightmost branch */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(me-&gt;leftBuffer) &amp;&amp; !GinPageRightMost(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!isRoot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L130" title="access/gin/ginvacuum.c:130">ginDeletePage</a>(gvs, blkno, <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(me-&gt;leftBuffer),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; me-&gt;parent-&gt;blkno, myoff, me-&gt;parent-&gt;isRoot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; meDelete = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!meDelete)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(me-&gt;leftBuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(me-&gt;leftBuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; me-&gt;leftBuffer = buffer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isRoot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIN_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isRoot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> meDelete;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Scan through posting tree leafs, delete empty tuples.&nbsp; Returns true if there<br/></li>
<li></span><span class="Comment"> * is at least one empty page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L346">&#x200c;</a></span><span class="linkable">ginVacuumPostingTreeLeaves</span>(<a href="#L28" title="access/gin/ginvacuum.c:28">GinVacuumState</a> *gvs, BlockNumber blkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasVoidPage = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldCxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find leftmost leaf page of posting tree and lock it in exclusive mode */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PostingItem *pitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(gvs-&gt;index, MAIN_FORKNUM, blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RBM_NORMAL, gvs-&gt;strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIN_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(GinPageIsData(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinPageIsLeaf(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIN_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIN_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(PageGetMaxOffsetNumber(page) &gt;= FirstOffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pitem = GinDataPageGetPostingItem(page, FirstOffsetNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blkno = PostingItemGetBlockNumber(pitem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(blkno != InvalidBlockNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Iterate all posting tree leaves using rightlinks and <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> them */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldCxt = MemoryContextSwitchTo(gvs-&gt;tmpCxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="gindatapage.c.html#L738" title="access/gin/gindatapage.c:738">ginVacuumPostingTreeLeaf</a>(gvs-&gt;index, buffer, gvs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldCxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(gvs-&gt;tmpCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinDataLeafPageIsEmpty(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasVoidPage = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blkno = GinPageGetOpaque(page)-&gt;rightlink;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(gvs-&gt;index, MAIN_FORKNUM, blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RBM_NORMAL, gvs-&gt;strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIN_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hasVoidPage;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L409">&#x200c;</a></span><span class="linkable">ginVacuumPostingTree</span>(<a href="#L28" title="access/gin/ginvacuum.c:28">GinVacuumState</a> *gvs, BlockNumber rootBlkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L346" title="access/gin/ginvacuum.c:346">ginVacuumPostingTreeLeaves</a>(gvs, rootBlkno))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is at least one empty page.&nbsp; So we have to rescan the tree<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deleting empty pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L114" title="access/gin/ginvacuum.c:114">DataPageDeleteStack</a> root,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(gvs-&gt;index, MAIN_FORKNUM, rootBlkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RBM_NORMAL, gvs-&gt;strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lock posting tree root for <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> to ensure there are no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * concurrent inserts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5165" title="storage/buffer/bufmgr.c:5165">LockBufferForCleanup</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;root, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L114" title="access/gin/ginvacuum.c:114">DataPageDeleteStack</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root.leftBuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; root.isRoot = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L247" title="access/gin/ginvacuum.c:247">ginScanToDelete</a>(gvs, rootBlkno, <span class="Constant">true</span>, &amp;root, InvalidOffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = root.child;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (ptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = ptr-&gt;child;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = tmp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * returns modified page or NULL if page isn't modified.<br/></li>
<li></span><span class="Comment"> * Function works with original page until first change is occurred,<br/></li>
<li></span><span class="Comment"> * then page is copied into temporary one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Page<br/></li>
<li><a id="L456">&#x200c;</a><span class="linkable">ginVacuumEntryPage</span>(<a href="#L28" title="access/gin/ginvacuum.c:28">GinVacuumState</a> *gvs, Buffer buffer, BlockNumber *roots, uint32 *nroot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; origpage = BufferGetPage(buffer),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmppage;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(origpage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tmppage = origpage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *nroot = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= maxoff; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup = (IndexTuple) PageGetItem(tmppage, PageGetItemId(tmppage, i));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinIsPostingTree(itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * store posting tree's roots for further processing, we can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> it just <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> due to risk of deadlocks with scans/inserts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; roots[*nroot] = GinGetDownlink(itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*nroot)++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (GinGetNPosting(itup) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer items_orig;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; free_items_orig;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer items;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get list of item pointers from the tuple. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinItupIsCompressed(itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items_orig = <a href="ginpostinglist.c.html#L284" title="access/gin/ginpostinglist.c:284">ginPostingListDecode</a>((GinPostingList *) GinGetPosting(itup), &amp;nitems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free_items_orig = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items_orig = (ItemPointer) GinGetPosting(itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems = GinGetNPosting(itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free_items_orig = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> items from the list that need to be vacuumed. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items = <a href="#L48" title="access/gin/ginvacuum.c:48">ginVacuumItemPointers</a>(gvs, items_orig, nitems, &amp;nitems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (free_items_orig)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(items_orig);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> item pointers were removed, recreate the tuple. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (items)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinNullCategory category;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinPostingList *plist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plistsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nitems &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plist = <a href="ginpostinglist.c.html#L197" title="access/gin/ginpostinglist.c:197">ginCompressPostingList</a>(items, nitems, GinMaxItemSize, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plistsize = SizeOfGinPostingList(plist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plist = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plistsize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we already created a temporary page, make changes in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * place<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tmppage == origpage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On first difference, create a temporary copy of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page and copy the tuple's posting list to it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmppage = <a href="../../storage/page/bufpage.c.html#L382" title="storage/page/bufpage.c:382">PageGetTempPageCopy</a>(origpage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set itup pointer to new page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(tmppage, PageGetItemId(tmppage, i));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = <a href="ginutil.c.html#L226" title="access/gin/ginutil.c:226">gintuple_get_attrnum</a>(&amp;gvs-&gt;ginstate, itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key = <a href="ginutil.c.html#L259" title="access/gin/ginutil.c:259">gintuple_get_key</a>(&amp;gvs-&gt;ginstate, itup, &amp;category);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup = <a href="ginentrypage.c.html#L44" title="access/gin/ginentrypage.c:44">GinFormTuple</a>(&amp;gvs-&gt;ginstate, attnum, key, category,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">char</span> *) plist, plistsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (plist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(plist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1052" title="storage/page/bufpage.c:1052">PageIndexTupleDelete</a>(tmppage, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(tmppage, (Item) itup, IndexTupleSize(itup), i, <span class="Constant">false</span>, <span class="Constant">false</span>) != i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add item to index page in </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(gvs-&gt;index));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(items);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (tmppage == origpage) ? <span class="Constant">NULL</span> : tmppage;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>IndexBulkDeleteResult *<br/></li>
<li><a id="L565">&#x200c;</a><span class="linkable">ginbulkdelete</span>(IndexVacuumInfo *info, IndexBulkDeleteResult *stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexBulkDeleteCallback callback, <span class="Type">void</span> *callback_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; index = info-&gt;index;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno = GIN_ROOT_BLKNO;<br/></li>
<li>&nbsp; &nbsp; <a href="#L28" title="access/gin/ginvacuum.c:28">GinVacuumState</a> gvs;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; BlockNumber rootOfPostingTree[BLCKSZ / (<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemId))];<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nRoot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gvs.tmpCxt = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Gin <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> temporary context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; gvs.index = index;<br/></li>
<li>&nbsp; &nbsp; gvs.callback = callback;<br/></li>
<li>&nbsp; &nbsp; gvs.callback_state = callback_state;<br/></li>
<li>&nbsp; &nbsp; gvs.strategy = info-&gt;strategy;<br/></li>
<li>&nbsp; &nbsp; <a href="ginutil.c.html#L97" title="access/gin/ginutil.c:97">initGinState</a>(&amp;gvs.ginstate, index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* first time through? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stats == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Yes, so <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> stats to zeroes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stats = (IndexBulkDeleteResult *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexBulkDeleteResult));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending inserts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="ginfast.c.html#L780" title="access/gin/ginfast.c:780">ginInsertCleanup</a>(&amp;gvs.ginstate, !AmAutoVacuumWorkerProcess(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>, stats);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we'll re-count the tuples each time */<br/></li>
<li></span>&nbsp; &nbsp; stats-&gt;num_index_tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; gvs.result = stats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(index, MAIN_FORKNUM, blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RBM_NORMAL, info-&gt;strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> leaf page */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIN_SHARE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!GinPageIsData(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinPageIsLeaf(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIN_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIN_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno == GIN_ROOT_BLKNO &amp;&amp; !GinPageIsLeaf(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIN_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check it one more */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(PageGetMaxOffsetNumber(page) &gt;= FirstOffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, FirstOffsetNumber));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blkno = GinGetDownlink(itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(blkno != InvalidBlockNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(index, MAIN_FORKNUM, blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RBM_NORMAL, info-&gt;strategy);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we found leftmost page in entry's BTree */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; resPage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!GinPageIsData(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resPage = <a href="#L456" title="access/gin/ginvacuum.c:456">ginVacuumEntryPage</a>(&amp;gvs, buffer, rootOfPostingTree, &amp;nRoot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blkno = GinPageGetOpaque(page)-&gt;rightlink;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (resPage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L424" title="storage/page/bufpage.c:424">PageRestoreTempPage</a>(resPage, page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L90" title="access/gin/ginvacuum.c:90">xlogVacuumPage</a>(gvs.index, buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nRoot; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L409" title="access/gin/ginvacuum.c:409">ginVacuumPostingTree</a>(&amp;gvs, rootOfPostingTree[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno == InvalidBlockNumber)&nbsp; &nbsp; <span class="Comment">/* rightmost page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(index, MAIN_FORKNUM, blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RBM_NORMAL, info-&gt;strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIN_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(gvs.tmpCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> gvs.result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>IndexBulkDeleteResult *<br/></li>
<li><a id="L688">&#x200c;</a><span class="linkable">ginvacuumcleanup</span>(IndexVacuumInfo *info, IndexBulkDeleteResult *stats)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; index = info-&gt;index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needLock;<br/></li>
<li>&nbsp; &nbsp; BlockNumber npages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno;<br/></li>
<li>&nbsp; &nbsp; BlockNumber totFreePages;<br/></li>
<li>&nbsp; &nbsp; GinState&nbsp; &nbsp; ginstate;<br/></li>
<li>&nbsp; &nbsp; GinStatsData idxStat;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In an autovacuum <a href="../../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>, we want to clean up pending insertions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, an ANALYZE-only call is a no-op.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (info-&gt;analyze_only)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (AmAutoVacuumWorkerProcess())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="ginutil.c.html#L97" title="access/gin/ginutil.c:97">initGinState</a>(&amp;ginstate, index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="ginfast.c.html#L780" title="access/gin/ginfast.c:780">ginInsertCleanup</a>(&amp;ginstate, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">true</span>, stats);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> stats;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up all-zero stats and <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> pending inserts if <a href="#L565" title="access/gin/ginvacuum.c:565">ginbulkdelete</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wasn't called<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stats == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = (IndexBulkDeleteResult *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexBulkDeleteResult));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="ginutil.c.html#L97" title="access/gin/ginutil.c:97">initGinState</a>(&amp;ginstate, index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="ginfast.c.html#L780" title="access/gin/ginfast.c:780">ginInsertCleanup</a>(&amp;ginstate, !AmAutoVacuumWorkerProcess(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>, stats);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;idxStat, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(idxStat));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> we always report the heap tuple count as the number of index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries.&nbsp; This is bogus if the index is partial, but it's real hard to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tell how many distinct heap entries are referenced by a GIN index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; stats-&gt;num_index_tuples = Max(info-&gt;num_heap_tuples, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; stats-&gt;estimated_count = info-&gt;estimated_count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Need lock unless it's local to this backend.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; needLock = !RELATION_IS_LOCAL(index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (needLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L430" title="storage/lmgr/lmgr.c:430">LockRelationForExtension</a>(index, ExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; npages = RelationGetNumberOfBlocks(index);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (needLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L480" title="storage/lmgr/lmgr.c:480">UnlockRelationForExtension</a>(index, ExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; totFreePages = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (blkno = GIN_ROOT_BLKNO; blkno &lt; npages; blkno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(index, MAIN_FORKNUM, blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RBM_NORMAL, info-&gt;strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIN_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L802" title="access/gin/ginvacuum.c:802">GinPageIsRecyclable</a>(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(blkno != GIN_ROOT_BLKNO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/indexfsm.c.html#L52" title="storage/freespace/indexfsm.c:52">RecordFreeIndexPage</a>(index, blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totFreePages++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (GinPageIsData(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idxStat.nDataPages++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!GinPageIsList(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idxStat.nEntryPages++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinPageIsLeaf(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idxStat.nEntries += PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update the metapage with accurate page and entry counts */<br/></li>
<li></span>&nbsp; &nbsp; idxStat.nTotalPages = npages;<br/></li>
<li>&nbsp; &nbsp; <a href="ginutil.c.html#L650" title="access/gin/ginutil.c:650">ginUpdateStats</a>(info-&gt;index, &amp;idxStat, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally, <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> the FSM */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/freespace/indexfsm.c.html#L71" title="storage/freespace/indexfsm.c:71">IndexFreeSpaceMapVacuum</a>(info-&gt;index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stats-&gt;pages_free = totFreePages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (needLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L430" title="storage/lmgr/lmgr.c:430">LockRelationForExtension</a>(index, ExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; stats-&gt;num_pages = RelationGetNumberOfBlocks(index);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (needLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L480" title="storage/lmgr/lmgr.c:480">UnlockRelationForExtension</a>(index, ExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stats;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return whether Page can safely be recycled.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L802">&#x200c;</a></span><span class="linkable">GinPageIsRecyclable</span>(Page page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId delete_xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!GinPageIsDeleted(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delete_xid = GinPageGetDeleteXid(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(delete_xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If no backend still could view delete_xid as in running, all scans<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrent with <a href="#L130" title="access/gin/ginvacuum.c:130">ginDeletePage</a>() must have finished.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../storage/ipc/procarray.c.html#L4284" title="storage/ipc/procarray.c:4284">GlobalVisCheckRemovableXid</a>(<span class="Constant">NULL</span>, delete_xid);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
