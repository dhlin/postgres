<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/gin/ginxlog.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/gin/ginxlog.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L22">opCtx</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L25">ginRedoClearIncompleteSplit</a></li>
<li><a href="#L44">ginRedoCreatePTree</a></li>
<li><a href="#L675">ginRedoDeleteListPages</a></li>
<li><a href="#L477">ginRedoDeletePage</a></li>
<li><a href="#L347">ginRedoInsert</a></li>
<li><a href="#L319">ginRedoInsertData</a></li>
<li><a href="#L71">ginRedoInsertEntry</a></li>
<li><a href="#L620">ginRedoInsertListPage</a></li>
<li><a href="#L117">ginRedoRecompress</a></li>
<li><a href="#L402">ginRedoSplit</a></li>
<li><a href="#L528">ginRedoUpdateMetapage</a></li>
<li><a href="#L452">ginRedoVacuumDataLeafPage</a></li>
<li><a href="#L440">ginRedoVacuumPage</a></li>
<li><a href="#L793">gin_mask</a></li>
<li><a href="#L726">gin_redo</a></li>
<li><a href="#L783">gin_xlog_cleanup</a></li>
<li><a href="#L775">gin_xlog_startup</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ginxlog.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; WAL replay logic for inverted index.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; src/backend/access/gin/ginxlog.c<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/bufmask.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/gin_private.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/ginxlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L22">&#x200c;</a><span class="Type">static</span> MemoryContext <span class="linkable">opCtx</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* working memory for operations */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L25">&#x200c;</a></span><span class="linkable">ginRedoClearIncompleteSplit</span>(XLogReaderState *record, uint8 block_id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, block_id, &amp;buffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinPageGetOpaque(page)-&gt;flags &amp;= ~GIN_INCOMPLETE_SPLIT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L44">&#x200c;</a></span><span class="linkable">ginRedoCreatePTree</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; ginxlogCreatePostingTree *data = (ginxlogCreatePostingTree *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer = <a href="../transam/xlogutils.c.html#L326" title="access/transam/xlogutils.c:326">XLogInitBufferForRedo</a>(record, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="ginutil.c.html#L350" title="access/gin/ginutil.c:350">GinInitBuffer</a>(buffer, GIN_DATA | GIN_LEAF | GIN_COMPRESSED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ptr = XLogRecGetData(record) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ginxlogCreatePostingTree);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Place page data */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(GinDataLeafPageGetPostingList(page), ptr, data-&gt;size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; GinDataPageSetDataSize(page, data-&gt;size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="linkable">ginRedoInsertEntry</span>(Buffer buffer, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isLeaf, BlockNumber rightblkno, <span class="Type">void</span> *rdata)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; ginxlogInsertEntry *data = (ginxlogInsertEntry *) rdata;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offset = data-&gt;offset;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rightblkno != InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update link to right page after split */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!GinPageIsLeaf(page));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(offset &gt;= FirstOffsetNumber &amp;&amp; offset &lt;= PageGetMaxOffsetNumber(page));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, offset));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinSetDownlink(itup, rightblkno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (data-&gt;isDelete)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(GinPageIsLeaf(page));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(offset &gt;= FirstOffsetNumber &amp;&amp; offset &lt;= PageGetMaxOffsetNumber(page));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1052" title="storage/page/bufpage.c:1052">PageIndexTupleDelete</a>(page, offset);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itup = &amp;data-&gt;tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(page, (Item) itup, IndexTupleSize(itup), offset, <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator locator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forknum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blknum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3688" title="storage/buffer/bufmgr.c:3688">BufferGetTag</a>(buffer, &amp;locator, &amp;forknum, &amp;blknum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add item to index page in </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; locator.spcOid, locator.dbOid, locator.relNumber);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Redo recompression of posting list.&nbsp; Doing all the changes in-place is not<br/></li>
<li></span><span class="Comment"> * always possible, because it might require more space than we've on the page.<br/></li>
<li></span><span class="Comment"> * Instead, once modification is required we copy unprocessed tail of the page<br/></li>
<li></span><span class="Comment"> * into separately allocated chunk of memory for further reading original<br/></li>
<li></span><span class="Comment"> * versions of segments.&nbsp; Thanks to that we don't bother about moving page data<br/></li>
<li></span><span class="Comment"> * in-place.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L117">&#x200c;</a></span><span class="linkable">ginRedoRecompress</span>(Page page, ginxlogRecompressDataLeaf *data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; actionno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segno;<br/></li>
<li>&nbsp; &nbsp; GinPostingList *oldseg;<br/></li>
<li>&nbsp; &nbsp; Pointer&nbsp; &nbsp; &nbsp; &nbsp; segmentend;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *walbuf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalsize;<br/></li>
<li>&nbsp; &nbsp; Pointer&nbsp; &nbsp; &nbsp; &nbsp; tailCopy = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Pointer&nbsp; &nbsp; &nbsp; &nbsp; writePtr;<br/></li>
<li>&nbsp; &nbsp; Pointer&nbsp; &nbsp; &nbsp; &nbsp; segptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the page is in pre-9.4 format, convert to new format first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!GinPageIsCompressed(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointer uncompressed = (ItemPointer) GinDataPageGetData(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nuncompressed = GinPageGetOpaque(page)-&gt;maxoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npacked;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Empty leaf pages are deleted as part of <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>, but leftmost and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rightmost pages are never deleted.&nbsp; So, pg_upgrade'd from pre-9.4<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * instances might contain empty leaf pages, and we need to handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them correctly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nuncompressed &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinPostingList *plist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plist = <a href="ginpostinglist.c.html#L197" title="access/gin/ginpostinglist.c:197">ginCompressPostingList</a>(uncompressed, nuncompressed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BLCKSZ, &amp;npacked);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalsize = SizeOfGinPostingList(plist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(npacked == nuncompressed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(GinDataLeafPageGetPostingList(page), plist, totalsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalsize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinDataPageSetDataSize(page, totalsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinPageSetCompressed(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinPageGetOpaque(page)-&gt;maxoff = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldseg = GinDataLeafPageGetPostingList(page);<br/></li>
<li>&nbsp; &nbsp; writePtr = (Pointer) oldseg;<br/></li>
<li>&nbsp; &nbsp; segmentend = (Pointer) oldseg + GinDataLeafPageGetPostingListSize(page);<br/></li>
<li>&nbsp; &nbsp; segno = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; walbuf = ((<span class="Type">char</span> *) data) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ginxlogRecompressDataLeaf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (actionno = <span class="Constant">0</span>; actionno &lt; data-&gt;nactions; actionno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; a_segno = *((uint8 *) (walbuf++));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; a_action = *((uint8 *) (walbuf++));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinPostingList *newseg = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newsegsize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerData *items = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; nitems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerData *olditems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nolditems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerData *newitems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nnewitems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract all the information we need from the WAL record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a_action == GIN_SEGMENT_INSERT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a_action == GIN_SEGMENT_REPLACE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newseg = (GinPostingList *) walbuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newsegsize = SizeOfGinPostingList(newseg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walbuf += SHORTALIGN(newsegsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a_action == GIN_SEGMENT_ADDITEMS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;nitems, walbuf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walbuf += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; items = (ItemPointerData *) walbuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; walbuf += nitems * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip to the segment that this action concerns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(segno &lt;= a_segno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (segno &lt; a_segno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Once modification is started and page tail is copied, we've to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * copy unmodified segments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segsize = SizeOfGinPostingList(oldseg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tailCopy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(writePtr + segsize &lt; PageGetSpecialPointer(page));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(writePtr, (Pointer) oldseg, segsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; writePtr += segsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldseg = GinNextPostingListSegment(oldseg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segno++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ADDITEMS action is handled like REPLACE, but the new segment to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * replace the old one is reconstructed using the old segment from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * disk and the new items from the WAL record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a_action == GIN_SEGMENT_ADDITEMS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npacked;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; olditems = <a href="ginpostinglist.c.html#L284" title="access/gin/ginpostinglist.c:284">ginPostingListDecode</a>(oldseg, &amp;nolditems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newitems = <a href="ginpostinglist.c.html#L378" title="access/gin/ginpostinglist.c:378">ginMergeItemPointers</a>(items, nitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; olditems, nolditems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;nnewitems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nnewitems == nolditems + nitems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newseg = <a href="ginpostinglist.c.html#L197" title="access/gin/ginpostinglist.c:197">ginCompressPostingList</a>(newitems, nnewitems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BLCKSZ, &amp;npacked);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(npacked == nnewitems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newsegsize = SizeOfGinPostingList(newseg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; a_action = GIN_SEGMENT_REPLACE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; segptr = (Pointer) oldseg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (segptr != segmentend)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segsize = SizeOfGinPostingList(oldseg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Positioned after the last existing segment. Only INSERTs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expected here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(a_action == GIN_SEGMENT_INSERT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segsize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're about to start modification of the page.&nbsp; So, copy tail of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the page if it's not done already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tailCopy &amp;&amp; segptr != segmentend)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tailSize = segmentend - segptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tailCopy = (Pointer) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(tailSize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(tailCopy, segptr, tailSize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segptr = tailCopy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldseg = (GinPostingList *) segptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segmentend = segptr + tailSize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (a_action)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> GIN_SEGMENT_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segptr += segsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segno++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> GIN_SEGMENT_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy the new segment in place */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(writePtr + newsegsize &lt;= PageGetSpecialPointer(page));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(writePtr, newseg, newsegsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; writePtr += newsegsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> GIN_SEGMENT_REPLACE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy the new version of segment in place */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(writePtr + newsegsize &lt;= PageGetSpecialPointer(page));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(writePtr, newseg, newsegsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; writePtr += newsegsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segptr += segsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segno++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected GIN leaf action: </span><span class="Special">%u</span><span class="Constant">&quot;</span>, a_action);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldseg = (GinPostingList *) segptr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy the rest of unmodified segments if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li></span>&nbsp; &nbsp; segptr = (Pointer) oldseg;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (segptr != segmentend &amp;&amp; tailCopy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restSize = segmentend - segptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(writePtr + restSize &lt;= PageGetSpecialPointer(page));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(writePtr, segptr, restSize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; writePtr += restSize;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; totalsize = writePtr - (Pointer) GinDataLeafPageGetPostingList(page);<br/></li>
<li>&nbsp; &nbsp; GinDataPageSetDataSize(page, totalsize);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L319">&#x200c;</a></span><span class="linkable">ginRedoInsertData</span>(Buffer buffer, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isLeaf, BlockNumber rightblkno, <span class="Type">void</span> *rdata)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isLeaf)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ginxlogRecompressDataLeaf *data = (ginxlogRecompressDataLeaf *) rdata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(GinPageIsLeaf(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L117" title="access/gin/ginxlog.c:117">ginRedoRecompress</a>(page, data);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ginxlogInsertDataInternal *data = (ginxlogInsertDataInternal *) rdata;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PostingItem *oldpitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!GinPageIsLeaf(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update link to right page after split */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldpitem = GinDataPageGetPostingItem(page, data-&gt;offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PostingItemSetBlockNumber(oldpitem, rightblkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="gindatapage.c.html#L380" title="access/gin/gindatapage.c:380">GinDataPageAddPostingItem</a>(page, &amp;data-&gt;newitem, data-&gt;offset);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L347">&#x200c;</a></span><span class="linkable">ginRedoInsert</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; ginxlogInsert *data = (ginxlogInsert *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber leftChildBlkno = InvalidBlockNumber;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber rightChildBlkno = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isLeaf = (data-&gt;flags &amp; GIN_INSERT_ISLEAF) != <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First clear incomplete-split flag on child page if this finishes a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * split.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isLeaf)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *payload = XLogRecGetData(record) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ginxlogInsert);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; leftChildBlkno = BlockIdGetBlockNumber((BlockId) payload);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; payload += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BlockIdData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rightChildBlkno = BlockIdGetBlockNumber((BlockId) payload);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; payload += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BlockIdData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L25" title="access/gin/ginxlog.c:25">ginRedoClearIncompleteSplit</a>(record, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">0</span>, &amp;buffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *payload = <a href="../transam/xlogreader.c.html#L2025" title="access/transam/xlogreader.c:2025">XLogRecGetBlockData</a>(record, <span class="Constant">0</span>, &amp;len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* How to insert the payload is tree-type specific */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (data-&gt;flags &amp; GIN_INSERT_ISDATA)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(GinPageIsData(page));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L319" title="access/gin/ginxlog.c:319">ginRedoInsertData</a>(buffer, isLeaf, rightChildBlkno, payload);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!GinPageIsData(page));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/gin/ginxlog.c:71">ginRedoInsertEntry</a>(buffer, isLeaf, rightChildBlkno, payload);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L402">&#x200c;</a></span><span class="linkable">ginRedoSplit</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ginxlogSplit *data = (ginxlogSplit *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; lbuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rbuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootbuf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isLeaf = (data-&gt;flags &amp; GIN_INSERT_ISLEAF) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isRoot = (data-&gt;flags &amp; GIN_SPLIT_ROOT) != <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First clear incomplete-split flag on child page if this finishes a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * split<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isLeaf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L25" title="access/gin/ginxlog.c:25">ginRedoClearIncompleteSplit</a>(record, <span class="Constant">3</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">0</span>, &amp;lbuffer) != BLK_RESTORED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;GIN split record did not contain a full-page image of left page&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">1</span>, &amp;rbuffer) != BLK_RESTORED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;GIN split record did not contain a full-page image of right page&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isRoot)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">2</span>, &amp;rootbuf) != BLK_RESTORED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;GIN split record did not contain a full-page image of root page&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(rootbuf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(rbuffer);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(lbuffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * VACUUM_PAGE record contains simply a full image of the page, similar to<br/></li>
<li></span><span class="Comment"> * an XLOG_FPI record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L440">&#x200c;</a></span><span class="linkable">ginRedoVacuumPage</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">0</span>, &amp;buffer) != BLK_RESTORED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;replay of gin entry tree page <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> did not restore the page&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L452">&#x200c;</a></span><span class="linkable">ginRedoVacuumDataLeafPage</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">0</span>, &amp;buffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ginxlogVacuumDataLeafPage *xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec = (ginxlogVacuumDataLeafPage *) <a href="../transam/xlogreader.c.html#L2025" title="access/transam/xlogreader.c:2025">XLogRecGetBlockData</a>(record, <span class="Constant">0</span>, &amp;len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(GinPageIsLeaf(page));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(GinPageIsData(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L117" title="access/gin/ginxlog.c:117">ginRedoRecompress</a>(page, &amp;xlrec-&gt;data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L477">&#x200c;</a></span><span class="linkable">ginRedoDeletePage</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; ginxlogDeletePage *data = (ginxlogDeletePage *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; dbuffer;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; pbuffer;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; lbuffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lock left page first in order to prevent possible deadlock with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="ginbtree.c.html#L177" title="access/gin/ginbtree.c:177">ginStepRight</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">2</span>, &amp;lbuffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(lbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(GinPageIsData(page));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinPageGetOpaque(page)-&gt;rightlink = data-&gt;rightLink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(lbuffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">0</span>, &amp;dbuffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(dbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(GinPageIsData(page));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinPageSetDeleted(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinPageSetDeleteXid(page, data-&gt;deleteXid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(dbuffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">1</span>, &amp;pbuffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(pbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(GinPageIsData(page));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!GinPageIsLeaf(page));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="gindatapage.c.html#L417" title="access/gin/gindatapage.c:417">GinPageDeletePostingItem</a>(page, data-&gt;parentOffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(pbuffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(lbuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(lbuffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(pbuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(pbuffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(dbuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(dbuffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L528">&#x200c;</a></span><span class="linkable">ginRedoUpdateMetapage</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; ginxlogUpdateMeta *data = (ginxlogUpdateMeta *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; metapage;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Restore the metapage. This is essentially the same as a full-page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * image, so restore the metapage unconditionally without looking at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LSN, to avoid torn page hazards.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; metabuffer = <a href="../transam/xlogutils.c.html#L326" title="access/transam/xlogutils.c:326">XLogInitBufferForRedo</a>(record, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(metabuffer) == GIN_METAPAGE_BLKNO);<br/></li>
<li>&nbsp; &nbsp; metapage = BufferGetPage(metabuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="ginutil.c.html#L356" title="access/gin/ginutil.c:356">GinInitMetabuffer</a>(metabuffer);<br/></li>
<li>&nbsp; &nbsp; memcpy(GinPageGetMeta(metapage), &amp;data-&gt;metadata, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinMetaPageData));<br/></li>
<li>&nbsp; &nbsp; PageSetLSN(metapage, lsn);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(metabuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (data-&gt;ntuples &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * insert into tail page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">1</span>, &amp;buffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; tupsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *payload;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; tuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; totaltupsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; payload = <a href="../transam/xlogreader.c.html#L2025" title="access/transam/xlogreader.c:2025">XLogRecGetBlockData</a>(record, <span class="Constant">1</span>, &amp;totaltupsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuples = (IndexTuple) payload;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsEmpty(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off = OffsetNumberNext(PageGetMaxOffsetNumber(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; data-&gt;ntuples; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupsize = IndexTupleSize(tuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(page, (Item) tuples, tupsize, off,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add item to index page&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuples = (IndexTuple) (((<span class="Type">char</span> *) tuples) + tupsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(payload + totaltupsize == (<span class="Type">char</span> *) tuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Increase counter of heap tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinPageGetOpaque(page)-&gt;maxoff++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (data-&gt;prevTail != InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * New tail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">1</span>, &amp;buffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinPageGetOpaque(page)-&gt;rightlink = data-&gt;newRightlink;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(metabuffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L620">&#x200c;</a></span><span class="linkable">ginRedoInsertListPage</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; ginxlogInsertListPage *data = (ginxlogInsertListPage *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber l,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupsize;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *payload;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; tuples;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; totaltupsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We always re-<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the page. */<br/></li>
<li></span>&nbsp; &nbsp; buffer = <a href="../transam/xlogutils.c.html#L326" title="access/transam/xlogutils.c:326">XLogInitBufferForRedo</a>(record, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="ginutil.c.html#L350" title="access/gin/ginutil.c:350">GinInitBuffer</a>(buffer, GIN_LIST);<br/></li>
<li>&nbsp; &nbsp; GinPageGetOpaque(page)-&gt;rightlink = data-&gt;rightlink;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (data-&gt;rightlink == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tail of sublist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; GinPageSetFullRow(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinPageGetOpaque(page)-&gt;maxoff = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinPageGetOpaque(page)-&gt;maxoff = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; payload = <a href="../transam/xlogreader.c.html#L2025" title="access/transam/xlogreader.c:2025">XLogRecGetBlockData</a>(record, <span class="Constant">0</span>, &amp;totaltupsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuples = (IndexTuple) payload;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; data-&gt;ntuples; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupsize = IndexTupleSize(tuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; l = PageAddItem(page, (Item) tuples, tupsize, off, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (l == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add item to index page&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuples = (IndexTuple) (((<span class="Type">char</span> *) tuples) + tupsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; off++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert((<span class="Type">char</span> *) tuples == payload + totaltupsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L675">&#x200c;</a></span><span class="linkable">ginRedoDeleteListPages</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; ginxlogDeleteListPages *data = (ginxlogDeleteListPages *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; metapage;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metabuffer = <a href="../transam/xlogutils.c.html#L326" title="access/transam/xlogutils.c:326">XLogInitBufferForRedo</a>(record, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(metabuffer) == GIN_METAPAGE_BLKNO);<br/></li>
<li>&nbsp; &nbsp; metapage = BufferGetPage(metabuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="ginutil.c.html#L356" title="access/gin/ginutil.c:356">GinInitMetabuffer</a>(metabuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(GinPageGetMeta(metapage), &amp;data-&gt;metadata, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinMetaPageData));<br/></li>
<li>&nbsp; &nbsp; PageSetLSN(metapage, lsn);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(metabuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In normal operation, <a href="ginfast.c.html#L554" title="access/gin/ginfast.c:554">shiftList</a>() takes exclusive lock on all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages-to-be-deleted simultaneously.&nbsp; During replay, however, it should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be all right to lock them one at a time.&nbsp; This is dependent on the fact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we are deleting pages from the head of the list, and that readers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * share-lock the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing the one they are on. So we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cannot get past a reader that is on, or due to visit, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> page we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * going to delete.&nbsp; New incoming readers will block behind our metapage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock and then see a fully updated page list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No full-page images are taken of the deleted pages. Instead, they are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-initialized as empty, deleted pages. Their right-links don't need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be preserved, because no new readers can see the pages, as explained<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; data-&gt;ndeleted; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../transam/xlogutils.c.html#L326" title="access/transam/xlogutils.c:326">XLogInitBufferForRedo</a>(record, i + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="ginutil.c.html#L350" title="access/gin/ginutil.c:350">GinInitBuffer</a>(buffer, GIN_DELETED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(metabuffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L726">&#x200c;</a></span><span class="linkable">gin_redo</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(record) &amp; ~XLR_INFO_MASK;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldCtx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * GIN indexes do not require <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> conflict processing. NB: If we ever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implement a similar optimization as we have in b-tree, and remove<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * killed tuples outside VACUUM, we'll need to handle that here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; oldCtx = MemoryContextSwitchTo(<a href="../spgist/spgxlog.c.html#L25" title="access/spgist/spgxlog.c:25">opCtx</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_GIN_CREATE_PTREE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="access/gin/ginxlog.c:44">ginRedoCreatePTree</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_GIN_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L347" title="access/gin/ginxlog.c:347">ginRedoInsert</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_GIN_SPLIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L402" title="access/gin/ginxlog.c:402">ginRedoSplit</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_GIN_VACUUM_PAGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L440" title="access/gin/ginxlog.c:440">ginRedoVacuumPage</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_GIN_VACUUM_DATA_LEAF_PAGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L452" title="access/gin/ginxlog.c:452">ginRedoVacuumDataLeafPage</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_GIN_DELETE_PAGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L477" title="access/gin/ginxlog.c:477">ginRedoDeletePage</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_GIN_UPDATE_META_PAGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L528" title="access/gin/ginxlog.c:528">ginRedoUpdateMetapage</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_GIN_INSERT_LISTPAGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L620" title="access/gin/ginxlog.c:620">ginRedoInsertListPage</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_GIN_DELETE_LISTPAGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L675" title="access/gin/ginxlog.c:675">ginRedoDeleteListPages</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;<a href="#L726" title="access/gin/ginxlog.c:726">gin_redo</a>: unknown op code </span><span class="Special">%u</span><span class="Constant">&quot;</span>, info);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldCtx);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="../spgist/spgxlog.c.html#L25" title="access/spgist/spgxlog.c:25">opCtx</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L775">&#x200c;</a></span><span class="linkable">gin_xlog_startup</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../spgist/spgxlog.c.html#L25" title="access/spgist/spgxlog.c:25">opCtx</a> = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;GIN recovery temporary context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L783">&#x200c;</a></span><span class="linkable">gin_xlog_cleanup</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(<a href="../spgist/spgxlog.c.html#L25" title="access/spgist/spgxlog.c:25">opCtx</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../spgist/spgxlog.c.html#L25" title="access/spgist/spgxlog.c:25">opCtx</a> = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Mask a GIN page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> running consistency checks on it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L793">&#x200c;</a></span><span class="linkable">gin_mask</span>(<span class="Type">char</span> *pagedata, BlockNumber blkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) pagedata;<br/></li>
<li>&nbsp; &nbsp; PageHeader&nbsp; &nbsp; pagehdr = (PageHeader) page;<br/></li>
<li>&nbsp; &nbsp; GinPageOpaque opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../common/bufmask.c.html#L31" title="access/common/bufmask.c:31">mask_page_lsn_and_checksum</a>(page);<br/></li>
<li>&nbsp; &nbsp; opaque = GinPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../common/bufmask.c.html#L46" title="access/common/bufmask.c:46">mask_page_hint_bits</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For a GIN_DELETED page, the page is initialized to empty.&nbsp; Hence, mask<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the whole page content.&nbsp; For other pages, mask the hole if pd_lower<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appears to have been set correctly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (opaque-&gt;flags &amp; GIN_DELETED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/bufmask.c.html#L119" title="access/common/bufmask.c:119">mask_page_content</a>(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pagehdr-&gt;pd_lower &gt; SizeOfPageHeaderData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/bufmask.c.html#L71" title="access/common/bufmask.c:71">mask_unused_space</a>(page);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
