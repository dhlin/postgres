<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/gin/ginfast.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/gin/ginfast.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L39">gin_pending_list_limit</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L44">KeyArray</a></li>
<li><a href="#L50">KeyArray</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L685">addDatum</a></li>
<li><a href="#L483">ginHeapTupleFastCollect</a></li>
<li><a href="#L219">ginHeapTupleFastInsert</a></li>
<li><a href="#L780">ginInsertCleanup</a></li>
<li><a href="#L1031">gin_clean_pending_list</a></li>
<li><a href="#L675">initKeyArray</a></li>
<li><a href="#L145">makeSublist</a></li>
<li><a href="#L709">processPendingPage</a></li>
<li><a href="#L554">shiftList</a></li>
<li><a href="#L59">writeListPage</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L41">GIN_PAGE_FREESIZE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ginfast.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Fast insert routines for the Postgres inverted index access method.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Pending entries are stored in linear list of pages.&nbsp; Later on<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; (typically during VACUUM), <a href="#L780" title="access/gin/ginfast.c:780">ginInsertCleanup</a>() will be invoked to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transfer pending entries into the regular index structure.&nbsp; This<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; wins because bulk insertion is much more efficient than retail.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src/backend/access/gin/ginfast.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/gin_private.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/ginxlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_am.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/autovacuum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/indexfsm.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/acl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* GUC parameter */<br/></li>
<li><a id="L39">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">gin_pending_list_limit</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><a id="L41">&#x200c;</a><span class="PreProc">#define <span class="linkable">GIN_PAGE_FREESIZE</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ( BLCKSZ - MAXALIGN(SizeOfPageHeaderData) - MAXALIGN(</span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(GinPageOpaqueData)) )<br/></li>
<li></span><br/></li>
<li><a id="L44">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">KeyArray</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *keys;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expansible array */<br/></li>
<li></span>&nbsp; &nbsp; GinNullCategory *categories;&nbsp; &nbsp; <span class="Comment">/* another expansible array */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; nvalues;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current number of valid entries */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; maxvalues;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocated size of arrays */<br/></li>
<li><a id="L50">&#x200c;</a></span>} <span class="linkable">KeyArray</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build a pending-list page from the given array of tuples, and write it out.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns amount of free space left on the page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> int32<br/></li>
<li><a id="L59">&#x200c;</a><span class="linkable">writeListPage</span>(Relation index, Buffer buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple *tuples, int32 ntuples, BlockNumber rightlink)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freesize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber l,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off;<br/></li>
<li>&nbsp; &nbsp; PGAlignedBlock workspace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="ginutil.c.html#L350" title="access/gin/ginutil.c:350">GinInitBuffer</a>(buffer, GIN_LIST);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; off = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; ptr = workspace.data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ntuples; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_size = IndexTupleSize(tuples[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, tuples[i], this_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += this_size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size += this_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; l = PageAddItem(page, (Item) tuples[i], this_size, off, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (l == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add item to index page in </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(index));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; off++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(size &lt;= BLCKSZ);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else we overran workspace */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; GinPageGetOpaque(page)-&gt;rightlink = rightlink;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tail page may contain only whole row(s) or final part of row placed on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previous pages (a &quot;row&quot; here meaning all the index tuples generated for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one heap tuple)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rightlink == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinPageSetFullRow(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinPageGetOpaque(page)-&gt;maxoff = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinPageGetOpaque(page)-&gt;maxoff = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(index))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ginxlogInsertListPage data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data.rightlink = rightlink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data.ntuples = ntuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;data, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ginxlogInsertListPage));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buffer, REGBUF_WILL_INIT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, workspace.data, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_GIN_ID, XLOG_GIN_INSERT_LISTPAGE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* get free space <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing buffer */<br/></li>
<li></span>&nbsp; &nbsp; freesize = <a href="../../storage/page/bufpage.c.html#L958" title="storage/page/bufpage.c:958">PageGetExactFreeSpace</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> freesize;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L145">&#x200c;</a></span><span class="linkable">makeSublist</span>(Relation index, IndexTuple *tuples, int32 ntuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinMetaPageData *res)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; curBuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; prevBuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupsize;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startTuple = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ntuples &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Split tuples into pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ntuples; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curBuffer == InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curBuffer = <a href="ginutil.c.html#L300" title="access/gin/ginutil.c:300">GinNewBuffer</a>(index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prevBuffer != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res-&gt;nPendingPages++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L59" title="access/gin/ginfast.c:59">writeListPage</a>(index, prevBuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuples + startTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i - startTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(curBuffer));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res-&gt;head = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(curBuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevBuffer = curBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startTuple = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupsize = MAXALIGN(IndexTupleSize(tuples[i])) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (size + tupsize &gt; GinListPageSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* won't fit, force a new page and reprocess */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curBuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size += tupsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write last page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; res-&gt;tail = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(curBuffer);<br/></li>
<li>&nbsp; &nbsp; res-&gt;tailFreeSize = <a href="#L59" title="access/gin/ginfast.c:59">writeListPage</a>(index, curBuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuples + startTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntuples - startTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidBlockNumber);<br/></li>
<li>&nbsp; &nbsp; res-&gt;nPendingPages++;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* that was only one heap tuple */<br/></li>
<li></span>&nbsp; &nbsp; res-&gt;nPendingHeapTuples = <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write the index tuples contained in *collector into the index's<br/></li>
<li></span><span class="Comment"> * pending list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Function guarantees that all these tuples will be inserted consecutively,<br/></li>
<li></span><span class="Comment"> * preserving order<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L219">&#x200c;</a></span><span class="linkable">ginHeapTupleFastInsert</span>(GinState *ginstate, GinTupleCollector *collector)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; index = ginstate-&gt;index;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; metapage;<br/></li>
<li>&nbsp; &nbsp; GinMetaPageData *metadata = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ginxlogUpdateMeta data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; separateList = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needCleanup = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cleanupSize;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needWal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (collector-&gt;ntuples == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; needWal = RelationNeedsWAL(index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; data.locator = index-&gt;rd_locator;<br/></li>
<li>&nbsp; &nbsp; data.ntuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; data.newRightlink = data.prevTail = InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metabuffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(index, GIN_METAPAGE_BLKNO);<br/></li>
<li>&nbsp; &nbsp; metapage = BufferGetPage(metabuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * An insertion to the pending list could logically belong anywhere in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tree, so it conflicts with all serializable scans.&nbsp; All scans acquire a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * predicate lock on the metabuffer to represent that.&nbsp; Therefore we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check for conflicts in, but not until we have the page locked and are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ready to modify the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (collector-&gt;sumsize + collector-&gt;ntuples * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData) &gt; GinListPageSize)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Total size is greater than one page =&gt; make sublist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; separateList = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuffer, GIN_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metadata = GinPageGetMeta(metapage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (metadata-&gt;head == InvalidBlockNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collector-&gt;sumsize + collector-&gt;ntuples * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData) &gt; metadata-&gt;tailFreeSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pending list is empty or total size is greater than freespace<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on tail page =&gt; make sublist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We unlock metabuffer to keep high concurrency<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; separateList = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuffer, GIN_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (separateList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should make sublist separately and append it to the tail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; GinMetaPageData sublist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;sublist, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinMetaPageData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L145" title="access/gin/ginfast.c:145">makeSublist</a>(index, collector-&gt;tuples, collector-&gt;ntuples, &amp;sublist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * metapage was unlocked, see above<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuffer, GIN_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metadata = GinPageGetMeta(metapage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L4321" title="storage/lmgr/predicate.c:4321">CheckForSerializableConflictIn</a>(index, <span class="Constant">NULL</span>, GIN_METAPAGE_BLKNO);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (metadata-&gt;head == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Main list is empty, so just insert sublist as <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metadata-&gt;head = sublist.head;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metadata-&gt;tail = sublist.tail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metadata-&gt;tailFreeSize = sublist.tailFreeSize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metadata-&gt;nPendingPages = sublist.nPendingPages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metadata-&gt;nPendingHeapTuples = sublist.nPendingHeapTuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needWal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Merge lists<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data.prevTail = metadata-&gt;tail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data.newRightlink = sublist.head;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(index, metadata-&gt;tail);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIN_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(GinPageGetOpaque(page)-&gt;rightlink == InvalidBlockNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinPageGetOpaque(page)-&gt;rightlink = sublist.head;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metadata-&gt;tail = sublist.tail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metadata-&gt;tailFreeSize = sublist.tailFreeSize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metadata-&gt;nPendingPages += sublist.nPendingPages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metadata-&gt;nPendingHeapTuples += sublist.nPendingHeapTuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needWal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">1</span>, buffer, REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> into tail page.&nbsp; Metapage is already locked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber l,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *collectordata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L4321" title="storage/lmgr/predicate.c:4321">CheckForSerializableConflictIn</a>(index, <span class="Constant">NULL</span>, GIN_METAPAGE_BLKNO);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(index, metadata-&gt;tail);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIN_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; off = (PageIsEmpty(page)) ? FirstOffsetNumber :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumberNext(PageGetMaxOffsetNumber(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collectordata = ptr = (<span class="Type">char</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(collector-&gt;sumsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data.ntuples = collector-&gt;ntuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needWal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Increase counter of heap tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(GinPageGetOpaque(page)-&gt;maxoff &lt;= metadata-&gt;nPendingHeapTuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinPageGetOpaque(page)-&gt;maxoff++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metadata-&gt;nPendingHeapTuples++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; collector-&gt;ntuples; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupsize = IndexTupleSize(collector-&gt;tuples[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l = PageAddItem(page, (Item) collector-&gt;tuples[i], tupsize, off, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (l == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add item to index page in </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(index));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, collector-&gt;tuples[i], tupsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += tupsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert((ptr - collectordata) &lt;= collector-&gt;sumsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needWal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">1</span>, buffer, REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">1</span>, collectordata, collector-&gt;sumsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metadata-&gt;tailFreeSize = <a href="../../storage/page/bufpage.c.html#L958" title="storage/page/bufpage.c:958">PageGetExactFreeSpace</a>(page);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set pd_lower just past the end of the metadata.&nbsp; This is essential,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because without doing so, metadata will be lost if xlog.c compresses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the page.&nbsp; (We must do this here because pre-v11 versions of PG did not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set the metapage's pd_lower correctly, so a pg_upgraded index might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contain the wrong value.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ((PageHeader) metapage)-&gt;pd_lower =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">char</span> *) metadata + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinMetaPageData)) - (<span class="Type">char</span> *) metapage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write metabuffer, make xlog entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(metabuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (needWal)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;data.metadata, metadata, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinMetaPageData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, metabuffer, REGBUF_WILL_INIT | REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;data, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ginxlogUpdateMeta));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_GIN_ID, XLOG_GIN_UPDATE_META_PAGE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(metapage, recptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buffer != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (buffer != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Force pending list <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> when it becomes too long. And,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L780" title="access/gin/ginfast.c:780">ginInsertCleanup</a> could take significant amount of time, so we prefer to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * call it when it can do all the work in a single collection cycle. In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> mode, it shouldn't require <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a>, so fire it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * while pending list is still small enough to fit into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L39" title="access/gin/ginfast.c:39">gin_pending_list_limit</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L780" title="access/gin/ginfast.c:780">ginInsertCleanup</a>() should not be called inside our CRIT_SECTION.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cleanupSize = GinGetPendingListCleanupSize(index);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (metadata-&gt;nPendingPages * <a href="#L41" title="access/gin/ginfast.c:41">GIN_PAGE_FREESIZE</a> &gt; cleanupSize * <span class="Constant">1024L</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; needCleanup = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(metabuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since it could contend with concurrent <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> process we <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pending list not forcibly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (needCleanup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L780" title="access/gin/ginfast.c:780">ginInsertCleanup</a>(ginstate, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create temporary index tuples for a single indexable item (one index column<br/></li>
<li></span><span class="Comment"> * for the heap tuple specified by ht_ctid), and append them to the array<br/></li>
<li></span><span class="Comment"> * in *collector.&nbsp; They will subsequently be written out using<br/></li>
<li></span><span class="Comment"> * <a href="#L219" title="access/gin/ginfast.c:219">ginHeapTupleFastInsert</a>.&nbsp; Note that to guarantee consistent state, all<br/></li>
<li></span><span class="Comment"> * temp tuples for a given heap tuple must be written in one call to<br/></li>
<li></span><span class="Comment"> * <a href="#L219" title="access/gin/ginfast.c:219">ginHeapTupleFastInsert</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L483">&#x200c;</a></span><span class="linkable">ginHeapTupleFastCollect</span>(GinState *ginstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinTupleCollector *collector,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber attnum, Datum value, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer ht_ctid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *entries;<br/></li>
<li>&nbsp; &nbsp; GinNullCategory *categories;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nentries;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Extract the key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that need to be inserted in the index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; entries = <a href="ginutil.c.html#L483" title="access/gin/ginutil.c:483">ginExtractEntries</a>(ginstate, attnum, value, isNull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;nentries, &amp;categories);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Protect against integer overflow in allocation calculations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nentries &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collector-&gt;ntuples + nentries &gt; MaxAllocSize / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too many entries for GIN index&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate/reallocate memory for storing collected tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (collector-&gt;tuples == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine the number of elements to allocate in the tuples array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * initially.&nbsp; Make it a power of 2 to avoid wasting memory when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * resizing (since <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> likes powers of 2).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; collector-&gt;lentuples = pg_nextpower2_32(Max(<span class="Constant">16</span>, nentries));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collector-&gt;tuples = palloc_array(IndexTuple, collector-&gt;lentuples);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (collector-&gt;lentuples &lt; collector-&gt;ntuples + nentries)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Advance lentuples to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> suitable power of 2.&nbsp; This won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overflow, though we could get to a value that exceeds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * MaxAllocSize/<a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(IndexTuple), causing an error in <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; collector-&gt;lentuples = pg_nextpower2_32(collector-&gt;ntuples + nentries);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collector-&gt;tuples = repalloc_array(collector-&gt;tuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTuple, collector-&gt;lentuples);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build an index tuple for each key value, and add to array.&nbsp; In pending<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples we just stick the heap TID into t_tid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nentries; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = <a href="ginentrypage.c.html#L44" title="access/gin/ginentrypage.c:44">GinFormTuple</a>(ginstate, attnum, entries[i], categories[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup-&gt;t_tid = *ht_ctid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collector-&gt;tuples[collector-&gt;ntuples++] = itup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collector-&gt;sumsize += IndexTupleSize(itup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Deletes pending list pages up to (not including) newHead page.<br/></li>
<li></span><span class="Comment"> * If newHead == InvalidBlockNumber then function drops the whole list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * metapage is pinned and exclusive-locked throughout this function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L554">&#x200c;</a></span><span class="linkable">shiftList</span>(Relation index, Buffer metabuffer, BlockNumber newHead,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fill_fsm, IndexBulkDeleteResult *stats)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; metapage;<br/></li>
<li>&nbsp; &nbsp; GinMetaPageData *metadata;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blknoToDelete;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metapage = BufferGetPage(metabuffer);<br/></li>
<li>&nbsp; &nbsp; metadata = GinPageGetMeta(metapage);<br/></li>
<li>&nbsp; &nbsp; blknoToDelete = metadata-&gt;head;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; nDeletedHeapTuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ginxlogDeleteListPages data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffers[GIN_NDELETE_AT_ONCE];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber freespace[GIN_NDELETE_AT_ONCE];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data.ndeleted = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (data.ndeleted &lt; GIN_NDELETE_AT_ONCE &amp;&amp; blknoToDelete != newHead)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freespace[data.ndeleted] = blknoToDelete;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffers[data.ndeleted] = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(index, blknoToDelete);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffers[data.ndeleted], GIN_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffers[data.ndeleted]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data.ndeleted++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!GinPageIsDeleted(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nDeletedHeapTuples += GinPageGetOpaque(page)-&gt;maxoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blknoToDelete = GinPageGetOpaque(page)-&gt;rightlink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stats)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;pages_deleted += data.ndeleted;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This operation touches an unusually large number of pages, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prepare the <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a> machinery for that <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> entering the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * critical section.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(index))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L175" title="access/transam/xloginsert.c:175">XLogEnsureRecordSpace</a>(data.ndeleted, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metadata-&gt;head = blknoToDelete;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(metadata-&gt;nPendingPages &gt;= data.ndeleted);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metadata-&gt;nPendingPages -= data.ndeleted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(metadata-&gt;nPendingHeapTuples &gt;= nDeletedHeapTuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metadata-&gt;nPendingHeapTuples -= nDeletedHeapTuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blknoToDelete == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metadata-&gt;tail = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metadata-&gt;tailFreeSize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metadata-&gt;nPendingPages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metadata-&gt;nPendingHeapTuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set pd_lower just past the end of the metadata.&nbsp; This is essential,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because without doing so, metadata will be lost if xlog.c<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * compresses the page.&nbsp; (We must do this here because pre-v11<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * versions of PG did not set the metapage's pd_lower correctly, so a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_upgraded index might contain the wrong value.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ((PageHeader) metapage)-&gt;pd_lower =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">char</span> *) metadata + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinMetaPageData)) - (<span class="Type">char</span> *) metapage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(metabuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; data.ndeleted; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffers[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinPageGetOpaque(page)-&gt;flags = GIN_DELETED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffers[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(index))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, metabuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; REGBUF_WILL_INIT | REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; data.ndeleted; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(i + <span class="Constant">1</span>, buffers[i], REGBUF_WILL_INIT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;data.metadata, metadata, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinMetaPageData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ginxlogDeleteListPages));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_GIN_ID, XLOG_GIN_DELETE_LISTPAGE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(metapage, recptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; data.ndeleted; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffers[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; data.ndeleted; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffers[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; fill_fsm &amp;&amp; i &lt; data.ndeleted; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/indexfsm.c.html#L52" title="storage/freespace/indexfsm.c:52">RecordFreeIndexPage</a>(index, freespace[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (blknoToDelete != newHead);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Initialize empty <a href="#L44" title="access/gin/ginfast.c:44">KeyArray</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L675">&#x200c;</a></span><span class="linkable">initKeyArray</span>(<a href="#L44" title="access/gin/ginfast.c:44">KeyArray</a> *keys, int32 maxvalues)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; keys-&gt;keys = palloc_array(Datum, maxvalues);<br/></li>
<li>&nbsp; &nbsp; keys-&gt;categories = palloc_array(GinNullCategory, maxvalues);<br/></li>
<li>&nbsp; &nbsp; keys-&gt;nvalues = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; keys-&gt;maxvalues = maxvalues;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Add datum to <a href="#L44" title="access/gin/ginfast.c:44">KeyArray</a>, resizing if needed */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L685">&#x200c;</a></span><span class="linkable">addDatum</span>(<a href="#L44" title="access/gin/ginfast.c:44">KeyArray</a> *keys, Datum datum, GinNullCategory category)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (keys-&gt;nvalues &gt;= keys-&gt;maxvalues)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; keys-&gt;maxvalues *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; keys-&gt;keys = repalloc_array(keys-&gt;keys, Datum, keys-&gt;maxvalues);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; keys-&gt;categories = repalloc_array(keys-&gt;categories, GinNullCategory, keys-&gt;maxvalues);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; keys-&gt;keys[keys-&gt;nvalues] = datum;<br/></li>
<li>&nbsp; &nbsp; keys-&gt;categories[keys-&gt;nvalues] = category;<br/></li>
<li>&nbsp; &nbsp; keys-&gt;nvalues++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Collect data from a pending-list page in preparation for insertion into<br/></li>
<li></span><span class="Comment"> * the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> index.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Go through all tuples &gt;= startoff on page and collect <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in accum<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that ka is just workspace --- it does not carry <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> state across<br/></li>
<li></span><span class="Comment"> * calls.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L709">&#x200c;</a></span><span class="linkable">processPendingPage</span>(BuildAccumulator *accum, <a href="#L44" title="access/gin/ginfast.c:44">KeyArray</a> *ka,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Page page, OffsetNumber startoff)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ItemPointerData heapptr;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber attrnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reset *ka to empty */<br/></li>
<li></span>&nbsp; &nbsp; ka-&gt;nvalues = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; Assert(maxoff &gt;= FirstOffsetNumber);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;heapptr);<br/></li>
<li>&nbsp; &nbsp; attrnum = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = startoff; i &lt;= maxoff; i = OffsetNumberNext(i))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, i));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber curattnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; curkey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinNullCategory curcategory;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for change of heap TID or attnum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; curattnum = <a href="ginutil.c.html#L226" title="access/gin/ginutil.c:226">gintuple_get_attrnum</a>(accum-&gt;ginstate, itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ItemPointerIsValid(&amp;heapptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapptr = itup-&gt;t_tid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrnum = curattnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!(<a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;heapptr, &amp;itup-&gt;t_tid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curattnum == attrnum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="ginbulk.c.html#L210" title="access/gin/ginbulk.c:210">ginInsertBAEntries</a> can insert several datums per call, but only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for one heap tuple and one column.&nbsp; So call it at a boundary,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and reset ka.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="ginbulk.c.html#L210" title="access/gin/ginbulk.c:210">ginInsertBAEntries</a>(accum, &amp;heapptr, attrnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ka-&gt;keys, ka-&gt;categories, ka-&gt;nvalues);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ka-&gt;nvalues = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapptr = itup-&gt;t_tid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrnum = curattnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add key to <a href="#L44" title="access/gin/ginfast.c:44">KeyArray</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; curkey = <a href="ginutil.c.html#L259" title="access/gin/ginutil.c:259">gintuple_get_key</a>(accum-&gt;ginstate, itup, &amp;curcategory);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L685" title="access/gin/ginfast.c:685">addDatum</a>(ka, curkey, curcategory);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Dump out all remaining keys */<br/></li>
<li></span>&nbsp; &nbsp; <a href="ginbulk.c.html#L210" title="access/gin/ginbulk.c:210">ginInsertBAEntries</a>(accum, &amp;heapptr, attrnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ka-&gt;keys, ka-&gt;categories, ka-&gt;nvalues);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Move tuples from pending pages into regular GIN structure.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On first glance it looks completely not crash-safe. But if we crash<br/></li>
<li></span><span class="Comment"> * after posting entries to the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> index and <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> removing them from the<br/></li>
<li></span><span class="Comment"> * pending list, it's okay because when we redo the posting later on, nothing<br/></li>
<li></span><span class="Comment"> * bad will happen.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * fill_fsm indicates that <a href="#L780" title="access/gin/ginfast.c:780">ginInsertCleanup</a> should add deleted pages<br/></li>
<li></span><span class="Comment"> * to FSM otherwise caller is responsible to put deleted pages into<br/></li>
<li></span><span class="Comment"> * FSM.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If stats isn't null, we count deleted pending pages into the counts.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L780">&#x200c;</a></span><span class="linkable">ginInsertCleanup</span>(GinState *ginstate, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> full_clean,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fill_fsm, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forceCleanup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexBulkDeleteResult *stats)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; index = ginstate-&gt;index;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; metapage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; GinMetaPageData *metadata;<br/></li>
<li>&nbsp; &nbsp; MemoryContext <a href="../spgist/spgxlog.c.html#L25" title="access/spgist/spgxlog.c:25">opCtx</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldCtx;<br/></li>
<li>&nbsp; &nbsp; BuildAccumulator accum;<br/></li>
<li>&nbsp; &nbsp; <a href="#L44" title="access/gin/ginfast.c:44">KeyArray</a>&nbsp; &nbsp; datums;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blknoFinish;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; cleanupFinish = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; fsm_vac = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; workMemory;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We would like to prevent concurrent <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> process. For that we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock metapage in exclusive mode using <a href="../../storage/lmgr/lmgr.c.html#L513" title="storage/lmgr/lmgr.c:513">LockPage</a>() call. Nobody other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will use that lock for metapage, so we keep possibility of concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * insertion into pending list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (forceCleanup)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are called from [auto]<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>/<a href="../../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> or <a href="#L1031" title="access/gin/ginfast.c:1031">gin_clean_pending_list</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and we would like to wait concurrent <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> to finish.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L513" title="storage/lmgr/lmgr.c:513">LockPage</a>(index, GIN_METAPAGE_BLKNO, ExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; workMemory =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (AmAutoVacuumWorkerProcess() &amp;&amp; <a href="../../postmaster/autovacuum.c.html#L118" title="postmaster/autovacuum.c:118">autovacuum_work_mem</a> != -<span class="Constant">1</span>) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/autovacuum.c.html#L118" title="postmaster/autovacuum.c:118">autovacuum_work_mem</a> : <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are called from regular insert and if we see concurrent <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just exit in hope that concurrent process will clean up pending<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/lmgr/lmgr.c.html#L532" title="storage/lmgr/lmgr.c:532">ConditionalLockPage</a>(index, GIN_METAPAGE_BLKNO, ExclusiveLock))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; workMemory = <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metabuffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(index, GIN_METAPAGE_BLKNO);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuffer, GIN_SHARE);<br/></li>
<li>&nbsp; &nbsp; metapage = BufferGetPage(metabuffer);<br/></li>
<li>&nbsp; &nbsp; metadata = GinPageGetMeta(metapage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (metadata-&gt;head == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(metabuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L548" title="storage/lmgr/lmgr.c:548">UnlockPage</a>(index, GIN_METAPAGE_BLKNO, ExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember a tail page to prevent infinite <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> if other backends add<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new tuples faster than we can <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; blknoFinish = metadata-&gt;tail;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read and lock head of pending list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; blkno = metadata-&gt;head;<br/></li>
<li>&nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(index, blkno);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIN_SHARE);<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuffer, GIN_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize.&nbsp; All temporary space will be in <a href="../spgist/spgxlog.c.html#L25" title="access/spgist/spgxlog.c:25">opCtx</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../spgist/spgxlog.c.html#L25" title="access/spgist/spgxlog.c:25">opCtx</a> = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;GIN insert <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> temporary context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldCtx = MemoryContextSwitchTo(<a href="../spgist/spgxlog.c.html#L25" title="access/spgist/spgxlog.c:25">opCtx</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L675" title="access/gin/ginfast.c:675">initKeyArray</a>(&amp;datums, <span class="Constant">128</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="ginbulk.c.html#L109" title="access/gin/ginbulk.c:109">ginInitBA</a>(&amp;accum);<br/></li>
<li>&nbsp; &nbsp; accum.ginstate = ginstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At the top of this loop, we have pin and lock on the current page of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the pending list.&nbsp; However, we'll release that <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> exiting the loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note we also have pin but not lock on the metapage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!GinPageIsDeleted(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Are we walk through the page which as we remember was a tail when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we start our <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>?&nbsp; But if caller asks us to clean up whole<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pending list then ignore old tail, we will work until list becomes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno == blknoFinish &amp;&amp; full_clean == <span class="Constant">false</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cleanupFinish = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * read page's datums into accum<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L709" title="access/gin/ginfast.c:709">processPendingPage</a>(&amp;accum, &amp;datums, page, FirstOffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Is it time to flush memory to disk?&nbsp; &nbsp; Flush if we are at the end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the pending list, or if we have a full row and memory is getting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * full.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinPageGetOpaque(page)-&gt;rightlink == InvalidBlockNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (GinPageHasFullRow(page) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (accum.allocatedMemory &gt;= workMemory * <span class="Constant">1024L</span>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerData *list;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinNullCategory category;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber maxoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unlock current page to increase performance. Changes of page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will be checked later by comparing maxoff after completion of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memory flush.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIN_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Moving collected data into regular structure can take<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * significant amount of time - so, run it without locking pending<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="ginbulk.c.html#L257" title="access/gin/ginbulk.c:257">ginBeginBAScan</a>(&amp;accum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((list = <a href="ginbulk.c.html#L268" title="access/gin/ginbulk.c:268">ginGetBAEntry</a>(&amp;accum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;attnum, &amp;key, &amp;category, &amp;nlist)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="gininsert.c.html#L176" title="access/gin/gininsert.c:176">ginEntryInsert</a>(ginstate, attnum, key, category,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list, nlist, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lock the whole list to remove pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuffer, GIN_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIN_SHARE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!GinPageIsDeleted(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * While we left the page unlocked, more stuff might have gotten<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * added to it.&nbsp; If so, process those entries immediately.&nbsp; There<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shouldn't be very many, so we don't worry about the fact that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're doing this with exclusive lock. Insertion algorithm<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * guarantees that inserted row(s) will not continue on <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: intentionally no <a href="../../commands/vacuum.c.html#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a> in this loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) != maxoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="ginbulk.c.html#L109" title="access/gin/ginbulk.c:109">ginInitBA</a>(&amp;accum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L709" title="access/gin/ginfast.c:709">processPendingPage</a>(&amp;accum, &amp;datums, page, maxoff + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="ginbulk.c.html#L257" title="access/gin/ginbulk.c:257">ginBeginBAScan</a>(&amp;accum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((list = <a href="ginbulk.c.html#L268" title="access/gin/ginbulk.c:268">ginGetBAEntry</a>(&amp;accum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;attnum, &amp;key, &amp;category, &amp;nlist)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="gininsert.c.html#L176" title="access/gin/gininsert.c:176">ginEntryInsert</a>(ginstate, attnum, key, category,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list, nlist, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page - it will become the new list head<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno = GinPageGetOpaque(page)-&gt;rightlink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);&nbsp; &nbsp; <span class="Comment">/* <a href="#L554" title="access/gin/ginfast.c:554">shiftList</a> will do exclusive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locking */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remove read pages from pending list, at this point all content<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of read pages is in regular structure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L554" title="access/gin/ginfast.c:554">shiftList</a>(index, metabuffer, blkno, fill_fsm, stats);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* At this point, some pending pages have been freed up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsm_vac = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(blkno == metadata-&gt;head);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuffer, GIN_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we removed the whole pending list or we <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> tail (which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we remembered on start our <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> process) then just exit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno == InvalidBlockNumber || cleanupFinish)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * release memory used so far and reinit state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="../spgist/spgxlog.c.html#L25" title="access/spgist/spgxlog.c:25">opCtx</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L675" title="access/gin/ginfast.c:675">initKeyArray</a>(&amp;datums, datums.maxvalues);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="ginbulk.c.html#L109" title="access/gin/ginbulk.c:109">ginInitBA</a>(&amp;accum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno = GinPageGetOpaque(page)-&gt;rightlink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Read <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page in pending list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(index, blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIN_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L548" title="storage/lmgr/lmgr.c:548">UnlockPage</a>(index, GIN_METAPAGE_BLKNO, ExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(metabuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As pending list pages can have a high churn rate, it is desirable to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recycle them immediately to the FreeSpaceMap when ordinary backends<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clean the list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fsm_vac &amp;&amp; fill_fsm)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/indexfsm.c.html#L71" title="storage/freespace/indexfsm.c:71">IndexFreeSpaceMapVacuum</a>(index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up temporary space */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldCtx);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(<a href="../spgist/spgxlog.c.html#L25" title="access/spgist/spgxlog.c:25">opCtx</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL-callable function to clean the insert pending list<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1031">&#x200c;</a><span class="linkable">gin_clean_pending_list</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexoid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; indexRel = <a href="../index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(indexoid, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; IndexBulkDeleteResult stats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovery is in progress&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;GIN pending list cannot be cleaned up during recovery.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must be a GIN index */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexRel-&gt;rd_rel-&gt;relkind != RELKIND_INDEX ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexRel-&gt;rd_rel-&gt;relam != GIN_AM_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a GIN index&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(indexRel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reject attempts to read non-local temporary relations; we would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * likely to get wrong data since we have no visibility into the owning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * session's local buffers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RELATION_IS_OTHER_TEMP(indexRel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot access temporary indexes of other sessions&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* User must own the index (comparable to privileges needed for VACUUM) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../catalog/aclchk.c.html#L4130" title="catalog/aclchk.c:4130">object_ownercheck</a>(RelationRelationId, indexoid, <a href="../../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>()))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(ACLCHECK_NOT_OWNER, OBJECT_INDEX,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(indexRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;stats, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(stats));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Can't assume anything about the content of an !indisready index.&nbsp; Make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those a no-op, not an error, so users can just run this function on all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indexes of the access method.&nbsp; Since an indisready&amp;&amp;!indisvalid index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is merely awaiting missed aminsert calls, we're capable of processing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it.&nbsp; Decline to do so, out of an abundance of caution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexRel-&gt;rd_index-&gt;indisvalid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinState&nbsp; &nbsp; ginstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="ginutil.c.html#L97" title="access/gin/ginutil.c:97">initGinState</a>(&amp;ginstate, indexRel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L780" title="access/gin/ginfast.c:780">ginInsertCleanup</a>(&amp;ginstate, <span class="Constant">true</span>, <span class="Constant">true</span>, <span class="Constant">true</span>, &amp;stats);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not valid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(indexRel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(indexRel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT64((int64) stats.pages_deleted);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
