<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/gin/ginget.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/gin/ginget.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L27">GinFuzzySearchLimit</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L29">pendingPosition</a></li>
<li><a href="#L36">pendingPosition</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L121">collectMatchBitmap</a></li>
<li><a href="#L1605">collectMatchesForHeapRow</a></li>
<li><a href="#L808">entryGetItem</a></li>
<li><a href="#L488">entryIndexByFrequencyCmp</a></li>
<li><a href="#L653">entryLoadMoreItems</a></li>
<li><a href="#L1914">gingetbitmap</a></li>
<li><a href="#L990">keyGetItem</a></li>
<li><a href="#L1537">matchPartialInPendingList</a></li>
<li><a href="#L43">moveRightIfItNeeded</a></li>
<li><a href="#L1450">scanGetCandidate</a></li>
<li><a href="#L1285">scanGetItem</a></li>
<li><a href="#L1820">scanPendingInsert</a></li>
<li><a href="#L69">scanPostingTree</a></li>
<li><a href="#L601">startScan</a></li>
<li><a href="#L319">startScanEntry</a></li>
<li><a href="#L505">startScanKey</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L1911">GinIsVoidRes</a></li>
<li><a href="#L792">dropItem</a></li>
<li><a href="#L791">gin_rand</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ginget.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; fetch tuples from a GIN scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src/backend/access/gin/ginget.c<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/gin_private.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/pg_prng.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* GUC parameter */<br/></li>
<li><a id="L27">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">GinFuzzySearchLimit</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><a id="L29">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">pendingPosition</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; pendingBuffer;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber firstOffset;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber lastOffset;<br/></li>
<li>&nbsp; &nbsp; ItemPointerData item;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *hasMatchKey;<br/></li>
<li><a id="L36">&#x200c;</a>} <span class="linkable">pendingPosition</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Goes to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page if current offset is outside of bounds<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L43">&#x200c;</a></span><span class="linkable">moveRightIfItNeeded</span>(GinBtreeData *btree, GinBtreeStack *stack, Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(stack-&gt;buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stack-&gt;off &gt; PageGetMaxOffsetNumber(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We scanned the whole page, so we should take right page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinPageRightMost(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no more pages */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;buffer = <a href="ginbtree.c.html#L177" title="access/gin/ginbtree.c:177">ginStepRight</a>(stack-&gt;buffer, btree-&gt;index, GIN_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;blkno = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(stack-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;off = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L2584" title="storage/lmgr/predicate.c:2584">PredicateLockPage</a>(btree-&gt;index, stack-&gt;blkno, snapshot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Scan all pages of a posting tree and save all its heap ItemPointers<br/></li>
<li></span><span class="Comment"> * in scanEntry-&gt;matchBitmap<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L69">&#x200c;</a></span><span class="linkable">scanPostingTree</span>(Relation index, GinScanEntry scanEntry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber rootPostingTree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GinBtreeData btree;<br/></li>
<li>&nbsp; &nbsp; GinBtreeStack *stack;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Descend to the leftmost leaf page */<br/></li>
<li></span>&nbsp; &nbsp; stack = <a href="gindatapage.c.html#L1936" title="access/gin/gindatapage.c:1936">ginScanBeginPostingTree</a>(&amp;btree, index, rootPostingTree);<br/></li>
<li>&nbsp; &nbsp; buffer = stack-&gt;buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4882" title="storage/buffer/bufmgr.c:4882">IncrBufferRefCount</a>(buffer); <span class="Comment">/* prevent unpin in <a href="ginbtree.c.html#L198" title="access/gin/ginbtree.c:198">freeGinBtreeStack</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="ginbtree.c.html#L198" title="access/gin/ginbtree.c:198">freeGinBtreeStack</a>(stack);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop iterates through all leaf pages of posting tree<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((GinPageGetOpaque(page)-&gt;flags &amp; GIN_DELETED) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = <a href="gindatapage.c.html#L182" title="access/gin/gindatapage.c:182">GinDataLeafPageGetItemsToTbm</a>(page, scanEntry-&gt;matchBitmap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanEntry-&gt;predictNumberResult += n;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinPageRightMost(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no more pages */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="ginbtree.c.html#L177" title="access/gin/ginbtree.c:177">ginStepRight</a>(buffer, index, GIN_SHARE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Collects TIDs into scanEntry-&gt;matchBitmap for all heap tuples that<br/></li>
<li></span><span class="Comment"> * match the search entry.&nbsp; This supports three different match modes:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1. Partial-match support: scan from current point until the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; comparePartialFn says we're done.<br/></li>
<li></span><span class="Comment"> * 2. SEARCH_MODE_ALL: scan from current point (which should be first<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; key for the current attnum) until we hit null items or end of attnum<br/></li>
<li></span><span class="Comment"> * 3. SEARCH_MODE_EVERYTHING: scan from current point (which should be first<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; key for the current attnum) until we hit end of attnum<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if done, false if it's necessary to restart scan from scratch<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L121">&#x200c;</a></span><span class="linkable">collectMatchBitmap</span>(GinBtreeData *btree, GinBtreeStack *stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GinScanEntry scanEntry, Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber attnum;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize empty bitmap result */<br/></li>
<li></span>&nbsp; &nbsp; scanEntry-&gt;matchBitmap = <a href="../../nodes/tidbitmap.c.html#L266" title="nodes/tidbitmap.c:266">tbm_create</a>(<a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> * <span class="Constant">1024L</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Null query cannot partial-match anything */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scanEntry-&gt;isPartialMatch &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scanEntry-&gt;queryCategory != GIN_CAT_NORM_KEY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Locate tupdesc entry for key column (for attbyval/attlen data) */<br/></li>
<li></span>&nbsp; &nbsp; attnum = scanEntry-&gt;attnum;<br/></li>
<li>&nbsp; &nbsp; attr = TupleDescAttr(btree-&gt;ginstate-&gt;origTupdesc, attnum - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Predicate lock entry leaf page, following pages will be locked by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L43" title="access/gin/ginget.c:43">moveRightIfItNeeded</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L2584" title="storage/lmgr/predicate.c:2584">PredicateLockPage</a>(btree-&gt;index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(stack-&gt;buffer),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; idatum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinNullCategory icategory;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stack-&gt;off points to the interested entry, buffer is already locked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L43" title="access/gin/ginget.c:43">moveRightIfItNeeded</a>(btree, stack, snapshot) == <span class="Constant">false</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(stack-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, stack-&gt;off));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If tuple stores another attribute then stop scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="ginutil.c.html#L226" title="access/gin/ginutil.c:226">gintuple_get_attrnum</a>(btree-&gt;ginstate, itup) != attnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Safe to fetch attribute value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; idatum = <a href="ginutil.c.html#L259" title="access/gin/ginutil.c:259">gintuple_get_key</a>(btree-&gt;ginstate, itup, &amp;icategory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for appropriate scan stop conditions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scanEntry-&gt;isPartialMatch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In partial match, stop scan at <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> null (including<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * placeholders); partial matches never match nulls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (icategory != GIN_CAT_NORM_KEY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check of partial match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == 0 =&gt; match<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &gt; 0 =&gt; not match and finish scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &lt; 0 =&gt; not match and continue scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = DatumGetInt32(<a href="../../utils/fmgr/fmgr.c.html#L1196" title="utils/fmgr/fmgr.c:1196">FunctionCall4Coll</a>(&amp;btree-&gt;ginstate-&gt;comparePartialFn[attnum - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; btree-&gt;ginstate-&gt;supportCollation[attnum - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanEntry-&gt;queryKey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idatum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt16GetDatum(scanEntry-&gt;strategy),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(scanEntry-&gt;extra_data)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;off++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (scanEntry-&gt;searchMode == GIN_SEARCH_MODE_ALL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In ALL mode, we are not interested in null items, so we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stop if we get to a null-item placeholder (which will be the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * last entry for a given attnum).&nbsp; We do want to include NULL_KEY<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and EMPTY_ITEM entries, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (icategory == GIN_CAT_NULL_ITEM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OK, we want to return the TIDs listed in this entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinIsPostingTree(itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber rootPostingTree = GinGetPostingTree(itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should unlock current page (but not unpin) during tree scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to prevent deadlock with <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> processes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We save current entry value (idatum) to be able to re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple after re-locking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (icategory == GIN_CAT_NORM_KEY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idatum = <a href="../../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(idatum, attr-&gt;attbyval, attr-&gt;attlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(stack-&gt;buffer, GIN_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Acquire predicate lock on the posting tree.&nbsp; We already hold a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock on the entry page, but insertions to the posting tree<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't check for conflicts on that level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L2584" title="storage/lmgr/predicate.c:2584">PredicateLockPage</a>(btree-&gt;index, rootPostingTree, snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Collect all the TIDs in this entry's posting tree */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L69" title="access/gin/ginget.c:69">scanPostingTree</a>(btree-&gt;index, scanEntry, rootPostingTree);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We lock again the entry page and while it was unlocked insert<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might have occurred, so we need to re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> our position.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(stack-&gt;buffer, GIN_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(stack-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!GinPageIsLeaf(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Root page becomes non-leaf while we unlock it. We will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * start again, this situation doesn't occur often - root can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * became a non-leaf only once per life of index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Search forward to re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> idatum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L43" title="access/gin/ginget.c:43">moveRightIfItNeeded</a>(btree, stack, snapshot) == <span class="Constant">false</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERNAL_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;failed to re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> tuple within index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(btree-&gt;index))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(stack-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, stack-&gt;off));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="ginutil.c.html#L226" title="access/gin/ginutil.c:226">gintuple_get_attrnum</a>(btree-&gt;ginstate, itup) == attnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; newDatum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinNullCategory newCategory;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newDatum = <a href="ginutil.c.html#L259" title="access/gin/ginutil.c:259">gintuple_get_key</a>(btree-&gt;ginstate, itup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;newCategory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="ginutil.c.html#L388" title="access/gin/ginutil.c:388">ginCompareEntries</a>(btree-&gt;ginstate, attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newDatum, newCategory,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idatum, icategory) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; <span class="Comment">/* Found! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;off++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (icategory == GIN_CAT_NORM_KEY &amp;&amp; !attr-&gt;attbyval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(idatum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer ipd;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nipd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ipd = <a href="ginentrypage.c.html#L162" title="access/gin/ginentrypage.c:162">ginReadTuple</a>(btree-&gt;ginstate, scanEntry-&gt;attnum, itup, &amp;nipd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/tidbitmap.c.html#L377" title="nodes/tidbitmap.c:377">tbm_add_tuples</a>(scanEntry-&gt;matchBitmap, ipd, nipd, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanEntry-&gt;predictNumberResult += GinGetNPosting(itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ipd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Done with this entry, go to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;off++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Start* <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> setup beginning state of searches: finds correct buffer and pins it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L319">&#x200c;</a></span><span class="linkable">startScanEntry</span>(GinState *ginstate, GinScanEntry entry, Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GinBtreeData btreeEntry;<br/></li>
<li>&nbsp; &nbsp; GinBtreeStack *stackEntry;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needUnlock;<br/></li>
<li><br/></li>
<li><span class="Statement">restartScanEntry</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; entry-&gt;buffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetMin(&amp;entry-&gt;curItem);<br/></li>
<li>&nbsp; &nbsp; entry-&gt;offset = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;list)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(entry-&gt;list);<br/></li>
<li>&nbsp; &nbsp; entry-&gt;list = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; entry-&gt;nlist = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; entry-&gt;matchBitmap = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; entry-&gt;matchResult = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; entry-&gt;reduceResult = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; entry-&gt;predictNumberResult = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we should <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> entry, and begin scan of posting tree or just store<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * posting list in memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="ginentrypage.c.html#L747" title="access/gin/ginentrypage.c:747">ginPrepareEntryScan</a>(&amp;btreeEntry, entry-&gt;attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;queryKey, entry-&gt;queryCategory,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ginstate);<br/></li>
<li>&nbsp; &nbsp; stackEntry = <a href="ginbtree.c.html#L83" title="access/gin/ginbtree.c:83">ginFindLeafPage</a>(&amp;btreeEntry, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(stackEntry-&gt;buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="ginbtree.c.html#L83" title="access/gin/ginbtree.c:83">ginFindLeafPage</a>() will have already checked snapshot age. */<br/></li>
<li></span>&nbsp; &nbsp; needUnlock = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry-&gt;isFinished = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;isPartialMatch ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;queryCategory == GIN_CAT_EMPTY_QUERY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * btreeEntry.findItem locates the first item &gt;= given search key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (For GIN_CAT_EMPTY_QUERY, it will <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the leftmost index item<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because of the way the GIN_CAT_EMPTY_QUERY category code is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assigned.)&nbsp; We scan forward from there and collect all TIDs needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the entry type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; btreeEntry.findItem(&amp;btreeEntry, stackEntry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L121" title="access/gin/ginget.c:121">collectMatchBitmap</a>(&amp;btreeEntry, stackEntry, entry, snapshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; == <span class="Constant">false</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * GIN tree was seriously restructured, so we will <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * found data and rescan. See comments near 'return false' in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L121" title="access/gin/ginget.c:121">collectMatchBitmap</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;matchBitmap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;matchIterator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/tidbitmap.c.html#L1146" title="nodes/tidbitmap.c:1146">tbm_end_iterate</a>(entry-&gt;matchIterator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;matchIterator = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/tidbitmap.c.html#L322" title="nodes/tidbitmap.c:322">tbm_free</a>(entry-&gt;matchBitmap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;matchBitmap = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(stackEntry-&gt;buffer, GIN_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="ginbtree.c.html#L198" title="access/gin/ginbtree.c:198">freeGinBtreeStack</a>(stackEntry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> restartScanEntry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;matchBitmap &amp;&amp; !<a href="../../nodes/tidbitmap.c.html#L670" title="nodes/tidbitmap.c:670">tbm_is_empty</a>(entry-&gt;matchBitmap))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;matchIterator = <a href="../../nodes/tidbitmap.c.html#L689" title="nodes/tidbitmap.c:689">tbm_begin_iterate</a>(entry-&gt;matchBitmap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;isFinished = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (btreeEntry.findItem(&amp;btreeEntry, stackEntry))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, stackEntry-&gt;off));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinIsPostingTree(itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber rootPostingTree = GinGetPostingTree(itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinBtreeStack *stack;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; entrypage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerData minItem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is an equality scan, so lock the root of the posting tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It represents a lock on the exact key value, and covers all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * items in the posting tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L2584" title="storage/lmgr/predicate.c:2584">PredicateLockPage</a>(ginstate-&gt;index, rootPostingTree, snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should unlock entry page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> touching posting tree to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prevent deadlocks with <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> processes. Because entry is never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deleted from page and posting tree is never reduced to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * posting list, we can unlock page after getting BlockNumber of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * root of posting tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(stackEntry-&gt;buffer, GIN_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needUnlock = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack = <a href="gindatapage.c.html#L1936" title="access/gin/gindatapage.c:1936">ginScanBeginPostingTree</a>(&amp;entry-&gt;btree, ginstate-&gt;index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootPostingTree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;buffer = stack-&gt;buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We keep buffer pinned because we need to prevent deletion of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page during scan. See GIN's <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> implementation. RefCount is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * increased to keep buffer pinned after <a href="ginbtree.c.html#L198" title="access/gin/ginbtree.c:198">freeGinBtreeStack</a>() call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4882" title="storage/buffer/bufmgr.c:4882">IncrBufferRefCount</a>(entry-&gt;buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entrypage = BufferGetPage(entry-&gt;buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Load the first page into memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSetMin(&amp;minItem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;list = <a href="gindatapage.c.html#L135" title="access/gin/gindatapage.c:135">GinDataLeafPageGetItems</a>(entrypage, &amp;entry-&gt;nlist, minItem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;predictNumberResult = stack-&gt;predictNumber * entry-&gt;nlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(entry-&gt;buffer, GIN_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="ginbtree.c.html#L198" title="access/gin/ginbtree.c:198">freeGinBtreeStack</a>(stack);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;isFinished = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lock the entry leaf page.&nbsp; This is more coarse-grained than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * necessary, because it will conflict with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> insertions that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * land on the same leaf page, not only the exact key we searched<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for.&nbsp; But locking an individual tuple would require updating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that lock whenever it moves because of insertions or vacuums,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which seems too complicated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L2584" title="storage/lmgr/predicate.c:2584">PredicateLockPage</a>(ginstate-&gt;index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(stackEntry-&gt;buffer),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinGetNPosting(itup) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;list = <a href="ginentrypage.c.html#L162" title="access/gin/ginentrypage.c:162">ginReadTuple</a>(ginstate, entry-&gt;attnum, itup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;entry-&gt;nlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;predictNumberResult = entry-&gt;nlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;isFinished = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No entry found.&nbsp; Predicate lock the leaf page, to lock the place<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * where the entry would've been, had there been one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L2584" title="storage/lmgr/predicate.c:2584">PredicateLockPage</a>(ginstate-&gt;index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(stackEntry-&gt;buffer), snapshot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (needUnlock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(stackEntry-&gt;buffer, GIN_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; <a href="ginbtree.c.html#L198" title="access/gin/ginbtree.c:198">freeGinBtreeStack</a>(stackEntry);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Comparison function for scan entry indexes. Sorts by predictNumberResult,<br/></li>
<li></span><span class="Comment"> * least frequent items first.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L488">&#x200c;</a></span><span class="linkable">entryIndexByFrequencyCmp</span>(<span class="Type">const</span> <span class="Type">void</span> *<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>, <span class="Type">const</span> <span class="Type">void</span> *<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> GinScanKey key = (<span class="Type">const</span> GinScanKey) arg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i1 = *(<span class="Type">const</span> <span class="Type">int</span> *) <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2 = *(<span class="Type">const</span> <span class="Type">int</span> *) <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; n1 = key-&gt;scanEntry[i1]-&gt;predictNumberResult;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; n2 = key-&gt;scanEntry[i2]-&gt;predictNumberResult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n1 &lt; n2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (n1 == n2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L505">&#x200c;</a></span><span class="linkable">startScanKey</span>(GinState *ginstate, GinScanOpaque so, GinScanKey key)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldCtx = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *entryIndexes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ItemPointerSetMin(&amp;key-&gt;curItem);<br/></li>
<li>&nbsp; &nbsp; key-&gt;curItemMatches = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; key-&gt;recheckCurItem = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; key-&gt;isFinished = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Divide the entries into two distinct sets: required and additional.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Additional entries are not enough for a match alone, without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> items<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the required set, but are needed by the consistent function to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decide if an item matches. When scanning, we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over items from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * additional entries that have no corresponding matches in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * required entries. That speeds up queries like &quot;frequent &amp; rare&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * considerably, if the frequent term can be put in the additional set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There can be many legal ways to divide them entries into these two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sets. A conservative division is to just put everything in the required<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set, but the more you can put in the additional set, the more you can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> during the scan. To maximize skipping, we try to put as many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * frequent items as possible into additional, and less frequent ones into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * required. To do that, sort the entries by frequency<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (predictNumberResult), and put entries into the required set in that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * order, until the consistent function says that <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the remaining<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries can form a match, without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> items from the required set. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rest go to the additional set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Exclude-only scan keys are known to have no required entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;excludeOnly)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(so-&gt;keyCtx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;nrequired = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;nadditional = key-&gt;nentries;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;additionalEntries = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(key-&gt;nadditional * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinScanEntry));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; key-&gt;nadditional; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;additionalEntries[i] = key-&gt;scanEntry[i];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (key-&gt;nentries &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(so-&gt;tempCtx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entryIndexes = (<span class="Type">int</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * key-&gt;nentries);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; key-&gt;nentries; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entryIndexes[i] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qsort_arg(entryIndexes, key-&gt;nentries, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L488" title="access/gin/ginget.c:488">entryIndexByFrequencyCmp</a>, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; key-&gt;nentries - <span class="Constant">1</span>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Pass all entries &lt;= i as FALSE, and the rest as MAYBE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt;= i; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;entryRes[entryIndexes[j]] = GIN_FALSE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = i + <span class="Constant">1</span>; j &lt; key-&gt;nentries; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;entryRes[entryIndexes[j]] = GIN_MAYBE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;triConsistentFn(key) == GIN_FALSE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* i is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> the last required entry. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(so-&gt;keyCtx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;nrequired = i + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;nadditional = key-&gt;nentries - key-&gt;nrequired;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;requiredEntries = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(key-&gt;nrequired * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinScanEntry));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;additionalEntries = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(key-&gt;nadditional * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinScanEntry));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; j = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; key-&gt;nrequired; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;requiredEntries[i] = key-&gt;scanEntry[entryIndexes[j++]];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; key-&gt;nadditional; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;additionalEntries[i] = key-&gt;scanEntry[entryIndexes[j++]];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* clean up after consistentFn calls (also frees entryIndexes) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(so-&gt;tempCtx);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(so-&gt;keyCtx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;nrequired = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;nadditional = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;requiredEntries = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Constant">1</span> * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GinScanEntry));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;requiredEntries[<span class="Constant">0</span>] = key-&gt;scanEntry[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldCtx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L601">&#x200c;</a></span><span class="linkable">startScan</span>(IndexScanDesc scan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GinScanOpaque so = (GinScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; GinState&nbsp;&nbsp; *ginstate = &amp;so-&gt;ginstate;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; so-&gt;totalentries; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L319" title="access/gin/ginget.c:319">startScanEntry</a>(ginstate, so-&gt;entries[i], scan-&gt;xs_snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L27" title="access/gin/ginget.c:27">GinFuzzySearchLimit</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If all of keys more than threshold we will try to reduce result, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hope (and only hope, for intersection operation of array our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * supposition isn't true), that total result will not more than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * minimal predictNumberResult.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; reduce = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; so-&gt;totalentries; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;entries[i]-&gt;predictNumberResult &lt;= so-&gt;totalentries * <a href="#L27" title="access/gin/ginget.c:27">GinFuzzySearchLimit</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reduce = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reduce)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; so-&gt;totalentries; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;entries[i]-&gt;predictNumberResult /= so-&gt;totalentries;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;entries[i]-&gt;reduceResult = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we have the estimates for the entry frequencies, finish<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initializing the scan keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; so-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L505" title="access/gin/ginget.c:505">startScanKey</a>(ginstate, so, so-&gt;keys + i);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Load the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> batch of item pointers from a posting tree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we copy the page into GinScanEntry-&gt;list array and unlock it, but<br/></li>
<li></span><span class="Comment"> * keep it pinned to prevent interference with <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L653">&#x200c;</a></span><span class="linkable">entryLoadMoreItems</span>(GinState *ginstate, GinScanEntry entry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerData advancePast)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; stepright;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(entry-&gt;buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;isFinished = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have two strategies for finding the correct page: step right from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the current page, or descend the tree again from the root. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * advancePast equals the current item, the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> matching item should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page, so we step right. Otherwise, descend from root.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ginCompareItemPointers(&amp;entry-&gt;curItem, &amp;advancePast) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stepright = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(entry-&gt;buffer, GIN_SHARE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinBtreeStack *stack;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(entry-&gt;buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set the search key, and <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the correct leaf page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemPointerIsLossyPage(&amp;advancePast))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSet(&amp;entry-&gt;btree.itemptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GinItemPointerGetBlockNumber(&amp;advancePast) + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FirstOffsetNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSet(&amp;entry-&gt;btree.itemptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GinItemPointerGetBlockNumber(&amp;advancePast),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumberNext(GinItemPointerGetOffsetNumber(&amp;advancePast)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;btree.fullScan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stack = <a href="ginbtree.c.html#L83" title="access/gin/ginbtree.c:83">ginFindLeafPage</a>(&amp;entry-&gt;btree, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we don't need the stack, just the buffer. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;buffer = stack-&gt;buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4882" title="storage/buffer/bufmgr.c:4882">IncrBufferRefCount</a>(entry-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="ginbtree.c.html#L198" title="access/gin/ginbtree.c:198">freeGinBtreeStack</a>(stack);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stepright = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;<a href="#L653" title="access/gin/ginget.c:653">entryLoadMoreItems</a>, </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GinItemPointerGetBlockNumber(&amp;advancePast),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GinItemPointerGetOffsetNumber(&amp;advancePast),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !stepright);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(entry-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;offset = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;list)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(entry-&gt;list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;list = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;nlist = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stepright)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've processed all the entries on this page. If it was the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * last page in the tree, we're done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinPageRightMost(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(entry-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;buffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;isFinished = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Step to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page, following the right link. then <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first ItemPointer greater than advancePast.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;buffer = <a href="ginbtree.c.html#L177" title="access/gin/ginbtree.c:177">ginStepRight</a>(entry-&gt;buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ginstate-&gt;index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GIN_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(entry-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stepright = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinPageGetOpaque(page)-&gt;flags &amp; GIN_DELETED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* page was deleted by concurrent <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The first item &gt; advancePast might not be on this page, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * somewhere to the right, if the page was split, or a non-match from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * another key in the query allowed us to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> some items from this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry. Keep following the right-links until we re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!GinPageRightMost(page) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ginCompareItemPointers(&amp;advancePast, GinDataPageGetRightBound(page)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the item we're looking is &gt; the right bound of the page, so it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't be on this page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;list = <a href="gindatapage.c.html#L135" title="access/gin/gindatapage.c:135">GinDataLeafPageGetItems</a>(page, &amp;entry-&gt;nlist, advancePast);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; entry-&gt;nlist; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ginCompareItemPointers(&amp;advancePast, &amp;entry-&gt;list[i]) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;offset = i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinPageRightMost(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* after processing the copied items, we're done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(entry-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;buffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(entry-&gt;buffer, GIN_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L791">&#x200c;</a><span class="PreProc">#define <span class="linkable">gin_rand</span>() pg_prng_double(&amp;pg_global_prng_state)<br/></li>
<li><a id="L792">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">dropItem</span>(e) ( <a href="#L791" title="access/gin/ginget.c:791">gin_rand</a>() &gt; ((</span><span class="Type">double</span><span class="PreProc">)<a href="#L27" title="access/gin/ginget.c:27">GinFuzzySearchLimit</a>)/((</span><span class="Type">double</span><span class="PreProc">)((e)-&gt;predictNumberResult)) )<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sets entry-&gt;curItem to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> heap item pointer &gt; advancePast, for one entry<br/></li>
<li></span><span class="Comment"> * of one scan key, or sets entry-&gt;isFinished to true if there are no more.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Item pointers are returned in ascending order.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this can return a &quot;lossy page&quot; item pointer, indicating that the<br/></li>
<li></span><span class="Comment"> * entry potentially matches all items on that heap page.&nbsp; However, it is<br/></li>
<li></span><span class="Comment"> * not allowed to return both a lossy page pointer and exact (regular)<br/></li>
<li></span><span class="Comment"> * item pointers for the same page.&nbsp; (Doing so would break the key-combination<br/></li>
<li></span><span class="Comment"> * logic in <a href="#L990" title="access/gin/ginget.c:990">keyGetItem</a> and <a href="#L1285" title="access/gin/ginget.c:1285">scanGetItem</a>; see comment in <a href="#L1285" title="access/gin/ginget.c:1285">scanGetItem</a>.)&nbsp; In the<br/></li>
<li></span><span class="Comment"> * current implementation this is guaranteed by the behavior of tidbitmaps.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L808">&#x200c;</a></span><span class="linkable">entryGetItem</span>(GinState *ginstate, GinScanEntry entry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerData advancePast)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!entry-&gt;isFinished);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ItemPointerIsValid(&amp;entry-&gt;curItem) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ginCompareItemPointers(&amp;entry-&gt;curItem, &amp;advancePast) &lt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;matchBitmap)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A bitmap result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber advancePastBlk = GinItemPointerGetBlockNumber(&amp;advancePast);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber advancePastOff = GinItemPointerGetOffsetNumber(&amp;advancePast);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we've exhausted all items on this block, move to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the bitmap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (entry-&gt;matchResult == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (entry-&gt;matchResult-&gt;ntuples &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;offset &gt;= entry-&gt;matchResult-&gt;ntuples) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; entry-&gt;matchResult-&gt;blockno &lt; advancePastBlk ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (ItemPointerIsLossyPage(&amp;advancePast) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;matchResult-&gt;blockno == advancePastBlk))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;matchResult = <a href="../../nodes/tidbitmap.c.html#L971" title="nodes/tidbitmap.c:971">tbm_iterate</a>(entry-&gt;matchIterator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;matchResult == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSetInvalid(&amp;entry-&gt;curItem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/tidbitmap.c.html#L1146" title="nodes/tidbitmap.c:1146">tbm_end_iterate</a>(entry-&gt;matchIterator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;matchIterator = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;isFinished = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset counter to the beginning of entry-&gt;matchResult. Note:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry-&gt;offset is still greater than matchResult-&gt;ntuples if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matchResult is lossy.&nbsp; So, on <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call we will get <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result from <a href="../../nodes/tidbitmap.c.html#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;isFinished)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> on the first page after advancePast which has <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * items on it. If it's a lossy result, return that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;matchResult-&gt;ntuples &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSetLossyPage(&amp;entry-&gt;curItem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;matchResult-&gt;blockno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We might as well fall out of the loop; we could not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * estimate number of results on this page to support correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reducing of result even if it's enabled.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Not a lossy page. Skip over <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> offsets &lt;= advancePast, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * return that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;matchResult-&gt;blockno == advancePastBlk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First, do a quick check against the last offset on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page. If that's &gt; advancePast, so are all the other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * offsets, so just go back to the top to get the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;matchResult-&gt;offsets[entry-&gt;matchResult-&gt;ntuples - <span class="Constant">1</span>] &lt;= advancePastOff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;offset = entry-&gt;matchResult-&gt;ntuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise scan to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the first item &gt; advancePast */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (entry-&gt;matchResult-&gt;offsets[entry-&gt;offset] &lt;= advancePastOff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;offset++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSet(&amp;entry-&gt;curItem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; entry-&gt;matchResult-&gt;blockno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; entry-&gt;matchResult-&gt;offsets[entry-&gt;offset]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;offset++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done unless we need to reduce the result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!entry-&gt;reduceResult || !<a href="#L792" title="access/gin/ginget.c:792">dropItem</a>(entry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!BufferIsValid(entry-&gt;buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A posting list from an entry tuple, or the last page of a posting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;offset &gt;= entry-&gt;nlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSetInvalid(&amp;entry-&gt;curItem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;isFinished = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;curItem = entry-&gt;list[entry-&gt;offset++];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we're not past advancePast, keep scanning */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ginCompareItemPointers(&amp;entry-&gt;curItem, &amp;advancePast) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done unless we need to reduce the result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!entry-&gt;reduceResult || !<a href="#L792" title="access/gin/ginget.c:792">dropItem</a>(entry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A posting tree */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we've processed the current batch, load more items */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (entry-&gt;offset &gt;= entry-&gt;nlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L653" title="access/gin/ginget.c:653">entryLoadMoreItems</a>(ginstate, entry, advancePast);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;isFinished)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSetInvalid(&amp;entry-&gt;curItem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;curItem = entry-&gt;list[entry-&gt;offset++];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we're not past advancePast, keep scanning */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ginCompareItemPointers(&amp;entry-&gt;curItem, &amp;advancePast) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done unless we need to reduce the result */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!entry-&gt;reduceResult || !<a href="#L792" title="access/gin/ginget.c:792">dropItem</a>(entry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Advance advancePast (so that <a href="#L653" title="access/gin/ginget.c:653">entryLoadMoreItems</a> will load the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * right data), and keep scanning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; advancePast = entry-&gt;curItem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Identify the &quot;current&quot; item among the input entry streams for this scan key<br/></li>
<li></span><span class="Comment"> * that is greater than advancePast, and test whether it passes the scan key<br/></li>
<li></span><span class="Comment"> * qual condition.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The current item is the smallest curItem among the inputs.&nbsp; key-&gt;curItem<br/></li>
<li></span><span class="Comment"> * is set to that value.&nbsp; key-&gt;curItemMatches is set to indicate whether that<br/></li>
<li></span><span class="Comment"> * TID passes the consistentFn test.&nbsp; If so, key-&gt;recheckCurItem is set true<br/></li>
<li></span><span class="Comment"> * iff recheck is needed for this item pointer (including the case where the<br/></li>
<li></span><span class="Comment"> * item pointer is a lossy page pointer).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If all entry streams are exhausted, sets key-&gt;isFinished to true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Item pointers must be returned in ascending order.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this can return a &quot;lossy page&quot; item pointer, indicating that the<br/></li>
<li></span><span class="Comment"> * key potentially matches all items on that heap page.&nbsp; However, it is<br/></li>
<li></span><span class="Comment"> * not allowed to return both a lossy page pointer and exact (regular)<br/></li>
<li></span><span class="Comment"> * item pointers for the same page.&nbsp; (Doing so would break the key-combination<br/></li>
<li></span><span class="Comment"> * logic in <a href="#L1285" title="access/gin/ginget.c:1285">scanGetItem</a>.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L990">&#x200c;</a></span><span class="linkable">keyGetItem</span>(GinState *ginstate, MemoryContext tempCtx, GinScanKey key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerData advancePast)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ItemPointerData minItem;<br/></li>
<li>&nbsp; &nbsp; ItemPointerData curPageLossy;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; haveLossyEntry;<br/></li>
<li>&nbsp; &nbsp; GinScanEntry entry;<br/></li>
<li>&nbsp; &nbsp; GinTernaryValue res;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldCtx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; allFinished;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!key-&gt;isFinished);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We might have already tested this item; if so, no need to <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note: the &quot;&gt;&quot; case can happen, if advancePast is exact but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previously had to set curItem to a lossy-page pointer.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ginCompareItemPointers(&amp;key-&gt;curItem, &amp;advancePast) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find the minimum item &gt; advancePast among the active entry streams.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: a lossy-page entry is encoded by a ItemPointer with max value for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * offset (0xffff), so that it will sort after <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> exact entries for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same page.&nbsp; So we'll prefer to return exact pointers not lossy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointers, which is good.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ItemPointerSetMax(&amp;minItem);<br/></li>
<li>&nbsp; &nbsp; allFinished = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; key-&gt;nrequired; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry = key-&gt;requiredEntries[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;isFinished)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Advance this stream if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In particular, since entry-&gt;curItem was initialized with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ItemPointerSetMin, this ensures we fetch the first item for each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry on the first call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ginCompareItemPointers(&amp;entry-&gt;curItem, &amp;advancePast) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L808" title="access/gin/ginget.c:808">entryGetItem</a>(ginstate, entry, advancePast);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;isFinished)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; allFinished = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ginCompareItemPointers(&amp;entry-&gt;curItem, &amp;minItem) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minItem = entry-&gt;curItem;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (allFinished &amp;&amp; !key-&gt;excludeOnly)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all entries are finished */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;isFinished = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!key-&gt;excludeOnly)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For a normal scan key, we <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> know there are no matches &lt; minItem.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If minItem is lossy, it means that there were no exact items on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page among requiredEntries, because lossy pointers sort after exact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * items. However, there might be exact items for the same page among<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * additionalEntries, so we mustn't advance past them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemPointerIsLossyPage(&amp;minItem))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinItemPointerGetBlockNumber(&amp;advancePast) &lt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinItemPointerGetBlockNumber(&amp;minItem))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSet(&amp;advancePast,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GinItemPointerGetBlockNumber(&amp;minItem),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOffsetNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(GinItemPointerGetOffsetNumber(&amp;minItem) &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSet(&amp;advancePast,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GinItemPointerGetBlockNumber(&amp;minItem),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumberPrev(GinItemPointerGetOffsetNumber(&amp;minItem)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * excludeOnly scan keys don't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> entries that are necessarily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * present in matching items.&nbsp; So, we consider the item just after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * advancePast.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(key-&gt;nrequired == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSet(&amp;minItem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GinItemPointerGetBlockNumber(&amp;advancePast),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumberNext(GinItemPointerGetOffsetNumber(&amp;advancePast)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We might not have loaded all the entry streams for this TID yet. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could call the consistent function, passing MAYBE for those entries, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * see if it can decide if this TID matches based on the information we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have. But if the consistent-function is expensive, and cannot in fact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decide with partial information, that could be a big loss. So, load all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the additional entries, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling the consistent function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; key-&gt;nadditional; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry = key-&gt;additionalEntries[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;isFinished)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ginCompareItemPointers(&amp;entry-&gt;curItem, &amp;advancePast) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L808" title="access/gin/ginget.c:808">entryGetItem</a>(ginstate, entry, advancePast);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;isFinished)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normally, <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the items in additionalEntries can have a curItem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * larger than minItem. But if minItem is a lossy page, then there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might be exact items on the same page among additionalEntries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ginCompareItemPointers(&amp;entry-&gt;curItem, &amp;minItem) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemPointerIsLossyPage(&amp;minItem));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minItem = entry-&gt;curItem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ok, we've advanced all the entries up to minItem <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. Set key-&gt;curItem,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and perform consistentFn test.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lossy-page entries pose a problem, since we don't know the correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entryRes state to pass to the consistentFn, and we also don't know what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its combining logic will be (could be AND, OR, or even NOT). If the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * logic is OR then the consistentFn might succeed for all items in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lossy page even when <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the other entries match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Our strategy is to call the tri-state consistent function, with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lossy-page entries set to MAYBE, and all the other entries FALSE. If it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * returns FALSE, <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the lossy items alone are enough for a match, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we don't need to return a lossy-page pointer. Otherwise, return a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lossy-page pointer to indicate that the whole heap page must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checked.&nbsp; (On subsequent calls, we'll do nothing until minItem is past<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the page altogether, thus ensuring that we never return both regular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and lossy pointers for the same page.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * An exception is that it doesn't matter what we pass for lossy pointers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in &quot;hidden&quot; entries, because the consistentFn's result can't depend on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them. We could pass them as MAYBE as well, but if we're using the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;shim&quot; implementation of a tri-state consistent function (see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ginlogic.c), it's better to pass as few MAYBEs as possible. So pass<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them as true.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that only lossy-page entries pointing to the current item's page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> this processing; we might have future lossy pages in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entry array, but they aren't relevant yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; key-&gt;curItem = minItem;<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetLossyPage(&amp;curPageLossy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinItemPointerGetBlockNumber(&amp;key-&gt;curItem));<br/></li>
<li>&nbsp; &nbsp; haveLossyEntry = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; key-&gt;nentries; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry = key-&gt;scanEntry[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;isFinished == <span class="Constant">false</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ginCompareItemPointers(&amp;entry-&gt;curItem, &amp;curPageLossy) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; key-&gt;nuserentries)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;entryRes[i] = GIN_MAYBE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;entryRes[i] = GIN_TRUE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haveLossyEntry = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;entryRes[i] = GIN_FALSE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prepare for calling consistentFn in temp context */<br/></li>
<li></span>&nbsp; &nbsp; oldCtx = MemoryContextSwitchTo(tempCtx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (haveLossyEntry)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Have lossy-page entries, so see if whole page matches */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res = key-&gt;triConsistentFn(key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res == GIN_TRUE || res == GIN_MAYBE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Yes, so clean up ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldCtx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(tempCtx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and return lossy pointer for whole page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;curItem = curPageLossy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;curItemMatches = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;recheckCurItem = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point we know that we don't need to return a lossy whole-page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointer, but we might have matches for individual exact item pointers,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibly in combination with a lossy pointer. Pass lossy pointers as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MAYBE to the ternary consistent function, to let it decide if this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple satisfies the overall key, even though we don't know if the lossy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare entryRes array to be passed to consistentFn.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; key-&gt;nentries; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry = key-&gt;scanEntry[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;isFinished)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;entryRes[i] = GIN_FALSE;<br/></li>
<li><span class="PreProc">#if 0<br/></li>
<li></span><br/></li>
<li><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; /*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This case can't currently happen, because we loaded all the entries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for this item earlier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; else if (ginCompareItemPointers(&amp;entry-&gt;curItem, &amp;advancePast) &lt;= 0)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;entryRes[i] = GIN_MAYBE;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ginCompareItemPointers(&amp;entry-&gt;curItem, &amp;curPageLossy) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;entryRes[i] = GIN_MAYBE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ginCompareItemPointers(&amp;entry-&gt;curItem, &amp;minItem) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;entryRes[i] = GIN_TRUE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;entryRes[i] = GIN_FALSE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = key-&gt;triConsistentFn(key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (res)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> GIN_TRUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;curItemMatches = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* triConsistentFn set recheckCurItem */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> GIN_FALSE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;curItemMatches = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> GIN_MAYBE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;curItemMatches = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;recheckCurItem = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the 'default' case shouldn't happen, but if the consistent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function returns something bogus, this is the safe result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;curItemMatches = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;recheckCurItem = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have a tuple, and we know if it matches or not. If it's a non-match,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we could continue to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> matching tuple, but let's break out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and give <a href="#L1285" title="access/gin/ginget.c:1285">scanGetItem</a> a chance to advance the other keys. They might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * able to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> past to a much higher TID, allowing us to save work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clean up after consistentFn calls */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldCtx);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(tempCtx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> heap item pointer (after advancePast) from scan.<br/></li>
<li></span><span class="Comment"> * Returns true if anything found.<br/></li>
<li></span><span class="Comment"> * On success, *item and *recheck are set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is very nearly the same logic as in <a href="#L990" title="access/gin/ginget.c:990">keyGetItem</a>(), except<br/></li>
<li></span><span class="Comment"> * that we know the keys are to be combined with AND logic, whereas in<br/></li>
<li></span><span class="Comment"> * <a href="#L990" title="access/gin/ginget.c:990">keyGetItem</a>() the combination logic is known only to the consistentFn.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1285">&#x200c;</a></span><span class="linkable">scanGetItem</span>(IndexScanDesc scan, ItemPointerData advancePast,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerData *item, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *recheck)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GinScanOpaque so = (GinScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; match;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advance the scan keys in lock-step, until we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an item that matches<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all the keys. If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> key reports isFinished, meaning its <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries is exhausted, we can stop.&nbsp; Otherwise, set *item to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matching item.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This logic works only if a <a href="#L990" title="access/gin/ginget.c:990">keyGetItem</a> stream can never contain both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exact and lossy pointers for the same page.&nbsp; Else we could have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; stream 1&nbsp; &nbsp; &nbsp; &nbsp; stream 2<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; ...&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; 42/6&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 42/7<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; 50/1&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 42/0xffff<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; ...&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We would conclude that 42/6 is not a match and advance stream 1,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * thus never detecting the match to the lossy pointer in stream 2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (<a href="#L990" title="access/gin/ginget.c:990">keyGetItem</a> has a similar problem versus <a href="#L808" title="access/gin/ginget.c:808">entryGetItem</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSetMin(item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; match = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; so-&gt;nkeys &amp;&amp; match; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinScanKey&nbsp; &nbsp; key = so-&gt;keys + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're considering a lossy page, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> excludeOnly keys. They<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't exclude the whole page anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemPointerIsLossyPage(item) &amp;&amp; key-&gt;excludeOnly)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="ginscan.c.html#L263" title="access/gin/ginscan.c:263">ginNewScanKey</a>() should never mark the first key as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * excludeOnly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(i &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> item for this key that is &gt; advancePast. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L990" title="access/gin/ginget.c:990">keyGetItem</a>(&amp;so-&gt;ginstate, so-&gt;tempCtx, key, advancePast);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;isFinished)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's not a match, we can immediately conclude that nothing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &lt;= this item matches, without checking the rest of the keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!key-&gt;curItemMatches)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; advancePast = key-&gt;curItem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's a match. We can conclude that nothing &lt; matches, so the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other key streams can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> to this item.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Beware of lossy pointers, though; from a lossy pointer, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only conclude that nothing smaller than this *block* matches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemPointerIsLossyPage(&amp;key-&gt;curItem))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinItemPointerGetBlockNumber(&amp;advancePast) &lt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinItemPointerGetBlockNumber(&amp;key-&gt;curItem))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSet(&amp;advancePast,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GinItemPointerGetBlockNumber(&amp;key-&gt;curItem),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOffsetNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(GinItemPointerGetOffsetNumber(&amp;key-&gt;curItem) &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSet(&amp;advancePast,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GinItemPointerGetBlockNumber(&amp;key-&gt;curItem),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumberPrev(GinItemPointerGetOffsetNumber(&amp;key-&gt;curItem)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is the first key, remember this location as a potential<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * match, and proceed to check the rest of the keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, check if this is the same item that we checked the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previous keys for (or a lossy pointer for the same page). If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not, loop back to check the previous keys for this item (we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will check this key again too, but <a href="#L990" title="access/gin/ginget.c:990">keyGetItem</a> returns quickly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for that)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *item = key-&gt;curItem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemPointerIsLossyPage(&amp;key-&gt;curItem) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerIsLossyPage(item))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(GinItemPointerGetBlockNumber(&amp;key-&gt;curItem) &gt;= GinItemPointerGetBlockNumber(item));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match = (GinItemPointerGetBlockNumber(&amp;key-&gt;curItem) ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GinItemPointerGetBlockNumber(item));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ginCompareItemPointers(&amp;key-&gt;curItem, item) &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match = (ginCompareItemPointers(&amp;key-&gt;curItem, item) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (!match);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!ItemPointerIsMin(item));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now *item contains the first ItemPointer after previous result that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * satisfied all the keys for that exact TID, or a lossy reference to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must return recheck = true if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the keys are marked recheck.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *recheck = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; so-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinScanKey&nbsp; &nbsp; key = so-&gt;keys + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;recheckCurItem)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *recheck = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Functions for scanning the pending list<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get ItemPointer of <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> heap row to be checked from pending list.<br/></li>
<li></span><span class="Comment"> * Returns false if there are no more. On pages with several heap rows<br/></li>
<li></span><span class="Comment"> * it returns each row separately, on page with part of heap row returns<br/></li>
<li></span><span class="Comment"> * per page data.&nbsp; pos-&gt;firstOffset and pos-&gt;lastOffset are set to identify<br/></li>
<li></span><span class="Comment"> * the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of pending-list tuples belonging to this heap row.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The pendingBuffer is presumed pinned and share-locked on entry, and is<br/></li>
<li></span><span class="Comment"> * pinned and share-locked on success exit.&nbsp; On failure exit it's released.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1450">&#x200c;</a></span><span class="linkable">scanGetCandidate</span>(IndexScanDesc scan, <a href="#L29" title="access/gin/ginget.c:29">pendingPosition</a> *pos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber maxoff;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;pos-&gt;item);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(pos-&gt;pendingBuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos-&gt;firstOffset &gt; maxoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno = GinPageGetOpaque(page)-&gt;rightlink;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(pos-&gt;pendingBuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos-&gt;pendingBuffer = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here we must prevent deletion of <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page by insertcleanup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process, which may be trying to obtain exclusive lock on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current page.&nbsp; So, we lock <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/walsender.c.html#L170" title="replication/walsender.c:170">tmpbuf</a> = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(scan-&gt;indexRelation, blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(<a href="../../replication/walsender.c.html#L170" title="replication/walsender.c:170">tmpbuf</a>, GIN_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(pos-&gt;pendingBuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos-&gt;pendingBuffer = <a href="../../replication/walsender.c.html#L170" title="replication/walsender.c:170">tmpbuf</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos-&gt;firstOffset = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, pos-&gt;firstOffset));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos-&gt;item = itup-&gt;t_tid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinPageHasFullRow(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> itempointer to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> row<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (pos-&gt;lastOffset = pos-&gt;firstOffset + <span class="Constant">1</span>; pos-&gt;lastOffset &lt;= maxoff; pos-&gt;lastOffset++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, pos-&gt;lastOffset));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;pos-&gt;item, &amp;itup-&gt;t_tid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All itempointers are the same on this page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos-&gt;lastOffset = maxoff + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now pos-&gt;firstOffset points to the first tuple of current heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * row, pos-&gt;lastOffset points to the first tuple of <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> heap row<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (or to the end of page)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Scan pending-list page from current tuple (off) up till the first of:<br/></li>
<li></span><span class="Comment"> * - match is found (then returns true)<br/></li>
<li></span><span class="Comment"> * - no later match is possible<br/></li>
<li></span><span class="Comment"> * - tuple's attribute number is not <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to entry's attrnum<br/></li>
<li></span><span class="Comment"> * - reach end of page<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * datum[]/category[]/datumExtracted[] arrays are used to cache the results<br/></li>
<li></span><span class="Comment"> * of <a href="ginutil.c.html#L259" title="access/gin/ginutil.c:259">gintuple_get_key</a>() on the current page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1537">&#x200c;</a></span><span class="linkable">matchPartialInPendingList</span>(GinState *ginstate, Page page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber off, OffsetNumber maxoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinScanEntry entry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *datum, GinNullCategory *category,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *datumExtracted)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Partial match to a null is not possible */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;queryCategory != GIN_CAT_NORM_KEY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (off &lt; maxoff)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, off));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="ginutil.c.html#L226" title="access/gin/ginutil.c:226">gintuple_get_attrnum</a>(ginstate, itup) != entry-&gt;attnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (datumExtracted[off - <span class="Constant">1</span>] == <span class="Constant">false</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum[off - <span class="Constant">1</span>] = <a href="ginutil.c.html#L259" title="access/gin/ginutil.c:259">gintuple_get_key</a>(ginstate, itup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;category[off - <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datumExtracted[off - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Once we hit nulls, no further match is possible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (category[off - <span class="Constant">1</span>] != GIN_CAT_NORM_KEY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check partial match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == 0 =&gt; match<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &gt; 0 =&gt; not match and end scan (no later match possible)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &lt; 0 =&gt; not match and continue scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = DatumGetInt32(<a href="../../utils/fmgr/fmgr.c.html#L1196" title="utils/fmgr/fmgr.c:1196">FunctionCall4Coll</a>(&amp;ginstate-&gt;comparePartialFn[entry-&gt;attnum - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ginstate-&gt;supportCollation[entry-&gt;attnum - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;queryKey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum[off - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UInt16GetDatum(entry-&gt;strategy),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(entry-&gt;extra_data)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; off++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set up the entryRes array for each key by looking at<br/></li>
<li></span><span class="Comment"> * every entry for current heap row in pending list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if each scan key has at least one entryRes match.<br/></li>
<li></span><span class="Comment"> * This corresponds to the situations where the normal index search will<br/></li>
<li></span><span class="Comment"> * try to apply the key's consistentFn.&nbsp; (A tuple not meeting that requirement<br/></li>
<li></span><span class="Comment"> * cannot be returned by the normal search since no entry stream will<br/></li>
<li></span><span class="Comment"> * source its TID.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The pendingBuffer is presumed pinned and share-locked on entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1605">&#x200c;</a></span><span class="linkable">collectMatchesForHeapRow</span>(IndexScanDesc scan, <a href="#L29" title="access/gin/ginget.c:29">pendingPosition</a> *pos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GinScanOpaque so = (GinScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber attrnum;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset all entryRes and hasMatchKey flags<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; so-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinScanKey&nbsp; &nbsp; key = so-&gt;keys + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(key-&gt;entryRes, GIN_FALSE, key-&gt;nentries);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; memset(pos-&gt;hasMatchKey, <span class="Constant">false</span>, so-&gt;nkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Outer loop iterates over multiple pending-list pages when a single heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * row has entries spanning those pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum[BLCKSZ / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData)];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GinNullCategory category[BLCKSZ / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData)];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; datumExtracted[BLCKSZ / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData)];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(pos-&gt;lastOffset &gt; pos-&gt;firstOffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(datumExtracted + pos-&gt;firstOffset - <span class="Constant">1</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * (pos-&gt;lastOffset - pos-&gt;firstOffset));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(pos-&gt;pendingBuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; so-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinScanKey&nbsp; &nbsp; key = so-&gt;keys + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; key-&gt;nentries; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinScanEntry entry = key-&gt;scanEntry[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber StopLow = pos-&gt;firstOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StopHigh = pos-&gt;lastOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StopMiddle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If already matched on earlier page, do no extra work */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;entryRes[j])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Interesting tuples are from pos-&gt;firstOffset to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pos-&gt;lastOffset and they are ordered by (attnum, Datum) as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's done in entry tree.&nbsp; So we can use binary search to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * avoid linear scanning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (StopLow &lt; StopHigh)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StopMiddle = StopLow + ((StopHigh - StopLow) &gt;&gt; <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, StopMiddle));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrnum = <a href="ginutil.c.html#L226" title="access/gin/ginutil.c:226">gintuple_get_attrnum</a>(&amp;so-&gt;ginstate, itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;attnum &lt; attrnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StopHigh = StopMiddle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;attnum &gt; attrnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StopLow = StopMiddle + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (datumExtracted[StopMiddle - <span class="Constant">1</span>] == <span class="Constant">false</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum[StopMiddle - <span class="Constant">1</span>] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="ginutil.c.html#L259" title="access/gin/ginutil.c:259">gintuple_get_key</a>(&amp;so-&gt;ginstate, itup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;category[StopMiddle - <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datumExtracted[StopMiddle - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;queryCategory == GIN_CAT_EMPTY_QUERY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* special behavior depending on searchMode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;searchMode == GIN_SEARCH_MODE_ALL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* match anything except NULL_ITEM */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (category[StopMiddle - <span class="Constant">1</span>] == GIN_CAT_NULL_ITEM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* match everything */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="ginutil.c.html#L388" title="access/gin/ginutil.c:388">ginCompareEntries</a>(&amp;so-&gt;ginstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;queryKey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;queryCategory,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum[StopMiddle - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; category[StopMiddle - <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Found exact match (there can be only one, except in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * EMPTY_QUERY mode).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If doing partial match, scan forward from here to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end of page to check for matches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See comment above about tuple's ordering.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;isPartialMatch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;entryRes[j] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1537" title="access/gin/ginget.c:1537">matchPartialInPendingList</a>(&amp;so-&gt;ginstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StopMiddle,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos-&gt;lastOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; category,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datumExtracted);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;entryRes[j] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* done with binary search */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (res &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StopHigh = StopMiddle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StopLow = StopMiddle + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (StopLow &gt;= StopHigh &amp;&amp; entry-&gt;isPartialMatch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No exact match on this page.&nbsp; If doing partial match,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan from the first tuple greater than target value to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end of page.&nbsp; Note that since we don't remember whether<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the comparePartialFn told us to stop early on a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previous page, we will uselessly apply comparePartialFn<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the first tuple on each subsequent page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;entryRes[j] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1537" title="access/gin/ginget.c:1537">matchPartialInPendingList</a>(&amp;so-&gt;ginstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StopHigh,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos-&gt;lastOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; category,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datumExtracted);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos-&gt;hasMatchKey[i] |= key-&gt;entryRes[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance firstOffset over the scanned tuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pos-&gt;firstOffset = pos-&gt;lastOffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GinPageHasFullRow(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have examined all pending entries for the current heap row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Break out of loop over pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page of pending entries for the current heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * row.&nbsp; Complain if there isn't one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerData item = pos-&gt;item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1450" title="access/gin/ginget.c:1450">scanGetCandidate</a>(scan, pos) == <span class="Constant">false</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;pos-&gt;item, &amp;item))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> additional pending pages for same heap tuple&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All scan keys except excludeOnly require at least one entry to match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * excludeOnly keys are an exception, because their implied<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * GIN_CAT_EMPTY_QUERY scanEntry always matches.&nbsp; So return &quot;true&quot; if all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-excludeOnly scan keys have at least one match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; so-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos-&gt;hasMatchKey[i] == <span class="Constant">false</span> &amp;&amp; !so-&gt;keys[i].excludeOnly)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Collect all matched rows from pending list into bitmap.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1820">&#x200c;</a></span><span class="linkable">scanPendingInsert</span>(IndexScanDesc scan, <a href="../../nodes/tidbitmap.c.html#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm, int64 *ntids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GinScanOpaque so = (GinScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldCtx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; recheck,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <a href="#L29" title="access/gin/ginget.c:29">pendingPosition</a> pos;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(scan-&gt;indexRelation, GIN_METAPAGE_BLKNO);<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *ntids = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Acquire predicate lock on the metapage, to conflict with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fastupdate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * insertions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L2584" title="storage/lmgr/predicate.c:2584">PredicateLockPage</a>(scan-&gt;indexRelation, GIN_METAPAGE_BLKNO, scan-&gt;xs_snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuffer, GIN_SHARE);<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(metabuffer);<br/></li>
<li>&nbsp; &nbsp; blkno = GinPageGetMeta(page)-&gt;head;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fetch head of list <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> unlocking metapage. head page must be pinned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to prevent deletion by <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (blkno == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No pending list, so proceed with normal scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(metabuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pos.pendingBuffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(scan-&gt;indexRelation, blkno);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(pos.pendingBuffer, GIN_SHARE);<br/></li>
<li>&nbsp; &nbsp; pos.firstOffset = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(metabuffer);<br/></li>
<li>&nbsp; &nbsp; pos.hasMatchKey = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * so-&gt;nkeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loop for each heap row. <a href="#L1450" title="access/gin/ginget.c:1450">scanGetCandidate</a> returns full row or row's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples from first page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L1450" title="access/gin/ginget.c:1450">scanGetCandidate</a>(scan, &amp;pos))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check entries in tuple and set up entryRes array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If pending tuples belonging to the current heap row are spread<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * across several pages, <a href="#L1605" title="access/gin/ginget.c:1605">collectMatchesForHeapRow</a> will read all of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * those pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1605" title="access/gin/ginget.c:1605">collectMatchesForHeapRow</a>(scan, &amp;pos))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Matching of entries of one row is finished, so check row using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consistent <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldCtx = MemoryContextSwitchTo(so-&gt;tempCtx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recheck = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; match = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; so-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GinScanKey&nbsp; &nbsp; key = so-&gt;keys + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!key-&gt;boolConsistentFn(key))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recheck |= key-&gt;recheckCurItem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldCtx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(so-&gt;tempCtx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (match)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/tidbitmap.c.html#L377" title="nodes/tidbitmap.c:377">tbm_add_tuples</a>(tbm, &amp;pos.item, <span class="Constant">1</span>, recheck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*ntids)++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pos.hasMatchKey);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1911">&#x200c;</a><span class="PreProc">#define <span class="linkable">GinIsVoidRes</span>(s)&nbsp; &nbsp; &nbsp; &nbsp; ( ((GinScanOpaque) scan-&gt;opaque)-&gt;isVoidRes )<br/></li>
<li></span><br/></li>
<li>int64<br/></li>
<li><a id="L1914">&#x200c;</a><span class="linkable">gingetbitmap</span>(IndexScanDesc scan, <a href="../../nodes/tidbitmap.c.html#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GinScanOpaque so = (GinScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; ntids;<br/></li>
<li>&nbsp; &nbsp; ItemPointerData iptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; recheck;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up the scan keys, and check for unsatisfiable query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="ginscan.c.html#L233" title="access/gin/ginscan.c:233">ginFreeScanKeys</a>(so);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there should be no keys yet, but just to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sure */<br/></li>
<li></span>&nbsp; &nbsp; <a href="ginscan.c.html#L263" title="access/gin/ginscan.c:263">ginNewScanKey</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1911" title="access/gin/ginget.c:1911">GinIsVoidRes</a>(scan))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ntids = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, scan the pending list and collect <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> matching entries into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bitmap.&nbsp; After we scan a pending item, some other backend could post it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> index, and so we might visit it a second time during the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> scan.&nbsp; This is okay because we'll just re-set the same <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bitmap.&nbsp; (The possibility of duplicate visits is a major reason why GIN<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't support the amgettuple API, however.) Note that it would not do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to scan the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> index <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the pending list, since concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> could then make us <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> entries entirely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1820" title="access/gin/ginget.c:1820">scanPendingInsert</a>(scan, tbm, &amp;ntids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now scan the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L601" title="access/gin/ginget.c:601">startScan</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ItemPointerSetMin(&amp;iptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1285" title="access/gin/ginget.c:1285">scanGetItem</a>(scan, iptr, &amp;iptr, &amp;recheck))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemPointerIsLossyPage(&amp;iptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/tidbitmap.c.html#L443" title="nodes/tidbitmap.c:443">tbm_add_page</a>(tbm, ItemPointerGetBlockNumber(&amp;iptr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/tidbitmap.c.html#L377" title="nodes/tidbitmap.c:377">tbm_add_tuples</a>(tbm, &amp;iptr, <span class="Constant">1</span>, recheck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ntids++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ntids;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
