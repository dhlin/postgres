<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/gist/gistbuildbuffers.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/gist/gistbuildbuffers.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L525">RelocationBufferInfo</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L750">ReadTempFileBlock</a></li>
<li><a href="#L758">WriteTempFileBlock</a></li>
<li><a href="#L198">gistAddLoadedBuffer</a></li>
<li><a href="#L181">gistAllocateNewPageBuffer</a></li>
<li><a href="#L468">gistBuffersGetFreeBlock</a></li>
<li><a href="#L485">gistBuffersReleaseBlock</a></li>
<li><a href="#L507">gistFreeBuildBuffers</a></li>
<li><a href="#L311">gistGetItupFromPage</a></li>
<li><a href="#L113">gistGetNodeBuffer</a></li>
<li><a href="#L44">gistInitBuildBuffers</a></li>
<li><a href="#L221">gistLoadNodeBuffer</a></li>
<li><a href="#L288">gistPlaceItupToPage</a></li>
<li><a href="#L406">gistPopItupFromNodeBuffer</a></li>
<li><a href="#L336">gistPushItupToNodeBuffer</a></li>
<li><a href="#L533">gistRelocateBuildBuffersOnSplit</a></li>
<li><a href="#L246">gistUnloadNodeBuffer</a></li>
<li><a href="#L272">gistUnloadNodeBuffers</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * gistbuildbuffers.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; node buffer management <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for GiST buffering build algorithm.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/gist/gistbuildbuffers.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/gist_private.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/buffile.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> GISTNodeBufferPage *<a href="#L181" title="access/gist/gistbuildbuffers.c:181">gistAllocateNewPageBuffer</a>(GISTBuildBuffers *gfbb);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L198" title="access/gist/gistbuildbuffers.c:198">gistAddLoadedBuffer</a>(GISTBuildBuffers *gfbb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GISTNodeBuffer *nodeBuffer);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L221" title="access/gist/gistbuildbuffers.c:221">gistLoadNodeBuffer</a>(GISTBuildBuffers *gfbb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GISTNodeBuffer *nodeBuffer);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L246" title="access/gist/gistbuildbuffers.c:246">gistUnloadNodeBuffer</a>(GISTBuildBuffers *gfbb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GISTNodeBuffer *nodeBuffer);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L288" title="access/gist/gistbuildbuffers.c:288">gistPlaceItupToPage</a>(GISTNodeBufferPage *pageBuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple itup);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L311" title="access/gist/gistbuildbuffers.c:311">gistGetItupFromPage</a>(GISTNodeBufferPage *pageBuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple *itup);<br/></li>
<li><span class="Type">static</span> <span class="Type">long</span> <a href="#L468" title="access/gist/gistbuildbuffers.c:468">gistBuffersGetFreeBlock</a>(GISTBuildBuffers *gfbb);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L485" title="access/gist/gistbuildbuffers.c:485">gistBuffersReleaseBlock</a>(GISTBuildBuffers *gfbb, <span class="Type">long</span> blocknum);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L750" title="access/gist/gistbuildbuffers.c:750">ReadTempFileBlock</a>(<a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> *file, <span class="Type">long</span> blknum, <span class="Type">void</span> *ptr);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L758" title="access/gist/gistbuildbuffers.c:758">WriteTempFileBlock</a>(<a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> *file, <span class="Type">long</span> blknum, <span class="Type">const</span> <span class="Type">void</span> *ptr);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize GiST build buffers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>GISTBuildBuffers *<br/></li>
<li><a id="L44">&#x200c;</a><span class="linkable">gistInitBuildBuffers</span>(<span class="Type">int</span> pagesPerBuffer, <span class="Type">int</span> levelStep, <span class="Type">int</span> maxLevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTBuildBuffers *gfbb;<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hashCtl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gfbb = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTBuildBuffers));<br/></li>
<li>&nbsp; &nbsp; gfbb-&gt;pagesPerBuffer = pagesPerBuffer;<br/></li>
<li>&nbsp; &nbsp; gfbb-&gt;levelStep = levelStep;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a temporary file to hold buffer pages that are swapped out of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; gfbb-&gt;pfile = <a href="../../storage/file/buffile.c.html#L193" title="storage/file/buffile.c:193">BufFileCreateTemp</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; gfbb-&gt;nFileBlocks = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize free page management. */<br/></li>
<li></span>&nbsp; &nbsp; gfbb-&gt;nFreeBlocks = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; gfbb-&gt;freeBlocksLen = <span class="Constant">32</span>;<br/></li>
<li>&nbsp; &nbsp; gfbb-&gt;freeBlocks = (<span class="Type">long</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(gfbb-&gt;freeBlocksLen * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">long</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Current memory context will be used for all in-memory data structures<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of buffers which are persistent during buffering build.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; gfbb-&gt;context = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nodeBuffersTab <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> is association between index blocks and it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hashCtl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BlockNumber);<br/></li>
<li>&nbsp; &nbsp; hashCtl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTNodeBuffer);<br/></li>
<li>&nbsp; &nbsp; hashCtl.hcxt = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; gfbb-&gt;nodeBuffersTab = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;gistbuildbuffers&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1024</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;hashCtl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gfbb-&gt;bufferEmptyingQueue = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Per-level node buffers lists for final buffers emptying process. Node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffers are inserted here when they are created.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; gfbb-&gt;buffersOnLevelsLen = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; gfbb-&gt;buffersOnLevels = (List **) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(List *) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gfbb-&gt;buffersOnLevelsLen);<br/></li>
<li>&nbsp; &nbsp; gfbb-&gt;buffersOnLevels[<span class="Constant">0</span>] = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Block numbers of node buffers which last pages are currently loaded<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; gfbb-&gt;loadedBuffersLen = <span class="Constant">32</span>;<br/></li>
<li>&nbsp; &nbsp; gfbb-&gt;loadedBuffers = (GISTNodeBuffer **) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(gfbb-&gt;loadedBuffersLen *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTNodeBuffer *));<br/></li>
<li>&nbsp; &nbsp; gfbb-&gt;loadedBuffersCount = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gfbb-&gt;rootlevel = maxLevel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> gfbb;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns a node buffer for given block. The buffer is created if it<br/></li>
<li></span><span class="Comment"> * doesn't exist yet.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>GISTNodeBuffer *<br/></li>
<li><a id="L113">&#x200c;</a><span class="linkable">gistGetNodeBuffer</span>(GISTBuildBuffers *gfbb, GISTSTATE *giststate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber nodeBlocknum, <span class="Type">int</span> level)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTNodeBuffer *nodeBuffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find node buffer in <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; nodeBuffer = (GISTNodeBuffer *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(gfbb-&gt;nodeBuffersTab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;nodeBlocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Node buffer wasn't found. Initialize the new buffer as empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcxt = MemoryContextSwitchTo(gfbb-&gt;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nodeBuffer-&gt;nodeBlocknum is the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key and was filled in already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nodeBuffer-&gt;blocksCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nodeBuffer-&gt;pageBlocknum = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nodeBuffer-&gt;pageBuffer = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nodeBuffer-&gt;queuedForEmptying = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nodeBuffer-&gt;isTemp = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nodeBuffer-&gt;level = level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add this buffer to the list of buffers on this level. Enlarge<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffersOnLevels array if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (level &gt;= gfbb-&gt;buffersOnLevelsLen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gfbb-&gt;buffersOnLevels =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (List **) <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(gfbb-&gt;buffersOnLevels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (level + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(List *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the enlarged portion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = gfbb-&gt;buffersOnLevelsLen; i &lt;= level; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gfbb-&gt;buffersOnLevels[i] = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gfbb-&gt;buffersOnLevelsLen = level + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Prepend the new buffer to the list of buffers on this level. It's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not arbitrary that the new buffer is put to the beginning of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list: in the final emptying phase we loop through all buffers at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * each level, and flush them. If a page is split during the emptying,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's more efficient to flush the new split pages first, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * moving on to pre-existing pages on the level. The buffers just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * created during the page split are likely still in cache, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * flushing them immediately is more efficient than putting them to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the end of the queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; gfbb-&gt;buffersOnLevels[level] = <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(nodeBuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gfbb-&gt;buffersOnLevels[level]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nodeBuffer;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate memory for a buffer page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> GISTNodeBufferPage *<br/></li>
<li><a id="L181">&#x200c;</a><span class="linkable">gistAllocateNewPageBuffer</span>(GISTBuildBuffers *gfbb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTNodeBufferPage *pageBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pageBuffer = (GISTNodeBufferPage *) <a href="../../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(gfbb-&gt;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; pageBuffer-&gt;prev = InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set page free space */<br/></li>
<li></span>&nbsp; &nbsp; PAGE_FREE_SPACE(pageBuffer) = BLCKSZ - BUFFER_PAGE_DATA_OFFSET;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pageBuffer;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add specified buffer into loadedBuffers array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L198">&#x200c;</a></span><span class="linkable">gistAddLoadedBuffer</span>(GISTBuildBuffers *gfbb, GISTNodeBuffer *nodeBuffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Never add a temporary buffer to the array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nodeBuffer-&gt;isTemp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Enlarge the array if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (gfbb-&gt;loadedBuffersCount &gt;= gfbb-&gt;loadedBuffersLen)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gfbb-&gt;loadedBuffersLen *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gfbb-&gt;loadedBuffers = (GISTNodeBuffer **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(gfbb-&gt;loadedBuffers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gfbb-&gt;loadedBuffersLen * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTNodeBuffer *));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gfbb-&gt;loadedBuffers[gfbb-&gt;loadedBuffersCount] = nodeBuffer;<br/></li>
<li>&nbsp; &nbsp; gfbb-&gt;loadedBuffersCount++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Load last page of node buffer into <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L221">&#x200c;</a></span><span class="linkable">gistLoadNodeBuffer</span>(GISTBuildBuffers *gfbb, GISTNodeBuffer *nodeBuffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if we really should load something */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!nodeBuffer-&gt;pageBuffer &amp;&amp; nodeBuffer-&gt;blocksCount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allocate memory for page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nodeBuffer-&gt;pageBuffer = <a href="#L181" title="access/gist/gistbuildbuffers.c:181">gistAllocateNewPageBuffer</a>(gfbb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Read block from temporary file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L750" title="access/gist/gistbuildbuffers.c:750">ReadTempFileBlock</a>(gfbb-&gt;pfile, nodeBuffer-&gt;pageBlocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodeBuffer-&gt;pageBuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark file block as free */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L485" title="access/gist/gistbuildbuffers.c:485">gistBuffersReleaseBlock</a>(gfbb, nodeBuffer-&gt;pageBlocknum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark node buffer as loaded */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L198" title="access/gist/gistbuildbuffers.c:198">gistAddLoadedBuffer</a>(gfbb, nodeBuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nodeBuffer-&gt;pageBlocknum = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write last page of node buffer to the disk.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L246">&#x200c;</a></span><span class="linkable">gistUnloadNodeBuffer</span>(GISTBuildBuffers *gfbb, GISTNodeBuffer *nodeBuffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if we have something to write */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nodeBuffer-&gt;pageBuffer)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get free file block */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; blkno = <a href="#L468" title="access/gist/gistbuildbuffers.c:468">gistBuffersGetFreeBlock</a>(gfbb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Write block to the temporary file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L758" title="access/gist/gistbuildbuffers.c:758">WriteTempFileBlock</a>(gfbb-&gt;pfile, blkno, nodeBuffer-&gt;pageBuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Free memory of that page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nodeBuffer-&gt;pageBuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nodeBuffer-&gt;pageBuffer = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Save block number */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nodeBuffer-&gt;pageBlocknum = blkno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write last pages of all node buffers to the disk.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L272">&#x200c;</a></span><span class="linkable">gistUnloadNodeBuffers</span>(GISTBuildBuffers *gfbb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unload all the buffers that have a page loaded in memory. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; gfbb-&gt;loadedBuffersCount; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L246" title="access/gist/gistbuildbuffers.c:246">gistUnloadNodeBuffer</a>(gfbb, gfbb-&gt;loadedBuffers[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now there are no node buffers with loaded last page */<br/></li>
<li></span>&nbsp; &nbsp; gfbb-&gt;loadedBuffersCount = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add index tuple to buffer page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L288">&#x200c;</a></span><span class="linkable">gistPlaceItupToPage</span>(GISTNodeBufferPage *pageBuffer, IndexTuple itup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; itupsz = IndexTupleSize(itup);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There should be enough of space. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(PAGE_FREE_SPACE(pageBuffer) &gt;= MAXALIGN(itupsz));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reduce free space value of page to reserve a spot for the tuple. */<br/></li>
<li></span>&nbsp; &nbsp; PAGE_FREE_SPACE(pageBuffer) -= MAXALIGN(itupsz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get pointer to the spot we reserved (ie. end of free space). */<br/></li>
<li></span>&nbsp; &nbsp; ptr = (<span class="Type">char</span> *) pageBuffer + BUFFER_PAGE_DATA_OFFSET<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; + PAGE_FREE_SPACE(pageBuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy the index tuple there. */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(ptr, itup, itupsz);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get last item from buffer page and remove it from page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L311">&#x200c;</a></span><span class="linkable">gistGetItupFromPage</span>(GISTNodeBufferPage *pageBuffer, IndexTuple *itup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; ptr;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; itupsz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!PAGE_IS_EMPTY(pageBuffer)); <span class="Comment">/* Page shouldn't be empty */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get pointer to last index tuple */<br/></li>
<li></span>&nbsp; &nbsp; ptr = (IndexTuple) ((<span class="Type">char</span> *) pageBuffer<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + BUFFER_PAGE_DATA_OFFSET<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + PAGE_FREE_SPACE(pageBuffer));<br/></li>
<li>&nbsp; &nbsp; itupsz = IndexTupleSize(ptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make a copy of the tuple */<br/></li>
<li></span>&nbsp; &nbsp; *itup = (IndexTuple) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(itupsz);<br/></li>
<li>&nbsp; &nbsp; memcpy(*itup, ptr, itupsz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the space used by the tuple as free */<br/></li>
<li></span>&nbsp; &nbsp; PAGE_FREE_SPACE(pageBuffer) += MAXALIGN(itupsz);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Push an index tuple to node buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L336">&#x200c;</a></span><span class="linkable">gistPushItupToNodeBuffer</span>(GISTBuildBuffers *gfbb, GISTNodeBuffer *nodeBuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTuple itup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Most part of memory operations will be in buffering build persistent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context. So, let's switch to it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext oldcxt = MemoryContextSwitchTo(gfbb-&gt;context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the buffer is currently empty, create the first page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nodeBuffer-&gt;blocksCount == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nodeBuffer-&gt;pageBuffer = <a href="#L181" title="access/gist/gistbuildbuffers.c:181">gistAllocateNewPageBuffer</a>(gfbb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nodeBuffer-&gt;blocksCount = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L198" title="access/gist/gistbuildbuffers.c:198">gistAddLoadedBuffer</a>(gfbb, nodeBuffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Load last page of node buffer if it wasn't in memory already */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!nodeBuffer-&gt;pageBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L221" title="access/gist/gistbuildbuffers.c:221">gistLoadNodeBuffer</a>(gfbb, nodeBuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if there is enough space on the last page for the tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PAGE_NO_SPACE(nodeBuffer-&gt;pageBuffer, itup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Nope. Swap previous block to disk and allocate a new one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Write filled page to the disk */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; blkno = <a href="#L468" title="access/gist/gistbuildbuffers.c:468">gistBuffersGetFreeBlock</a>(gfbb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L758" title="access/gist/gistbuildbuffers.c:758">WriteTempFileBlock</a>(gfbb-&gt;pfile, blkno, nodeBuffer-&gt;pageBuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset the in-memory page as empty, and link the previous block to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the new page by storing its block number in the prev-link.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PAGE_FREE_SPACE(nodeBuffer-&gt;pageBuffer) =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BLCKSZ - MAXALIGN(offsetof(GISTNodeBufferPage, tupledata));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nodeBuffer-&gt;pageBuffer-&gt;prev = blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We've just added one more page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nodeBuffer-&gt;blocksCount++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L288" title="access/gist/gistbuildbuffers.c:288">gistPlaceItupToPage</a>(nodeBuffer-&gt;pageBuffer, itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the buffer just overflowed, add it to the emptying queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BUFFER_HALF_FILLED(nodeBuffer, gfbb) &amp;&amp; !nodeBuffer-&gt;queuedForEmptying)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gfbb-&gt;bufferEmptyingQueue = <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(nodeBuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gfbb-&gt;bufferEmptyingQueue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nodeBuffer-&gt;queuedForEmptying = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore memory context */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Removes one index tuple from node buffer. Returns true if success and false<br/></li>
<li></span><span class="Comment"> * if node buffer is empty.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L406">&#x200c;</a></span><span class="linkable">gistPopItupFromNodeBuffer</span>(GISTBuildBuffers *gfbb, GISTNodeBuffer *nodeBuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple *itup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If node buffer is empty then return false.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nodeBuffer-&gt;blocksCount &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Load last page of node buffer if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!nodeBuffer-&gt;pageBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L221" title="access/gist/gistbuildbuffers.c:221">gistLoadNodeBuffer</a>(gfbb, nodeBuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get index tuple from last non-empty page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L311" title="access/gist/gistbuildbuffers.c:311">gistGetItupFromPage</a>(nodeBuffer-&gt;pageBuffer, itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we just removed the last tuple from the page, fetch previous page on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this node buffer (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PAGE_IS_EMPTY(nodeBuffer-&gt;pageBuffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber prevblkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * blocksCount includes the page in pageBuffer, so decrease it <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nodeBuffer-&gt;blocksCount--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there's more pages, fetch previous one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; prevblkno = nodeBuffer-&gt;pageBuffer-&gt;prev;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prevblkno != InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There is a previous page. Fetch it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nodeBuffer-&gt;blocksCount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L750" title="access/gist/gistbuildbuffers.c:750">ReadTempFileBlock</a>(gfbb-&gt;pfile, prevblkno, nodeBuffer-&gt;pageBuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now that we've read the block in memory, we can release its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on-disk block for reuse.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L485" title="access/gist/gistbuildbuffers.c:485">gistBuffersReleaseBlock</a>(gfbb, prevblkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No more pages. Free memory. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nodeBuffer-&gt;blocksCount == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(nodeBuffer-&gt;pageBuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodeBuffer-&gt;pageBuffer = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Select a currently unused block for writing to.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">long<br/></li>
<li><a id="L468">&#x200c;</a></span><span class="linkable">gistBuffersGetFreeBlock</span>(GISTBuildBuffers *gfbb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are multiple free blocks, we <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the one appearing last in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * freeBlocks[].&nbsp; If there are <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>, assign the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block at the end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the file (causing the file to be extended).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (gfbb-&gt;nFreeBlocks &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gfbb-&gt;freeBlocks[--gfbb-&gt;nFreeBlocks];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gfbb-&gt;nFileBlocks++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a block# to the freelist.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L485">&#x200c;</a></span><span class="linkable">gistBuffersReleaseBlock</span>(GISTBuildBuffers *gfbb, <span class="Type">long</span> blocknum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Enlarge freeBlocks array if full. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (gfbb-&gt;nFreeBlocks &gt;= gfbb-&gt;freeBlocksLen)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gfbb-&gt;freeBlocksLen *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gfbb-&gt;freeBlocks = (<span class="Type">long</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(gfbb-&gt;freeBlocks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gfbb-&gt;freeBlocksLen *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">long</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add blocknum to array */<br/></li>
<li></span>&nbsp; &nbsp; ndx = gfbb-&gt;nFreeBlocks++;<br/></li>
<li>&nbsp; &nbsp; gfbb-&gt;freeBlocks[ndx] = blocknum;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free buffering build data structure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L507">&#x200c;</a></span><span class="linkable">gistFreeBuildBuffers</span>(GISTBuildBuffers *gfbb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close buffers file. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L412" title="storage/file/buffile.c:412">BufFileClose</a>(gfbb-&gt;pfile);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All other things will be freed on memory context release */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Data structure representing information about node buffer for index tuples<br/></li>
<li></span><span class="Comment"> * relocation from split node buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; &nbsp; entry[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; GISTPageSplitInfo *splitinfo;<br/></li>
<li>&nbsp; &nbsp; GISTNodeBuffer *nodeBuffer;<br/></li>
<li><a id="L525">&#x200c;</a>} <span class="linkable">RelocationBufferInfo</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * At page split, distribute tuples from the buffer of the split page to<br/></li>
<li></span><span class="Comment"> * new buffers for the created page halves. This also adjusts the downlinks<br/></li>
<li></span><span class="Comment"> * in 'splitinfo' to include the tuples in the buffers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L533">&#x200c;</a></span><span class="linkable">gistRelocateBuildBuffersOnSplit</span>(GISTBuildBuffers *gfbb, GISTSTATE *giststate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation r, <span class="Type">int</span> level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer buffer, List *splitinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L525" title="access/gist/gistbuildbuffers.c:525">RelocationBufferInfo</a> *relocationBuffersInfos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; GISTNodeBuffer *nodeBuffer;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blocknum;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splitPagesCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; &nbsp; entry[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; GISTNodeBuffer oldBuf;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the split page doesn't have buffers, we have nothing to do. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!LEVEL_HAS_BUFFERS(level, gfbb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the node buffer of the split page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; blocknum = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; nodeBuffer = <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(gfbb-&gt;nodeBuffersTab, &amp;blocknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_FIND, &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The page has no buffer, so we have nothing to do. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make a copy of the old buffer, as we're going reuse it as the buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the new left page, which is on the same block as the old page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * That's not true for the root page, but that's fine because we never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have a buffer on the root page anyway. The original algorithm as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * described by Arge et al did, but it's of no use, as you might as well<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read the tuples straight from the heap instead of the root buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(blocknum != GIST_ROOT_BLKNO);<br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;oldBuf, nodeBuffer, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTNodeBuffer));<br/></li>
<li>&nbsp; &nbsp; oldBuf.isTemp = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset the old buffer, used for the new left page from <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> on */<br/></li>
<li></span>&nbsp; &nbsp; nodeBuffer-&gt;blocksCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; nodeBuffer-&gt;pageBuffer = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; nodeBuffer-&gt;pageBlocknum = InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate memory for information about relocation buffers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; splitPagesCount = list_length(splitinfo);<br/></li>
<li>&nbsp; &nbsp; relocationBuffersInfos =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L525" title="access/gist/gistbuildbuffers.c:525">RelocationBufferInfo</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L525" title="access/gist/gistbuildbuffers.c:525">RelocationBufferInfo</a>) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splitPagesCount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill relocation buffers information for node buffers of pages produced<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by split.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, splitinfo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GISTPageSplitInfo *si = (GISTPageSplitInfo *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GISTNodeBuffer *newNodeBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = foreach_current_index(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Decompress parent index tuple of node buffer page. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L296" title="access/gist/gistutil.c:296">gistDeCompressAtt</a>(giststate, r,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; si-&gt;downlink, <span class="Constant">NULL</span>, (OffsetNumber) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relocationBuffersInfos[i].entry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relocationBuffersInfos[i].isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create a node buffer for the page. The leftmost half is on the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * block as the old page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> split, so for the leftmost half this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will return the original buffer. The tuples on the original buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * were relinked to the temporary buffer, so the original one is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newNodeBuffer = <a href="#L113" title="access/gist/gistbuildbuffers.c:113">gistGetNodeBuffer</a>(gfbb, giststate, <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(si-&gt;buf), level);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relocationBuffersInfos[i].nodeBuffer = newNodeBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relocationBuffersInfos[i].splitinfo = si;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop through all index tuples in the buffer of the page being split,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * moving them to buffers for the new pages.&nbsp; We try to move each tuple to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the page that will result in the lowest penalty for the leading column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or, in the case of a tie, the lowest penalty for the earliest column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that is not tied.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The page searching logic is very similar to <a href="gistutil.c.html#L374" title="access/gist/gistutil.c:374">gistchoose</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L406" title="access/gist/gistbuildbuffers.c:406">gistPopItupFromNodeBuffer</a>(gfbb, &amp;oldBuf, &amp;itup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">float</span>&nbsp; &nbsp; &nbsp; &nbsp; best_penalty[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; newtup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L525" title="access/gist/gistbuildbuffers.c:525">RelocationBufferInfo</a> *targetBufferInfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L296" title="access/gist/gistutil.c:296">gistDeCompressAtt</a>(giststate, r,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup, <span class="Constant">NULL</span>, (OffsetNumber) <span class="Constant">0</span>, entry, isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* default to using first page (shouldn't matter) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; which = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * best_penalty[j] is the best penalty we have seen so far for column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * j, or -1 when we haven't yet examined column j.&nbsp; Array entries to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the right of the first -1 are undefined.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; best_penalty[<span class="Constant">0</span>] = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Loop over possible target pages, looking for one to move this tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; splitPagesCount; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L525" title="access/gist/gistbuildbuffers.c:525">RelocationBufferInfo</a> *splitPageInfo = &amp;relocationBuffersInfos[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; zero_penalty;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zero_penalty = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Loop over index attributes. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; IndexRelationGetNumberOfKeyAttributes(r); j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">float</span>&nbsp; &nbsp; &nbsp; &nbsp; usize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute penalty for this column. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usize = <a href="gistutil.c.html#L724" title="access/gist/gistutil.c:724">gistpenalty</a>(giststate, j,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;splitPageInfo-&gt;entry[j],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splitPageInfo-&gt;isnull[j],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;entry[j], isnull[j]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (usize &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zero_penalty = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (best_penalty[j] &lt; <span class="Constant">0</span> || usize &lt; best_penalty[j])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * New best penalty for column.&nbsp; Tentatively <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page as the target, and record the best penalty.&nbsp; Then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reset the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> column's penalty to &quot;unknown&quot; (and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indirectly, the same for all the ones to its right).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This will force us to adopt this page's penalty <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as the best for all the remaining columns during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subsequent loop iterations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_penalty[j] = usize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j &lt; IndexRelationGetNumberOfKeyAttributes(r) - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_penalty[j + <span class="Constant">1</span>] = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (best_penalty[j] == usize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The current page is exactly as good for this column as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the best page seen so far.&nbsp; The <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iteration of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loop will <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The current page is worse for this column than the best<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page seen so far.&nbsp; Skip the remaining columns and move<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zero_penalty = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* so outer loop won't exit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a page with zero penalty for all columns, there's no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to examine remaining pages; just break out of the loop and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * return it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (zero_penalty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, &quot;which&quot; is the page index to <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> the tuple to */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; targetBufferInfo = &amp;relocationBuffersInfos[which];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Push item to selected node buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L336" title="access/gist/gistbuildbuffers.c:336">gistPushItupToNodeBuffer</a>(gfbb, targetBufferInfo-&gt;nodeBuffer, itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust the downlink for this page, if needed. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newtup = <a href="gistutil.c.html#L316" title="access/gist/gistutil.c:316">gistgetadjusted</a>(r, targetBufferInfo-&gt;splitinfo-&gt;downlink,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; itup, giststate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newtup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L296" title="access/gist/gistutil.c:296">gistDeCompressAtt</a>(giststate, r,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtup, <span class="Constant">NULL</span>, (OffsetNumber) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetBufferInfo-&gt;entry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetBufferInfo-&gt;isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetBufferInfo-&gt;splitinfo-&gt;downlink = newtup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(relocationBuffersInfos);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wrappers around <a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> operations. The <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> difference is that these<br/></li>
<li></span><span class="Comment"> * wrappers report errors with ereport(), so that the callers don't need<br/></li>
<li></span><span class="Comment"> * to check the return code.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L750">&#x200c;</a></span><span class="linkable">ReadTempFileBlock</span>(<a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> *file, <span class="Type">long</span> blknum, <span class="Type">void</span> *ptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/buffile.c.html#L851" title="storage/file/buffile.c:851">BufFileSeekBlock</a>(file, blknum) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not seek to block </span><span class="Special">%ld</span><span class="Constant"> in temporary file&quot;</span>, blknum);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L654" title="storage/file/buffile.c:654">BufFileReadExact</a>(file, ptr, BLCKSZ);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L758">&#x200c;</a></span><span class="linkable">WriteTempFileBlock</span>(<a href="../../storage/file/buffile.c.html#L70" title="storage/file/buffile.c:70">BufFile</a> *file, <span class="Type">long</span> blknum, <span class="Type">const</span> <span class="Type">void</span> *ptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/buffile.c.html#L851" title="storage/file/buffile.c:851">BufFileSeekBlock</a>(file, blknum) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not seek to block </span><span class="Special">%ld</span><span class="Constant"> in temporary file&quot;</span>, blknum);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/buffile.c.html#L676" title="storage/file/buffile.c:676">BufFileWrite</a>(file, ptr, BLCKSZ);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
