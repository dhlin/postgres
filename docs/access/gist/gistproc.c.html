<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/gist/gistproc.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/gist/gistproc.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L277">CommonEntry</a></li>
<li><a href="#L300">ConsiderSplitContext</a></li>
<li><a href="#L309">SplitInterval</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L146">adjustBox</a></li>
<li><a href="#L97">box_penalty</a></li>
<li><a href="#L460">common_entry_cmp</a></li>
<li><a href="#L1221">computeDistance</a></li>
<li><a href="#L216">fallbackSplit</a></li>
<li><a href="#L351">g_box_consider_split</a></li>
<li><a href="#L1479">gist_bbox_distance</a></li>
<li><a href="#L1736">gist_bbox_zorder_abbrev_abort</a></li>
<li><a href="#L1714">gist_bbox_zorder_abbrev_convert</a></li>
<li><a href="#L1681">gist_bbox_zorder_cmp</a></li>
<li><a href="#L113">gist_box_consistent</a></li>
<li><a href="#L1500">gist_box_distance</a></li>
<li><a href="#L872">gist_box_leaf_consistent</a></li>
<li><a href="#L199">gist_box_penalty</a></li>
<li><a href="#L495">gist_box_picksplit</a></li>
<li><a href="#L852">gist_box_same</a></li>
<li><a href="#L164">gist_box_union</a></li>
<li><a href="#L1100">gist_circle_compress</a></li>
<li><a href="#L1130">gist_circle_consistent</a></li>
<li><a href="#L1526">gist_circle_distance</a></li>
<li><a href="#L1168">gist_point_compress</a></li>
<li><a href="#L1337">gist_point_consistent</a></li>
<li><a href="#L1287">gist_point_consistent_internal</a></li>
<li><a href="#L1455">gist_point_distance</a></li>
<li><a href="#L1196">gist_point_fetch</a></li>
<li><a href="#L1745">gist_point_sortsupport</a></li>
<li><a href="#L1035">gist_poly_compress</a></li>
<li><a href="#L1062">gist_poly_consistent</a></li>
<li><a href="#L1543">gist_poly_distance</a></li>
<li><a href="#L1603">ieee_float32_to_uint32</a></li>
<li><a href="#L315">interval_cmp_lower</a></li>
<li><a href="#L327">interval_cmp_upper</a></li>
<li><a href="#L339">non_negative</a></li>
<li><a href="#L1586">part_bits32_by2</a></li>
<li><a href="#L1575">point_zorder_internal</a></li>
<li><a href="#L55">rt_box_union</a></li>
<li><a href="#L957">rtree_internal_consistent</a></li>
<li><a href="#L68">size_box</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L1332">BoxStrategyNumberGroup</a></li>
<li><a href="#L1334">CircleStrategyNumberGroup</a></li>
<li><a href="#L1330">GeoStrategyNumberOffset</a></li>
<li><a href="#L44">LIMIT_RATIO</a></li>
<li><a href="#L712">PLACE_LEFT</a></li>
<li><a href="#L721">PLACE_RIGHT</a></li>
<li><a href="#L1331">PointStrategyNumberGroup</a></li>
<li><a href="#L1333">PolygonStrategyNumberGroup</a></li>
<li><a href="#L1216">point_point_distance</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * gistproc.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Support procedures for GiSTs over 2-D objects (boxes, polygons, circles,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; points).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This gives R-tree behavior, with Guttman's poly-time split algorithm.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; src/backend/access/gist/gistproc.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/gist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/stratnum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/float.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/geo_decls.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/sortsupport.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L872" title="access/gist/gistproc.c:872">gist_box_leaf_consistent</a>(BOX *key, BOX *query,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; StrategyNumber strategy);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L957" title="access/gist/gistproc.c:957">rtree_internal_consistent</a>(BOX *key, BOX *query,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StrategyNumber strategy);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> uint64 <a href="#L1575" title="access/gist/gistproc.c:1575">point_zorder_internal</a>(float4 x, float4 y);<br/></li>
<li><span class="Type">static</span> uint64 <a href="#L1586" title="access/gist/gistproc.c:1586">part_bits32_by2</a>(uint32 x);<br/></li>
<li><span class="Type">static</span> uint32 <a href="#L1603" title="access/gist/gistproc.c:1603">ieee_float32_to_uint32</a>(<span class="Type">float</span> f);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1681" title="access/gist/gistproc.c:1681">gist_bbox_zorder_cmp</a>(Datum a, Datum b, SortSupport ssup);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L1714" title="access/gist/gistproc.c:1714">gist_bbox_zorder_abbrev_convert</a>(Datum original, SortSupport ssup);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1736" title="access/gist/gistproc.c:1736">gist_bbox_zorder_abbrev_abort</a>(<span class="Type">int</span> memtupcount, SortSupport ssup);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Minimum accepted ratio of split */<br/></li>
<li><a id="L44">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LIMIT_RATIO</span> </span><span class="Constant">0.3<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/**************************************************<br/></li>
<li></span><span class="Comment"> * Box ops<br/></li>
<li></span><span class="Comment"> **************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Calculates union of two boxes, a and b. The result is stored in *n.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L55">&#x200c;</a></span><span class="linkable">rt_box_union</span>(BOX *n, <span class="Type">const</span> BOX *a, <span class="Type">const</span> BOX *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; n-&gt;high.x = float8_max(a-&gt;high.x, b-&gt;high.x);<br/></li>
<li>&nbsp; &nbsp; n-&gt;high.y = float8_max(a-&gt;high.y, b-&gt;high.y);<br/></li>
<li>&nbsp; &nbsp; n-&gt;low.x = float8_min(a-&gt;low.x, b-&gt;low.x);<br/></li>
<li>&nbsp; &nbsp; n-&gt;low.y = float8_min(a-&gt;low.y, b-&gt;low.y);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Size of a BOX for penalty-calculation purposes.<br/></li>
<li></span><span class="Comment"> * The result can be +Infinity, but not NaN.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> float8<br/></li>
<li><a id="L68">&#x200c;</a><span class="linkable">size_box</span>(<span class="Type">const</span> BOX *box)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for zero-width cases.&nbsp; Note that we define the size of a zero-<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by-infinity box as zero.&nbsp; It's important to special-case this somehow,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as naively multiplying infinity by zero will produce NaN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The less-than cases should not happen, but if they do, say &quot;zero&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (float8_le(box-&gt;high.x, box-&gt;low.x) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; float8_le(box-&gt;high.y, box-&gt;low.y))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We treat NaN as larger than +Infinity, so <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> distance involving a NaN<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and a non-NaN is infinite.&nbsp; Note the previous check eliminated the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibility that the low fields are NaNs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(box-&gt;high.x) || isnan(box-&gt;high.y))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> get_float8_infinity();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> float8_mul(float8_mi(box-&gt;high.x, box-&gt;low.x),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8_mi(box-&gt;high.y, box-&gt;low.y));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return amount by which the union of the two boxes is larger than<br/></li>
<li></span><span class="Comment"> * the original BOX's area.&nbsp; The result can be +Infinity, but not NaN.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> float8<br/></li>
<li><a id="L97">&#x200c;</a><span class="linkable">box_penalty</span>(<span class="Type">const</span> BOX *original, <span class="Type">const</span> BOX *new)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unionbox;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L55" title="access/gist/gistproc.c:55">rt_box_union</a>(&amp;unionbox, original, new);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> float8_mi(<a href="#L68" title="access/gist/gistproc.c:68">size_box</a>(&amp;unionbox), <a href="#L68" title="access/gist/gistproc.c:68">size_box</a>(original));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The GiST Consistent method for boxes<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Should return false if for all data items x below entry,<br/></li>
<li></span><span class="Comment"> * the predicate x op query must be false, where op is the <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a><br/></li>
<li></span><span class="Comment"> * corresponding to strategy in the pg_amop table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L113">&#x200c;</a><span class="linkable">gist_box_consistent</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *entry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *query = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Oid&nbsp; &nbsp; &nbsp; &nbsp; subtype = PG_GETARG_OID(3); */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *recheck = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) PG_GETARG_POINTER(<span class="Constant">4</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All cases served by this function are exact */<br/></li>
<li></span>&nbsp; &nbsp; *recheck = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBoxP(entry-&gt;key) == <span class="Constant">NULL</span> || query == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if entry is not leaf, use <a href="#L957" title="access/gist/gistproc.c:957">rtree_internal_consistent</a>, else use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L872" title="access/gist/gistproc.c:872">gist_box_leaf_consistent</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (GIST_LEAF(entry))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L872" title="access/gist/gistproc.c:872">gist_box_leaf_consistent</a>(DatumGetBoxP(entry-&gt;key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strategy));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<a href="#L957" title="access/gist/gistproc.c:957">rtree_internal_consistent</a>(DatumGetBoxP(entry-&gt;key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; query,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategy));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Increase BOX b to include addon.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L146">&#x200c;</a></span><span class="linkable">adjustBox</span>(BOX *b, <span class="Type">const</span> BOX *addon)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(b-&gt;high.x, addon-&gt;high.x))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b-&gt;high.x = addon-&gt;high.x;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_gt(b-&gt;low.x, addon-&gt;low.x))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b-&gt;low.x = addon-&gt;low.x;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(b-&gt;high.y, addon-&gt;high.y))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b-&gt;high.y = addon-&gt;high.y;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (float8_gt(b-&gt;low.y, addon-&gt;low.y))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b-&gt;low.y = addon-&gt;low.y;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The GiST Union method for boxes<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * returns the minimal bounding box that encloses all the entries in entryvec<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L164">&#x200c;</a><span class="linkable">gist_box_union</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *sizep = (<span class="Type">int</span> *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numranges,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *cur,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *pageunion;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; numranges = entryvec-&gt;n;<br/></li>
<li>&nbsp; &nbsp; pageunion = (BOX *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li>&nbsp; &nbsp; cur = DatumGetBoxP(entryvec-&gt;vector[<span class="Constant">0</span>].key);<br/></li>
<li>&nbsp; &nbsp; memcpy(pageunion, cur, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; numranges; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cur = DatumGetBoxP(entryvec-&gt;vector[i].key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L146" title="access/gist/gistproc.c:146">adjustBox</a>(pageunion, cur);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *sizep = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(pageunion);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We store boxes as boxes in GiST indexes, so we do not need<br/></li>
<li></span><span class="Comment"> * compress, decompress, or fetch <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The GiST Penalty method for boxes (also used for points)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As in the R-tree paper, we use change in area as our penalty metric<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L199">&#x200c;</a><span class="linkable">gist_box_penalty</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *origentry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *newentry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">float</span>&nbsp; &nbsp; &nbsp;&nbsp; *result = (<span class="Type">float</span> *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *origbox = DatumGetBoxP(origentry-&gt;key);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newbox = DatumGetBoxP(newentry-&gt;key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *result = (<span class="Type">float</span>) <a href="#L97" title="access/gist/gistproc.c:97">box_penalty</a>(origbox, newbox);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Trivial split: half of entries will be placed on one page<br/></li>
<li></span><span class="Comment"> * and another half - to another<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L216">&#x200c;</a></span><span class="linkable">fallbackSplit</span>(GistEntryVector *entryvec, GIST_SPLITVEC *v)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *unionL = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *unionR = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxoff = entryvec-&gt;n - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nbytes = (maxoff + <span class="Constant">2</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber);<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_left = (OffsetNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nbytes);<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_right = (OffsetNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nbytes);<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_nleft = v-&gt;spl_nright = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *cur = DatumGetBoxP(entryvec-&gt;vector[i].key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt;= (maxoff - FirstOffsetNumber + <span class="Constant">1</span>) / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_left[v-&gt;spl_nleft] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unionL == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unionL = (BOX *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *unionL = *cur;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L146" title="access/gist/gistproc.c:146">adjustBox</a>(unionL, cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_nleft++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_right[v-&gt;spl_nright] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unionR == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unionR = (BOX *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *unionR = *cur;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L146" title="access/gist/gistproc.c:146">adjustBox</a>(unionR, cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_nright++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_ldatum = BoxPGetDatum(unionL);<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_rdatum = BoxPGetDatum(unionR);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Represents information about an entry that can be placed to either group<br/></li>
<li></span><span class="Comment"> * without affecting overlap over selected axis (&quot;common entry&quot;).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Index of entry in the initial array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Delta between penalties of entry insertion into different groups */<br/></li>
<li></span>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; delta;<br/></li>
<li><a id="L277">&#x200c;</a>} <span class="linkable">CommonEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Context for <a href="#L351" title="access/gist/gistproc.c:351">g_box_consider_split</a>. Contains information about currently<br/></li>
<li></span><span class="Comment"> * selected split and some general information.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entriesCount;&nbsp; &nbsp; <span class="Comment">/* total number of entries being split */<br/></li>
<li></span>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boundingBox;&nbsp; &nbsp; <span class="Comment">/* minimum bounding box across all entries */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Information about currently selected split follows */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; first;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* true if no split was selected yet */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; leftUpper;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of left interval */<br/></li>
<li></span>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; rightLower;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of right interval */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; ratio;<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; overlap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dim;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* axis of this split */<br/></li>
<li></span>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* width of general MBR projection to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * selected axis */<br/></li>
<li><a id="L300">&#x200c;</a></span>} <span class="linkable">ConsiderSplitContext</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Interval represents projection of box to axis.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li><a id="L309">&#x200c;</a>} <span class="linkable">SplitInterval</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Interval comparison function by <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of the interval;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L315">&#x200c;</a></span><span class="linkable">interval_cmp_lower</span>(<span class="Type">const</span> <span class="Type">void</span> *i1, <span class="Type">const</span> <span class="Type">void</span> *i2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; lower1 = ((<span class="Type">const</span> <a href="#L309" title="access/gist/gistproc.c:309">SplitInterval</a> *) i1)-&gt;<a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lower2 = ((<span class="Type">const</span> <a href="#L309" title="access/gist/gistproc.c:309">SplitInterval</a> *) i2)-&gt;<a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/adt/float.c.html#L903" title="utils/adt/float.c:903">float8_cmp_internal</a>(lower1, lower2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Interval comparison function by <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of the interval;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L327">&#x200c;</a></span><span class="linkable">interval_cmp_upper</span>(<span class="Type">const</span> <span class="Type">void</span> *i1, <span class="Type">const</span> <span class="Type">void</span> *i2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; upper1 = ((<span class="Type">const</span> <a href="#L309" title="access/gist/gistproc.c:309">SplitInterval</a> *) i1)-&gt;<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; upper2 = ((<span class="Type">const</span> <a href="#L309" title="access/gist/gistproc.c:309">SplitInterval</a> *) i2)-&gt;<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/adt/float.c.html#L903" title="utils/adt/float.c:903">float8_cmp_internal</a>(upper1, upper2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Replace negative (or NaN) value with zero.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">float<br/></li>
<li><a id="L339">&#x200c;</a></span><span class="linkable">non_negative</span>(<span class="Type">float</span> val)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (val &gt;= <span class="Constant">0.0f</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> val;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0.0f</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Consider replacement of currently selected split with the better one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L351">&#x200c;</a></span><span class="linkable">g_box_consider_split</span>(<a href="#L300" title="access/gist/gistproc.c:300">ConsiderSplitContext</a> *context, <span class="Type">int</span> dimNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8 rightLower, <span class="Type">int</span> minLeftCount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8 leftUpper, <span class="Type">int</span> maxLeftCount)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftCount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightCount;<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; ratio,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overlap;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate entries distribution ratio assuming most uniform distribution<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of common entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (minLeftCount &gt;= (context-&gt;entriesCount + <span class="Constant">1</span>) / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leftCount = minLeftCount;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (maxLeftCount &lt;= context-&gt;entriesCount / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftCount = maxLeftCount;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftCount = context-&gt;entriesCount / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; rightCount = context-&gt;entriesCount - leftCount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ratio of split - quotient between size of lesser group and total<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries count.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ratio = float4_div(<a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(leftCount, rightCount), context-&gt;entriesCount);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ratio &gt; <a href="#L44" title="access/gist/gistproc.c:44">LIMIT_RATIO</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; selectthis = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The ratio is acceptable, so <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> current split with previously<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * selected one. Between splits of one dimension we search for minimal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overlap (allowing negative <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>) and minimal ration (between same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overlaps. We switch dimension if <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> less overlap (non-negative)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or less <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> with same overlap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dimNum == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = float8_mi(context-&gt;boundingBox.high.x,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;boundingBox.low.x);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = float8_mi(context-&gt;boundingBox.high.y,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;boundingBox.low.y);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; overlap = float8_div(float8_mi(leftUpper, rightLower), <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If there is no previous selection, <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> this */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context-&gt;first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selectthis = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (context-&gt;dim == dimNum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Within the same dimension, choose the new split if it has a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * smaller overlap, or same overlap but better ratio.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (overlap &lt; context-&gt;overlap ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (overlap == context-&gt;overlap &amp;&amp; ratio &gt; context-&gt;ratio))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selectthis = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Across dimensions, choose the new split if it has a smaller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * *non-negative* overlap, or same *non-negative* overlap but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bigger <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. This condition differs from the one described in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the article. On the datasets where leaf MBRs don't overlap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * themselves, non-overlapping splits (i.e. splits which have zero<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * *non-negative* overlap) are frequently possible. In this case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * splits tends to be along one dimension, because most distant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-overlapping splits (i.e. having lowest negative overlap)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * appears to be in the same dimension as in the previous split.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Therefore MBRs appear to be very prolonged along another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dimension, which leads to bad search performance. Using <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as the second split criteria makes MBRs more quadratic. Using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * *non-negative* overlap instead of overlap as the first split<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * criteria gives to <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> criteria a chance to matter, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-overlapping splits are equivalent in this criteria.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L339" title="access/gist/gistproc.c:339">non_negative</a>(overlap) &lt; <a href="#L339" title="access/gist/gistproc.c:339">non_negative</a>(context-&gt;overlap) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> &gt; context-&gt;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L339" title="access/gist/gistproc.c:339">non_negative</a>(overlap) &lt;= <a href="#L339" title="access/gist/gistproc.c:339">non_negative</a>(context-&gt;overlap)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selectthis = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (selectthis)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* save information about selected split */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;first = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;ratio = ratio;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;overlap = overlap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;rightLower = rightLower;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;leftUpper = leftUpper;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context-&gt;dim = dimNum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compare common entries by their deltas.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L460">&#x200c;</a></span><span class="linkable">common_entry_cmp</span>(<span class="Type">const</span> <span class="Type">void</span> *i1, <span class="Type">const</span> <span class="Type">void</span> *i2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; delta1 = ((<span class="Type">const</span> <a href="#L277" title="access/gist/gistproc.c:277">CommonEntry</a> *) i1)-&gt;delta,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delta2 = ((<span class="Type">const</span> <a href="#L277" title="access/gist/gistproc.c:277">CommonEntry</a> *) i2)-&gt;delta;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/adt/float.c.html#L903" title="utils/adt/float.c:903">float8_cmp_internal</a>(delta1, delta2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * --------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Double sorting split algorithm. This is used for both boxes and points.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The algorithm finds split of boxes by considering splits along each axis.<br/></li>
<li></span><span class="Comment"> * Each entry is first projected as an interval on the X-axis, and different<br/></li>
<li></span><span class="Comment"> * ways to split the intervals into two groups are considered, trying to<br/></li>
<li></span><span class="Comment"> * minimize the overlap of the groups. Then the same is repeated for the<br/></li>
<li></span><span class="Comment"> * Y-axis, and the overall best split is chosen. The quality of a split is<br/></li>
<li></span><span class="Comment"> * determined by overlap along that axis and some other criteria (see<br/></li>
<li></span><span class="Comment"> * <a href="#L351" title="access/gist/gistproc.c:351">g_box_consider_split</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * After that, all the entries are divided into three groups:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1) Entries which should be placed to the left group<br/></li>
<li></span><span class="Comment"> * 2) Entries which should be placed to the right group<br/></li>
<li></span><span class="Comment"> * 3) &quot;Common entries&quot; which can be placed to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of groups without affecting<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; of overlap along selected axis.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The common entries are distributed by minimizing penalty.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For details see:<br/></li>
<li></span><span class="Comment"> * &quot;A new double sorting-based node splitting algorithm for R-tree&quot;, A. Korotkov<br/></li>
<li></span><span class="Comment"> * http://syrcose.ispras.ru/2011/files/SYRCoSE2011_Proceedings.pdf#page=36<br/></li>
<li></span><span class="Comment"> * --------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L495">&#x200c;</a><span class="linkable">gist_box_picksplit</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; GIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; OffsetNumber i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li>&nbsp; &nbsp; <a href="#L300" title="access/gist/gistproc.c:300">ConsiderSplitContext</a> context;<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *leftBox,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *rightBox;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commonEntriesCount;<br/></li>
<li>&nbsp; &nbsp; <a href="#L309" title="access/gist/gistproc.c:309">SplitInterval</a> *intervalsLower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *intervalsUpper;<br/></li>
<li>&nbsp; &nbsp; <a href="#L277" title="access/gist/gistproc.c:277">CommonEntry</a> *commonEntries;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nentries;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;context, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L300" title="access/gist/gistproc.c:300">ConsiderSplitContext</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxoff = entryvec-&gt;n - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; nentries = context.entriesCount = maxoff - FirstOffsetNumber + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate arrays for intervals along axes */<br/></li>
<li></span>&nbsp; &nbsp; intervalsLower = (<a href="#L309" title="access/gist/gistproc.c:309">SplitInterval</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nentries * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L309" title="access/gist/gistproc.c:309">SplitInterval</a>));<br/></li>
<li>&nbsp; &nbsp; intervalsUpper = (<a href="#L309" title="access/gist/gistproc.c:309">SplitInterval</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nentries * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L309" title="access/gist/gistproc.c:309">SplitInterval</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate the overall minimum bounding box over all the entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; box = DatumGetBoxP(entryvec-&gt;vector[i].key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == FirstOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context.boundingBox = *box;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L146" title="access/gist/gistproc.c:146">adjustBox</a>(&amp;context.boundingBox, box);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Iterate over axes for optimal split searching.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; context.first = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing selected yet */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (dim = <span class="Constant">0</span>; dim &lt; <span class="Constant">2</span>; dim++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; leftUpper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightLower;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Project each entry as an interval on the selected axis. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; box = DatumGetBoxP(entryvec-&gt;vector[i].key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dim == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intervalsLower[i - FirstOffsetNumber].<a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = box-&gt;low.x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intervalsLower[i - FirstOffsetNumber].<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = box-&gt;high.x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intervalsLower[i - FirstOffsetNumber].<a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = box-&gt;low.y;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intervalsLower[i - FirstOffsetNumber].<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = box-&gt;high.y;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make two arrays of intervals: one sorted by <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound and another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sorted by <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(intervalsUpper, intervalsLower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L309" title="access/gist/gistproc.c:309">SplitInterval</a>) * nentries);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qsort(intervalsLower, nentries, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L309" title="access/gist/gistproc.c:309">SplitInterval</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L315" title="access/gist/gistproc.c:315">interval_cmp_lower</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qsort(intervalsUpper, nentries, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L309" title="access/gist/gistproc.c:309">SplitInterval</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L327" title="access/gist/gistproc.c:327">interval_cmp_upper</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*----<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The goal is to form a left and right interval, so that every entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interval is contained by either left or right interval (or both).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For example, with the intervals (0,1), (1,3), (2,3), (2,4):<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 0 1 2 3 4<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * +-+<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp;&nbsp; +---+<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; +-+<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; +---+<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The left and right intervals are of the form (0,a) and (b,4).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We first consider splits where b is the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of an entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We iterate through all entries, and for each b, calculate the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * smallest possible a. Then we consider splits where a is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of an entry, and for each a, calculate the greatest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible b.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the above example, the first loop would consider splits:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * b=0: (0,1)-(0,4)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * b=1: (0,1)-(1,4)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * b=2: (0,3)-(2,4)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * And the second loop:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a=1: (0,1)-(1,4)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a=3: (0,3)-(2,4)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a=4: (0,4)-(2,4)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Iterate over <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of right group, finding smallest possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of left group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i1 = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i2 = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rightLower = intervalsLower[i1].<a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leftUpper = intervalsUpper[i2].<a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of right group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (i1 &lt; nentries &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8_eq(rightLower, intervalsLower[i1].<a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (float8_lt(leftUpper, intervalsLower[i1].<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftUpper = intervalsLower[i1].<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i1++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i1 &gt;= nentries)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightLower = intervalsLower[i1].<a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find count of intervals which anyway should be placed to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * left group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (i2 &lt; nentries &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8_le(intervalsUpper[i2].<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, leftUpper))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Consider found split.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L351" title="access/gist/gistproc.c:351">g_box_consider_split</a>(&amp;context, dim, rightLower, i1, leftUpper, i2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Iterate over <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of left group finding greatest possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of right group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i1 = nentries - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i2 = nentries - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rightLower = intervalsLower[i1].<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leftUpper = intervalsUpper[i2].<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of left group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (i2 &gt;= <span class="Constant">0</span> &amp;&amp; float8_eq(leftUpper, intervalsUpper[i2].<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (float8_gt(rightLower, intervalsUpper[i2].<a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightLower = intervalsUpper[i2].<a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i2--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i2 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftUpper = intervalsUpper[i2].<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find count of intervals which anyway should be placed to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * right group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (i1 &gt;= <span class="Constant">0</span> &amp;&amp; float8_ge(intervalsLower[i1].<a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, rightLower))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i1--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Consider found split.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L351" title="access/gist/gistproc.c:351">g_box_consider_split</a>(&amp;context, dim,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rightLower, i1 + <span class="Constant">1</span>, leftUpper, i2 + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we failed to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> acceptable splits, use trivial split.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (context.first)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L216" title="access/gist/gistproc.c:216">fallbackSplit</a>(entryvec, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(v);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ok, we have <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> selected the split across one axis.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * While considering the splits, we already determined that there will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enough entries in both groups to reach the desired ratio, but we did<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not memorize which entries go to which group. So determine that <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate vectors for results */<br/></li>
<li></span>&nbsp; &nbsp; v-&gt;spl_left = (OffsetNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nentries * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_right = (OffsetNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nentries * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_nleft = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_nright = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate bounding boxes of left and right groups */<br/></li>
<li></span>&nbsp; &nbsp; leftBox = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li>&nbsp; &nbsp; rightBox = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate an array for &quot;common entries&quot; - entries which can be placed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either group without affecting overlap along selected axis.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; commonEntriesCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; commonEntries = (<a href="#L277" title="access/gist/gistproc.c:277">CommonEntry</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nentries * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L277" title="access/gist/gistproc.c:277">CommonEntry</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Helper macros to place an entry in the left or right group */<br/></li>
<li><a id="L712">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PLACE_LEFT</span>(box, off)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (v-&gt;spl_nleft &gt; </span><span class="Constant">0</span><span class="PreProc">)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L146" title="access/gist/gistproc.c:146">adjustBox</a>(leftBox, box);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">else</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *leftBox = *(box);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_left[v-&gt;spl_nleft++] = off;&nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L721">&#x200c;</a><span class="PreProc">#define <span class="linkable">PLACE_RIGHT</span>(box, off)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (v-&gt;spl_nright &gt; </span><span class="Constant">0</span><span class="PreProc">)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L146" title="access/gist/gistproc.c:146">adjustBox</a>(rightBox, box);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">else</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rightBox = *(box);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_right[v-&gt;spl_nright++] = off;&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Distribute entries which can be distributed unambiguously, and collect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * common entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> and <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bounds along selected axis.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; box = DatumGetBoxP(entryvec-&gt;vector[i].key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (context.dim == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = box-&gt;low.x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = box-&gt;high.x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = box-&gt;low.y;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = box-&gt;high.y;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (float8_le(<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, context.leftUpper))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fits to the left group */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (float8_ge(<a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, context.rightLower))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fits also to the right group, so &quot;common entry&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commonEntries[commonEntriesCount++].index = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Doesn't fit to the right group, so join to the left group */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L712" title="access/gist/gistproc.c:712">PLACE_LEFT</a>(box, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Each entry should fit on either left or right group. Since this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry didn't fit on the left group, it better fit in the right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(float8_ge(<a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, context.rightLower));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Doesn't fit to the left group, so join to the right group */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L721" title="access/gist/gistproc.c:721">PLACE_RIGHT</a>(box, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Distribute &quot;common entries&quot;, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (commonEntriesCount &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Calculate minimum number of entries that must be placed in both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * groups, to reach <a href="#L44" title="access/gist/gistproc.c:44">LIMIT_RATIO</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; m = ceil(<a href="#L44" title="access/gist/gistproc.c:44">LIMIT_RATIO</a> * nentries);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Calculate delta between penalties of join &quot;common entries&quot; to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * different groups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; commonEntriesCount; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; box = DatumGetBoxP(entryvec-&gt;vector[commonEntries[i].index].key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commonEntries[i].delta = fabs(float8_mi(<a href="#L97" title="access/gist/gistproc.c:97">box_penalty</a>(leftBox, box),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L97" title="access/gist/gistproc.c:97">box_penalty</a>(rightBox, box)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sort &quot;common entries&quot; by calculated deltas in order to distribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the most ambiguous entries first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qsort(commonEntries, commonEntriesCount, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L277" title="access/gist/gistproc.c:277">CommonEntry</a>), <a href="#L460" title="access/gist/gistproc.c:460">common_entry_cmp</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Distribute &quot;common entries&quot; between groups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; commonEntriesCount; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; box = DatumGetBoxP(entryvec-&gt;vector[commonEntries[i].index].key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if we have to place this entry in either group to achieve<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L44" title="access/gist/gistproc.c:44">LIMIT_RATIO</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;spl_nleft + (commonEntriesCount - i) &lt;= m)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L712" title="access/gist/gistproc.c:712">PLACE_LEFT</a>(box, commonEntries[i].index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (v-&gt;spl_nright + (commonEntriesCount - i) &lt;= m)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L721" title="access/gist/gistproc.c:721">PLACE_RIGHT</a>(box, commonEntries[i].index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the group by minimal penalty */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L97" title="access/gist/gistproc.c:97">box_penalty</a>(leftBox, box) &lt; <a href="#L97" title="access/gist/gistproc.c:97">box_penalty</a>(rightBox, box))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L712" title="access/gist/gistproc.c:712">PLACE_LEFT</a>(box, commonEntries[i].index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L721" title="access/gist/gistproc.c:721">PLACE_RIGHT</a>(box, commonEntries[i].index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_ldatum = PointerGetDatum(leftBox);<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_rdatum = PointerGetDatum(rightBox);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(v);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Equality method<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used for boxes, points, circles, and polygons, all of which store<br/></li>
<li></span><span class="Comment"> * boxes as GiST index entries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true only when boxes are exactly the same.&nbsp; We can't use fuzzy<br/></li>
<li></span><span class="Comment"> * comparisons here without breaking index consistency; therefore, this isn't<br/></li>
<li></span><span class="Comment"> * equivalent to <a href="../../utils/adt/geo_ops.c.html#L551" title="utils/adt/geo_ops.c:551">box_same</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L852">&#x200c;</a><span class="linkable">gist_box_same</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *b1 = PG_GETARG_BOX_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *b2 = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *result = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (b1 &amp;&amp; b2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = (float8_eq(b1-&gt;low.x, b2-&gt;low.x) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8_eq(b1-&gt;low.y, b2-&gt;low.y) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8_eq(b1-&gt;high.x, b2-&gt;high.x) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; float8_eq(b1-&gt;high.y, b2-&gt;high.y));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *result = (b1 == <span class="Constant">NULL</span> &amp;&amp; b2 == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Leaf-level consistency for boxes: just apply the query operator<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L872">&#x200c;</a></span><span class="linkable">gist_box_leaf_consistent</span>(BOX *key, BOX *query, StrategyNumber strategy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; retval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (strategy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTLeftStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L583" title="utils/adt/geo_ops.c:583">box_left</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTOverLeftStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L598" title="utils/adt/geo_ops.c:598">box_overleft</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTOverlapStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L563" title="utils/adt/geo_ops.c:563">box_overlap</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTOverRightStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L624" title="utils/adt/geo_ops.c:624">box_overright</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTRightStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L609" title="utils/adt/geo_ops.c:609">box_right</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTSameStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L551" title="utils/adt/geo_ops.c:551">box_same</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTContainsStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L692" title="utils/adt/geo_ops.c:692">box_contain</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTContainedByStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L681" title="utils/adt/geo_ops.c:681">box_contained</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTOverBelowStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L647" title="utils/adt/geo_ops.c:647">box_overbelow</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTBelowStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L635" title="utils/adt/geo_ops.c:635">box_below</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTAboveStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L658" title="utils/adt/geo_ops.c:658">box_above</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTOverAboveStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L670" title="utils/adt/geo_ops.c:670">box_overabove</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized strategy number: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*****************************************<br/></li>
<li></span><span class="Comment"> * Common rtree <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> (for boxes, polygons, and circles)<br/></li>
<li></span><span class="Comment"> *****************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Internal-page consistency for all these types<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can use the same function since all types use bounding boxes as the<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>-page representation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L957">&#x200c;</a></span><span class="linkable">rtree_internal_consistent</span>(BOX *key, BOX *query, StrategyNumber strategy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; retval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (strategy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTLeftStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = !DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L624" title="utils/adt/geo_ops.c:624">box_overright</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTOverLeftStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = !DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L609" title="utils/adt/geo_ops.c:609">box_right</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTOverlapStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L563" title="utils/adt/geo_ops.c:563">box_overlap</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTOverRightStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = !DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L583" title="utils/adt/geo_ops.c:583">box_left</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTRightStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = !DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L598" title="utils/adt/geo_ops.c:598">box_overleft</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTSameStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTContainsStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L692" title="utils/adt/geo_ops.c:692">box_contain</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTContainedByStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L563" title="utils/adt/geo_ops.c:563">box_overlap</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTOverBelowStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = !DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L658" title="utils/adt/geo_ops.c:658">box_above</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTBelowStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = !DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L670" title="utils/adt/geo_ops.c:670">box_overabove</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTAboveStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = !DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L647" title="utils/adt/geo_ops.c:647">box_overbelow</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTOverAboveStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = !DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L635" title="utils/adt/geo_ops.c:635">box_below</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(query)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized strategy number: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/**************************************************<br/></li>
<li></span><span class="Comment"> * Polygon ops<br/></li>
<li></span><span class="Comment"> **************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GiST compress for polygons: represent a polygon by its bounding box<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1035">&#x200c;</a><span class="linkable">gist_poly_compress</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *entry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *retval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;leafkey)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; POLYGON&nbsp; &nbsp; *in = DatumGetPolygonP(entry-&gt;key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r = (BOX *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(r, &amp;(in-&gt;boundbox), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; retval = (GISTENTRY *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTENTRY));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gistentryinit(*retval, PointerGetDatum(r),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;rel, entry-&gt;page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;offset, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; retval = entry;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(retval);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The GiST Consistent method for polygons<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1062">&#x200c;</a><span class="linkable">gist_poly_consistent</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *entry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; POLYGON&nbsp; &nbsp; *query = PG_GETARG_POLYGON_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Oid&nbsp; &nbsp; &nbsp; &nbsp; subtype = PG_GETARG_OID(3); */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *recheck = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) PG_GETARG_POINTER(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All cases served by this function are inexact */<br/></li>
<li></span>&nbsp; &nbsp; *recheck = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBoxP(entry-&gt;key) == <span class="Constant">NULL</span> || query == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since the operators require recheck anyway, we can just use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L957" title="access/gist/gistproc.c:957">rtree_internal_consistent</a> even at leaf nodes.&nbsp; (This works in part<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because the index entries are bounding boxes not polygons.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L957" title="access/gist/gistproc.c:957">rtree_internal_consistent</a>(DatumGetBoxP(entry-&gt;key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;(query-&gt;boundbox), strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Avoid memory leak if supplied poly is toasted */<br/></li>
<li></span>&nbsp; &nbsp; PG_FREE_IF_COPY(query, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/**************************************************<br/></li>
<li></span><span class="Comment"> * Circle ops<br/></li>
<li></span><span class="Comment"> **************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GiST compress for circles: represent a circle by its bounding box<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1100">&#x200c;</a><span class="linkable">gist_circle_compress</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *entry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *retval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;leafkey)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *in = DatumGetCircleP(entry-&gt;key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r = (BOX *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r-&gt;high.x = float8_pl(in-&gt;center.x, in-&gt;radius);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r-&gt;low.x = float8_mi(in-&gt;center.x, in-&gt;radius);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r-&gt;high.y = float8_pl(in-&gt;center.y, in-&gt;radius);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r-&gt;low.y = float8_mi(in-&gt;center.y, in-&gt;radius);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; retval = (GISTENTRY *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTENTRY));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gistentryinit(*retval, PointerGetDatum(r),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;rel, entry-&gt;page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;offset, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; retval = entry;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(retval);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The GiST Consistent method for circles<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1130">&#x200c;</a><span class="linkable">gist_circle_consistent</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *entry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *query = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Oid&nbsp; &nbsp; &nbsp; &nbsp; subtype = PG_GETARG_OID(3); */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *recheck = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) PG_GETARG_POINTER(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bbox;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All cases served by this function are inexact */<br/></li>
<li></span>&nbsp; &nbsp; *recheck = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBoxP(entry-&gt;key) == <span class="Constant">NULL</span> || query == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since the operators require recheck anyway, we can just use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L957" title="access/gist/gistproc.c:957">rtree_internal_consistent</a> even at leaf nodes.&nbsp; (This works in part<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because the index entries are bounding boxes not circles.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bbox.high.x = float8_pl(query-&gt;center.x, query-&gt;radius);<br/></li>
<li>&nbsp; &nbsp; bbox.low.x = float8_mi(query-&gt;center.x, query-&gt;radius);<br/></li>
<li>&nbsp; &nbsp; bbox.high.y = float8_pl(query-&gt;center.y, query-&gt;radius);<br/></li>
<li>&nbsp; &nbsp; bbox.low.y = float8_mi(query-&gt;center.y, query-&gt;radius);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L957" title="access/gist/gistproc.c:957">rtree_internal_consistent</a>(DatumGetBoxP(entry-&gt;key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;bbox, strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/**************************************************<br/></li>
<li></span><span class="Comment"> * Point ops<br/></li>
<li></span><span class="Comment"> **************************************************/<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1168">&#x200c;</a><span class="linkable">gist_point_compress</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *entry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;leafkey)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Point, actually */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BOX));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *point = DatumGetPointP(entry-&gt;key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GISTENTRY&nbsp; *retval = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTENTRY));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; box-&gt;high = box-&gt;low = *point;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gistentryinit(*retval, BoxPGetDatum(box),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;rel, entry-&gt;page, entry-&gt;offset, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_POINTER(retval);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(entry);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GiST Fetch method for point<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Get point coordinates from its bounding box coordinates and form new<br/></li>
<li></span><span class="Comment"> * gistentry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1196">&#x200c;</a><span class="linkable">gist_point_fetch</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *entry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *in = DatumGetBoxP(entry-&gt;key);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *r;<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *retval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; retval = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTENTRY));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; r = (Point *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Point));<br/></li>
<li>&nbsp; &nbsp; r-&gt;x = in-&gt;high.x;<br/></li>
<li>&nbsp; &nbsp; r-&gt;y = in-&gt;high.y;<br/></li>
<li>&nbsp; &nbsp; gistentryinit(*retval, PointerGetDatum(r),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;rel, entry-&gt;page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;offset, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(retval);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1216">&#x200c;</a><span class="PreProc">#define <span class="linkable">point_point_distance</span>(p1,p2) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; DatumGetFloat8(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L1993" title="utils/adt/geo_ops.c:1993">point_distance</a>, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointPGetDatum(p1), PointPGetDatum(p2)))<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> float8<br/></li>
<li><a id="L1221">&#x200c;</a><span class="linkable">computeDistance</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isLeaf, BOX *box, Point *point)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isLeaf)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* simple point to point distance */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../spgist/spgproc.c.html#L25" title="access/spgist/spgproc.c:25">point_point_distance</a>(point, &amp;box-&gt;low);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (point-&gt;x &lt;= box-&gt;high.x &amp;&amp; point-&gt;x &gt;= box-&gt;low.x &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; point-&gt;y &lt;= box-&gt;high.y &amp;&amp; point-&gt;y &gt;= box-&gt;low.y)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* point inside the box */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (point-&gt;x &lt;= box-&gt;high.x &amp;&amp; point-&gt;x &gt;= box-&gt;low.x)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* point is over or below box */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(box-&gt;low.y &lt;= box-&gt;high.y);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (point-&gt;y &gt; box-&gt;high.y)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = float8_mi(point-&gt;y, box-&gt;high.y);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (point-&gt;y &lt; box-&gt;low.y)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = float8_mi(box-&gt;low.y, point-&gt;y);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;inconsistent point <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (point-&gt;y &lt;= box-&gt;high.y &amp;&amp; point-&gt;y &gt;= box-&gt;low.y)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* point is to left or right of box */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(box-&gt;low.x &lt;= box-&gt;high.x);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (point-&gt;x &gt; box-&gt;high.x)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = float8_mi(point-&gt;x, box-&gt;high.x);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (point-&gt;x &lt; box-&gt;low.x)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = float8_mi(box-&gt;low.x, point-&gt;x);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;inconsistent point <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* closest point will be a vertex */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp; &nbsp; p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; subresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../spgist/spgproc.c.html#L25" title="access/spgist/spgproc.c:25">point_point_distance</a>(point, &amp;box-&gt;low);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subresult = <a href="../spgist/spgproc.c.html#L25" title="access/spgist/spgproc.c:25">point_point_distance</a>(point, &amp;box-&gt;high);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &gt; subresult)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = subresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p.x = box-&gt;low.x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p.y = box-&gt;high.y;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subresult = <a href="../spgist/spgproc.c.html#L25" title="access/spgist/spgproc.c:25">point_point_distance</a>(point, &amp;p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &gt; subresult)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = subresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p.x = box-&gt;high.x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p.y = box-&gt;low.y;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subresult = <a href="../spgist/spgproc.c.html#L25" title="access/spgist/spgproc.c:25">point_point_distance</a>(point, &amp;p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &gt; subresult)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = subresult;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1287">&#x200c;</a></span><span class="linkable">gist_point_consistent_internal</span>(StrategyNumber strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isLeaf, BOX *key, Point *query)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (strategy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTLeftStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = FPlt(key-&gt;low.x, query-&gt;x);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTRightStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = FPgt(key-&gt;high.x, query-&gt;x);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTAboveStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = FPgt(key-&gt;high.y, query-&gt;y);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTBelowStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = FPlt(key-&gt;low.y, query-&gt;y);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTSameStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isLeaf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* key.high must <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> key.low, so we can disregard it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (FPeq(key-&gt;low.x, query-&gt;x) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FPeq(key-&gt;low.y, query-&gt;y));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (FPle(query-&gt;x, key-&gt;high.x) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FPge(query-&gt;x, key-&gt;low.x) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FPle(query-&gt;y, key-&gt;high.y) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FPge(query-&gt;y, key-&gt;low.y));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized strategy number: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L1330">&#x200c;</a><span class="PreProc">#define <span class="linkable">GeoStrategyNumberOffset</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">20<br/></li>
<li><a id="L1331">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PointStrategyNumberGroup</span>&nbsp; &nbsp; </span><span class="Constant">0<br/></li>
<li><a id="L1332">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BoxStrategyNumberGroup</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1<br/></li>
<li><a id="L1333">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PolygonStrategyNumberGroup</span>&nbsp; &nbsp; </span><span class="Constant">2<br/></li>
<li><a id="L1334">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CircleStrategyNumberGroup</span>&nbsp; &nbsp; </span><span class="Constant">3<br/></li>
<li></span><br/></li>
<li>Datum<br/></li>
<li><a id="L1337">&#x200c;</a><span class="linkable">gist_point_consistent</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *entry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *recheck = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) PG_GETARG_POINTER(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strategyGroup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to remap these strategy numbers to get this klugy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * classification logic to work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strategy == RTOldBelowStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strategy = RTBelowStrategyNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strategy == RTOldAboveStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strategy = RTAboveStrategyNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; strategyGroup = strategy / <a href="#L1330" title="access/gist/gistproc.c:1330">GeoStrategyNumberOffset</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (strategyGroup)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1331" title="access/gist/gistproc.c:1331">PointStrategyNumberGroup</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1287" title="access/gist/gistproc.c:1287">gist_point_consistent_internal</a>(strategy % <a href="#L1330" title="access/gist/gistproc.c:1330">GeoStrategyNumberOffset</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GIST_LEAF(entry),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetBoxP(entry-&gt;key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_GETARG_POINT_P(<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *recheck = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1332" title="access/gist/gistproc.c:1332">BoxStrategyNumberGroup</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The only operator in this group is point &lt;@ box (<a href="../../utils/adt/geo_ops.c.html#L3137" title="utils/adt/geo_ops.c:3137">on_pb</a>), so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we needn't examine strategy again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For historical reasons, <a href="../../utils/adt/geo_ops.c.html#L3137" title="utils/adt/geo_ops.c:3137">on_pb</a> uses exact rather than fuzzy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comparisons.&nbsp; We could use <a href="../../utils/adt/geo_ops.c.html#L563" title="utils/adt/geo_ops.c:563">box_overlap</a> when at an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page, but that would lead to possibly visiting child pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * uselessly, because <a href="../../utils/adt/geo_ops.c.html#L563" title="utils/adt/geo_ops.c:563">box_overlap</a> uses fuzzy comparisons.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Instead we write a non-fuzzy overlap test.&nbsp; The same code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will also serve for leaf-page tests, since leaf keys have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * high == low.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *query,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *key;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query = PG_GETARG_BOX_P(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key = DatumGetBoxP(entry-&gt;key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (key-&gt;high.x &gt;= query-&gt;low.x &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;low.x &lt;= query-&gt;high.x &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;high.y &gt;= query-&gt;low.y &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;low.y &lt;= query-&gt;high.y);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *recheck = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1333" title="access/gist/gistproc.c:1333">PolygonStrategyNumberGroup</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; POLYGON&nbsp; &nbsp; *query = PG_GETARG_POLYGON_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = DatumGetBool(DirectFunctionCall5(<a href="#L1062" title="access/gist/gistproc.c:1062">gist_poly_consistent</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(entry),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PolygonPGetDatum(query),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int16GetDatum(RTOverlapStrategyNumber),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, PointerGetDatum(recheck)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GIST_LEAF(entry) &amp;&amp; result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are on leaf page and quick check shows overlapping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of polygon's bounding box and point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = DatumGetBoxP(entry-&gt;key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(box-&gt;high.x == box-&gt;low.x<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;&amp; box-&gt;high.y == box-&gt;low.y);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L4008" title="utils/adt/geo_ops.c:4008">poly_contain_pt</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PolygonPGetDatum(query),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointPGetDatum(&amp;box-&gt;high)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *recheck = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1334" title="access/gist/gistproc.c:1334">CircleStrategyNumberGroup</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CIRCLE&nbsp; &nbsp; &nbsp;&nbsp; *query = PG_GETARG_CIRCLE_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = DatumGetBool(DirectFunctionCall5(<a href="#L1130" title="access/gist/gistproc.c:1130">gist_circle_consistent</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(entry),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CirclePGetDatum(query),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int16GetDatum(RTOverlapStrategyNumber),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, PointerGetDatum(recheck)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GIST_LEAF(entry) &amp;&amp; result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are on leaf page and quick check shows overlapping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of polygon's bounding box and point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = DatumGetBoxP(entry-&gt;key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(box-&gt;high.x == box-&gt;low.x<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;&amp; box-&gt;high.y == box-&gt;low.y);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/geo_ops.c.html#L5082" title="utils/adt/geo_ops.c:5082">circle_contain_pt</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CirclePGetDatum(query),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointPGetDatum(&amp;box-&gt;high)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *recheck = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized strategy number: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1455">&#x200c;</a><span class="linkable">gist_point_distance</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *entry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; distance;<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strategyGroup = strategy / <a href="#L1330" title="access/gist/gistproc.c:1330">GeoStrategyNumberOffset</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (strategyGroup)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1331" title="access/gist/gistproc.c:1331">PointStrategyNumberGroup</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; distance = <a href="#L1221" title="access/gist/gistproc.c:1221">computeDistance</a>(GIST_LEAF(entry),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DatumGetBoxP(entry-&gt;key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GETARG_POINT_P(<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized strategy number: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; distance = <span class="Constant">0.0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(distance);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> float8<br/></li>
<li><a id="L1479">&#x200c;</a><span class="linkable">gist_bbox_distance</span>(GISTENTRY *entry, Datum query, StrategyNumber strategy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; distance;<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strategyGroup = strategy / <a href="#L1330" title="access/gist/gistproc.c:1330">GeoStrategyNumberOffset</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (strategyGroup)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L1331" title="access/gist/gistproc.c:1331">PointStrategyNumberGroup</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; distance = <a href="#L1221" title="access/gist/gistproc.c:1221">computeDistance</a>(<span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DatumGetBoxP(entry-&gt;key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DatumGetPointP(query));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized strategy number: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; distance = <span class="Constant">0.0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> distance;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1500">&#x200c;</a><span class="linkable">gist_box_distance</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *entry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; query = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Oid subtype = PG_GETARG_OID(3); */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a>&nbsp; &nbsp; &nbsp;&nbsp; *recheck = (<a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> *) PG_GETARG_POINTER(4); */<br/></li>
<li></span>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; distance;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; distance = <a href="#L1479" title="access/gist/gistproc.c:1479">gist_bbox_distance</a>(entry, query, strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(distance);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The inexact GiST distance methods for geometric types that store bounding<br/></li>
<li></span><span class="Comment"> * boxes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Compute lossy distance from point to index entries.&nbsp; The result is inexact<br/></li>
<li></span><span class="Comment"> * because index entries are bounding boxes, not the exact shapes of the<br/></li>
<li></span><span class="Comment"> * indexed geometric types.&nbsp; We use distance from point to MBR of index entry.<br/></li>
<li></span><span class="Comment"> * This is a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound estimate of distance from point to indexed geometric<br/></li>
<li></span><span class="Comment"> * type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1526">&#x200c;</a><span class="linkable">gist_circle_distance</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *entry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; query = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Oid subtype = PG_GETARG_OID(3); */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *recheck = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) PG_GETARG_POINTER(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; distance;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; distance = <a href="#L1479" title="access/gist/gistproc.c:1479">gist_bbox_distance</a>(entry, query, strategy);<br/></li>
<li>&nbsp; &nbsp; *recheck = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(distance);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1543">&#x200c;</a><span class="linkable">gist_poly_distance</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; *entry = (GISTENTRY *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; query = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Oid subtype = PG_GETARG_OID(3); */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *recheck = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) PG_GETARG_POINTER(<span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; distance;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; distance = <a href="#L1479" title="access/gist/gistproc.c:1479">gist_bbox_distance</a>(entry, query, strategy);<br/></li>
<li>&nbsp; &nbsp; *recheck = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(distance);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Z-order routines for fast index build<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute Z-value of a point<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Z-order (also known as Morton Code) <a href="../../utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> a two-dimensional point to a<br/></li>
<li></span><span class="Comment"> * single integer, in a way that preserves locality. Points that are close in<br/></li>
<li></span><span class="Comment"> * the two-dimensional space are mapped to integer that are not far from each<br/></li>
<li></span><span class="Comment"> * other. We do that by interleaving the bits in the X and Y components.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Morton Code is normally defined only for integers, but the X and Y <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * of a point are floating point. We expect floats to be in IEEE format.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint64<br/></li>
<li><a id="L1575">&#x200c;</a><span class="linkable">point_zorder_internal</span>(float4 x, float4 y)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; ix = <a href="#L1603" title="access/gist/gistproc.c:1603">ieee_float32_to_uint32</a>(x);<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; iy = <a href="#L1603" title="access/gist/gistproc.c:1603">ieee_float32_to_uint32</a>(y);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Interleave the bits */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1586" title="access/gist/gistproc.c:1586">part_bits32_by2</a>(ix) | (<a href="#L1586" title="access/gist/gistproc.c:1586">part_bits32_by2</a>(iy) &lt;&lt; <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Interleave 32 bits with zeroes */<br/></li>
<li></span><span class="Type">static</span> uint64<br/></li>
<li><a id="L1586">&#x200c;</a><span class="linkable">part_bits32_by2</span>(uint32 x)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; n = x;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n = (n | (n &lt;&lt; <span class="Constant">16</span>)) &amp; UINT64CONST(<span class="Constant">0x0000FFFF0000FFFF</span>);<br/></li>
<li>&nbsp; &nbsp; n = (n | (n &lt;&lt; <span class="Constant">8</span>)) &amp; UINT64CONST(<span class="Constant">0x00FF00FF00FF00FF</span>);<br/></li>
<li>&nbsp; &nbsp; n = (n | (n &lt;&lt; <span class="Constant">4</span>)) &amp; UINT64CONST(<span class="Constant">0x0F0F0F0F0F0F0F0F</span>);<br/></li>
<li>&nbsp; &nbsp; n = (n | (n &lt;&lt; <span class="Constant">2</span>)) &amp; UINT64CONST(<span class="Constant">0x3333333333333333</span>);<br/></li>
<li>&nbsp; &nbsp; n = (n | (n &lt;&lt; <span class="Constant">1</span>)) &amp; UINT64CONST(<span class="Constant">0x5555555555555555</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert a 32-<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> IEEE float to uint32 in a way that preserves the ordering<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint32<br/></li>
<li><a id="L1603">&#x200c;</a><span class="linkable">ieee_float32_to_uint32</span>(<span class="Type">float</span> f)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * IEEE 754 floating point format<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * IEEE 754 floating point numbers have this format:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; exponent (8 bits)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * s eeeeeeee mmmmmmmmmmmmmmmmmmmmmmm<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sign&nbsp; &nbsp; &nbsp;&nbsp; mantissa (23 bits)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Infinity has all bits in the exponent set and the mantissa is all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * zeros. Negative infinity is the same but with the sign <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NaNs are represented with all bits in the exponent set, and the least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * significant <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in the mantissa also set. The rest of the mantissa bits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can be used to distinguish different kinds of NaNs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The IEEE format has the nice property that when you take the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * representation and interpret it as an integer, the order is preserved,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * except for the sign. That holds for the +-Infinity <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mapping to uint32<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * -----------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In order to have a smooth transition from negative to positive numbers,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we map floats to unsigned integers like this:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * x &lt; 0 to <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> 0-7FFFFFFF<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * x = 0 to value 8000000 (both positive and negative zero)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * x &gt; 0 to <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> 8000001-FFFFFFFF<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't care to distinguish different kind of NaNs, so they are all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mapped to the same arbitrary value, FFFFFFFF. Because of the IEEE <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * representation of NaNs, there aren't <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-NaN <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mapped to FFFFFFFF. In fact, there is a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of unused <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> on both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ends of the uint32 space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(f))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0xFFFFFFFF</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">union<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">float</span>&nbsp; &nbsp; &nbsp; &nbsp; f;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; u.f = f;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check the sign <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((u.i &amp; <span class="Constant">0x80000000</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Map the negative value to <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> 0-7FFFFFFF. This flips the sign<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> to 0 in the same instruction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(f &lt;= <span class="Constant">0</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can be -0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u.i ^= <span class="Constant">0xFFFFFFFF</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Map the positive value (or 0) to <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> 80000000-FFFFFFFF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u.i |= <span class="Constant">0x80000000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> u.i;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compare the Z-order of points<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1681">&#x200c;</a></span><span class="linkable">gist_bbox_zorder_cmp</span>(Datum a, Datum b, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p1 = &amp;(DatumGetBoxP(a)-&gt;low);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p2 = &amp;(DatumGetBoxP(b)-&gt;low);<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; z1;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; z2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do a quick check for equality first. It's not clear if this is worth it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in general, but certainly is when used as tie-breaker with abbreviated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keys,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (p1-&gt;x == p2-&gt;x &amp;&amp; p1-&gt;y == p2-&gt;y)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; z1 = <a href="#L1575" title="access/gist/gistproc.c:1575">point_zorder_internal</a>(p1-&gt;x, p1-&gt;y);<br/></li>
<li>&nbsp; &nbsp; z2 = <a href="#L1575" title="access/gist/gistproc.c:1575">point_zorder_internal</a>(p2-&gt;x, p2-&gt;y);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (z1 &gt; z2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (z1 &lt; z2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Abbreviated version of Z-order comparison<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The abbreviated format is a Z-order value computed from the two 32-<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment"> * floats. If SIZEOF_DATUM == 8, the 64-<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> Z-order value fits fully in the<br/></li>
<li></span><span class="Comment"> * abbreviated Datum, otherwise use its most significant bits.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L1714">&#x200c;</a><span class="linkable">gist_bbox_zorder_abbrev_convert</span>(Datum original, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p = &amp;(DatumGetBoxP(original)-&gt;low);<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; z;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; z = <a href="#L1575" title="access/gist/gistproc.c:1575">point_zorder_internal</a>(p-&gt;x, p-&gt;y);<br/></li>
<li><br/></li>
<li><span class="PreProc">#if SIZEOF_DATUM == </span><span class="Constant">8<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (Datum) z;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (Datum) (z &gt;&gt; <span class="Constant">32</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We never consider aborting the abbreviation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On 64-<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> systems, the abbreviation is not lossy so it is always<br/></li>
<li></span><span class="Comment"> * worthwhile. (Perhaps it's not on 32-<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> systems, but we don't bother<br/></li>
<li></span><span class="Comment"> * with logic to decide.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1736">&#x200c;</a></span><span class="linkable">gist_bbox_zorder_abbrev_abort</span>(<span class="Type">int</span> memtupcount, SortSupport ssup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sort support routine for fast GiST index build by sorting.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1745">&#x200c;</a><span class="linkable">gist_point_sortsupport</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortSupport ssup = (SortSupport) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ssup-&gt;abbreviate)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;comparator = <a href="../../utils/sort/tuplesort.c.html#L3177" title="utils/sort/tuplesort.c:3177">ssup_datum_unsigned_cmp</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;abbrev_converter = <a href="#L1714" title="access/gist/gistproc.c:1714">gist_bbox_zorder_abbrev_convert</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;abbrev_abort = <a href="#L1736" title="access/gist/gistproc.c:1736">gist_bbox_zorder_abbrev_abort</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;abbrev_full_comparator = <a href="#L1681" title="access/gist/gistproc.c:1681">gist_bbox_zorder_cmp</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ssup-&gt;comparator = <a href="#L1681" title="access/gist/gistproc.c:1681">gist_bbox_zorder_cmp</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
