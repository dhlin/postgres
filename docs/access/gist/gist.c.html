<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/gist/gist.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/gist/gist.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L122">createTempGistContext</a></li>
<li><a href="#L1653">freeGISTstate</a></li>
<li><a href="#L1022">gistFindCorrectParent</a></li>
<li><a href="#L909">gistFindPath</a></li>
<li><a href="#L1438">gistSplit</a></li>
<li><a href="#L133">gistbuildempty</a></li>
<li><a href="#L634">gistdoinsert</a></li>
<li><a href="#L1342">gistfinishsplit</a></li>
<li><a href="#L1188">gistfixsplit</a></li>
<li><a href="#L1128">gistformdownlink</a></li>
<li><a href="#L59">gisthandler</a></li>
<li><a href="#L159">gistinsert</a></li>
<li><a href="#L1248">gistinserttuple</a></li>
<li><a href="#L1282">gistinserttuples</a></li>
<li><a href="#L225">gistplacetopage</a></li>
<li><a href="#L1664">gistprunepage</a></li>
<li><a href="#L1525">initGISTstate</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L45">ROTATEDIST</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * gist.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; interface routines for the postgres GiST index access method.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/gist/gist.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/gist_private.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/gistscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_collation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/execnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/index_selfuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* non-export function prototypes */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1188" title="access/gist/gist.c:1188">gistfixsplit</a>(GISTInsertState *state, GISTSTATE *giststate);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1248" title="access/gist/gist.c:1248">gistinserttuple</a>(GISTInsertState *state, GISTInsertStack *stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GISTSTATE *giststate, IndexTuple tuple, OffsetNumber oldoffnum);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1282" title="access/gist/gist.c:1282">gistinserttuples</a>(GISTInsertState *state, GISTInsertStack *stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GISTSTATE *giststate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTuple *tuples, <span class="Type">int</span> ntup, OffsetNumber oldoffnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer <a href="../../storage/freespace/fsmpage.c.html#L29" title="storage/freespace/fsmpage.c:29">leftchild</a>, Buffer <a href="../../storage/freespace/fsmpage.c.html#L30" title="storage/freespace/fsmpage.c:30">rightchild</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> unlockbuf, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> unlockleftchild);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1342" title="access/gist/gist.c:1342">gistfinishsplit</a>(GISTInsertState *state, GISTInsertStack *stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GISTSTATE *giststate, List *splitinfo, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> unlockbuf);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1664" title="access/gist/gist.c:1664">gistprunepage</a>(Relation rel, Page page, Buffer buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation heapRel);<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L45">&#x200c;</a><span class="PreProc">#define <span class="linkable">ROTATEDIST</span>(d) </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; SplitPageLayout *tmp=(SplitPageLayout*)<a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(</span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(SplitPageLayout)); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; tmp-&gt;block.blkno = InvalidBlockNumber;&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; tmp-&gt;buffer = InvalidBuffer;&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; tmp-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = (d); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (d)=tmp; \<br/></li>
<li></span><span class="PreProc">} </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GiST handler function: return IndexAmRoutine with access method parameters<br/></li>
<li></span><span class="Comment"> * and callbacks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L59">&#x200c;</a><span class="linkable">gisthandler</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexAmRoutine *amroutine = makeNode(IndexAmRoutine);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amstrategies = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsupport = GISTNProcs;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amoptsprocnum = GIST_OPTIONS_PROC;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanorder = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanorderbyop = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanbackward = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanunique = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanmulticol = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amoptionalkey = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsearcharray = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsearchnulls = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amstorage = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amclusterable = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ampredlocks = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanparallel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanbuildparallel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcaninclude = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amusemaintenanceworkmem = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsummarizing = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amparallelvacuumoptions =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VACUUM_OPTION_PARALLEL_BULKDEL | VACUUM_OPTION_PARALLEL_COND_CLEANUP;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amkeytype = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambuild = <a href="gistbuild.c.html#L179" title="access/gist/gistbuild.c:179">gistbuild</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambuildempty = <a href="#L133" title="access/gist/gist.c:133">gistbuildempty</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;aminsert = <a href="#L159" title="access/gist/gist.c:159">gistinsert</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;aminsertcleanup = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambulkdelete = <a href="gistvacuum.c.html#L59" title="access/gist/gistvacuum.c:59">gistbulkdelete</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amvacuumcleanup = <a href="gistvacuum.c.html#L75" title="access/gist/gistvacuum.c:75">gistvacuumcleanup</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanreturn = <a href="gistget.c.html#L793" title="access/gist/gistget.c:793">gistcanreturn</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcostestimate = <a href="../../utils/adt/selfuncs.c.html#L7173" title="utils/adt/selfuncs.c:7173">gistcostestimate</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amoptions = <a href="gistutil.c.html#L912" title="access/gist/gistutil.c:912">gistoptions</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amproperty = <a href="gistutil.c.html#L933" title="access/gist/gistutil.c:933">gistproperty</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambuildphasename = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;<a href="../index/amapi.c.html#L114" title="access/index/amapi.c:114">amvalidate</a> = <a href="gistvalidate.c.html#L33" title="access/gist/gistvalidate.c:33">gistvalidate</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amadjustmembers = <a href="gistvalidate.c.html#L295" title="access/gist/gistvalidate.c:295">gistadjustmembers</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambeginscan = <a href="gistscan.c.html#L74" title="access/gist/gistscan.c:74">gistbeginscan</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amrescan = <a href="gistscan.c.html#L127" title="access/gist/gistscan.c:127">gistrescan</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amgettuple = <a href="gistget.c.html#L612" title="access/gist/gistget.c:612">gistgettuple</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amgetbitmap = <a href="gistget.c.html#L743" title="access/gist/gistget.c:743">gistgetbitmap</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amendscan = <a href="gistscan.c.html#L349" title="access/gist/gistscan.c:349">gistendscan</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ammarkpos = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amrestrpos = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amestimateparallelscan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;aminitparallelscan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amparallelrescan = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(amroutine);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create and return a temporary memory context for use by GiST. We<br/></li>
<li></span><span class="Comment"> * _always_ invoke user-provided methods in a temporary memory<br/></li>
<li></span><span class="Comment"> * context, so that memory leaks in those <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> cannot cause<br/></li>
<li></span><span class="Comment"> * problems. Also, we use some additional temporary contexts in the<br/></li>
<li></span><span class="Comment"> * GiST code itself, to avoid the need to do some awkward manual<br/></li>
<li></span><span class="Comment"> * memory management.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MemoryContext<br/></li>
<li><a id="L122">&#x200c;</a><span class="linkable">createTempGistContext</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;GiST temporary context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L133" title="access/gist/gist.c:133">gistbuildempty</a>() -- build an empty gist index in the initialization fork<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L133">&#x200c;</a></span><span class="linkable">gistbuildempty</span>(Relation index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the root page */<br/></li>
<li></span>&nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L845" title="storage/buffer/bufmgr.c:845">ExtendBufferedRel</a>(BMR_REL(index), INIT_FORKNUM, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EB_SKIP_EXTENSION_LOCK | EB_LOCK_FIRST);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize and xlog buffer */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; <a href="gistutil.c.html#L773" title="access/gist/gistutil.c:773">GISTInitBuffer</a>(buffer, F_LEAF);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L1237" title="access/transam/xloginsert.c:1237">log_newpage_buffer</a>(buffer, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unlock and release the buffer */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L159" title="access/gist/gist.c:159">gistinsert</a> -- wrapper for GiST tuple insertion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This is the public interface routine for tuple insertion in GiSTs.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; It doesn't do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> work; just locks the relation and passes the buck.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L159">&#x200c;</a></span><span class="linkable">gistinsert</span>(Relation r, Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointer ht_ctid, Relation heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexUniqueCheck checkUnique,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> indexUnchanged,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexInfo *indexInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTSTATE&nbsp; *giststate = (GISTSTATE *) indexInfo-&gt;ii_AmCache;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldCxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize GISTSTATE cache if first call in this statement */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (giststate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldCxt = MemoryContextSwitchTo(indexInfo-&gt;ii_Context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; giststate = <a href="#L1525" title="access/gist/gist.c:1525">initGISTstate</a>(r);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; giststate-&gt;tempCxt = <a href="#L122" title="access/gist/gist.c:122">createTempGistContext</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexInfo-&gt;ii_AmCache = (<span class="Type">void</span> *) giststate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldCxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldCxt = MemoryContextSwitchTo(giststate-&gt;tempCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itup = <a href="gistutil.c.html#L575" title="access/gist/gistutil.c:575">gistFormTuple</a>(giststate, r,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull, <span class="Constant">true</span> <span class="Comment">/* size is currently bogus */</span> );<br/></li>
<li>&nbsp; &nbsp; itup-&gt;t_tid = *ht_ctid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L634" title="access/gist/gist.c:634">gistdoinsert</a>(r, itup, <span class="Constant">0</span>, giststate, heapRel, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldCxt);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(giststate-&gt;tempCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Place tuples from 'itup' to 'buffer'. If 'oldoffnum' is valid, the tuple<br/></li>
<li></span><span class="Comment"> * at that offset is atomically removed along with inserting the new tuples.<br/></li>
<li></span><span class="Comment"> * This is used to replace a tuple with a new one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If 'leftchildbuf' is valid, we're inserting the downlink for the page<br/></li>
<li></span><span class="Comment"> * to the right of 'leftchildbuf', or updating the downlink for 'leftchildbuf'.<br/></li>
<li></span><span class="Comment"> * F_FOLLOW_RIGHT flag on 'leftchildbuf' is cleared and NSN is set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If 'markfollowright' is true and the page is split, the left child is<br/></li>
<li></span><span class="Comment"> * marked with F_FOLLOW_RIGHT flag. That is the normal case. During buffered<br/></li>
<li></span><span class="Comment"> * index build, however, there is no concurrent access and the page splitting<br/></li>
<li></span><span class="Comment"> * is done in a slightly simpler fashion, and false is passed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there is not enough room on the page, it is split. All the split<br/></li>
<li></span><span class="Comment"> * pages are kept pinned and locked and returned in *splitinfo, the caller<br/></li>
<li></span><span class="Comment"> * is responsible for inserting the downlinks for them. However, if<br/></li>
<li></span><span class="Comment"> * 'buffer' is the root page and it needs to be split, <a href="#L225" title="access/gist/gist.c:225">gistplacetopage</a>()<br/></li>
<li></span><span class="Comment"> * performs the split as one atomic operation, and *splitinfo is set to NIL.<br/></li>
<li></span><span class="Comment"> * In that case, we continue to hold the root page locked, and the child<br/></li>
<li></span><span class="Comment"> * pages are released; note that new tuple(s) are *not* on the root page<br/></li>
<li></span><span class="Comment"> * but in one of the new child pages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If 'newblkno' is not NULL, returns the block number of page the first<br/></li>
<li></span><span class="Comment"> * new/updated tuple was inserted to. Usually it's the given page, but could<br/></li>
<li></span><span class="Comment"> * be its right sibling if the page was split.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 'true' if the page was split, 'false' otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L225">&#x200c;</a></span><span class="linkable">gistplacetopage</span>(Relation rel, Size freespace, GISTSTATE *giststate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple *itup, <span class="Type">int</span> ntup, OffsetNumber oldoffnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber *newblkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer leftchildbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **splitinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> markfollowright,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_build)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_leaf = (GistPageIsLeaf(page)) ? <span class="Constant">true</span> : <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_split;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Refuse to modify a page that's incompletely split. This should not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happen because we finish <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> incomplete splits while we walk down the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tree. However, it's remotely possible that another concurrent inserter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * splits a parent page, and errors out <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> completing the split. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will just throw an error in that case, and leave <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> split we had in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * progress unfinished too. The <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> insert that comes along will clean up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the mess.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (GistFollowRight(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;concurrent GiST page split was incomplete&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* should never try to insert to a deleted page */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!GistPageIsDeleted(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *splitinfo = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if isupdate, remove old key: This node's key has been modified, either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because a child split occurred or because we needed to adjust our key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for an insert in a child node. Therefore, remove the old version of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this node's key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for WAL replay, in the non-split case we handle this by setting up a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> todelete array; in the split case, it's handled implicitly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because the tuple vector passed to <a href="#L1438" title="access/gist/gist.c:1438">gistSplit</a> won't include this tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; is_split = <a href="gistutil.c.html#L59" title="access/gist/gistutil.c:59">gistnospace</a>(page, itup, ntup, oldoffnum, freespace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If leaf page is full, try at first to delete dead tuples. And then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_split &amp;&amp; GistPageIsLeaf(page) &amp;&amp; GistPageHasGarbage(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1664" title="access/gist/gist.c:1664">gistprunepage</a>(rel, page, buffer, heapRel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; is_split = <a href="gistutil.c.html#L59" title="access/gist/gistutil.c:59">gistnospace</a>(page, itup, ntup, oldoffnum, freespace);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_split)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no space for insertion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple *itvec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SplitPageLayout *dist = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber oldrlink = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GistNSN&nbsp; &nbsp; &nbsp; &nbsp; oldnsn = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SplitPageLayout rootpg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_rootsplit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; is_rootsplit = (blkno == GIST_ROOT_BLKNO);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Form index tuples vector to split. If we're replacing an old tuple,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remove the old version from the vector.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itvec = <a href="gistutil.c.html#L95" title="access/gist/gistutil.c:95">gistextractpage</a>(page, &amp;tlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OffsetNumberIsValid(oldoffnum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* on inner page we should remove old tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos = oldoffnum - FirstOffsetNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlen--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos != tlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memmove(itvec + pos, itvec + pos + <span class="Constant">1</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTuple) * (tlen - pos));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itvec = <a href="gistutil.c.html#L114" title="access/gist/gistutil.c:114">gistjoinvector</a>(itvec, &amp;tlen, itup, ntup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dist = <a href="#L1438" title="access/gist/gist.c:1438">gistSplit</a>(rel, page, itvec, tlen, giststate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that split didn't produce too many pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; npage = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (ptr = dist; ptr; ptr = ptr-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npage++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in a root split, we'll add one more page to the list below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_rootsplit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npage++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (npage &gt; GIST_MAX_SPLIT_PAGES)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;GiST page split into too many halves (</span><span class="Special">%d</span><span class="Constant">, maximum </span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; npage, GIST_MAX_SPLIT_PAGES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set up pages to work with. Allocate new buffers for all but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leftmost page. The original page becomes the new leftmost page, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is just replaced with the new contents.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For a root-split, allocate new buffers for all child pages, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original page is overwritten with new root page containing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * downlinks to the new child pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ptr = dist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!is_rootsplit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* save old rightlink and NSN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldrlink = GistPageGetOpaque(page)-&gt;rightlink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldnsn = GistPageGetNSN(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dist-&gt;buffer = buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dist-&gt;block.blkno = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dist-&gt;page = <a href="../../storage/page/bufpage.c.html#L402" title="storage/page/bufpage.c:402">PageGetTempPageCopySpecial</a>(BufferGetPage(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* clean all flags except F_LEAF */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistPageGetOpaque(dist-&gt;page)-&gt;flags = (is_leaf) ? F_LEAF : <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = ptr-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; ptr; ptr = ptr-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allocate new page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr-&gt;buffer = <a href="gistutil.c.html#L824" title="access/gist/gistutil.c:824">gistNewBuffer</a>(rel, heapRel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L773" title="access/gist/gistutil.c:773">GISTInitBuffer</a>(ptr-&gt;buffer, (is_leaf) ? F_LEAF : <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr-&gt;page = BufferGetPage(ptr-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr-&gt;block.blkno = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(ptr-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L3129" title="storage/lmgr/predicate.c:3129">PredicateLockPageSplit</a>(rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(ptr-&gt;buffer));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now that we know which blocks the new pages go to, set up downlink<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples to point to them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (ptr = dist; ptr; ptr = ptr-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSetBlockNumber(&amp;(ptr-&gt;itup-&gt;t_tid), ptr-&gt;block.blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistTupleSetValid(ptr-&gt;itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is a root split, we construct the new root page with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * downlinks here directly, instead of requiring the caller to insert<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them. Add the new root page to the list along with the child pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_rootsplit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple *downlinks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndownlinks = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootpg.buffer = buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootpg.page = <a href="../../storage/page/bufpage.c.html#L402" title="storage/page/bufpage.c:402">PageGetTempPageCopySpecial</a>(BufferGetPage(rootpg.buffer));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistPageGetOpaque(rootpg.page)-&gt;flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepare a vector of all the downlinks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (ptr = dist; ptr; ptr = ptr-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndownlinks++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; downlinks = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTuple) * ndownlinks);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>, ptr = dist; ptr; ptr = ptr-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; downlinks[i++] = ptr-&gt;itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootpg.block.blkno = GIST_ROOT_BLKNO;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootpg.block.num = ndownlinks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootpg.list = <a href="gistutil.c.html#L127" title="access/gist/gistutil.c:127">gistfillitupvec</a>(downlinks, ndownlinks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;(rootpg.lenlist));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootpg.itup = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootpg.<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = dist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dist = &amp;rootpg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepare split-info to be returned to caller */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (ptr = dist; ptr; ptr = ptr-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GISTPageSplitInfo *si = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTPageSplitInfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; si-&gt;buf = ptr-&gt;buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; si-&gt;downlink = ptr-&gt;itup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *splitinfo = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*splitinfo, si);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fill all pages. All the pages are new, ie. freshly allocated empty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pages, or a temporary copy of the old page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (ptr = dist; ptr; ptr = ptr-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *data = (<span class="Type">char</span> *) (ptr-&gt;list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; ptr-&gt;block.num; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; thistup = (IndexTuple) data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(ptr-&gt;page, (Item) data, IndexTupleSize(thistup), i + FirstOffsetNumber, <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add item to index page in </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, RelationGetRelationName(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is the first inserted/updated tuple, let the caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * know which page it landed on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newblkno &amp;&amp; <a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;thistup-&gt;t_tid, &amp;(*itup)-&gt;t_tid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *newblkno = ptr-&gt;block.blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += IndexTupleSize(thistup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up rightlinks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptr-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> &amp;&amp; ptr-&gt;block.blkno != GIST_ROOT_BLKNO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistPageGetOpaque(ptr-&gt;page)-&gt;rightlink =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-&gt;block.blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistPageGetOpaque(ptr-&gt;page)-&gt;rightlink = oldrlink;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mark the all but the right-most page with the follow-right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * flag. It will be cleared as soon as the downlink is inserted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * into the parent, but this ensures that if we error out <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that, the index is still consistent. (in buffering build mode,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error will abort the index build anyway, so this is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * needed.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptr-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> &amp;&amp; !is_rootsplit &amp;&amp; markfollowright)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistMarkFollowRight(ptr-&gt;page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistClearFollowRight(ptr-&gt;page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy the NSN of the original page to all pages. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * F_FOLLOW_RIGHT flags ensure that scans will follow the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rightlinks until the downlinks are inserted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistPageSetNSN(ptr-&gt;page, oldnsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="gistxlog.c.html#L495" title="access/gist/gistxlog.c:495">gistXLogSplit</a>() needs to WAL log a lot of pages, prepare WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * insertion for that. NB: The number of pages and data segments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * specified here must match the calculations in <a href="gistxlog.c.html#L495" title="access/gist/gistxlog.c:495">gistXLogSplit</a>()!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!is_build &amp;&amp; RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L175" title="access/transam/xloginsert.c:175">XLogEnsureRecordSpace</a>(npage, <span class="Constant">1</span> + npage * <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Must mark buffers dirty <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>, even though we'll still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be changing their opaque fields below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (ptr = dist; ptr; ptr = ptr-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(ptr-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(leftchildbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(leftchildbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The first page in the chain was a temporary working copy meant to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * replace the old page. Copy it over the old page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L424" title="storage/page/bufpage.c:424">PageRestoreTempPage</a>(dist-&gt;page, BufferGetPage(dist-&gt;buffer));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dist-&gt;page = BufferGetPage(dist-&gt;buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Write the WAL record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're building a new index, however, we don't WAL-log changes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * yet. The LSN-NSN interlock between parent and child requires that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LSNs never move backwards, so set the LSNs to a value that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * smaller than <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> real or fake unlogged LSN that might be generated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later. (There can't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> concurrent scans during index build, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't need to be able to detect concurrent splits yet.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_build)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recptr = GistBuildLSN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="gistxlog.c.html#L495" title="access/gist/gistxlog.c:495">gistXLogSplit</a>(is_leaf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dist, oldrlink, oldnsn, leftchildbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; markfollowright);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="gistutil.c.html#L1016" title="access/gist/gistutil.c:1016">gistGetFakeLSN</a>(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (ptr = dist; ptr; ptr = ptr-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(ptr-&gt;page, recptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Return the new child buffers to the caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this was a root split, we've already inserted the downlink<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointers, in the form of a new root page. Therefore we can release<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all the new buffers, and keep just the root page locked.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_rootsplit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (ptr = dist-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>; ptr; ptr = ptr-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(ptr-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Enough space.&nbsp; We always get here if ntup==0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> old tuple if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, then insert new tuple(s) if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible, use the fast path of <a href="../../storage/page/bufpage.c.html#L1405" title="storage/page/bufpage.c:1405">PageIndexTupleOverwrite</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OffsetNumberIsValid(oldoffnum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ntup == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* One-for-one replacement, so use <a href="../../storage/page/bufpage.c.html#L1405" title="storage/page/bufpage.c:1405">PageIndexTupleOverwrite</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/page/bufpage.c.html#L1405" title="storage/page/bufpage.c:1405">PageIndexTupleOverwrite</a>(page, oldoffnum, (Item) *itup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTupleSize(*itup)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add item to index page in </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> old, then append new tuple(s) to page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1052" title="storage/page/bufpage.c:1052">PageIndexTupleDelete</a>(page, oldoffnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L34" title="access/gist/gistutil.c:34">gistfillbuffer</a>(page, itup, ntup, InvalidOffsetNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Just append new tuples at the end of the page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L34" title="access/gist/gistutil.c:34">gistfillbuffer</a>(page, itup, ntup, InvalidOffsetNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(leftchildbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(leftchildbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_build)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recptr = GistBuildLSN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber ndeloffs = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deloffs[<span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OffsetNumberIsValid(oldoffnum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deloffs[<span class="Constant">0</span>] = oldoffnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndeloffs = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="gistxlog.c.html#L629" title="access/gist/gistxlog.c:629">gistXLogUpdate</a>(buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deloffs, ndeloffs, itup, ntup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftchildbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="gistutil.c.html#L1016" title="access/gist/gistutil.c:1016">gistGetFakeLSN</a>(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *newblkno = blkno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we inserted the downlink for a child page, set NSN and clear<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * F_FOLLOW_RIGHT flag on the left child, so that concurrent scans know to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * follow the rightlink if and only if they looked at the parent page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we inserted the downlink.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we do this *after* writing the WAL record. That means that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the possible full page image in the WAL record does not include these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * changes, and they must be replayed even if the page is restored from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the full page image. There's a chicken-and-egg problem: if we updated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the child pages first, we wouldn't know the recptr of the WAL record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're about to write.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(leftchildbuf))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; leftpg = BufferGetPage(leftchildbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GistPageSetNSN(leftpg, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GistClearFollowRight(leftpg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(leftpg, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> is_split;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Workhouse routine for doing insertion into a GiST index. Note that<br/></li>
<li></span><span class="Comment"> * this routine assumes it is invoked in a short-lived memory context,<br/></li>
<li></span><span class="Comment"> * so it does not bother releasing <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d allocations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L634">&#x200c;</a></span><span class="linkable">gistdoinsert</span>(Relation r, IndexTuple itup, Size freespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GISTSTATE *giststate, Relation heapRel, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_build)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; idxtuple;<br/></li>
<li>&nbsp; &nbsp; GISTInsertStack firststack;<br/></li>
<li>&nbsp; &nbsp; GISTInsertStack *stack;<br/></li>
<li>&nbsp; &nbsp; GISTInsertState state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; xlocked = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;state, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTInsertState));<br/></li>
<li>&nbsp; &nbsp; state.freespace = freespace;<br/></li>
<li>&nbsp; &nbsp; state.r = r;<br/></li>
<li>&nbsp; &nbsp; state.heapRel = heapRel;<br/></li>
<li>&nbsp; &nbsp; state.is_build = is_build;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Start from the root */<br/></li>
<li></span>&nbsp; &nbsp; firststack.blkno = GIST_ROOT_BLKNO;<br/></li>
<li>&nbsp; &nbsp; firststack.lsn = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; firststack.retry_from_parent = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; firststack.parent = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; firststack.downlinkoffnum = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; state.stack = stack = &amp;firststack;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Walk down along the path of smallest penalty, updating the parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointers with the key we're inserting as we go. If we crash in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * middle, the tree is consistent, although the possible parent updates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * were a waste.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we split an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page while descending the tree, we have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * retry at the parent. (Normally, the LSN-NSN interlock below would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * also catch this and cause us to retry. But LSNs are not updated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during index build.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (stack-&gt;retry_from_parent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlocked)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(stack-&gt;buffer, GIST_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlocked = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(stack-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state.stack = stack = stack-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(stack-&gt;lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(state.r, stack-&gt;blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Be optimistic and grab shared lock first. Swap it for an exclusive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock later if we need to update the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!xlocked)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(stack-&gt;buffer, GIST_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L785" title="access/gist/gistutil.c:785">gistcheckpage</a>(state.r, stack-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;page = (Page) BufferGetPage(stack-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;lsn = xlocked ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageGetLSN(stack-&gt;page) : <a href="../../storage/buffer/bufmgr.c.html#L3928" title="storage/buffer/bufmgr.c:3928">BufferGetLSNAtomic</a>(stack-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!RelationNeedsWAL(state.r) || !XLogRecPtrIsInvalid(stack-&gt;lsn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this page was split but the downlink was never inserted to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent because the inserting backend crashed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing that, fix<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GistFollowRight(stack-&gt;page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!xlocked)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(stack-&gt;buffer, GIST_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(stack-&gt;buffer, GIST_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlocked = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* someone might've completed the split when we unlocked */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!GistFollowRight(stack-&gt;page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1188" title="access/gist/gist.c:1188">gistfixsplit</a>(&amp;state, giststate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(stack-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlocked = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state.stack = stack = stack-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((stack-&gt;blkno != GIST_ROOT_BLKNO &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stack-&gt;parent-&gt;lsn &lt; GistPageGetNSN(stack-&gt;page)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistPageIsDeleted(stack-&gt;page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Concurrent split or page deletion detected. There's no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * guarantee that the downlink for this page is consistent with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the tuple we're inserting anymore, so go back to parent and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rechoose the best child.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(stack-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlocked = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state.stack = stack = stack-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!GistPageIsLeaf(stack-&gt;page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page so continue to walk down the tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find the child node that has the minimum insertion penalty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber childblkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; newtup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GISTInsertStack *item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber downlinkoffnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; downlinkoffnum = <a href="gistutil.c.html#L374" title="access/gist/gistutil.c:374">gistchoose</a>(state.r, stack-&gt;page, itup, giststate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(stack-&gt;page, downlinkoffnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idxtuple = (IndexTuple) PageGetItem(stack-&gt;page, iid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childblkno = ItemPointerGetBlockNumber(&amp;(idxtuple-&gt;t_tid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that it's not a leftover invalid tuple from pre-9.1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GistTupleIsInvalid(idxtuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains an inner tuple marked as invalid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(r)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;This is caused by an incomplete page split at crash recovery <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> upgrading to PostgreSQL 9.1.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Please REINDEX it.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that the key representing the target child node is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consistent with the key we're inserting. Update it if it's not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtup = <a href="gistutil.c.html#L316" title="access/gist/gistutil.c:316">gistgetadjusted</a>(state.r, idxtuple, itup, giststate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newtup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Swap shared lock for an exclusive one. Beware, the page may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * change while we unlock/lock the page...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!xlocked)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(stack-&gt;buffer, GIST_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(stack-&gt;buffer, GIST_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlocked = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;page = (Page) BufferGetPage(stack-&gt;buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageGetLSN(stack-&gt;page) != stack-&gt;lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the page was changed while we unlocked it, retry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update the tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We still hold the lock after <a href="#L1248" title="access/gist/gist.c:1248">gistinserttuple</a>(), but it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might have to split the page to make the updated tuple fit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In that case the updated tuple might migrate to the other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * half of the split, so we have to go back to the parent and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * descend back to the half that's a better fit for the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1248" title="access/gist/gist.c:1248">gistinserttuple</a>(&amp;state, stack, giststate, newtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; downlinkoffnum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this was a root split, the root page continues to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the parent and the updated tuple went to one of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * child pages, so we just need to retry from the root<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stack-&gt;blkno != GIST_ROOT_BLKNO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(stack-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlocked = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state.stack = stack = stack-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(stack-&gt;buffer, GIST_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlocked = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* descend to the chosen child */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item = (GISTInsertStack *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTInsertStack));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;blkno = childblkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;parent = stack;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;downlinkoffnum = downlinkoffnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state.stack = stack = item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Leaf page. <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> the new key. We've already updated all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parents on the way down, but we might have to split the page if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it doesn't fit. <a href="#L1248" title="access/gist/gist.c:1248">gistinserttuple</a>() will take care of that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Swap shared lock for an exclusive one. Be careful, the page may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * change while we unlock/lock the page...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!xlocked)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(stack-&gt;buffer, GIST_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(stack-&gt;buffer, GIST_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlocked = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;page = (Page) BufferGetPage(stack-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;lsn = PageGetLSN(stack-&gt;page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stack-&gt;blkno == GIST_ROOT_BLKNO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the only page that can become inner instead of leaf is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the root page, so for root we should recheck it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!GistPageIsLeaf(stack-&gt;page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * very rare situation: during unlock/lock index with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * number of pages = 1 was increased<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(stack-&gt;buffer, GIST_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlocked = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't need to check root split, because checking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leaf/inner is enough to recognize split for root<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((GistFollowRight(stack-&gt;page) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;parent-&gt;lsn &lt; GistPageGetNSN(stack-&gt;page)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GistPageIsDeleted(stack-&gt;page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The page was split or deleted while we momentarily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unlocked the page. Go back to parent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(stack-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlocked = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state.stack = stack = stack-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> state.stack-&gt;(page, buffer and blkno) points to leaf page */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1248" title="access/gist/gist.c:1248">gistinserttuple</a>(&amp;state, stack, giststate, itup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOffsetNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(stack-&gt;buffer, GIST_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pins we might still hold <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> exiting */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; stack; stack = stack-&gt;parent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(stack-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Traverse the tree to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> path from root page to specified &quot;child&quot; block.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * returns a new insertion stack, starting from the parent of &quot;child&quot;, up<br/></li>
<li></span><span class="Comment"> * to the root. *downlinkoffnum is set to the offset of the downlink in the<br/></li>
<li></span><span class="Comment"> * direct parent of child.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To prevent deadlocks, this should lock only one page at a time.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> GISTInsertStack *<br/></li>
<li><a id="L909">&#x200c;</a><span class="linkable">gistFindPath</span>(Relation r, BlockNumber child, OffsetNumber *downlinkoffnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; idxtuple;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *fifo;<br/></li>
<li>&nbsp; &nbsp; GISTInsertStack *top,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; top = (GISTInsertStack *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTInsertStack));<br/></li>
<li>&nbsp; &nbsp; top-&gt;blkno = GIST_ROOT_BLKNO;<br/></li>
<li>&nbsp; &nbsp; top-&gt;downlinkoffnum = InvalidOffsetNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fifo = list_make1(top);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (fifo != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page to visit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; top = linitial(fifo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fifo = <a href="../../nodes/list.c.html#L943" title="nodes/list.c:943">list_delete_first</a>(fifo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(r, top-&gt;blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIST_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L785" title="access/gist/gistutil.c:785">gistcheckpage</a>(r, buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GistPageIsLeaf(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Because we scan the index top-down, all the rest of the pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the queue must be leaf pages as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* currently, <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages are never deleted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!GistPageIsDeleted(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; top-&gt;lsn = <a href="../../storage/buffer/bufmgr.c.html#L3928" title="storage/buffer/bufmgr.c:3928">BufferGetLSNAtomic</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If F_FOLLOW_RIGHT is set, the page to the right doesn't have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * downlink. This should not normally happen..<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GistFollowRight(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;concurrent GiST page split was incomplete&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (top-&gt;parent &amp;&amp; top-&gt;parent-&gt;lsn &lt; GistPageGetNSN(page) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistPageGetOpaque(page)-&gt;rightlink != InvalidBlockNumber <span class="Comment">/* sanity check */</span> )<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Page was split while we looked elsewhere. We didn't see the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * downlink to the right page when we scanned the parent, so add<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it to the queue <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Put the right page ahead of the queue, so that we visit it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>. That's important, because if this is the lowest <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * level, just above leaves, we might already have queued up some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leaf pages, and we assume that there can't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-leaf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pages behind leaf pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = (GISTInsertStack *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTInsertStack));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr-&gt;blkno = GistPageGetOpaque(page)-&gt;rightlink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr-&gt;downlinkoffnum = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr-&gt;parent = top-&gt;parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fifo = <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(ptr, fifo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(page, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idxtuple = (IndexTuple) PageGetItem(page, iid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno = ItemPointerGetBlockNumber(&amp;(idxtuple-&gt;t_tid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno == child)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found it! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *downlinkoffnum = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> top;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Append this child to the list of pages to visit later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = (GISTInsertStack *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTInsertStack));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr-&gt;blkno = blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr-&gt;downlinkoffnum = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr-&gt;parent = top;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fifo = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(fifo, ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> parent of a page in index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, block </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(r), child);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Updates the stack so that child-&gt;parent is the correct parent of the<br/></li>
<li></span><span class="Comment"> * child. child-&gt;parent must be exclusively locked on entry, and will<br/></li>
<li></span><span class="Comment"> * remain so at exit, but it might not be the same page anymore.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1022">&#x200c;</a></span><span class="linkable">gistFindCorrectParent</span>(Relation r, GISTInsertStack *child, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_build)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTInsertStack *parent = child-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; idxtuple;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber maxoff;<br/></li>
<li>&nbsp; &nbsp; GISTInsertStack *ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="gistutil.c.html#L785" title="access/gist/gistutil.c:785">gistcheckpage</a>(r, parent-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; parent-&gt;page = (Page) BufferGetPage(parent-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(parent-&gt;page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if the downlink is still where it was <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (child-&gt;downlinkoffnum != InvalidOffsetNumber &amp;&amp; child-&gt;downlinkoffnum &lt;= maxoff)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(parent-&gt;page, child-&gt;downlinkoffnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idxtuple = (IndexTuple) PageGetItem(parent-&gt;page, iid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemPointerGetBlockNumber(&amp;(idxtuple-&gt;t_tid)) == child-&gt;blkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* still there */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The page has changed since we looked. During normal operation, every<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update of a page changes its LSN, so the LSN we memorized should have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * changed too. During index build, however, we don't WAL-log the changes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until we have built the index, so the LSN doesn't change. There is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrent activity during index build, but we might have changed the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent ourselves.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(parent-&gt;lsn != PageGetLSN(parent-&gt;page) || is_build);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan the page to re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the downlink. If the page was split, it might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have moved to a different page, so follow the right links until we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(parent-&gt;page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(parent-&gt;page, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idxtuple = (IndexTuple) PageGetItem(parent-&gt;page, iid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemPointerGetBlockNumber(&amp;(idxtuple-&gt;t_tid)) == child-&gt;blkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* yes!!, found */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child-&gt;downlinkoffnum = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;blkno = GistPageGetOpaque(parent-&gt;page)-&gt;rightlink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;downlinkoffnum = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(parent-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent-&gt;blkno == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * End of chain and still didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> parent. It's a very-very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rare situation when the root was split.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(r, parent-&gt;blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(parent-&gt;buffer, GIST_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L785" title="access/gist/gistutil.c:785">gistcheckpage</a>(r, parent-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;page = (Page) BufferGetPage(parent-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * awful!!, we need search tree to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> parent ... , but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * release all old parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; ptr = child-&gt;parent-&gt;parent;&nbsp; &nbsp; <span class="Comment">/* child-&gt;parent already released above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (ptr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(ptr-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = ptr-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ok, <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> new path */<br/></li>
<li></span>&nbsp; &nbsp; ptr = parent = <a href="#L909" title="access/gist/gist.c:909">gistFindPath</a>(r, child-&gt;blkno, &amp;child-&gt;downlinkoffnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read all buffers as expected by caller */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* note we don't lock them or <a href="gistutil.c.html#L785" title="access/gist/gistutil.c:785">gistcheckpage</a> them here! */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (ptr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr-&gt;buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(r, ptr-&gt;blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr-&gt;page = (Page) BufferGetPage(ptr-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = ptr-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* install new chain of parents to stack */<br/></li>
<li></span>&nbsp; &nbsp; child-&gt;parent = parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make recursive call to normal processing */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(child-&gt;parent-&gt;buffer, GIST_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1022" title="access/gist/gist.c:1022">gistFindCorrectParent</a>(r, child, is_build);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Form a downlink pointer for the page in 'buf'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> IndexTuple<br/></li>
<li><a id="L1128">&#x200c;</a><span class="linkable">gistformdownlink</span>(Relation rel, Buffer buf, GISTSTATE *giststate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GISTInsertStack *stack, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_build)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; OffsetNumber maxoff;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offset;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; downlink = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (offset = FirstOffsetNumber; offset &lt;= maxoff; offset = OffsetNumberNext(offset))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; ituple = (IndexTuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageGetItem(page, PageGetItemId(page, offset));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (downlink == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; downlink = <a href="../common/indextuple.c.html#L547" title="access/common/indextuple.c:547">CopyIndexTuple</a>(ituple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; newdownlink;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdownlink = <a href="gistutil.c.html#L316" title="access/gist/gistutil.c:316">gistgetadjusted</a>(rel, downlink, ituple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; giststate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newdownlink)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; downlink = newdownlink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the page is completely empty, we can't form a meaningful downlink<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for it. But we have to insert a downlink for the page. Any key will do,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as long as its consistent with the downlink of parent page, so that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can legally insert it to the parent. A minimal one that matches as few<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scans as possible would be best, to keep scans from doing useless work,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but we don't know how to construct that. So we just use the downlink of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the original page that was split - that's as far from optimal as it can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get but will do..<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!downlink)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(stack-&gt;parent-&gt;buffer, GIST_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1022" title="access/gist/gist.c:1022">gistFindCorrectParent</a>(rel, stack, is_build);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(stack-&gt;parent-&gt;page, stack-&gt;downlinkoffnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; downlink = (IndexTuple) PageGetItem(stack-&gt;parent-&gt;page, iid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; downlink = <a href="../common/indextuple.c.html#L547" title="access/common/indextuple.c:547">CopyIndexTuple</a>(downlink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(stack-&gt;parent-&gt;buffer, GIST_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ItemPointerSetBlockNumber(&amp;(downlink-&gt;t_tid), <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf));<br/></li>
<li>&nbsp; &nbsp; GistTupleSetValid(downlink);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> downlink;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Complete the incomplete split of state-&gt;stack-&gt;page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1188">&#x200c;</a></span><span class="linkable">gistfixsplit</span>(GISTInsertState *state, GISTSTATE *giststate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTInsertStack *stack = state-&gt;stack;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *splitinfo = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;fixing incomplete split in index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, block </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(state-&gt;r), stack-&gt;blkno)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(GistFollowRight(stack-&gt;page));<br/></li>
<li>&nbsp; &nbsp; Assert(OffsetNumberIsValid(stack-&gt;downlinkoffnum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf = stack-&gt;buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read the chain of split pages, following the rightlinks. Construct a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * downlink tuple for each page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GISTPageSplitInfo *si = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTPageSplitInfo));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; downlink;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Form the new downlink tuples to insert to parent */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; downlink = <a href="#L1128" title="access/gist/gist.c:1128">gistformdownlink</a>(state-&gt;r, buf, giststate, stack, state-&gt;is_build);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; si-&gt;buf = buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; si-&gt;downlink = downlink;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; splitinfo = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(splitinfo, si);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GistFollowRight(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lock <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(state-&gt;r, GistPageGetOpaque(page)-&gt;rightlink);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, GIST_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> the downlinks */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1342" title="access/gist/gist.c:1342">gistfinishsplit</a>(state, stack, giststate, splitinfo, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> or replace a tuple in stack-&gt;buffer. If 'oldoffnum' is valid, the<br/></li>
<li></span><span class="Comment"> * tuple at 'oldoffnum' is replaced, otherwise the tuple is inserted as new.<br/></li>
<li></span><span class="Comment"> * 'stack' represents the path from the root to the page being updated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must hold an exclusive lock on stack-&gt;buffer.&nbsp; The lock is still<br/></li>
<li></span><span class="Comment"> * held on return, but the page might not contain the inserted tuple if the<br/></li>
<li></span><span class="Comment"> * page was split. The function returns true if the page was split, false<br/></li>
<li></span><span class="Comment"> * otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1248">&#x200c;</a></span><span class="linkable">gistinserttuple</span>(GISTInsertState *state, GISTInsertStack *stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GISTSTATE *giststate, IndexTuple tuple, OffsetNumber oldoffnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1282" title="access/gist/gist.c:1282">gistinserttuples</a>(state, stack, giststate, &amp;tuple, <span class="Constant">1</span>, oldoffnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidBuffer, InvalidBuffer, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> * An extended workhorse version of <a href="#L1248" title="access/gist/gist.c:1248">gistinserttuple</a>(). This version allows<br/></li>
<li></span><span class="Comment"> * inserting multiple tuples, or replacing a single tuple with multiple tuples.<br/></li>
<li></span><span class="Comment"> * This is used to recursively update the downlinks in the parent when a page<br/></li>
<li></span><span class="Comment"> * is split.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If <a href="../../storage/freespace/fsmpage.c.html#L29" title="storage/freespace/fsmpage.c:29">leftchild</a> and <a href="../../storage/freespace/fsmpage.c.html#L30" title="storage/freespace/fsmpage.c:30">rightchild</a> are valid, we're inserting/replacing the<br/></li>
<li></span><span class="Comment"> * downlink for <a href="../../storage/freespace/fsmpage.c.html#L30" title="storage/freespace/fsmpage.c:30">rightchild</a>, and <a href="../../storage/freespace/fsmpage.c.html#L29" title="storage/freespace/fsmpage.c:29">leftchild</a> is its left sibling. We clear the<br/></li>
<li></span><span class="Comment"> * F_FOLLOW_RIGHT flag and update NSN on <a href="../../storage/freespace/fsmpage.c.html#L29" title="storage/freespace/fsmpage.c:29">leftchild</a>, atomically with the<br/></li>
<li></span><span class="Comment"> * insertion of the downlink.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid holding locks for longer than necessary, when recursing up the<br/></li>
<li></span><span class="Comment"> * tree to update the parents, the locking is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> peculiar here. On entry,<br/></li>
<li></span><span class="Comment"> * the caller must hold an exclusive lock on stack-&gt;buffer, as well as<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/freespace/fsmpage.c.html#L29" title="storage/freespace/fsmpage.c:29">leftchild</a> and <a href="../../storage/freespace/fsmpage.c.html#L30" title="storage/freespace/fsmpage.c:30">rightchild</a> if given. On return:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; - Lock on stack-&gt;buffer is released, if 'unlockbuf' is true. The page is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; always kept pinned, however.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; - Lock on '<a href="../../storage/freespace/fsmpage.c.html#L29" title="storage/freespace/fsmpage.c:29">leftchild</a>' is released, if 'unlockleftchild' is true. The page<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; is kept pinned.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; - Lock and pin on '<a href="../../storage/freespace/fsmpage.c.html#L30" title="storage/freespace/fsmpage.c:30">rightchild</a>' are always released.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 'true' if the page had to be split. Note that if the page was<br/></li>
<li></span><span class="Comment"> * split, the inserted/updated tuples might've been inserted to a right<br/></li>
<li></span><span class="Comment"> * sibling of stack-&gt;buffer instead of stack-&gt;buffer itself.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1282">&#x200c;</a></span><span class="linkable">gistinserttuples</span>(GISTInsertState *state, GISTInsertStack *stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GISTSTATE *giststate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTuple *tuples, <span class="Type">int</span> ntup, OffsetNumber oldoffnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer <a href="../../storage/freespace/fsmpage.c.html#L29" title="storage/freespace/fsmpage.c:29">leftchild</a>, Buffer <a href="../../storage/freespace/fsmpage.c.html#L30" title="storage/freespace/fsmpage.c:30">rightchild</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> unlockbuf, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> unlockleftchild)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *splitinfo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_split;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> rw conflicts (in serializable isolation level) just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we intend to modify the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L4321" title="storage/lmgr/predicate.c:4321">CheckForSerializableConflictIn</a>(state-&gt;r, <span class="Constant">NULL</span>, <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(stack-&gt;buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> the tuple(s) to the page, splitting the page if necessary */<br/></li>
<li></span>&nbsp; &nbsp; is_split = <a href="#L225" title="access/gist/gist.c:225">gistplacetopage</a>(state-&gt;r, state-&gt;freespace, giststate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stack-&gt;buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tuples, ntup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldoffnum, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/freespace/fsmpage.c.html#L29" title="storage/freespace/fsmpage.c:29">leftchild</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;splitinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;is_build);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Before recursing up in case the page was split, release locks on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * child pages. We don't need to keep them locked when updating the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(<a href="../../storage/freespace/fsmpage.c.html#L30" title="storage/freespace/fsmpage.c:30">rightchild</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(<a href="../../storage/freespace/fsmpage.c.html#L30" title="storage/freespace/fsmpage.c:30">rightchild</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(<a href="../../storage/freespace/fsmpage.c.html#L29" title="storage/freespace/fsmpage.c:29">leftchild</a>) &amp;&amp; unlockleftchild)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(<a href="../../storage/freespace/fsmpage.c.html#L29" title="storage/freespace/fsmpage.c:29">leftchild</a>, GIST_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we had to split, insert/update the downlinks in the parent. If the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caller requested us to release the lock on stack-&gt;buffer, tell<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1342" title="access/gist/gist.c:1342">gistfinishsplit</a>() to do that as soon as it's safe to do so. If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * didn't have to split, release it ourselves.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (splitinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1342" title="access/gist/gist.c:1342">gistfinishsplit</a>(state, stack, giststate, splitinfo, unlockbuf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (unlockbuf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(stack-&gt;buffer, GIST_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> is_split;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Finish an incomplete split by inserting/updating the downlinks in parent<br/></li>
<li></span><span class="Comment"> * page. 'splitinfo' contains all the child pages involved in the split,<br/></li>
<li></span><span class="Comment"> * from left-to-right.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On entry, the caller must hold a lock on stack-&gt;buffer and all the child<br/></li>
<li></span><span class="Comment"> * pages in 'splitinfo'. If 'unlockbuf' is true, the lock on stack-&gt;buffer is<br/></li>
<li></span><span class="Comment"> * released on return. The child pages are always unlocked and unpinned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1342">&#x200c;</a></span><span class="linkable">gistfinishsplit</span>(GISTInsertState *state, GISTInsertStack *stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GISTSTATE *giststate, List *splitinfo, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> unlockbuf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTPageSplitInfo *right;<br/></li>
<li>&nbsp; &nbsp; GISTPageSplitInfo *left;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; tuples[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* A split always contains at least two halves */<br/></li>
<li></span>&nbsp; &nbsp; Assert(list_length(splitinfo) &gt;= <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to insert downlinks for each new page, and update the downlink<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the original (leftmost) page in the split. Begin at the rightmost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page, inserting one downlink at a time until there's only two pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * left. Finally insert the downlink for the last new page and update the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * downlink for the original page as one operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(stack-&gt;parent-&gt;buffer, GIST_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> downlinks for the siblings from right to left, until there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only two siblings left.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> pos = list_length(splitinfo) - <span class="Constant">1</span>; pos &gt; <span class="Constant">1</span>; pos--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; right = (GISTPageSplitInfo *) list_nth(splitinfo, pos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; left = (GISTPageSplitInfo *) list_nth(splitinfo, pos - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1022" title="access/gist/gist.c:1022">gistFindCorrectParent</a>(state-&gt;r, stack, state-&gt;is_build);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1282" title="access/gist/gist.c:1282">gistinserttuples</a>(state, stack-&gt;parent, giststate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;right-&gt;downlink, <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOffsetNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; left-&gt;buf, right-&gt;buf, <span class="Constant">false</span>, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the parent page was split, the existing downlink might have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * moved.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;downlinkoffnum = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L1282" title="access/gist/gist.c:1282">gistinserttuples</a>() released the lock on right-&gt;buf. */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; right = (GISTPageSplitInfo *) lsecond(splitinfo);<br/></li>
<li>&nbsp; &nbsp; left = (GISTPageSplitInfo *) linitial(splitinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finally insert downlink for the remaining right page and update the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * downlink for the original page to not contain the tuples that were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * moved to the new pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tuples[<span class="Constant">0</span>] = left-&gt;downlink;<br/></li>
<li>&nbsp; &nbsp; tuples[<span class="Constant">1</span>] = right-&gt;downlink;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1022" title="access/gist/gist.c:1022">gistFindCorrectParent</a>(state-&gt;r, stack, state-&gt;is_build);<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1282" title="access/gist/gist.c:1282">gistinserttuples</a>(state, stack-&gt;parent, giststate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuples, <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack-&gt;downlinkoffnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left-&gt;buf, right-&gt;buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>,&nbsp; &nbsp; <span class="Comment">/* Unlock parent */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unlockbuf&nbsp; &nbsp; <span class="Comment">/* Unlock stack-&gt;buffer if caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wants that */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; );<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The downlink might have moved when we updated it. Even if the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wasn't split, because <a href="#L1282" title="access/gist/gist.c:1282">gistinserttuples</a>() implements updating the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple by removing and re-inserting it!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; stack-&gt;downlinkoffnum = InvalidOffsetNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(left-&gt;buf == stack-&gt;buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we split the page because we had to adjust the downlink on an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page, while descending the tree for inserting a new tuple,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then this might no longer be the correct page for the new tuple. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * downlink to this page might not cover the new tuple anymore, it might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to go to the newly-created right sibling instead. Tell the caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to walk back up the stack, to re-check at the parent which page to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * insert to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normally, the LSN-NSN interlock during the tree descend would also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * detect that a concurrent split happened (by ourselves), and cause us to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * retry at the parent. But that mechanism doesn't work during index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * build, because we don't do WAL-logging, and don't update LSNs, during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index build.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; stack-&gt;retry_from_parent = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1438" title="access/gist/gist.c:1438">gistSplit</a> -- split a page in the tree and fill struct<br/></li>
<li></span><span class="Comment"> * used for XLOG and real writes buffers. Function is recursive, ie<br/></li>
<li></span><span class="Comment"> * it will split page until keys will fit in every page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>SplitPageLayout *<br/></li>
<li><a id="L1438">&#x200c;</a><span class="linkable">gistSplit</span>(Relation r,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple *itup,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* contains compressed entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GISTSTATE *giststate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexTuple *lvectup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *rvectup;<br/></li>
<li>&nbsp; &nbsp; GistSplitVector v;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; SplitPageLayout *res = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this should never recurse very deeply, but better safe than sorry */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* there's no point in splitting an empty page */<br/></li>
<li></span>&nbsp; &nbsp; Assert(len &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a single tuple doesn't fit on a page, no amount of splitting will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index row size </span><span class="Special">%zu</span><span class="Constant"> exceeds maximum </span><span class="Special">%zu</span><span class="Constant"> for index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTupleSize(itup[<span class="Constant">0</span>]), GiSTPageSize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(r))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(v.spl_lisnull, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * giststate-&gt;nonLeafTupdesc-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; memset(v.spl_risnull, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * giststate-&gt;nonLeafTupdesc-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; <a href="gistsplit.c.html#L623" title="access/gist/gistsplit.c:623">gistSplitByKey</a>(r, page, itup, len, giststate, &amp;v, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* form left and right vector */<br/></li>
<li></span>&nbsp; &nbsp; lvectup = (IndexTuple *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTuple) * (len + <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; rvectup = (IndexTuple *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTuple) * (len + <span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; v.splitVector.spl_nleft; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lvectup[i] = itup[v.splitVector.spl_left[i] - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; v.splitVector.spl_nright; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rvectup[i] = itup[v.splitVector.spl_right[i] - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* finalize splitting (may need another split) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="gistutil.c.html#L79" title="access/gist/gistutil.c:79">gistfitpage</a>(rvectup, v.splitVector.spl_nright))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L1438" title="access/gist/gist.c:1438">gistSplit</a>(r, page, rvectup, v.splitVector.spl_nright, giststate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="access/gist/gist.c:45">ROTATEDIST</a>(res);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res-&gt;block.num = v.splitVector.spl_nright;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res-&gt;list = <a href="gistutil.c.html#L127" title="access/gist/gistutil.c:127">gistfillitupvec</a>(rvectup, v.splitVector.spl_nright, &amp;(res-&gt;lenlist));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res-&gt;itup = <a href="gistutil.c.html#L575" title="access/gist/gistutil.c:575">gistFormTuple</a>(giststate, r, v.spl_rattr, v.spl_risnull, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="gistutil.c.html#L79" title="access/gist/gistutil.c:79">gistfitpage</a>(lvectup, v.splitVector.spl_nleft))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SplitPageLayout *resptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *subres;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resptr = subres = <a href="#L1438" title="access/gist/gist.c:1438">gistSplit</a>(r, page, lvectup, v.splitVector.spl_nleft, giststate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* install on list's tail */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (resptr-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; resptr = resptr-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; resptr-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = subres;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="access/gist/gist.c:45">ROTATEDIST</a>(res);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res-&gt;block.num = v.splitVector.spl_nleft;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res-&gt;list = <a href="gistutil.c.html#L127" title="access/gist/gistutil.c:127">gistfillitupvec</a>(lvectup, v.splitVector.spl_nleft, &amp;(res-&gt;lenlist));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res-&gt;itup = <a href="gistutil.c.html#L575" title="access/gist/gistutil.c:575">gistFormTuple</a>(giststate, r, v.spl_lattr, v.spl_lisnull, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a GISTSTATE and fill it with information about the index<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>GISTSTATE *<br/></li>
<li><a id="L1525">&#x200c;</a><span class="linkable">initGISTstate</span>(Relation index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTSTATE&nbsp; *giststate;<br/></li>
<li>&nbsp; &nbsp; MemoryContext scanCxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldCxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* safety check to protect fixed-size arrays in GISTSTATE */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;rd_att-&gt;natts &gt; INDEX_MAX_KEYS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;numberOfAttributes </span><span class="Special">%d</span><span class="Constant"> &gt; </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index-&gt;rd_att-&gt;natts, INDEX_MAX_KEYS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create the memory context that will hold the GISTSTATE */<br/></li>
<li></span>&nbsp; &nbsp; scanCxt = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;GiST scan context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; oldCxt = MemoryContextSwitchTo(scanCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create and fill in the GISTSTATE */<br/></li>
<li></span>&nbsp; &nbsp; giststate = (GISTSTATE *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTSTATE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; giststate-&gt;scanCxt = scanCxt;<br/></li>
<li>&nbsp; &nbsp; giststate-&gt;tempCxt = scanCxt;&nbsp; &nbsp; <span class="Comment">/* caller must change this if needed */<br/></li>
<li></span>&nbsp; &nbsp; giststate-&gt;leafTupdesc = index-&gt;rd_att;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The truncated tupdesc for non-leaf index tuples, which doesn't contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the INCLUDE attributes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is used to form tuples during tuple adjustment and page split.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * B-tree creates shortened tuple descriptor for every truncated tuple,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because it is doing this less often: it does not have to form truncated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples during page split.&nbsp; Also, B-tree is not adjusting tuples on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages the way GiST does.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; giststate-&gt;nonLeafTupdesc = <a href="../common/tupdesc.c.html#L173" title="access/common/tupdesc.c:173">CreateTupleDescCopyConstr</a>(index-&gt;rd_att);<br/></li>
<li>&nbsp; &nbsp; giststate-&gt;nonLeafTupdesc-&gt;natts =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexRelationGetNumberOfKeyAttributes(index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; IndexRelationGetNumberOfKeyAttributes(index); i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L580" title="utils/fmgr/fmgr.c:580">fmgr_info_copy</a>(&amp;(giststate-&gt;consistentFn[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(index, i + <span class="Constant">1</span>, GIST_CONSISTENT_PROC),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scanCxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L580" title="utils/fmgr/fmgr.c:580">fmgr_info_copy</a>(&amp;(giststate-&gt;unionFn[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(index, i + <span class="Constant">1</span>, GIST_UNION_PROC),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scanCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* opclasses are not required to provide a Compress method */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(<a href="../index/indexam.c.html#L826" title="access/index/indexam.c:826">index_getprocid</a>(index, i + <span class="Constant">1</span>, GIST_COMPRESS_PROC)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L580" title="utils/fmgr/fmgr.c:580">fmgr_info_copy</a>(&amp;(giststate-&gt;compressFn[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(index, i + <span class="Constant">1</span>, GIST_COMPRESS_PROC),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scanCxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; giststate-&gt;compressFn[i].fn_oid = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* opclasses are not required to provide a Decompress method */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(<a href="../index/indexam.c.html#L826" title="access/index/indexam.c:826">index_getprocid</a>(index, i + <span class="Constant">1</span>, GIST_DECOMPRESS_PROC)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L580" title="utils/fmgr/fmgr.c:580">fmgr_info_copy</a>(&amp;(giststate-&gt;decompressFn[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(index, i + <span class="Constant">1</span>, GIST_DECOMPRESS_PROC),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scanCxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; giststate-&gt;decompressFn[i].fn_oid = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L580" title="utils/fmgr/fmgr.c:580">fmgr_info_copy</a>(&amp;(giststate-&gt;penaltyFn[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(index, i + <span class="Constant">1</span>, GIST_PENALTY_PROC),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scanCxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L580" title="utils/fmgr/fmgr.c:580">fmgr_info_copy</a>(&amp;(giststate-&gt;picksplitFn[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(index, i + <span class="Constant">1</span>, GIST_PICKSPLIT_PROC),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scanCxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L580" title="utils/fmgr/fmgr.c:580">fmgr_info_copy</a>(&amp;(giststate-&gt;equalFn[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(index, i + <span class="Constant">1</span>, GIST_EQUAL_PROC),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scanCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* opclasses are not required to provide a Distance method */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(<a href="../index/indexam.c.html#L826" title="access/index/indexam.c:826">index_getprocid</a>(index, i + <span class="Constant">1</span>, GIST_DISTANCE_PROC)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L580" title="utils/fmgr/fmgr.c:580">fmgr_info_copy</a>(&amp;(giststate-&gt;distanceFn[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(index, i + <span class="Constant">1</span>, GIST_DISTANCE_PROC),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scanCxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; giststate-&gt;distanceFn[i].fn_oid = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* opclasses are not required to provide a Fetch method */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(<a href="../index/indexam.c.html#L826" title="access/index/indexam.c:826">index_getprocid</a>(index, i + <span class="Constant">1</span>, GIST_FETCH_PROC)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L580" title="utils/fmgr/fmgr.c:580">fmgr_info_copy</a>(&amp;(giststate-&gt;fetchFn[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(index, i + <span class="Constant">1</span>, GIST_FETCH_PROC),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scanCxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; giststate-&gt;fetchFn[i].fn_oid = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the index column has a specified collation, we should honor that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * while doing comparisons.&nbsp; However, we may have a collatable storage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * type for a noncollatable indexed data type.&nbsp; If there's no index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * collation then specify default collation in case the support<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> need collation.&nbsp; This is harmless if the support<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> don't care about collation, so we just do it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unconditionally.&nbsp; (We could alternatively call <a href="../../utils/cache/lsyscache.c.html#L3056" title="utils/cache/lsyscache.c:3056">get_typcollation</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but that seems like expensive overkill --- there aren't going to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cases where a GiST storage type has a nondefault collation.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(index-&gt;rd_indcollation[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; giststate-&gt;supportCollation[i] = index-&gt;rd_indcollation[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; giststate-&gt;supportCollation[i] = DEFAULT_COLLATION_OID;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No opclass information for INCLUDE attributes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (; i &lt; index-&gt;rd_att-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; giststate-&gt;consistentFn[i].fn_oid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; giststate-&gt;unionFn[i].fn_oid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; giststate-&gt;compressFn[i].fn_oid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; giststate-&gt;decompressFn[i].fn_oid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; giststate-&gt;penaltyFn[i].fn_oid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; giststate-&gt;picksplitFn[i].fn_oid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; giststate-&gt;equalFn[i].fn_oid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; giststate-&gt;distanceFn[i].fn_oid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; giststate-&gt;fetchFn[i].fn_oid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; giststate-&gt;supportCollation[i] = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> giststate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1653">&#x200c;</a></span><span class="linkable">freeGISTstate</span>(GISTSTATE *giststate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It's sufficient to delete the scanCxt */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(giststate-&gt;scanCxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1664" title="access/gist/gist.c:1664">gistprunepage</a>() -- try to remove LP_DEAD items from the given page.<br/></li>
<li></span><span class="Comment"> * Function assumes that buffer is exclusively locked.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1664">&#x200c;</a></span><span class="linkable">gistprunepage</span>(Relation rel, Page page, Buffer buffer, Relation heapRel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber deletable[MaxIndexTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndeletable = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(GistPageIsLeaf(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan over all items to see which ones need to be deleted according to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LP_DEAD flags.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (offnum = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum &lt;= maxoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum = OffsetNumberNext(offnum))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemId = PageGetItemId(page, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdIsDead(itemId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deletable[ndeletable++] = offnum;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndeletable &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId snapshotConflictHorizon = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogStandbyInfoActive() &amp;&amp; RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshotConflictHorizon =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../index/genam.c.html#L291" title="access/index/genam.c:291">index_compute_xid_horizon_for_tuples</a>(rel, heapRel, buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; deletable, ndeletable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1161" title="storage/page/bufpage.c:1161">PageIndexMultiDelete</a>(page, deletable, ndeletable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mark the page as not containing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LP_DEAD items.&nbsp; This is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * certainly true (there might be some that have recently been marked,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but weren't included in our target-item list), but it will almost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * always be true and it doesn't seem worth an additional page scan to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check it. Remember that F_HAS_GARBAGE is only a hint anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; GistClearPageHasGarbage(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="gistxlog.c.html#L670" title="access/gist/gistxlog.c:670">gistXLogDelete</a>(buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deletable, ndeletable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshotConflictHorizon,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, <a href="gistutil.c.html#L1016" title="access/gist/gistutil.c:1016">gistGetFakeLSN</a>(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: if we didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LP_DEAD items, then the page's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * F_HAS_GARBAGE hint <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is falsely set.&nbsp; We do not bother expending a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * separate write to clear it, however.&nbsp; We will clear it when we split<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
