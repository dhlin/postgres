<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/gist/gistvacuum.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/gist/gistvacuum.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L43">GistVacState</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L59">gistbulkdelete</a></li>
<li><a href="#L588">gistdeletepage</a></li>
<li><a href="#L461">gistvacuum_delete_empty_pages</a></li>
<li><a href="#L75">gistvacuumcleanup</a></li>
<li><a href="#L272">gistvacuumpage</a></li>
<li><a href="#L125">gistvacuumscan</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * gistvacuum.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; vacuuming routines for the postgres GiST index access method.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/gist/gistvacuum.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/gist_private.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/integerset.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/indexfsm.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Working state needed by <a href="#L59" title="access/gist/gistvacuum.c:59">gistbulkdelete</a> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; IndexVacuumInfo *info;<br/></li>
<li>&nbsp; &nbsp; IndexBulkDeleteResult *stats;<br/></li>
<li>&nbsp; &nbsp; IndexBulkDeleteCallback callback;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *callback_state;<br/></li>
<li>&nbsp; &nbsp; GistNSN&nbsp; &nbsp; &nbsp; &nbsp; startNSN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These are used to memorize all <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> and empty leaf pages.&nbsp; They are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used for deleting all the empty pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../lib/integerset.c.html#L197" title="lib/integerset.c:197">IntegerSet</a> *internal_page_set;<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/integerset.c.html#L197" title="lib/integerset.c:197">IntegerSet</a> *empty_leaf_set;<br/></li>
<li>&nbsp; &nbsp; MemoryContext page_set_context;<br/></li>
<li><a id="L43">&#x200c;</a>} <span class="linkable">GistVacState</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L125" title="access/gist/gistvacuum.c:125">gistvacuumscan</a>(IndexVacuumInfo *info, IndexBulkDeleteResult *stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexBulkDeleteCallback callback, <span class="Type">void</span> *callback_state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L272" title="access/gist/gistvacuum.c:272">gistvacuumpage</a>(<a href="#L43" title="access/gist/gistvacuum.c:43">GistVacState</a> *vstate, BlockNumber blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber orig_blkno);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L461" title="access/gist/gistvacuum.c:461">gistvacuum_delete_empty_pages</a>(IndexVacuumInfo *info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L43" title="access/gist/gistvacuum.c:43">GistVacState</a> *vstate);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L588" title="access/gist/gistvacuum.c:588">gistdeletepage</a>(IndexVacuumInfo *info, IndexBulkDeleteResult *stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer parentBuffer, OffsetNumber downlink,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer leafBuffer);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * VACUUM bulkdelete stage: remove index entries.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexBulkDeleteResult *<br/></li>
<li><a id="L59">&#x200c;</a><span class="linkable">gistbulkdelete</span>(IndexVacuumInfo *info, IndexBulkDeleteResult *stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexBulkDeleteCallback callback, <span class="Type">void</span> *callback_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate stats if first time through, else re-use existing struct */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stats == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = (IndexBulkDeleteResult *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexBulkDeleteResult));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L125" title="access/gist/gistvacuum.c:125">gistvacuumscan</a>(info, stats, callback, callback_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stats;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * VACUUM <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> stage: delete empty pages, and update index statistics.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexBulkDeleteResult *<br/></li>
<li><a id="L75">&#x200c;</a><span class="linkable">gistvacuumcleanup</span>(IndexVacuumInfo *info, IndexBulkDeleteResult *stats)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No-op in ANALYZE ONLY mode */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (info-&gt;analyze_only)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> stats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="#L59" title="access/gist/gistvacuum.c:59">gistbulkdelete</a> was called, we need not do anything, just return the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stats from the latest <a href="#L59" title="access/gist/gistvacuum.c:59">gistbulkdelete</a> call.&nbsp; If it wasn't called, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still need to do a pass over the index, to obtain index statistics.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stats == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = (IndexBulkDeleteResult *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexBulkDeleteResult));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L125" title="access/gist/gistvacuum.c:125">gistvacuumscan</a>(info, stats, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's quite possible for us to be fooled by concurrent page splits into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * double-counting some index tuples, so disbelieve <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> total that exceeds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the underlying heap's count ... if we know that accurately.&nbsp; Otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this might just make matters worse.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!info-&gt;estimated_count)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stats-&gt;num_index_tuples &gt; info-&gt;num_heap_tuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;num_index_tuples = info-&gt;num_heap_tuples;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stats;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L125" title="access/gist/gistvacuum.c:125">gistvacuumscan</a> --- scan the index for VACUUMing purposes<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This scans the index for leaf tuples that are deletable according to the<br/></li>
<li></span><span class="Comment"> * <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> callback, and updates the stats.&nbsp; Both <a href="../nbtree/nbtree.c.html#L808" title="access/nbtree/nbtree.c:808">btbulkdelete</a> and<br/></li>
<li></span><span class="Comment"> * <a href="../nbtree/nbtree.c.html#L838" title="access/nbtree/nbtree.c:838">btvacuumcleanup</a> invoke this (the latter only if no <a href="../nbtree/nbtree.c.html#L808" title="access/nbtree/nbtree.c:808">btbulkdelete</a> call<br/></li>
<li></span><span class="Comment"> * occurred).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This also makes note of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> empty leaf pages, as well as all <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a><br/></li>
<li></span><span class="Comment"> * pages while looping over all index pages.&nbsp; After scanning all the pages, we<br/></li>
<li></span><span class="Comment"> * remove the empty pages so that they can be reused.&nbsp; Any deleted pages are<br/></li>
<li></span><span class="Comment"> * added directly to the free space map.&nbsp; (They should've been added there<br/></li>
<li></span><span class="Comment"> * when they were originally deleted, already, but it's possible that the FSM<br/></li>
<li></span><span class="Comment"> * was lost at a crash, for example.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller is responsible for initially allocating/zeroing a stats struct.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L125">&#x200c;</a></span><span class="linkable">gistvacuumscan</span>(IndexVacuumInfo *info, IndexBulkDeleteResult *stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexBulkDeleteCallback callback, <span class="Type">void</span> *callback_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = info-&gt;index;<br/></li>
<li>&nbsp; &nbsp; <a href="#L43" title="access/gist/gistvacuum.c:43">GistVacState</a> vstate;<br/></li>
<li>&nbsp; &nbsp; BlockNumber num_pages;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needLock;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset fields that track information about the entire index <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoids double-counting in the case where a single VACUUM command<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requires multiple scans of the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid resetting the tuples_removed and pages_newly_deleted fields here,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since they track information about the VACUUM command, and so must last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * across each call to <a href="#L125" title="access/gist/gistvacuum.c:125">gistvacuumscan</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note that pages_free is treated as state about the whole index, not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the current VACUUM.&nbsp; This is appropriate because <a href="../../storage/freespace/indexfsm.c.html#L52" title="storage/freespace/indexfsm.c:52">RecordFreeIndexPage</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls are idempotent, and get repeated for the same deleted pages in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some scenarios.&nbsp; The point for us is to track the number of recyclable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages in the index at the end of the VACUUM command.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; stats-&gt;num_pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;estimated_count = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;num_index_tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;pages_deleted = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;pages_free = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the integer sets to remember all the <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> and the empty leaf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages in page_set_context.&nbsp; Internally, the integer set will remember<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this context so that the subsequent allocations for these integer sets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be done from the same context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> the allocation sizes used below pre-date generation context's block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * growing code.&nbsp; These <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> should likely be benchmarked and set to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more suitable <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; vstate.page_set_context = <a href="../../utils/mmgr/generation.c.html#L160" title="utils/mmgr/generation.c:160">GenerationContextCreate</a>(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;GiST VACUUM page set context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">16</span> * <span class="Constant">1024</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">16</span> * <span class="Constant">1024</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">16</span> * <span class="Constant">1024</span>);<br/></li>
<li>&nbsp; &nbsp; oldctx = MemoryContextSwitchTo(vstate.page_set_context);<br/></li>
<li>&nbsp; &nbsp; vstate.internal_page_set = <a href="../../lib/integerset.c.html#L284" title="lib/integerset.c:284">intset_create</a>();<br/></li>
<li>&nbsp; &nbsp; vstate.empty_leaf_set = <a href="../../lib/integerset.c.html#L284" title="lib/integerset.c:284">intset_create</a>();<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up info to pass down to <a href="#L272" title="access/gist/gistvacuum.c:272">gistvacuumpage</a> */<br/></li>
<li></span>&nbsp; &nbsp; vstate.info = info;<br/></li>
<li>&nbsp; &nbsp; vstate.stats = stats;<br/></li>
<li>&nbsp; &nbsp; vstate.callback = callback;<br/></li>
<li>&nbsp; &nbsp; vstate.callback_state = callback_state;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vstate.startNSN = <a href="../transam/xlog.c.html#L6438" title="access/transam/xlog.c:6438">GetInsertRecPtr</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vstate.startNSN = <a href="gistutil.c.html#L1016" title="access/gist/gistutil.c:1016">gistGetFakeLSN</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The outer loop iterates over all index pages, in physical order (we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hope the kernel will cooperate in providing read-ahead for speed).&nbsp; It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is critical that we visit all leaf pages, including ones added after we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * start the scan, else we might fail to delete some deletable tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Hence, we must repeatedly check the relation length.&nbsp; We must acquire<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the relation-extension lock while doing so to avoid a race condition:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if someone else is extending the relation, there is a window where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bufmgr/smgr have created a new all-zero page but it hasn't yet been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * write-locked by <a href="gistutil.c.html#L824" title="access/gist/gistutil.c:824">gistNewBuffer</a>().&nbsp; If we manage to scan such a page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here, we'll improperly assume it can be recycled.&nbsp; Taking the lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * synchronizes things enough to prevent a problem: either num_pages won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * include the new page, or <a href="gistutil.c.html#L824" title="access/gist/gistutil.c:824">gistNewBuffer</a> already has write lock on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer and it will be fully initialized <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can examine it.&nbsp; (See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also vacuumlazy.c, which has the same issue.)&nbsp; Also, we need not worry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if a page is added immediately after we look; the page splitting code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already has write-lock on the left page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it adds a right page, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we must already have processed <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples due to be moved into such a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> locking for new or temp relations, however, since no one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * else could be accessing them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; needLock = !RELATION_IS_LOCAL(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; blkno = GIST_ROOT_BLKNO;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the current relation length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L430" title="storage/lmgr/lmgr.c:430">LockRelationForExtension</a>(rel, ExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num_pages = RelationGetNumberOfBlocks(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L480" title="storage/lmgr/lmgr.c:480">UnlockRelationForExtension</a>(rel, ExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Quit if we've scanned the whole relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno &gt;= num_pages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Iterate over pages, then loop back to recheck length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; blkno &lt; num_pages; blkno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L272" title="access/gist/gistvacuum.c:272">gistvacuumpage</a>(&amp;vstate, blkno, blkno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we found <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> recyclable pages (and recorded them in the FSM), then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * forcibly update the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level FSM pages to ensure that searchers can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> them.&nbsp; It's possible that the pages were also found during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previous scans and so this is a waste of time, but it's cheap enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relative to scanning the index that it shouldn't matter much, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * making sure that free pages are available sooner not later seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worthwhile.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that if no recyclable pages exist, we don't bother vacuuming the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FSM at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stats-&gt;pages_free &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/indexfsm.c.html#L71" title="storage/freespace/indexfsm.c:71">IndexFreeSpaceMapVacuum</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update statistics */<br/></li>
<li></span>&nbsp; &nbsp; stats-&gt;num_pages = num_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we saw <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> empty pages, try to unlink them from the tree so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they can be reused.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L461" title="access/gist/gistvacuum.c:461">gistvacuum_delete_empty_pages</a>(info, &amp;vstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't need the <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> and empty page sets anymore */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(vstate.page_set_context);<br/></li>
<li>&nbsp; &nbsp; vstate.page_set_context = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; vstate.internal_page_set = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; vstate.empty_leaf_set = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L272" title="access/gist/gistvacuum.c:272">gistvacuumpage</a> --- VACUUM one page<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This processes a single page for <a href="#L59" title="access/gist/gistvacuum.c:59">gistbulkdelete</a>().&nbsp; In some cases we<br/></li>
<li></span><span class="Comment"> * must go back and re-examine previously-scanned pages; this routine<br/></li>
<li></span><span class="Comment"> * recurses when necessary to handle that case.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * blkno is the page to process.&nbsp; orig_blkno is the highest block number<br/></li>
<li></span><span class="Comment"> * reached by the outer <a href="#L125" title="access/gist/gistvacuum.c:125">gistvacuumscan</a> loop (the same as blkno, unless we<br/></li>
<li></span><span class="Comment"> * are recursing to re-examine a previous page).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L272">&#x200c;</a></span><span class="linkable">gistvacuumpage</span>(<a href="#L43" title="access/gist/gistvacuum.c:43">GistVacState</a> *vstate, BlockNumber blkno, BlockNumber orig_blkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexVacuumInfo *info = vstate-&gt;info;<br/></li>
<li>&nbsp; &nbsp; IndexBulkDeleteCallback callback = vstate-&gt;callback;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *callback_state = vstate-&gt;callback_state;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = info-&gt;index;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BlockNumber recurse_to;<br/></li>
<li><br/></li>
<li><span class="Statement">restart</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; recurse_to = InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* call <a href="../../commands/vacuum.c.html#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a> while not holding <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> buffer lock */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(rel, MAIN_FORKNUM, blkno, RBM_NORMAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info-&gt;strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We are not going to stay here for a long time, aggressively grab an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exclusive lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIST_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="gistutil.c.html#L888" title="access/gist/gistutil.c:888">gistPageRecyclable</a>(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Okay to recycle this page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/indexfsm.c.html#L52" title="storage/freespace/indexfsm.c:52">RecordFreeIndexPage</a>(rel, blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vstate-&gt;stats-&gt;pages_deleted++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vstate-&gt;stats-&gt;pages_free++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (GistPageIsDeleted(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Already deleted, but can't recycle yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vstate-&gt;stats-&gt;pages_deleted++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (GistPageIsLeaf(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber todelete[MaxOffsetNumber];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntodelete = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nremain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GISTPageOpaque opaque = GistPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check whether we need to recurse back to earlier pages.&nbsp; What we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are concerned about is a page split that happened since we started<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> scan.&nbsp; If the split moved some tuples to a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then we might have missed 'em.&nbsp; If so, set up for tail recursion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is similar to the checks we do during searches, when following<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a downlink, but we don't need to jump to higher-numbered pages,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because we will process them later, anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((GistFollowRight(page) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vstate-&gt;startNSN &lt; GistPageGetNSN(page)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (opaque-&gt;rightlink != InvalidBlockNumber) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (opaque-&gt;rightlink &lt; orig_blkno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recurse_to = opaque-&gt;rightlink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Scan over all items to see which ones need to be deleted according<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the callback function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (callback)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber off;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (off = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; off &lt;= maxoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; off = OffsetNumberNext(off))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(page, off);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; idxtuple = (IndexTuple) PageGetItem(page, iid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (callback(&amp;(idxtuple-&gt;t_tid), callback_state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; todelete[ntodelete++] = off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Apply <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> needed deletes.&nbsp; We issue just one WAL record per page,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so as to minimize WAL traffic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ntodelete &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1161" title="storage/page/bufpage.c:1161">PageIndexMultiDelete</a>(page, todelete, ntodelete);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistMarkTuplesDeleted(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="gistxlog.c.html#L629" title="access/gist/gistxlog.c:629">gistXLogUpdate</a>(buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; todelete, ntodelete,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>, InvalidBuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, <a href="gistutil.c.html#L1016" title="access/gist/gistutil.c:1016">gistGetFakeLSN</a>(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vstate-&gt;stats-&gt;tuples_removed += ntodelete;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must recompute maxoff */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nremain = maxoff - FirstOffsetNumber + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nremain == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The page is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> completely empty.&nbsp; Remember its block number,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so that we will try to delete the page in the second stage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Skip this when recursing, because <a href="../../lib/integerset.c.html#L197" title="lib/integerset.c:197">IntegerSet</a> requires that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are added in ascending order.&nbsp; The <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> VACUUM will pick<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno == orig_blkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/integerset.c.html#L370" title="lib/integerset.c:370">intset_add_member</a>(vstate-&gt;empty_leaf_set, blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vstate-&gt;stats-&gt;num_index_tuples += nremain;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page, check for &quot;invalid tuples&quot;, left behind by an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incomplete page split on PostgreSQL 9.0 or below.&nbsp; These are not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * created by newer PostgreSQL versions, but unfortunately, there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no version number anywhere in a GiST index, so we don't know<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether this index might still contain invalid tuples or not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber off;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (off = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; off &lt;= maxoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; off = OffsetNumberNext(off))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(page, off);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; idxtuple = (IndexTuple) PageGetItem(page, iid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GistTupleIsInvalid(idxtuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains an inner tuple marked as invalid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;This is caused by an incomplete page split at crash recovery <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> upgrading to PostgreSQL 9.1.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Please REINDEX it.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember the block number of this page, so that we can revisit it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later in <a href="#L461" title="access/gist/gistvacuum.c:461">gistvacuum_delete_empty_pages</a>(), when we search for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parents of empty leaf pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno == orig_blkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/integerset.c.html#L370" title="lib/integerset.c:370">intset_add_member</a>(vstate-&gt;internal_page_set, blkno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is really tail recursion, but if the compiler is too stupid to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> it as such, we'd eat an uncomfortably large amount of stack<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space per recursion level (due to the deletable[] array).&nbsp; A failure is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * improbable since the number of levels isn't likely to be large ... but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just in case, let's hand-<a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> into a loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (recurse_to != InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blkno = recurse_to;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> restart;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Scan all <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages, and try to delete their empty child pages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L461">&#x200c;</a></span><span class="linkable">gistvacuum_delete_empty_pages</span>(IndexVacuumInfo *info, <a href="#L43" title="access/gist/gistvacuum.c:43">GistVacState</a> *vstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = info-&gt;index;<br/></li>
<li>&nbsp; &nbsp; BlockNumber empty_pages_remaining;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Rescan all inner pages to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> those that have empty child pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; empty_pages_remaining = <a href="../../lib/integerset.c.html#L350" title="lib/integerset.c:350">intset_num_entries</a>(vstate-&gt;empty_leaf_set);<br/></li>
<li>&nbsp; &nbsp; <a href="../../lib/integerset.c.html#L624" title="lib/integerset.c:624">intset_begin_iterate</a>(vstate-&gt;internal_page_set);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (empty_pages_remaining &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../lib/integerset.c.html#L643" title="lib/integerset.c:643">intset_iterate_next</a>(vstate-&gt;internal_page_set, &amp;blkno))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber off,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber todelete[MaxOffsetNumber];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber leafs_to_delete[MaxOffsetNumber];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntodelete;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deleted;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(rel, MAIN_FORKNUM, (BlockNumber) blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RBM_NORMAL, info-&gt;strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIST_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(page) || GistPageIsDeleted(page) || GistPageIsLeaf(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This page was an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page earlier, but <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> it's something<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * else. Shouldn't happen...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Scan all the downlinks, and see if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of them point to empty leaf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ntodelete = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (off = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; off &lt;= maxoff &amp;&amp; ntodelete &lt; maxoff - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; off = OffsetNumberNext(off))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(page, off);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; idxtuple = (IndexTuple) PageGetItem(page, iid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber leafblk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leafblk = ItemPointerGetBlockNumber(&amp;(idxtuple-&gt;t_tid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../lib/integerset.c.html#L554" title="lib/integerset.c:554">intset_is_member</a>(vstate-&gt;empty_leaf_set, leafblk))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leafs_to_delete[ntodelete] = leafblk;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; todelete[ntodelete++] = off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In order to avoid deadlock, child page must be locked <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent, so we must release the lock on the parent, lock the child,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and then re-acquire the lock the parent.&nbsp; (And we wouldn't want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do I/O, while holding a lock, anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At the instant that we're not holding a lock on the parent, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * downlink might get moved by a concurrent insert, so we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * re-check that it still points to the same child page after we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * acquired both locks.&nbsp; Also, another backend might have inserted a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple to the page, so that it is no longer empty.&nbsp; <a href="#L588" title="access/gist/gistvacuum.c:588">gistdeletepage</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * re-checks all these conditions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIST_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; deleted = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; ntodelete; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; leafbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't remove the last downlink from the parent.&nbsp; That would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * confuse the insertion code.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) == FirstOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leafbuf = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(rel, MAIN_FORKNUM, leafs_to_delete[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RBM_NORMAL, info-&gt;strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(leafbuf, GIST_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L785" title="access/gist/gistutil.c:785">gistcheckpage</a>(rel, leafbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIST_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L588" title="access/gist/gistvacuum.c:588">gistdeletepage</a>(info, vstate-&gt;stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buffer, todelete[i] - deleted,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; leafbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deleted++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIST_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(leafbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can stop the scan as soon as we have seen the downlinks, even if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we were not able to remove them all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; empty_pages_remaining -= ntodelete;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L588" title="access/gist/gistvacuum.c:588">gistdeletepage</a> takes a leaf page, and its parent, and tries to delete the<br/></li>
<li></span><span class="Comment"> * leaf.&nbsp; Both pages must be locked.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Even if the page was empty when we first saw it, a concurrent inserter might<br/></li>
<li></span><span class="Comment"> * have added a tuple to it since.&nbsp; Similarly, the downlink might have moved.<br/></li>
<li></span><span class="Comment"> * We re-check all the conditions, to make sure the page is still deletable,<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> modifying anything.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true, if the page was deleted, and false if a concurrent update<br/></li>
<li></span><span class="Comment"> * prevented it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L588">&#x200c;</a></span><span class="linkable">gistdeletepage</span>(IndexVacuumInfo *info, IndexBulkDeleteResult *stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer parentBuffer, OffsetNumber downlink,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer leafBuffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; parentPage = BufferGetPage(parentBuffer);<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; leafPage = BufferGetPage(leafBuffer);<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; idxtuple;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId txid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that the leaf is still empty and deletable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!GistPageIsLeaf(leafPage))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* a leaf page should never become a non-leaf page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (GistFollowRight(leafPage))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't mess with a concurrent page split */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(leafPage) != InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not empty anymore */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ok, the leaf is deletable.&nbsp; Is the downlink in the parent page still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * valid?&nbsp; It might have been moved by a concurrent insert.&nbsp; We could try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it by scanning the page again, possibly moving right if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * was split.&nbsp; But for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, let's keep it simple and just give up.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> VACUUM will pick it up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(parentPage) || GistPageIsDeleted(parentPage) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GistPageIsLeaf(parentPage))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen, <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages are never deleted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(parentPage) &lt; downlink<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; || PageGetMaxOffsetNumber(parentPage) &lt;= FirstOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; iid = PageGetItemId(parentPage, downlink);<br/></li>
<li>&nbsp; &nbsp; idxtuple = (IndexTuple) PageGetItem(parentPage, iid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(leafBuffer) !=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetBlockNumber(&amp;(idxtuple-&gt;t_tid)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All good, proceed with the deletion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The page cannot be immediately recycled, because in-progress scans that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * saw the downlink might still visit it.&nbsp; Mark the page with the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-XID counter, so that we know when it can be recycled.&nbsp; Once that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XID becomes older than GlobalXmin, we know that all scans that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * currently in progress must have ended.&nbsp; (That's much more conservative<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than needed, but let's keep it safe and simple.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; txid = <a href="../transam/varsup.c.html#L288" title="access/transam/varsup.c:288">ReadNextFullTransactionId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* mark the page as deleted */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(leafBuffer);<br/></li>
<li>&nbsp; &nbsp; GistPageSetDeleted(leafPage, txid);<br/></li>
<li>&nbsp; &nbsp; stats-&gt;pages_newly_deleted++;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;pages_deleted++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remove the downlink from the parent */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(parentBuffer);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1052" title="storage/page/bufpage.c:1052">PageIndexTupleDelete</a>(parentPage, downlink);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(info-&gt;index))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="gistxlog.c.html#L552" title="access/gist/gistxlog.c:552">gistXLogPageDelete</a>(leafBuffer, txid, parentBuffer, downlink);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="gistutil.c.html#L1016" title="access/gist/gistutil.c:1016">gistGetFakeLSN</a>(info-&gt;index);<br/></li>
<li>&nbsp; &nbsp; PageSetLSN(parentPage, recptr);<br/></li>
<li>&nbsp; &nbsp; PageSetLSN(leafPage, recptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
