<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/gist/gistxlog.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/gist/gistxlog.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L26">opCtx</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L223">decodePageSplitRecord</a></li>
<li><a href="#L40">gistRedoClearFollowRight</a></li>
<li><a href="#L172">gistRedoDeleteRecord</a></li>
<li><a href="#L342">gistRedoPageDelete</a></li>
<li><a href="#L376">gistRedoPageReuse</a></li>
<li><a href="#L247">gistRedoPageSplitRecord</a></li>
<li><a href="#L70">gistRedoPageUpdateRecord</a></li>
<li><a href="#L576">gistXLogAssignLSN</a></li>
<li><a href="#L670">gistXLogDelete</a></li>
<li><a href="#L552">gistXLogPageDelete</a></li>
<li><a href="#L594">gistXLogPageReuse</a></li>
<li><a href="#L495">gistXLogSplit</a></li>
<li><a href="#L629">gistXLogUpdate</a></li>
<li><a href="#L453">gist_mask</a></li>
<li><a href="#L397">gist_redo</a></li>
<li><a href="#L444">gist_xlog_cleanup</a></li>
<li><a href="#L438">gist_xlog_startup</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * gistxlog.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; WAL replay logic for GiST.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; src/backend/access/gist/gistxlog.c<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/bufmask.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/gist_private.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/gistxlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/standby.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L26">&#x200c;</a><span class="Type">static</span> MemoryContext <span class="linkable">opCtx</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* working memory for operations */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Replay the clearing of F_FOLLOW_RIGHT flag on a child page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Even if the WAL record includes a full-page image, we have to update the<br/></li>
<li></span><span class="Comment"> * follow-right flag, because that change is not included in the full-page<br/></li>
<li></span><span class="Comment"> * image.&nbsp; To be sure that the intermediate state with the wrong flag value is<br/></li>
<li></span><span class="Comment"> * not visible to concurrent Hot Standby queries, this function handles<br/></li>
<li></span><span class="Comment"> * restoring the full-page image as well as updating the flag.&nbsp; (Note that<br/></li>
<li></span><span class="Comment"> * we never need to do anything else to the child page in the current WAL<br/></li>
<li></span><span class="Comment"> * action.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L40">&#x200c;</a></span><span class="linkable">gistRedoClearFollowRight</span>(XLogReaderState *record, uint8 block_id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; XLogRedoAction action;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we still update the page even if it was restored from a full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page image, because the updated NSN is not included in the image.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; action = <a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, block_id, &amp;buffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (action == BLK_NEEDS_REDO || action == BLK_RESTORED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GistPageSetNSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GistClearFollowRight(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * redo <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> page update (except page split)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L70">&#x200c;</a></span><span class="linkable">gistRedoPageUpdateRecord</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; gistxlogPageUpdate *xldata = (gistxlogPageUpdate *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">0</span>, &amp;buffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *begin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; datalen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ninserted <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data = begin = <a href="../transam/xlogreader.c.html#L2025" title="access/transam/xlogreader.c:2025">XLogRecGetBlockData</a>(record, <span class="Constant">0</span>, &amp;datalen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xldata-&gt;ntodelete == <span class="Constant">1</span> &amp;&amp; xldata-&gt;ntoinsert == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When replacing one tuple with one other tuple, we must use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/page/bufpage.c.html#L1405" title="storage/page/bufpage.c:1405">PageIndexTupleOverwrite</a> for consistency with <a href="gist.c.html#L225" title="access/gist/gist.c:225">gistplacetopage</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offnum = *((OffsetNumber *) data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; itupsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itupsize = IndexTupleSize(itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/page/bufpage.c.html#L1405" title="storage/page/bufpage.c:1405">PageIndexTupleOverwrite</a>(page, offnum, (Item) itup, itupsize))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add item to GiST index page, size </span><span class="Special">%d</span><span class="Constant"> bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) itupsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += itupsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should be nothing left after consuming 1 tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(data - begin == datalen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update insertion count for assert check below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ninserted++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (xldata-&gt;ntodelete &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise, delete old tuples if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *todelete = (OffsetNumber *) data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber) * xldata-&gt;ntodelete;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1161" title="storage/page/bufpage.c:1161">PageIndexMultiDelete</a>(page, todelete, xldata-&gt;ntodelete);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GistPageIsLeaf(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistMarkTuplesDeleted(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add new tuples if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (data - begin &lt; datalen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber off = (PageIsEmpty(page)) ? FirstOffsetNumber :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumberNext(PageGetMaxOffsetNumber(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (data - begin &lt; datalen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup = (IndexTuple) data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; sz = IndexTupleSize(itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += sz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; l = PageAddItem(page, (Item) itup, sz, off, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (l == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add item to GiST index page, size </span><span class="Special">%d</span><span class="Constant"> bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) sz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; off++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ninserted++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check that XLOG record contained expected number of tuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ninserted == xldata-&gt;ntoinsert);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fix follow-right data on left child page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This must be done while still holding the lock on the target page. Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that even if the target page no longer exists, we still attempt to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replay the change on the child page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (XLogRecHasBlockRef(record, <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="access/gist/gistxlog.c:40">gistRedoClearFollowRight</a>(record, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * redo delete on gist index page to remove tuples marked as DEAD during index<br/></li>
<li></span><span class="Comment"> * tuple insertion<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L172">&#x200c;</a></span><span class="linkable">gistRedoDeleteRecord</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; gistxlogDelete *xldata = (gistxlogDelete *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber *toDelete = xldata-&gt;offsets;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> conflict processing to do, it must happen <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * GiST delete <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> can conflict with standby queries.&nbsp; You might think<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> would conflict as well, but we've handled that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already.&nbsp; XLOG_HEAP2_PRUNE_VACUUM_SCAN <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> provide the highest xid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cleaned by the <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> of the heap and so we can resolve <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> conflicts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just once when that arrives.&nbsp; After that we know that no conflicts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exist from individual gist <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> on that index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (InHotStandby)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xlogreader.c.html#L1971" title="access/transam/xlogreader.c:1971">XLogRecGetBlockTag</a>(record, <span class="Constant">0</span>, &amp;rlocator, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/standby.c.html#L467" title="storage/ipc/standby.c:467">ResolveRecoveryConflictWithSnapshot</a>(xldata-&gt;snapshotConflictHorizon,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xldata-&gt;isCatalogRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlocator);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">0</span>, &amp;buffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1161" title="storage/page/bufpage.c:1161">PageIndexMultiDelete</a>(page, toDelete, xldata-&gt;ntodelete);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GistClearPageHasGarbage(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GistMarkTuplesDeleted(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns an array of index pointers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> IndexTuple *<br/></li>
<li><a id="L223">&#x200c;</a><span class="linkable">decodePageSplitRecord</span>(<span class="Type">char</span> *begin, <span class="Type">int</span> len, <span class="Type">int</span> *n)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; IndexTuple *tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* extract the number of tuples */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(n, begin, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; ptr = begin + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuples = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(*n * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTuple));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; *n; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ptr - begin &lt; len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuples[i] = (IndexTuple) ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += IndexTupleSize((IndexTuple) ptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(ptr - begin == len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tuples;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L247">&#x200c;</a></span><span class="linkable">gistRedoPageSplitRecord</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; gistxlogPageSplit *xldata = (gistxlogPageSplit *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; firstbuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isrootsplit = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must hold lock on the first-listed page throughout the action,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * including while updating the left child page (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).&nbsp; We can unlock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remaining pages in the list as soon as they've been written, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there is no path for concurrent queries to reach those pages without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first visiting the first-listed page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* loop around all pages */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; xldata-&gt;npage; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; datalen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple *tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xlogreader.c.html#L1971" title="access/transam/xlogreader.c:1971">XLogRecGetBlockTag</a>(record, i + <span class="Constant">1</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, &amp;blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno == GIST_ROOT_BLKNO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(i == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isrootsplit = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../transam/xlogutils.c.html#L326" title="access/transam/xlogutils.c:326">XLogInitBufferForRedo</a>(record, i + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data = <a href="../transam/xlogreader.c.html#L2025" title="access/transam/xlogreader.c:2025">XLogRecGetBlockData</a>(record, i + <span class="Constant">1</span>, &amp;datalen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuples = <a href="#L223" title="access/gist/gistxlog.c:223">decodePageSplitRecord</a>(data, datalen, &amp;num);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ok, clear buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xldata-&gt;origleaf &amp;&amp; blkno != GIST_ROOT_BLKNO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags = F_LEAF;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L773" title="access/gist/gistutil.c:773">GISTInitBuffer</a>(buffer, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and fill it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L34" title="access/gist/gistutil.c:34">gistfillbuffer</a>(page, tuples, num, FirstOffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno == GIST_ROOT_BLKNO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistPageGetOpaque(page)-&gt;rightlink = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistPageSetNSN(page, xldata-&gt;orignsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistClearFollowRight(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; xldata-&gt;npage - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber nextblkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xlogreader.c.html#L1971" title="access/transam/xlogreader.c:1971">XLogRecGetBlockTag</a>(record, i + <span class="Constant">2</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, &amp;nextblkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistPageGetOpaque(page)-&gt;rightlink = nextblkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistPageGetOpaque(page)-&gt;rightlink = xldata-&gt;origrlink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistPageSetNSN(page, xldata-&gt;orignsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; xldata-&gt;npage - <span class="Constant">1</span> &amp;&amp; !isrootsplit &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xldata-&gt;markfollowright)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistMarkFollowRight(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistClearFollowRight(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstbuffer = buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fix follow-right data on left child page, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (XLogRecHasBlockRef(record, <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L40" title="access/gist/gistxlog.c:40">gistRedoClearFollowRight</a>(record, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally, release lock on the first page */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(firstbuffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* redo page deletion */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L342">&#x200c;</a></span><span class="linkable">gistRedoPageDelete</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; gistxlogPageDelete *xldata = (gistxlogPageDelete *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; parentBuffer;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; leafBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">0</span>, &amp;leafBuffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(leafBuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GistPageSetDeleted(page, xldata-&gt;deleteXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(leafBuffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">1</span>, &amp;parentBuffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(parentBuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1052" title="storage/page/bufpage.c:1052">PageIndexTupleDelete</a>(page, xldata-&gt;downlinkOffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(parentBuffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(parentBuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(parentBuffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(leafBuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(leafBuffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L376">&#x200c;</a></span><span class="linkable">gistRedoPageReuse</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; gistxlogPageReuse *xlrec = (gistxlogPageReuse *) XLogRecGetData(record);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PAGE_REUSE <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> exist to provide a conflict point when we reuse<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages in the index via the FSM.&nbsp; That's all they do though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshotConflictHorizon was the page's deleteXid.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/procarray.c.html#L4270" title="storage/ipc/procarray.c:4270">GlobalVisCheckRemovableFullXid</a>(deleteXid) test in <a href="gistutil.c.html#L888" title="access/gist/gistutil.c:888">gistPageRecyclable</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conceptually mirrors the PGPROC-&gt;xmin &gt; limitXmin test in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/procarray.c.html#L3404" title="storage/ipc/procarray.c:3404">GetConflictingVirtualXIDs</a>().&nbsp; Consequently, one XID value achieves the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same exclusion effect on primary and standby.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (InHotStandby)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/standby.c.html#L511" title="storage/ipc/standby.c:511">ResolveRecoveryConflictWithSnapshotFullXid</a>(xlrec-&gt;snapshotConflictHorizon,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;isCatalogRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;locator);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L397">&#x200c;</a></span><span class="linkable">gist_redo</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(record) &amp; ~XLR_INFO_MASK;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldCxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * GiST indexes do not require <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> conflict processing. NB: If we ever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implement a similar optimization we have in b-tree, and remove killed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples outside VACUUM, we'll need to handle that here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; oldCxt = MemoryContextSwitchTo(<a href="../spgist/spgxlog.c.html#L25" title="access/spgist/spgxlog.c:25">opCtx</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_GIST_PAGE_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L70" title="access/gist/gistxlog.c:70">gistRedoPageUpdateRecord</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_GIST_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L172" title="access/gist/gistxlog.c:172">gistRedoDeleteRecord</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_GIST_PAGE_REUSE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L376" title="access/gist/gistxlog.c:376">gistRedoPageReuse</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_GIST_PAGE_SPLIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L247" title="access/gist/gistxlog.c:247">gistRedoPageSplitRecord</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_GIST_PAGE_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L342" title="access/gist/gistxlog.c:342">gistRedoPageDelete</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_GIST_ASSIGN_LSN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nop. See <a href="gistutil.c.html#L1016" title="access/gist/gistutil.c:1016">gistGetFakeLSN</a>(). */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;<a href="#L397" title="access/gist/gistxlog.c:397">gist_redo</a>: unknown op code </span><span class="Special">%u</span><span class="Constant">&quot;</span>, info);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldCxt);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="../spgist/spgxlog.c.html#L25" title="access/spgist/spgxlog.c:25">opCtx</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L438">&#x200c;</a></span><span class="linkable">gist_xlog_startup</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../spgist/spgxlog.c.html#L25" title="access/spgist/spgxlog.c:25">opCtx</a> = <a href="gist.c.html#L122" title="access/gist/gist.c:122">createTempGistContext</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L444">&#x200c;</a></span><span class="linkable">gist_xlog_cleanup</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(<a href="../spgist/spgxlog.c.html#L25" title="access/spgist/spgxlog.c:25">opCtx</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Mask a Gist page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> running consistency checks on it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L453">&#x200c;</a></span><span class="linkable">gist_mask</span>(<span class="Type">char</span> *pagedata, BlockNumber blkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) pagedata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../common/bufmask.c.html#L31" title="access/common/bufmask.c:31">mask_page_lsn_and_checksum</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../common/bufmask.c.html#L46" title="access/common/bufmask.c:46">mask_page_hint_bits</a>(page);<br/></li>
<li>&nbsp; &nbsp; <a href="../common/bufmask.c.html#L71" title="access/common/bufmask.c:71">mask_unused_space</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NSN is nothing but a special purpose LSN. Hence, mask it for the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reason as <a href="../common/bufmask.c.html#L31" title="access/common/bufmask.c:31">mask_page_lsn_and_checksum</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; GistPageSetNSN(page, (uint64) MASK_MARKER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We update F_FOLLOW_RIGHT flag on the left child after writing WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record. Hence, mask this flag. See <a href="gist.c.html#L225" title="access/gist/gist.c:225">gistplacetopage</a>() for details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; GistMarkFollowRight(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (GistPageIsLeaf(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In gist leaf pages, it is possible to modify the LP_FLAGS without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * emitting <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WAL record. Hence, mask the line pointer flags. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="gistget.c.html#L38" title="access/gist/gistget.c:38">gistkillitems</a>() for details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/bufmask.c.html#L95" title="access/common/bufmask.c:95">mask_lp_flags</a>(page);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During gist redo, we never mark a page as garbage. Hence, mask it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> differences.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; GistClearPageHasGarbage(page);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write WAL record of a page split.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L495">&#x200c;</a><span class="linkable">gistXLogSplit</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> page_is_leaf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SplitPageLayout *dist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber origrlink, GistNSN orignsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer leftchildbuf, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> markfollowright)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; gistxlogPageSplit xlrec;<br/></li>
<li>&nbsp; &nbsp; SplitPageLayout *ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npage = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (ptr = dist; ptr; ptr = ptr-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; npage++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec.origrlink = origrlink;<br/></li>
<li>&nbsp; &nbsp; xlrec.orignsn = orignsn;<br/></li>
<li>&nbsp; &nbsp; xlrec.origleaf = page_is_leaf;<br/></li>
<li>&nbsp; &nbsp; xlrec.npage = (uint16) npage;<br/></li>
<li>&nbsp; &nbsp; xlrec.markfollowright = markfollowright;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Include a full page image of the child buf. (only necessary if a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoint happened since the child page was split)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(leftchildbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, leftchildbuf, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: We register a lot of data. The caller must've called<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../transam/xloginsert.c.html#L175" title="access/transam/xloginsert.c:175">XLogEnsureRecordSpace</a>() to prepare for that. We cannot do it here,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because we're already in a critical section. If you change the number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of buffer or data registrations here, make sure you modify the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../transam/xloginsert.c.html#L175" title="access/transam/xloginsert.c:175">XLogEnsureRecordSpace</a>() calls accordingly!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(gistxlogPageSplit));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (ptr = dist; ptr; ptr = ptr-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(i, ptr-&gt;buffer, REGBUF_WILL_INIT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(i, (<span class="Type">char</span> *) &amp;(ptr-&gt;block.num), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(i, (<span class="Type">char</span> *) ptr-&gt;list, ptr-&gt;lenlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_GIST_ID, XLOG_GIST_PAGE_SPLIT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> recptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write XLOG record describing a page deletion. This also includes removal of<br/></li>
<li></span><span class="Comment"> * downlink from the parent page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L552">&#x200c;</a><span class="linkable">gistXLogPageDelete</span>(Buffer buffer, FullTransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer parentBuffer, OffsetNumber downlinkOffset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; gistxlogPageDelete xlrec;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec.deleteXid = xid;<br/></li>
<li>&nbsp; &nbsp; xlrec.downlinkOffset = downlinkOffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfGistxlogPageDelete);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buffer, REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">1</span>, parentBuffer, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_GIST_ID, XLOG_GIST_PAGE_DELETE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> recptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write an empty XLOG record to assign a distinct LSN.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L576">&#x200c;</a><span class="linkable">gistXLogAssignLSN</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dummy = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Records other than XLOG_SWITCH must have content. We use an integer 0<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to follow the restriction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L456" title="access/transam/xloginsert.c:456">XLogSetRecordFlags</a>(XLOG_MARK_UNIMPORTANT);<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;dummy, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dummy));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_GIST_ID, XLOG_GIST_ASSIGN_LSN);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write XLOG record about reuse of a deleted page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L594">&#x200c;</a></span><span class="linkable">gistXLogPageReuse</span>(Relation rel, Relation heaprel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno, FullTransactionId deleteXid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; gistxlogPageReuse xlrec_reuse;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we don't register the buffer with the record, because this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operation doesn't modify the page. This record only exists to provide a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conflict point for Hot Standby.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; xlrec_reuse.isCatalogRel = RelationIsAccessibleInLogicalDecoding(heaprel);<br/></li>
<li>&nbsp; &nbsp; xlrec_reuse.locator = rel-&gt;rd_locator;<br/></li>
<li>&nbsp; &nbsp; xlrec_reuse.block = blkno;<br/></li>
<li>&nbsp; &nbsp; xlrec_reuse.snapshotConflictHorizon = deleteXid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec_reuse, SizeOfGistxlogPageReuse);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_GIST_ID, XLOG_GIST_PAGE_REUSE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write XLOG record describing a page update. The update can include <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * number of deletions and/or insertions of tuples on a single index page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If this update inserts a downlink for a split page, also record that<br/></li>
<li></span><span class="Comment"> * the F_FOLLOW_RIGHT flag on the child page is cleared and NSN set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that both the todelete array and the tuples are marked as belonging<br/></li>
<li></span><span class="Comment"> * to the target buffer; they need not be stored in XLOG if <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a> decides<br/></li>
<li></span><span class="Comment"> * to log the whole buffer contents instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L629">&#x200c;</a><span class="linkable">gistXLogUpdate</span>(Buffer buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber *todelete, <span class="Type">int</span> ntodelete,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTuple *itup, <span class="Type">int</span> ituplen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer leftchildbuf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; gistxlogPageUpdate xlrec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec.ntodelete = ntodelete;<br/></li>
<li>&nbsp; &nbsp; xlrec.ntoinsert = ituplen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(gistxlogPageUpdate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buffer, REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) todelete, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber) * ntodelete);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* new tuples */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ituplen; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) (itup[i]), IndexTupleSize(itup[i]));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Include a full page image of the child buf. (only necessary if a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoint happened since the child page was split)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(leftchildbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">1</span>, leftchildbuf, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_GIST_ID, XLOG_GIST_PAGE_UPDATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> recptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write XLOG record describing a delete of leaf index tuples marked as DEAD<br/></li>
<li></span><span class="Comment"> * during new tuple insertion.&nbsp; One may think that this case is already covered<br/></li>
<li></span><span class="Comment"> * by <a href="#L629" title="access/gist/gistxlog.c:629">gistXLogUpdate</a>().&nbsp; But deletion of index tuples might conflict with<br/></li>
<li></span><span class="Comment"> * standby queries and needs special handling.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L670">&#x200c;</a><span class="linkable">gistXLogDelete</span>(Buffer buffer, OffsetNumber *todelete, <span class="Type">int</span> ntodelete,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId snapshotConflictHorizon, Relation heaprel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; gistxlogDelete xlrec;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec.isCatalogRel = RelationIsAccessibleInLogicalDecoding(heaprel);<br/></li>
<li>&nbsp; &nbsp; xlrec.snapshotConflictHorizon = snapshotConflictHorizon;<br/></li>
<li>&nbsp; &nbsp; xlrec.ntodelete = ntodelete;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfGistxlogDelete);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need the target-offsets array whether or not we store the whole<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer, to allow us to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the snapshotConflictHorizon on a standby<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * server.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) todelete, ntodelete * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buffer, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_GIST_ID, XLOG_GIST_DELETE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> recptr;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
