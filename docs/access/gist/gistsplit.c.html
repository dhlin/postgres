<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/gist/gistsplit.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/gist/gistsplit.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L38">GistSplitUnion</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L113">findDontCares</a></li>
<li><a href="#L344">genericPickSplit</a></li>
<li><a href="#L623">gistSplitByKey</a></li>
<li><a href="#L585">gistSplitHalf</a></li>
<li><a href="#L415">gistUserPicksplit</a></li>
<li><a href="#L80">gistunionsubkey</a></li>
<li><a href="#L47">gistunionsubkeyvec</a></li>
<li><a href="#L200">placeOne</a></li>
<li><a href="#L167">removeDontCares</a></li>
<li><a href="#L258">supportSecondarySplit</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L237">SWAPVAR</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * gistsplit.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Multi-column page splitting algorithm<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This file is concerned with making good page-split decisions in multi-column<br/></li>
<li></span><span class="Comment"> * GiST indexes.&nbsp; The opclass-specific picksplit <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> can only be expected<br/></li>
<li></span><span class="Comment"> * to produce answers based on a single column.&nbsp; We first run the picksplit<br/></li>
<li></span><span class="Comment"> * function for column 1; then, if there are more columns, we check if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of<br/></li>
<li></span><span class="Comment"> * the tuples are &quot;don't cares&quot; so far as the column 1 split is concerned<br/></li>
<li></span><span class="Comment"> * (that is, they could go to either side for no additional penalty).&nbsp; If so,<br/></li>
<li></span><span class="Comment"> * we try to redistribute those tuples on the basis of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> column.<br/></li>
<li></span><span class="Comment"> * Repeat till we're out of columns.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L623" title="access/gist/gistsplit.c:623">gistSplitByKey</a>() is the entry point to this file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/gist/gistsplit.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/gist_private.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber *entries;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *attr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *isnull;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *dontcare;<br/></li>
<li><a id="L38">&#x200c;</a>} <span class="linkable">GistSplitUnion</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Form unions of subkeys in itvec[] entries listed in gsvp-&gt;entries[],<br/></li>
<li></span><span class="Comment"> * ignoring <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples that are marked in gsvp-&gt;dontcare[].&nbsp; Subroutine for<br/></li>
<li></span><span class="Comment"> * <a href="#L80" title="access/gist/gistsplit.c:80">gistunionsubkey</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L47">&#x200c;</a></span><span class="linkable">gistunionsubkeyvec</span>(GISTSTATE *giststate, IndexTuple *itvec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L38" title="access/gist/gistsplit.c:38">GistSplitUnion</a> *gsvp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexTuple *cleanedItVec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cleanedLen = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cleanedItVec = (IndexTuple *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTuple) * gsvp-&gt;len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; gsvp-&gt;len; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gsvp-&gt;dontcare &amp;&amp; gsvp-&gt;dontcare[gsvp-&gt;entries[i]])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cleanedItVec[cleanedLen++] = itvec[gsvp-&gt;entries[i] - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="gistutil.c.html#L155" title="access/gist/gistutil.c:155">gistMakeUnionItVec</a>(giststate, cleanedItVec, cleanedLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gsvp-&gt;attr, gsvp-&gt;isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cleanedItVec);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recompute unions of left- and right-side subkeys after a page split,<br/></li>
<li></span><span class="Comment"> * ignoring <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples that are marked in spl-&gt;spl_dontcare[].<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we always recompute union keys for all index columns.&nbsp; In some cases<br/></li>
<li></span><span class="Comment"> * this might represent duplicate work for the leftmost column(s), but it's<br/></li>
<li></span><span class="Comment"> * not safe to assume that &quot;zero penalty to move a tuple&quot; means &quot;the union<br/></li>
<li></span><span class="Comment"> * key doesn't change at all&quot;.&nbsp; Penalty <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> aren't 100% accurate.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L80">&#x200c;</a></span><span class="linkable">gistunionsubkey</span>(GISTSTATE *giststate, IndexTuple *itvec, GistSplitVector *spl)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L38" title="access/gist/gistsplit.c:38">GistSplitUnion</a> gsvp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gsvp.dontcare = spl-&gt;spl_dontcare;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gsvp.entries = spl-&gt;splitVector.spl_left;<br/></li>
<li>&nbsp; &nbsp; gsvp.len = spl-&gt;splitVector.spl_nleft;<br/></li>
<li>&nbsp; &nbsp; gsvp.attr = spl-&gt;spl_lattr;<br/></li>
<li>&nbsp; &nbsp; gsvp.isnull = spl-&gt;spl_lisnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L47" title="access/gist/gistsplit.c:47">gistunionsubkeyvec</a>(giststate, itvec, &amp;gsvp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gsvp.entries = spl-&gt;splitVector.spl_right;<br/></li>
<li>&nbsp; &nbsp; gsvp.len = spl-&gt;splitVector.spl_nright;<br/></li>
<li>&nbsp; &nbsp; gsvp.attr = spl-&gt;spl_rattr;<br/></li>
<li>&nbsp; &nbsp; gsvp.isnull = spl-&gt;spl_risnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L47" title="access/gist/gistsplit.c:47">gistunionsubkeyvec</a>(giststate, itvec, &amp;gsvp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find tuples that are &quot;don't cares&quot;, that is could be moved to the other<br/></li>
<li></span><span class="Comment"> * side of the split with zero penalty, so far as the attno column is<br/></li>
<li></span><span class="Comment"> * concerned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Don't-care tuples are marked by setting the corresponding entry in<br/></li>
<li></span><span class="Comment"> * spl-&gt;spl_dontcare[] to &quot;true&quot;.&nbsp; Caller must have initialized that array<br/></li>
<li></span><span class="Comment"> * to zeroes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns number of don't-cares found.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L113">&#x200c;</a></span><span class="linkable">findDontCares</span>(Relation r, GISTSTATE *giststate, GISTENTRY *valvec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistSplitVector *spl, <span class="Type">int</span> attno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; &nbsp; entry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NumDontCare = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, search the left-side tuples to see if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> have zero penalty to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be added to the right-side union key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attno column is known all-not-null (see <a href="#L623" title="access/gist/gistsplit.c:623">gistSplitByKey</a>), so we need not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check for nulls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; gistentryinit(entry, spl-&gt;splitVector.spl_rdatum, r, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (OffsetNumber) <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; spl-&gt;splitVector.spl_nleft; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = spl-&gt;splitVector.spl_left[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">float</span>&nbsp; &nbsp; &nbsp; &nbsp; penalty = <a href="gistutil.c.html#L724" title="access/gist/gistutil.c:724">gistpenalty</a>(giststate, attno, &amp;entry, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;valvec[j], <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (penalty == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spl-&gt;spl_dontcare[j] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NumDontCare++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And conversely for the right-side tuples */<br/></li>
<li></span>&nbsp; &nbsp; gistentryinit(entry, spl-&gt;splitVector.spl_ldatum, r, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (OffsetNumber) <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; spl-&gt;splitVector.spl_nright; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = spl-&gt;splitVector.spl_right[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">float</span>&nbsp; &nbsp; &nbsp; &nbsp; penalty = <a href="gistutil.c.html#L724" title="access/gist/gistutil.c:724">gistpenalty</a>(giststate, attno, &amp;entry, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;valvec[j], <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (penalty == <span class="Constant">0.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spl-&gt;spl_dontcare[j] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NumDontCare++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> NumDontCare;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove tuples that are marked don't-cares from the tuple index array a[]<br/></li>
<li></span><span class="Comment"> * of length *len.&nbsp; This is applied separately to the spl_left and spl_right<br/></li>
<li></span><span class="Comment"> * arrays.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L167">&#x200c;</a></span><span class="linkable">removeDontCares</span>(OffsetNumber *a, <span class="Type">int</span> *len, <span class="Type">const</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *dontcare)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber *curwpos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; origlen = newlen = *len;<br/></li>
<li>&nbsp; &nbsp; curwpos = a;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; origlen; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber ai = a[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dontcare[ai] == <span class="Constant">false</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* re-emit item into a[] */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *curwpos = ai;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curwpos++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlen--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *len = newlen;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Place a single don't-care tuple into either the left or right side of the<br/></li>
<li></span><span class="Comment"> * split, according to which has least penalty for merging the tuple into<br/></li>
<li></span><span class="Comment"> * the previously-computed union keys.&nbsp; We need consider only columns starting<br/></li>
<li></span><span class="Comment"> * at attno.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L200">&#x200c;</a></span><span class="linkable">placeOne</span>(Relation r, GISTSTATE *giststate, GistSplitVector *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTuple itup, OffsetNumber off, <span class="Type">int</span> attno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; &nbsp; identry[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; toLeft = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="gistutil.c.html#L296" title="access/gist/gistutil.c:296">gistDeCompressAtt</a>(giststate, r, itup, <span class="Constant">NULL</span>, (OffsetNumber) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; identry, isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (; attno &lt; giststate-&gt;nonLeafTupdesc-&gt;natts; attno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">float</span>&nbsp; &nbsp; &nbsp; &nbsp; lpenalty,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rpenalty;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GISTENTRY&nbsp; &nbsp; entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gistentryinit(entry, v-&gt;spl_lattr[attno], r, <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lpenalty = <a href="gistutil.c.html#L724" title="access/gist/gistutil.c:724">gistpenalty</a>(giststate, attno, &amp;entry, v-&gt;spl_lisnull[attno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; identry + attno, isnull[attno]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gistentryinit(entry, v-&gt;spl_rattr[attno], r, <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rpenalty = <a href="gistutil.c.html#L724" title="access/gist/gistutil.c:724">gistpenalty</a>(giststate, attno, &amp;entry, v-&gt;spl_risnull[attno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; identry + attno, isnull[attno]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lpenalty != rpenalty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lpenalty &gt; rpenalty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toLeft = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (toLeft)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;splitVector.spl_left[v-&gt;splitVector.spl_nleft++] = off;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;splitVector.spl_right[v-&gt;splitVector.spl_nright++] = off;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L237">&#x200c;</a><span class="PreProc">#define <span class="linkable">SWAPVAR</span>( s, d, t ) \<br/></li>
<li></span><span class="Statement">do</span><span class="PreProc"> {&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (t) = (s); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (s) = (d); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (d) = (t); \<br/></li>
<li></span><span class="PreProc">} </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Clean up when we did a secondary split but the user-defined PickSplit<br/></li>
<li></span><span class="Comment"> * method didn't support it (leaving spl_ldatum_exists or spl_rdatum_exists<br/></li>
<li></span><span class="Comment"> * true).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We consider whether to swap the left and right outputs of the secondary<br/></li>
<li></span><span class="Comment"> * split; this can be worthwhile if the penalty for merging those tuples into<br/></li>
<li></span><span class="Comment"> * the previously chosen sets is less that way.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case we must update the union datums for the current column by<br/></li>
<li></span><span class="Comment"> * adding in the previous union keys (oldL/oldR), since the user-defined<br/></li>
<li></span><span class="Comment"> * PickSplit method didn't do so.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L258">&#x200c;</a></span><span class="linkable">supportSecondarySplit</span>(Relation r, GISTSTATE *giststate, <span class="Type">int</span> attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GIST_SPLITVEC *sv, Datum oldL, Datum oldR)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; leaveOnLeft = <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmpBool;<br/></li>
<li>&nbsp; &nbsp; GISTENTRY&nbsp; &nbsp; entryL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entryR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entrySL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entrySR;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gistentryinit(entryL, oldL, r, <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; gistentryinit(entryR, oldR, r, <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; gistentryinit(entrySL, sv-&gt;spl_ldatum, r, <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; gistentryinit(entrySR, sv-&gt;spl_rdatum, r, <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sv-&gt;spl_ldatum_exists &amp;&amp; sv-&gt;spl_rdatum_exists)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">float</span>&nbsp; &nbsp; &nbsp; &nbsp; penalty1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; penalty2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; penalty1 = <a href="gistutil.c.html#L724" title="access/gist/gistutil.c:724">gistpenalty</a>(giststate, attno, &amp;entryL, <span class="Constant">false</span>, &amp;entrySL, <span class="Constant">false</span>) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L724" title="access/gist/gistutil.c:724">gistpenalty</a>(giststate, attno, &amp;entryR, <span class="Constant">false</span>, &amp;entrySR, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; penalty2 = <a href="gistutil.c.html#L724" title="access/gist/gistutil.c:724">gistpenalty</a>(giststate, attno, &amp;entryL, <span class="Constant">false</span>, &amp;entrySR, <span class="Constant">false</span>) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L724" title="access/gist/gistutil.c:724">gistpenalty</a>(giststate, attno, &amp;entryR, <span class="Constant">false</span>, &amp;entrySL, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (penalty1 &gt; penalty2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leaveOnLeft = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GISTENTRY&nbsp; *entry1 = (sv-&gt;spl_ldatum_exists) ? &amp;entryL : &amp;entryR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">float</span>&nbsp; &nbsp; &nbsp; &nbsp; penalty1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; penalty2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is only one previously defined union, so we just choose swap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or not by lowest penalty for that side.&nbsp; We can only get here if a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * secondary split happened to have all NULLs in its column in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples that the outer recursion level had assigned to one side.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Note that the null checks in <a href="#L623" title="access/gist/gistsplit.c:623">gistSplitByKey</a> don't prevent the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case, because they'll only be checking tuples that were considered<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't-cares at the outer recursion level, not the tuples that went<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * into determining the passed-down left and right union keys.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; penalty1 = <a href="gistutil.c.html#L724" title="access/gist/gistutil.c:724">gistpenalty</a>(giststate, attno, entry1, <span class="Constant">false</span>, &amp;entrySL, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; penalty2 = <a href="gistutil.c.html#L724" title="access/gist/gistutil.c:724">gistpenalty</a>(giststate, attno, entry1, <span class="Constant">false</span>, &amp;entrySR, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (penalty1 &lt; penalty2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leaveOnLeft = sv-&gt;spl_ldatum_exists;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leaveOnLeft = sv-&gt;spl_rdatum_exists;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (leaveOnLeft == <span class="Constant">false</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * swap left and right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *off,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; noff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L237" title="access/gist/gistsplit.c:237">SWAPVAR</a>(sv-&gt;spl_left, sv-&gt;spl_right, off);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L237" title="access/gist/gistsplit.c:237">SWAPVAR</a>(sv-&gt;spl_nleft, sv-&gt;spl_nright, noff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L237" title="access/gist/gistsplit.c:237">SWAPVAR</a>(sv-&gt;spl_ldatum, sv-&gt;spl_rdatum, datum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gistentryinit(entrySL, sv-&gt;spl_ldatum, r, <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gistentryinit(entrySR, sv-&gt;spl_rdatum, r, <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sv-&gt;spl_ldatum_exists)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L233" title="access/gist/gistutil.c:233">gistMakeUnionKey</a>(giststate, attno, &amp;entryL, <span class="Constant">false</span>, &amp;entrySL, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sv-&gt;spl_ldatum, &amp;tmpBool);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sv-&gt;spl_rdatum_exists)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L233" title="access/gist/gistutil.c:233">gistMakeUnionKey</a>(giststate, attno, &amp;entryR, <span class="Constant">false</span>, &amp;entrySR, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sv-&gt;spl_rdatum, &amp;tmpBool);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sv-&gt;spl_ldatum_exists = sv-&gt;spl_rdatum_exists = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Trivial picksplit implementation. Function called only<br/></li>
<li></span><span class="Comment"> * if user-defined picksplit puts all keys on the same side of the split.<br/></li>
<li></span><span class="Comment"> * That is a bug of user-defined picksplit but we don't want to fail.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L344">&#x200c;</a></span><span class="linkable">genericPickSplit</span>(GISTSTATE *giststate, GistEntryVector *entryvec, GIST_SPLITVEC *v, <span class="Type">int</span> attno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; GistEntryVector *evec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxoff = entryvec-&gt;n - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nbytes = (maxoff + <span class="Constant">2</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_left = (OffsetNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nbytes);<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_right = (OffsetNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nbytes);<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_nleft = v-&gt;spl_nright = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt;= (maxoff - FirstOffsetNumber + <span class="Constant">1</span>) / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_left[v-&gt;spl_nleft] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_nleft++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_right[v-&gt;spl_nright] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_nright++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Form union datums for each side<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; evec = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTENTRY) * entryvec-&gt;n + GEVHDRSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; evec-&gt;n = v-&gt;spl_nleft;<br/></li>
<li>&nbsp; &nbsp; memcpy(evec-&gt;vector, entryvec-&gt;vector + FirstOffsetNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTENTRY) * evec-&gt;n);<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_ldatum = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;giststate-&gt;unionFn[attno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; giststate-&gt;supportCollation[attno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(evec),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(&amp;nbytes));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; evec-&gt;n = v-&gt;spl_nright;<br/></li>
<li>&nbsp; &nbsp; memcpy(evec-&gt;vector, entryvec-&gt;vector + FirstOffsetNumber + v-&gt;spl_nleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTENTRY) * evec-&gt;n);<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_rdatum = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;giststate-&gt;unionFn[attno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; giststate-&gt;supportCollation[attno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(evec),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(&amp;nbytes));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Calls user picksplit method for attno column to split tuples into<br/></li>
<li></span><span class="Comment"> * two vectors.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false if split is complete (there are no more index columns, or<br/></li>
<li></span><span class="Comment"> * there is no need to consider them because split is optimal already).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true and v-&gt;spl_dontcare = NULL if the picksplit result is<br/></li>
<li></span><span class="Comment"> * degenerate (all tuples seem to be don't-cares), so we should just<br/></li>
<li></span><span class="Comment"> * disregard this column and split on the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> column(s) instead.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true and v-&gt;spl_dontcare != NULL if there are don't-care tuples<br/></li>
<li></span><span class="Comment"> * that could be relocated based on the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> column(s).&nbsp; The don't-care<br/></li>
<li></span><span class="Comment"> * tuples have been removed from the split and must be reinserted by caller.<br/></li>
<li></span><span class="Comment"> * There is at least one non-don't-care tuple on each side of the split,<br/></li>
<li></span><span class="Comment"> * and union keys for all columns are updated to include just those tuples.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A true result implies there is at least one more index column.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L415">&#x200c;</a></span><span class="linkable">gistUserPicksplit</span>(Relation r, GistEntryVector *entryvec, <span class="Type">int</span> attno, GistSplitVector *v,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple *itup, <span class="Type">int</span> len, GISTSTATE *giststate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GIST_SPLITVEC *sv = &amp;v-&gt;splitVector;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare spl_ldatum/spl_rdatum/spl_ldatum_exists/spl_rdatum_exists in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case we are doing a secondary split (see comments in gist.h).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sv-&gt;spl_ldatum_exists = !(v-&gt;spl_lisnull[attno]);<br/></li>
<li>&nbsp; &nbsp; sv-&gt;spl_rdatum_exists = !(v-&gt;spl_risnull[attno]);<br/></li>
<li>&nbsp; &nbsp; sv-&gt;spl_ldatum = v-&gt;spl_lattr[attno];<br/></li>
<li>&nbsp; &nbsp; sv-&gt;spl_rdatum = v-&gt;spl_rattr[attno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Let the opclass-specific PickSplit method do its thing.&nbsp; Note that at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this point we know there are no null keys in the entryvec.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;giststate-&gt;picksplitFn[attno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; giststate-&gt;supportCollation[attno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(entryvec),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(sv));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sv-&gt;spl_nleft == <span class="Constant">0</span> || sv-&gt;spl_nright == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * User-defined picksplit failed to create an actual split, ie it put<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * everything on the same side.&nbsp; Complain but cope.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERNAL_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;picksplit method for column </span><span class="Special">%d</span><span class="Constant"> of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> failed&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attno + <span class="Constant">1</span>, RelationGetRelationName(r)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;The index is not optimal. To <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> it, contact a developer, or try to use the column as the second one in the CREATE INDEX command.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reinit GIST_SPLITVEC. Although these fields are not used by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L344" title="access/gist/gistsplit.c:344">genericPickSplit</a>(), set them up for further processing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sv-&gt;spl_ldatum_exists = !(v-&gt;spl_lisnull[attno]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sv-&gt;spl_rdatum_exists = !(v-&gt;spl_risnull[attno]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sv-&gt;spl_ldatum = v-&gt;spl_lattr[attno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sv-&gt;spl_rdatum = v-&gt;spl_rattr[attno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do a generic split */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L344" title="access/gist/gistsplit.c:344">genericPickSplit</a>(giststate, entryvec, sv, attno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* hack for compatibility with old picksplit API */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sv-&gt;spl_left[sv-&gt;spl_nleft - <span class="Constant">1</span>] == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sv-&gt;spl_left[sv-&gt;spl_nleft - <span class="Constant">1</span>] = (OffsetNumber) (entryvec-&gt;n - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sv-&gt;spl_right[sv-&gt;spl_nright - <span class="Constant">1</span>] == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sv-&gt;spl_right[sv-&gt;spl_nright - <span class="Constant">1</span>] = (OffsetNumber) (entryvec-&gt;n - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up if PickSplit didn't take care of a secondary split */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sv-&gt;spl_ldatum_exists || sv-&gt;spl_rdatum_exists)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L258" title="access/gist/gistsplit.c:258">supportSecondarySplit</a>(r, giststate, attno, sv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_lattr[attno], v-&gt;spl_rattr[attno]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* emit union datums computed by PickSplit back to v arrays */<br/></li>
<li></span>&nbsp; &nbsp; v-&gt;spl_lattr[attno] = sv-&gt;spl_ldatum;<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_rattr[attno] = sv-&gt;spl_rdatum;<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_lisnull[attno] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_risnull[attno] = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If index columns remain, then consider whether we can improve the split<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by using them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; v-&gt;spl_dontcare = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attno + <span class="Constant">1</span> &lt; giststate-&gt;nonLeafTupdesc-&gt;natts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NumDontCare;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make a quick check to see if left and right union keys are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if so, the split is certainly degenerate, so tell caller to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * re-split with the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="gistutil.c.html#L281" title="access/gist/gistutil.c:281">gistKeyIsEQ</a>(giststate, attno, sv-&gt;spl_ldatum, sv-&gt;spl_rdatum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Locate don't-care tuples, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; If there are <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>, the split is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * optimal, so just fall out and return false.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_dontcare = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * (entryvec-&gt;n + <span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; NumDontCare = <a href="#L113" title="access/gist/gistsplit.c:113">findDontCares</a>(r, giststate, entryvec-&gt;vector, v, attno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (NumDontCare &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remove don't-cares from spl_left[] and spl_right[].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L167" title="access/gist/gistsplit.c:167">removeDontCares</a>(sv-&gt;spl_left, &amp;sv-&gt;spl_nleft, v-&gt;spl_dontcare);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L167" title="access/gist/gistsplit.c:167">removeDontCares</a>(sv-&gt;spl_right, &amp;sv-&gt;spl_nright, v-&gt;spl_dontcare);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If all tuples on either side were don't-cares, the split is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * degenerate, and we're best off to ignore it and split on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> column.&nbsp; (We used to try to press on with a secondary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * split by forcing a random tuple on each side to be treated as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-don't-care, but it seems unlikely that that technique<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * really gives a better result.&nbsp; Note that we don't want to try a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * secondary split with empty left or right primary split sides,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because then there is no union key on that side for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PickSplit function to try to expand, so it can have no good<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * figure of merit for what it's doing.&nbsp; Also note that this check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ensures we can't produce a bogus one-side-only split in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NumDontCare == 1 special case below.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sv-&gt;spl_nleft == <span class="Constant">0</span> || sv-&gt;spl_nright == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_dontcare = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Recompute union keys, considering only non-don't-care tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: this will set union keys for remaining index columns,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which will cause later calls of <a href="#L415" title="access/gist/gistsplit.c:415">gistUserPicksplit</a> to pass those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> down to user-defined PickSplit methods with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * spl_ldatum_exists/spl_rdatum_exists set true.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L80" title="access/gist/gistsplit.c:80">gistunionsubkey</a>(giststate, itup, v);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (NumDontCare == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there's only one don't-care tuple then we can't do a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PickSplit on it, so just choose whether to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> it left or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * right by comparing penalties.&nbsp; We needed the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L80" title="access/gist/gistsplit.c:80">gistunionsubkey</a> step anyway so that we have appropriate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * union keys for figuring the penalties.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber toMove;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (toMove = FirstOffsetNumber; toMove &lt; entryvec-&gt;n; toMove++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;spl_dontcare[toMove])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(toMove &lt; entryvec-&gt;n);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and assign it to cheaper side */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L200" title="access/gist/gistsplit.c:200">placeOne</a>(r, giststate, v, itup[toMove - <span class="Constant">1</span>], toMove, attno + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point the union keys are wrong, but we don't care<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because we're done splitting.&nbsp; The outermost recursion<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * level of <a href="#L623" title="access/gist/gistsplit.c:623">gistSplitByKey</a> will fix things <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * simply split page in half<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L585">&#x200c;</a></span><span class="linkable">gistSplitHalf</span>(GIST_SPLITVEC *v, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_nright = v-&gt;spl_nleft = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_left = (OffsetNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li>&nbsp; &nbsp; v-&gt;spl_right = (OffsetNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= len; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; len / <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_right[v-&gt;spl_nright++] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_left[v-&gt;spl_nleft++] = i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we need not compute union keys, caller took care of it */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L623" title="access/gist/gistsplit.c:623">gistSplitByKey</a>: <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> entry point for page-splitting algorithm<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * r: index relation<br/></li>
<li></span><span class="Comment"> * page: page being split<br/></li>
<li></span><span class="Comment"> * itup: array of IndexTuples to be processed<br/></li>
<li></span><span class="Comment"> * len: number of IndexTuples to be processed (must be at least 2)<br/></li>
<li></span><span class="Comment"> * giststate: additional info about index<br/></li>
<li></span><span class="Comment"> * v: working state and output area<br/></li>
<li></span><span class="Comment"> * attno: column we are working on (zero-based index)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Outside caller must <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> v-&gt;spl_lisnull and v-&gt;spl_risnull arrays<br/></li>
<li></span><span class="Comment"> * to all-true.&nbsp; On return, spl_left/spl_nleft contain indexes of tuples<br/></li>
<li></span><span class="Comment"> * to go left, spl_right/spl_nright contain indexes of tuples to go right,<br/></li>
<li></span><span class="Comment"> * spl_lattr/spl_lisnull contain left-side union key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, and<br/></li>
<li></span><span class="Comment"> * spl_rattr/spl_risnull contain right-side union key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; Other fields<br/></li>
<li></span><span class="Comment"> * in this struct are workspace for this file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Outside caller must pass zero for attno.&nbsp; The function may internally<br/></li>
<li></span><span class="Comment"> * recurse to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> column by passing attno+1.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L623">&#x200c;</a></span><span class="linkable">gistSplitByKey</span>(Relation r, Page page, IndexTuple *itup, <span class="Type">int</span> len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GISTSTATE *giststate, GistSplitVector *v, <span class="Type">int</span> attno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GistEntryVector *entryvec;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber *offNullTuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nOffNullTuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* generate the item array, and identify tuples with null keys */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* note that entryvec-&gt;vector[0] goes unused in this code */<br/></li>
<li></span>&nbsp; &nbsp; entryvec = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(GEVHDRSZ + (len + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTENTRY));<br/></li>
<li>&nbsp; &nbsp; entryvec-&gt;n = len + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; offNullTuples = (OffsetNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= len; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; IsNull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum = index_getattr(itup[i - <span class="Constant">1</span>], attno + <span class="Constant">1</span>, giststate-&gt;leafTupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;IsNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L547" title="access/gist/gistutil.c:547">gistdentryinit</a>(giststate, attno, &amp;(entryvec-&gt;vector[i]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; datum, r, page, i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, IsNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offNullTuples[nOffNullTuples++] = i;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nOffNullTuples == len)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Corner case: All keys in attno column are null, so just transfer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * our attention to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> column.&nbsp; If there's no <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> column, just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * split page in half.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_risnull[attno] = v-&gt;spl_lisnull[attno] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attno + <span class="Constant">1</span> &lt; giststate-&gt;nonLeafTupdesc-&gt;natts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L623" title="access/gist/gistsplit.c:623">gistSplitByKey</a>(r, page, itup, len, giststate, v, attno + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L585" title="access/gist/gistsplit.c:585">gistSplitHalf</a>(&amp;v-&gt;splitVector, len);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (nOffNullTuples &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't want to mix NULL and not-NULL keys on one page, so split<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nulls to right page and not-nulls to left.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;splitVector.spl_right = offNullTuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;splitVector.spl_nright = nOffNullTuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_risnull[attno] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;splitVector.spl_left = (OffsetNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;splitVector.spl_nleft = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= len; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j &lt; v-&gt;splitVector.spl_nright &amp;&amp; offNullTuples[j] == i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;splitVector.spl_left[v-&gt;splitVector.spl_nleft++] = i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute union keys, unless outer recursion level will handle it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attno == <span class="Constant">0</span> &amp;&amp; giststate-&gt;nonLeafTupdesc-&gt;natts == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_dontcare = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L80" title="access/gist/gistsplit.c:80">gistunionsubkey</a>(giststate, itup, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All keys are not-null, so apply user-defined PickSplit method<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L415" title="access/gist/gistsplit.c:415">gistUserPicksplit</a>(r, entryvec, attno, v, itup, len, giststate))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Splitting on attno column is not optimal, so consider<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * redistributing don't-care tuples according to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(attno + <span class="Constant">1</span> &lt; giststate-&gt;nonLeafTupdesc-&gt;natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;spl_dontcare == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This split was actually degenerate, so ignore it altogether<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and just split according to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L623" title="access/gist/gistsplit.c:623">gistSplitByKey</a>(r, page, itup, len, giststate, v, attno + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Form an array of just the don't-care tuples to pass to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recursive invocation of this function for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple *newitup = (IndexTuple *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTuple));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *map = (OffsetNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GIST_SPLITVEC backupSplit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; len; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;spl_dontcare[i + <span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newitup[newlen] = itup[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map[newlen] = i + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlen++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(newlen &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make a backup copy of v-&gt;splitVector, since the recursive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * call will overwrite that with its own result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backupSplit = v-&gt;splitVector;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backupSplit.spl_left = (OffsetNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber) * len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(backupSplit.spl_left, v-&gt;splitVector.spl_left, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber) * v-&gt;splitVector.spl_nleft);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backupSplit.spl_right = (OffsetNumber *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber) * len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(backupSplit.spl_right, v-&gt;splitVector.spl_right, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber) * v-&gt;splitVector.spl_nright);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recursively decide how to split the don't-care tuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L623" title="access/gist/gistsplit.c:623">gistSplitByKey</a>(r, page, newitup, newlen, giststate, v, attno + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Merge result of subsplit with non-don't-care tuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; v-&gt;splitVector.spl_nleft; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backupSplit.spl_left[backupSplit.spl_nleft++] = map[v-&gt;splitVector.spl_left[i] - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; v-&gt;splitVector.spl_nright; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backupSplit.spl_right[backupSplit.spl_nright++] = map[v-&gt;splitVector.spl_right[i] - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;splitVector = backupSplit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're handling a multicolumn index, at the end of the recursion<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recompute the left and right union datums for all index columns.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * makes sure we hand back correct union datums in all corner cases,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * including when we haven't processed all columns to start with, or when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a secondary split moved &quot;don't care&quot; tuples from one side to the other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (we really shouldn't assume that that didn't change the union datums).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: when we're in an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> recursion (attno &gt; 0), we do not worry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about whether the union datums we return with are sensible, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calling levels won't care.&nbsp; Also, in a single-column index, we expect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that PickSplit (or the special cases above) produced correct union<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * datums.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attno == <span class="Constant">0</span> &amp;&amp; giststate-&gt;nonLeafTupdesc-&gt;natts &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; v-&gt;spl_dontcare = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L80" title="access/gist/gistsplit.c:80">gistunionsubkey</a>(giststate, itup, v);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
