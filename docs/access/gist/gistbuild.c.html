<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/gist/gistbuild.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/gist/gistbuild.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L111">GISTBuildState</a></li>
<li><a href="#L79">GistBuildMode</a></li>
<li><a href="#L123">GistSortedBuildLevelState</a></li>
<li><a href="#L129">GistSortedBuildLevelState</a></li>
<li><a href="#L1511">ParentMapEntry</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L787">calculatePagesPerBuffer</a></li>
<li><a href="#L907">gistBufferingBuildInsert</a></li>
<li><a href="#L1223">gistBufferingFindCorrectParent</a></li>
<li><a href="#L820">gistBuildCallback</a></li>
<li><a href="#L1370">gistEmptyAllBuffers</a></li>
<li><a href="#L1425">gistGetMaxLevel</a></li>
<li><a href="#L1565">gistGetParent</a></li>
<li><a href="#L626">gistInitBuffering</a></li>
<li><a href="#L1514">gistInitParentMap</a></li>
<li><a href="#L1544">gistMemorizeAllDownlinks</a></li>
<li><a href="#L1528">gistMemorizeParent</a></li>
<li><a href="#L1297">gistProcessEmptyingQueue</a></li>
<li><a href="#L923">gistProcessItup</a></li>
<li><a href="#L366">gistSortedBuildCallback</a></li>
<li><a href="#L400">gist_indexsortbuild</a></li>
<li><a href="#L461">gist_indexsortbuild_levelstate_add</a></li>
<li><a href="#L493">gist_indexsortbuild_levelstate_flush</a></li>
<li><a href="#L1054">gistbufferinginserttuples</a></li>
<li><a href="#L179">gistbuild</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L52">BUFFERING_MODE_SWITCH_CHECK_STEP</a></li>
<li><a href="#L60">BUFFERING_MODE_TUPLE_SIZE_STATS_TARGET</a></li>
<li><a href="#L113">GIST_SORTED_BUILD_PAGE_NUM</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L179" title="access/gist/gistbuild.c:179">gistbuild</a>.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; build algorithm for GiST indexes implementation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There are two different strategies:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1. Sort all input tuples, pack them into GiST leaf pages in the sorted<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; order, and create downlinks and <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages as we go. This builds<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the index from the bottom up, similar to how B-tree index build<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; works.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 2. Start with an empty index, and insert all tuples one by one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The sorted method is used if the operator classes for all columns have<br/></li>
<li></span><span class="Comment"> * a 'sortsupport' defined. Otherwise, we resort to the second strategy.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The second strategy can optionally use buffers at different levels of<br/></li>
<li></span><span class="Comment"> * the tree to reduce I/O, see &quot;Buffering build algorithm&quot; in the README<br/></li>
<li></span><span class="Comment"> * for a more detailed explanation. It initially calls insert over and<br/></li>
<li></span><span class="Comment"> * over, but switches to the buffered algorithm after a certain number of<br/></li>
<li></span><span class="Comment"> * tuples (unless buffering mode is disabled).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/gist/<a href="#L179" title="access/gist/gistbuild.c:179">gistbuild</a>.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/gist_private.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/execnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bulk_write.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/tuplesort.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Step of index tuples for check whether to switch to buffering build mode */<br/></li>
<li><a id="L52">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BUFFERING_MODE_SWITCH_CHECK_STEP</span> </span><span class="Constant">256<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Number of tuples to process in the slow way <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> switching to buffering<br/></li>
<li></span><span class="Comment"> * mode, when buffering is explicitly turned on. Also, the number of tuples<br/></li>
<li></span><span class="Comment"> * to process between readjusting the buffer size parameter, while in<br/></li>
<li></span><span class="Comment"> * buffering mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L60">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BUFFERING_MODE_TUPLE_SIZE_STATS_TARGET</span> </span><span class="Constant">4096<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Strategy used to build the index. It can change between the<br/></li>
<li></span><span class="Comment"> * GIST_BUFFERING_* modes on the fly, but if the Sorted method is used,<br/></li>
<li></span><span class="Comment"> * that needs to be decided up-front and cannot be changed afterwards.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; GIST_SORTED_BUILD,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* bottom-up build by sorting */<br/></li>
<li></span>&nbsp; &nbsp; GIST_BUFFERING_DISABLED,&nbsp; &nbsp; <span class="Comment">/* in regular build mode and aren't going to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * switch */<br/></li>
<li></span>&nbsp; &nbsp; GIST_BUFFERING_AUTO,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in regular build mode, but will switch to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffering build mode if the index grows too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * big */<br/></li>
<li></span>&nbsp; &nbsp; GIST_BUFFERING_STATS,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* gathering statistics of index tuple size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> switching to the buffering build<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mode */<br/></li>
<li></span>&nbsp; &nbsp; GIST_BUFFERING_ACTIVE,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in buffering build mode */<br/></li>
<li><a id="L79">&#x200c;</a></span>} <span class="linkable">GistBuildMode</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Working state for <a href="#L179" title="access/gist/gistbuild.c:179">gistbuild</a> and its callback */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; indexrel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; heaprel;<br/></li>
<li>&nbsp; &nbsp; GISTSTATE&nbsp; *giststate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; freespace;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* amount of free space to leave on pages */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L79" title="access/gist/gistbuild.c:79">GistBuildMode</a> buildMode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; indtuples;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of tuples indexed */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Extra data structures used during a buffering build. 'gfbb' contains<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * information related to managing the build buffers. 'parentMap' is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lookup table of the parent of each <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; indtuplesSize;&nbsp; &nbsp; <span class="Comment">/* total size of all indexed tuples */<br/></li>
<li></span>&nbsp; &nbsp; GISTBuildBuffers *gfbb;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *parentMap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Extra data structures used during a sorting build.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *sortstate;&nbsp; &nbsp; <span class="Comment">/* state data for tuplesort.c */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; BlockNumber pages_allocated;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/smgr/bulk_write.c.html#L60" title="storage/smgr/bulk_write.c:60">BulkWriteState</a> *bulkstate;<br/></li>
<li><a id="L111">&#x200c;</a>} <span class="linkable">GISTBuildState</span>;<br/></li>
<li><br/></li>
<li><a id="L113">&#x200c;</a><span class="PreProc">#define <span class="linkable">GIST_SORTED_BUILD_PAGE_NUM</span> </span><span class="Constant">4<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * In sorted build, we use a stack of these structs, one for each level,<br/></li>
<li></span><span class="Comment"> * to hold an in-memory buffer of last pages at the level.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Sorting GiST build requires good linearization of the sort opclass. This is<br/></li>
<li></span><span class="Comment"> * not always the case in multidimensional data. To tackle the anomalies, we<br/></li>
<li></span><span class="Comment"> * buffer index tuples and apply picksplit that can be multidimension-aware.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L123">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">GistSortedBuildLevelState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_page;<br/></li>
<li>&nbsp; &nbsp; BlockNumber last_blkno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L123" title="access/gist/gistbuild.c:123">GistSortedBuildLevelState</a> *parent;&nbsp; &nbsp; <span class="Comment">/* Upper level, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; pages[<a href="#L113" title="access/gist/gistbuild.c:113">GIST_SORTED_BUILD_PAGE_NUM</a>];<br/></li>
<li><a id="L129">&#x200c;</a>} <span class="linkable">GistSortedBuildLevelState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* prototypes for private <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L366" title="access/gist/gistbuild.c:366">gistSortedBuildCallback</a>(Relation index, ItemPointer tid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tupleIsAlive, <span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L400" title="access/gist/gistbuild.c:400">gist_indexsortbuild</a>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L461" title="access/gist/gistbuild.c:461">gist_indexsortbuild_levelstate_add</a>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L123" title="access/gist/gistbuild.c:123">GistSortedBuildLevelState</a> *levelstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTuple itup);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L493" title="access/gist/gistbuild.c:493">gist_indexsortbuild_levelstate_flush</a>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L123" title="access/gist/gistbuild.c:123">GistSortedBuildLevelState</a> *levelstate);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L626" title="access/gist/gistbuild.c:626">gistInitBuffering</a>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L787" title="access/gist/gistbuild.c:787">calculatePagesPerBuffer</a>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate, <span class="Type">int</span> levelStep);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L820" title="access/gist/gistbuild.c:820">gistBuildCallback</a>(Relation index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer tid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tupleIsAlive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L907" title="access/gist/gistbuild.c:907">gistBufferingBuildInsert</a>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTuple itup);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L923" title="access/gist/gistbuild.c:923">gistProcessItup</a>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate, IndexTuple itup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber startblkno, <span class="Type">int</span> startlevel);<br/></li>
<li><span class="Type">static</span> BlockNumber <a href="#L1054" title="access/gist/gistbuild.c:1054">gistbufferinginserttuples</a>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer buffer, <span class="Type">int</span> level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTuple *itup, <span class="Type">int</span> ntup, OffsetNumber oldoffnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber parentblk, OffsetNumber downlinkoffnum);<br/></li>
<li><span class="Type">static</span> Buffer <a href="#L1223" title="access/gist/gistbuild.c:1223">gistBufferingFindCorrectParent</a>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber childblkno, <span class="Type">int</span> level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber *parentblkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber *downlinkoffnum);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1297" title="access/gist/gistbuild.c:1297">gistProcessEmptyingQueue</a>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1370" title="access/gist/gistbuild.c:1370">gistEmptyAllBuffers</a>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1425" title="access/gist/gistbuild.c:1425">gistGetMaxLevel</a>(Relation index);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1514" title="access/gist/gistbuild.c:1514">gistInitParentMap</a>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1528" title="access/gist/gistbuild.c:1528">gistMemorizeParent</a>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate, BlockNumber child,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber parent);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1544" title="access/gist/gistbuild.c:1544">gistMemorizeAllDownlinks</a>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer parentbuf);<br/></li>
<li><span class="Type">static</span> BlockNumber <a href="#L1565" title="access/gist/gistbuild.c:1565">gistGetParent</a>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate, BlockNumber child);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Main entry point to GiST index build.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexBuildResult *<br/></li>
<li><a id="L179">&#x200c;</a><span class="linkable">gistbuild</span>(Relation heap, Relation index, IndexInfo *indexInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexBuildResult *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; reltuples;<br/></li>
<li>&nbsp; &nbsp; <a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> buildstate;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fillfactor;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortSupportFnOids[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; GiSTOptions *options = (GiSTOptions *) index-&gt;rd_options;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We expect to be called exactly once for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index relation. If that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not the case, big trouble's what we have.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationGetNumberOfBlocks(index) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already contains data&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(index));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buildstate.indexrel = index;<br/></li>
<li>&nbsp; &nbsp; buildstate.heaprel = heap;<br/></li>
<li>&nbsp; &nbsp; buildstate.sortstate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; buildstate.giststate = <a href="gist.c.html#L1525" title="access/gist/gist.c:1525">initGISTstate</a>(index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a temporary memory context that is reset once for each tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processed.&nbsp; (Note: we don't bother to make this a child of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * giststate's scanCxt, so we have to delete it separately at the end.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; buildstate.giststate-&gt;tempCxt = <a href="gist.c.html#L122" title="access/gist/gist.c:122">createTempGistContext</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Choose build strategy.&nbsp; First check whether the user specified to use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffering mode.&nbsp; (The use-case for that in the field is somewhat<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * questionable perhaps, but it's important for testing purposes.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (options)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (options-&gt;buffering_mode == GIST_OPTION_BUFFERING_ON)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buildstate.buildMode = GIST_BUFFERING_STATS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (options-&gt;buffering_mode == GIST_OPTION_BUFFERING_OFF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buildstate.buildMode = GIST_BUFFERING_DISABLED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must be &quot;auto&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buildstate.buildMode = GIST_BUFFERING_AUTO;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buildstate.buildMode = GIST_BUFFERING_AUTO;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unless buffering mode was forced, see if we can use sorting instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (buildstate.buildMode != GIST_BUFFERING_STATS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasallsortsupports = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyscount = IndexRelationGetNumberOfKeyAttributes(index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; keyscount; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortSupportFnOids[i] = <a href="../index/indexam.c.html#L826" title="access/index/indexam.c:826">index_getprocid</a>(index, i + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GIST_SORTSUPPORT_PROC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(SortSupportFnOids[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasallsortsupports = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hasallsortsupports)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buildstate.buildMode = GIST_SORTED_BUILD;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate target amount of free space to leave on pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fillfactor = options ? options-&gt;fillfactor : GIST_DEFAULT_FILLFACTOR;<br/></li>
<li>&nbsp; &nbsp; buildstate.freespace = BLCKSZ * (<span class="Constant">100</span> - fillfactor) / <span class="Constant">100</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build the index using the chosen strategy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; buildstate.indtuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; buildstate.indtuplesSize = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (buildstate.buildMode == GIST_SORTED_BUILD)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sort all data, build the index from bottom up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buildstate.sortstate = <a href="../../utils/sort/tuplesortvariants.c.html#L490" title="utils/sort/tuplesortvariants.c:490">tuplesort_begin_index_gist</a>(heap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TUPLESORT_NONE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Scan the table, adding all tuples to the tuplesort */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; reltuples = table_index_build_scan(heap, index, indexInfo, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L366" title="access/gist/gistbuild.c:366">gistSortedBuildCallback</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) &amp;buildstate, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Perform the sort and build index pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(buildstate.sortstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L400" title="access/gist/gistbuild.c:400">gist_indexsortbuild</a>(&amp;buildstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a>(buildstate.sortstate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initialize an empty index and insert all tuples, possibly using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffers on intermediate levels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the root page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="gistutil.c.html#L824" title="access/gist/gistutil.c:824">gistNewBuffer</a>(index, heap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer) == GIST_ROOT_BLKNO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L773" title="access/gist/gistutil.c:773">GISTInitBuffer</a>(buffer, F_LEAF);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, GistBuildLSN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Scan the table, inserting all the tuples to the index. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; reltuples = table_index_build_scan(heap, index, indexInfo, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L820" title="access/gist/gistbuild.c:820">gistBuildCallback</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) &amp;buildstate, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If buffering was used, flush out all the tuples that are still in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the buffers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buildstate.buildMode == GIST_BUFFERING_ACTIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;all tuples processed, emptying buffers&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1370" title="access/gist/gistbuild.c:1370">gistEmptyAllBuffers</a>(&amp;buildstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="gistbuildbuffers.c.html#L507" title="access/gist/gistbuildbuffers.c:507">gistFreeBuildBuffers</a>(buildstate.gfbb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We didn't write WAL <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> as we built the index, so if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL-logging is required, write all pages to the WAL <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(index))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L1270" title="access/transam/xloginsert.c:1270">log_newpage_range</a>(index, MAIN_FORKNUM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, RelationGetNumberOfBlocks(index),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* okay, all heap tuples are indexed */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(buildstate.giststate-&gt;tempCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="gist.c.html#L1653" title="access/gist/gist.c:1653">freeGISTstate</a>(buildstate.giststate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return statistics<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = (IndexBuildResult *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexBuildResult));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;heap_tuples = reltuples;<br/></li>
<li>&nbsp; &nbsp; result-&gt;index_tuples = (<span class="Type">double</span>) buildstate.indtuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Routines for sorted build<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Per-tuple callback for table_index_build_scan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L366">&#x200c;</a></span><span class="linkable">gistSortedBuildCallback</span>(Relation index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer tid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tupleIsAlive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate = (<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *) state;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldCtx;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; compressed_values[INDEX_MAX_KEYS];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldCtx = MemoryContextSwitchTo(buildstate-&gt;giststate-&gt;tempCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Form an index tuple and point it at the heap tuple */<br/></li>
<li></span>&nbsp; &nbsp; <a href="gistutil.c.html#L596" title="access/gist/gistutil.c:596">gistCompressValues</a>(buildstate-&gt;giststate, index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, compressed_values);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesortvariants.c.html#L752" title="utils/sort/tuplesortvariants.c:752">tuplesort_putindextuplevalues</a>(buildstate-&gt;sortstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buildstate-&gt;indexrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compressed_values, isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldCtx);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(buildstate-&gt;giststate-&gt;tempCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update tuple count. */<br/></li>
<li></span>&nbsp; &nbsp; buildstate-&gt;indtuples += <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build GiST index from bottom up from pre-sorted tuples.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L400">&#x200c;</a></span><span class="linkable">gist_indexsortbuild</span>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; <a href="#L123" title="access/gist/gistbuild.c:123">GistSortedBuildLevelState</a> *levelstate;<br/></li>
<li>&nbsp; &nbsp; BulkWriteBuffer rootbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reserve block 0 for the root page */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;pages_allocated = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;bulkstate = <a href="../../storage/smgr/bulk_write.c.html#L86" title="storage/smgr/bulk_write.c:86">smgr_bulk_start_rel</a>(state-&gt;indexrel, MAIN_FORKNUM);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate a temporary buffer for the first leaf page batch. */<br/></li>
<li></span>&nbsp; &nbsp; levelstate = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L123" title="access/gist/gistbuild.c:123">GistSortedBuildLevelState</a>));<br/></li>
<li>&nbsp; &nbsp; levelstate-&gt;pages[<span class="Constant">0</span>] = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; levelstate-&gt;parent = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="gistutil.c.html#L757" title="access/gist/gistutil.c:757">gistinitpage</a>(levelstate-&gt;pages[<span class="Constant">0</span>], F_LEAF);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill index pages with tuples in the sorted order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> ((itup = <a href="../../utils/sort/tuplesortvariants.c.html#L949" title="utils/sort/tuplesortvariants.c:949">tuplesort_getindextuple</a>(state-&gt;sortstate, <span class="Constant">true</span>)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L461" title="access/gist/gistbuild.c:461">gist_indexsortbuild_levelstate_add</a>(state, levelstate, itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(state-&gt;giststate-&gt;tempCxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write out the partially full non-root pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Keep in mind that flush can build a new root. If number of pages is &gt; 1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then new root is required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (levelstate-&gt;parent != <span class="Constant">NULL</span> || levelstate-&gt;current_page != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L123" title="access/gist/gistbuild.c:123">GistSortedBuildLevelState</a> *parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L493" title="access/gist/gistbuild.c:493">gist_indexsortbuild_levelstate_flush</a>(state, levelstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent = levelstate-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="#L113" title="access/gist/gistbuild.c:113">GIST_SORTED_BUILD_PAGE_NUM</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (levelstate-&gt;pages[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(levelstate-&gt;pages[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(levelstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; levelstate = parent;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write out the root */<br/></li>
<li></span>&nbsp; &nbsp; PageSetLSN(levelstate-&gt;pages[<span class="Constant">0</span>], GistBuildLSN);<br/></li>
<li>&nbsp; &nbsp; rootbuf = <a href="../../storage/smgr/bulk_write.c.html#L295" title="storage/smgr/bulk_write.c:295">smgr_bulk_get_buf</a>(state-&gt;bulkstate);<br/></li>
<li>&nbsp; &nbsp; memcpy(rootbuf, levelstate-&gt;pages[<span class="Constant">0</span>], BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/smgr/bulk_write.c.html#L271" title="storage/smgr/bulk_write.c:271">smgr_bulk_write</a>(state-&gt;bulkstate, GIST_ROOT_BLKNO, rootbuf, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(levelstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/smgr/bulk_write.c.html#L129" title="storage/smgr/bulk_write.c:129">smgr_bulk_finish</a>(state-&gt;bulkstate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add tuple to a page. If the pages are full, write them out and re-<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a><br/></li>
<li></span><span class="Comment"> * a new page first.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L461">&#x200c;</a></span><span class="linkable">gist_indexsortbuild_levelstate_add</span>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L123" title="access/gist/gistbuild.c:123">GistSortedBuildLevelState</a> *levelstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTuple itup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; sizeNeeded;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if tuple can be added to the current page */<br/></li>
<li></span>&nbsp; &nbsp; sizeNeeded = IndexTupleSize(itup) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData); <span class="Comment">/* fillfactor ignored */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/page/bufpage.c.html#L907" title="storage/page/bufpage.c:907">PageGetFreeSpace</a>(levelstate-&gt;pages[levelstate-&gt;current_page]) &lt; sizeNeeded)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; newPage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; old_page = levelstate-&gt;pages[levelstate-&gt;current_page];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; old_page_flags = GistPageGetOpaque(old_page)-&gt;flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (levelstate-&gt;current_page + <span class="Constant">1</span> == <a href="#L113" title="access/gist/gistbuild.c:113">GIST_SORTED_BUILD_PAGE_NUM</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L493" title="access/gist/gistbuild.c:493">gist_indexsortbuild_levelstate_flush</a>(state, levelstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; levelstate-&gt;current_page++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (levelstate-&gt;pages[levelstate-&gt;current_page] == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; levelstate-&gt;pages[levelstate-&gt;current_page] = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newPage = levelstate-&gt;pages[levelstate-&gt;current_page];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L757" title="access/gist/gistutil.c:757">gistinitpage</a>(newPage, old_page_flags);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="gistutil.c.html#L34" title="access/gist/gistutil.c:34">gistfillbuffer</a>(levelstate-&gt;pages[levelstate-&gt;current_page], &amp;itup, <span class="Constant">1</span>, InvalidOffsetNumber);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L493">&#x200c;</a></span><span class="linkable">gist_indexsortbuild_levelstate_flush</span>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L123" title="access/gist/gistbuild.c:123">GistSortedBuildLevelState</a> *levelstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L123" title="access/gist/gistbuild.c:123">GistSortedBuildLevelState</a> *parent;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldCtx;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; union_tuple;<br/></li>
<li>&nbsp; &nbsp; SplitPageLayout *dist;<br/></li>
<li>&nbsp; &nbsp; IndexTuple *itvec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vect_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isleaf = GistPageIsLeaf(levelstate-&gt;pages[<span class="Constant">0</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldCtx = MemoryContextSwitchTo(state-&gt;giststate-&gt;tempCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get index tuples from first page */<br/></li>
<li></span>&nbsp; &nbsp; itvec = <a href="gistutil.c.html#L95" title="access/gist/gistutil.c:95">gistextractpage</a>(levelstate-&gt;pages[<span class="Constant">0</span>], &amp;vect_len);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (levelstate-&gt;current_page &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Append tuples from each page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">1</span>; i &lt; levelstate-&gt;current_page + <span class="Constant">1</span>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len_local;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple *itvec_local = <a href="gistutil.c.html#L95" title="access/gist/gistutil.c:95">gistextractpage</a>(levelstate-&gt;pages[i], &amp;len_local);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itvec = <a href="gistutil.c.html#L114" title="access/gist/gistutil.c:114">gistjoinvector</a>(itvec, &amp;vect_len, itvec_local, len_local);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(itvec_local);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Apply picksplit to list of all collected tuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dist = <a href="gist.c.html#L1438" title="access/gist/gist.c:1438">gistSplit</a>(state-&gt;indexrel, levelstate-&gt;pages[<span class="Constant">0</span>], itvec, vect_len, state-&gt;giststate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create split layout from single page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dist = (SplitPageLayout *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SplitPageLayout));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; union_tuple = <a href="gistutil.c.html#L219" title="access/gist/gistutil.c:219">gistunion</a>(state-&gt;indexrel, itvec, vect_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;giststate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dist-&gt;itup = union_tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dist-&gt;list = <a href="gistutil.c.html#L127" title="access/gist/gistutil.c:127">gistfillitupvec</a>(itvec, vect_len, &amp;(dist-&gt;lenlist));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dist-&gt;block.num = vect_len;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldCtx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset page counter */<br/></li>
<li></span>&nbsp; &nbsp; levelstate-&gt;current_page = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create pages for all partitions in split result */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (; dist != <span class="Constant">NULL</span>; dist = dist-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BulkWriteBuffer buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; target;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check once per page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create page and copy data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; data = (<span class="Type">char</span> *) (dist-&gt;list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../../storage/smgr/bulk_write.c.html#L295" title="storage/smgr/bulk_write.c:295">smgr_bulk_get_buf</a>(state-&gt;bulkstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; target = (Page) buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L757" title="access/gist/gistutil.c:757">gistinitpage</a>(target, isleaf ? F_LEAF : <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; dist-&gt;block.num; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; thistup = (IndexTuple) data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(target, (Item) data, IndexTupleSize(thistup), i + FirstOffsetNumber, <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add item to index page in </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, RelationGetRelationName(state-&gt;indexrel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; data += IndexTupleSize(thistup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; union_tuple = dist-&gt;itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set the right link to point to the previous page. This is just for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * debugging purposes: GiST only follows the right link if a page is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * split concurrently to a scan, and that cannot happen during index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * build.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> counterintuitive that we set the right link on the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page to point to the previous page, not the other way around. But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * GiST pages are not ordered like B-tree pages are, so as long as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * right-links form a chain through all the pages at the same level,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the order doesn't matter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (levelstate-&gt;last_blkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GistPageGetOpaque(target)-&gt;rightlink = levelstate-&gt;last_blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The page is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> complete. Assign a block number to it, and pass it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the bulk writer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; blkno = state-&gt;pages_allocated++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(target, GistBuildLSN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/smgr/bulk_write.c.html#L271" title="storage/smgr/bulk_write.c:271">smgr_bulk_write</a>(state-&gt;bulkstate, blkno, buf, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSetBlockNumber(&amp;(union_tuple-&gt;t_tid), blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; levelstate-&gt;last_blkno = blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> the downlink to the parent page. If this was the root,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * create a new page as the parent, which becomes the new root.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; parent = levelstate-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parent == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L123" title="access/gist/gistbuild.c:123">GistSortedBuildLevelState</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;pages[<span class="Constant">0</span>] = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;parent = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="gistutil.c.html#L757" title="access/gist/gistutil.c:757">gistinitpage</a>(parent-&gt;pages[<span class="Constant">0</span>], <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; levelstate-&gt;parent = parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L461" title="access/gist/gistbuild.c:461">gist_indexsortbuild_levelstate_add</a>(state, parent, union_tuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Routines for non-sorted build<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attempt to switch to buffering mode.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there is not enough memory for buffering build, sets bufferingMode<br/></li>
<li></span><span class="Comment"> * to GIST_BUFFERING_DISABLED, so that we don't bother to try the switch<br/></li>
<li></span><span class="Comment"> * anymore. Otherwise initializes the build buffers, and sets bufferingMode to<br/></li>
<li></span><span class="Comment"> * GIST_BUFFERING_ACTIVE.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L626">&#x200c;</a></span><span class="linkable">gistInitBuffering</span>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; index = buildstate-&gt;indexrel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pagesPerBuffer;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; pageFreeSpace;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; itupAvgSize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itupMinSize;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; avgIndexTuplesPerPage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxIndexTuplesPerPage;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; levelStep;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Calc space of index page which is available for index tuples */<br/></li>
<li></span>&nbsp; &nbsp; pageFreeSpace = BLCKSZ - SizeOfPageHeaderData - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTPageOpaqueData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; - buildstate-&gt;freespace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate average size of already inserted index tuples using gathered<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * statistics.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; itupAvgSize = (<span class="Type">double</span>) buildstate-&gt;indtuplesSize /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">double</span>) buildstate-&gt;indtuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate minimal possible size of index tuple by index metadata.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Minimal possible size of varlena is VARHDRSZ.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: that's not actually true, as a short varlen can be just 2 bytes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And we should take padding into account here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; itupMinSize = (Size) MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; index-&gt;rd_att-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupleDescAttr(index-&gt;rd_att, i)-&gt;attlen &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itupMinSize += VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itupMinSize += TupleDescAttr(index-&gt;rd_att, i)-&gt;attlen;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Calculate average and maximal number of index tuples which fit to page */<br/></li>
<li></span>&nbsp; &nbsp; avgIndexTuplesPerPage = pageFreeSpace / itupAvgSize;<br/></li>
<li>&nbsp; &nbsp; maxIndexTuplesPerPage = pageFreeSpace / itupMinSize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to calculate two parameters for the buffering algorithm:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * levelStep and pagesPerBuffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * levelStep determines the size of subtree that we operate on, while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * emptying a buffer. A higher value is better, as you need fewer buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * emptying steps to build the index. However, if you set it too high, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtree doesn't fit in cache anymore, and you quickly lose the benefit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the buffers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In Arge et al's paper, levelStep is chosen as logB(M/4B), where B is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the number of tuples on page (ie. fanout), and M is the amount of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> memory available. Curiously, they doesn't explain *why* that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * setting is optimal. We calculate it by taking the highest levelStep so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that a subtree still fits in cache. For a small B, our way of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calculating levelStep is very close to Arge et al's formula. For a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * large B, our formula gives a value that is 2x higher.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The average size (in pages) of a subtree of depth n can be calculated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as a geometric series:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * B^0 + B^1 + B^2 + ... + B^n = (1 - B^(n + 1)) / (1 - B)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where B is the average number of index tuples on page. The subtree is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cached in the shared buffer cache and the OS cache, so we choose<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * levelStep so that the subtree size is comfortably smaller than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../optimizer/path/costsize.c.html#L128" title="optimizer/path/costsize.c:128">effective_cache_size</a>, with a safety factor of 4.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The estimate on the average number of index tuples on page is based on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * average tuple sizes observed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> switching to buffered build, so the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * real subtree size can be somewhat larger. Also, it would selfish to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gobble the whole cache for our index build. The safety factor of 4<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should account for those effects.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The other limiting factor for setting levelStep is that while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processing a subtree, we need to hold one page for each buffer at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> buffered level. The max. number of buffers needed for that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is maxIndexTuplesPerPage^levelStep. This is very conservative, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hopefully <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> is set high enough that you're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constrained by <a href="../../optimizer/path/costsize.c.html#L128" title="optimizer/path/costsize.c:128">effective_cache_size</a> rather than <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: the buffer <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table consumes a fair amount of memory too per<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer, but that is not currently taken into account. That scales on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the total number of buffers used, ie. the index size and on levelStep.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that a higher levelStep *reduces* the amount of memory needed for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; levelStep = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; subtreesize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; maxlowestlevelpages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* size of an average subtree at this levelStep (in pages). */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; subtreesize =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Constant">1</span> - pow(avgIndexTuplesPerPage, (<span class="Type">double</span>) (levelStep + <span class="Constant">1</span>))) /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Constant">1</span> - avgIndexTuplesPerPage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* max number of pages at the lowest level of a subtree */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; maxlowestlevelpages = pow(maxIndexTuplesPerPage, (<span class="Type">double</span>) levelStep);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* subtree must fit in cache (with safety factor of 4) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subtreesize &gt; <a href="../../optimizer/path/costsize.c.html#L128" title="optimizer/path/costsize.c:128">effective_cache_size</a> / <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* each node in the lowest level of a subtree has one page in memory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (maxlowestlevelpages &gt; ((<span class="Type">double</span>) <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> * <span class="Constant">1024</span>) / BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Good, we can handle this levelStep. See if we can go one higher. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; levelStep++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We just reached an unacceptable value of levelStep in previous loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * So, decrease levelStep to get last acceptable value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; levelStep--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's not enough cache or <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a>, fall back to plain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inserts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (levelStep &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;failed to switch to buffered GiST build&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buildstate-&gt;buildMode = GIST_BUFFERING_DISABLED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The second parameter to set is pagesPerBuffer, which determines the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * size of each buffer. We adjust pagesPerBuffer also during the build,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which is why this calculation is in a separate function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pagesPerBuffer = <a href="#L787" title="access/gist/gistbuild.c:787">calculatePagesPerBuffer</a>(buildstate, levelStep);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize GISTBuildBuffers with these parameters */<br/></li>
<li></span>&nbsp; &nbsp; buildstate-&gt;gfbb = <a href="gistbuildbuffers.c.html#L44" title="access/gist/gistbuildbuffers.c:44">gistInitBuildBuffers</a>(pagesPerBuffer, levelStep,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1425" title="access/gist/gistbuild.c:1425">gistGetMaxLevel</a>(index));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1514" title="access/gist/gistbuild.c:1514">gistInitParentMap</a>(buildstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buildstate-&gt;buildMode = GIST_BUFFERING_ACTIVE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;switched to buffered GiST build; level step = </span><span class="Special">%d</span><span class="Constant">, pagesPerBuffer = </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; levelStep, pagesPerBuffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Calculate pagesPerBuffer parameter for the buffering algorithm.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Buffer size is chosen so that assuming that tuples are distributed<br/></li>
<li></span><span class="Comment"> * randomly, emptying half a buffer fills on average one page in every buffer<br/></li>
<li></span><span class="Comment"> * at the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> level.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L787">&#x200c;</a></span><span class="linkable">calculatePagesPerBuffer</span>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate, <span class="Type">int</span> levelStep)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; pagesPerBuffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; avgIndexTuplesPerPage;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; itupAvgSize;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; pageFreeSpace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Calc space of index page which is available for index tuples */<br/></li>
<li></span>&nbsp; &nbsp; pageFreeSpace = BLCKSZ - SizeOfPageHeaderData - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GISTPageOpaqueData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; - buildstate-&gt;freespace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate average size of already inserted index tuples using gathered<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * statistics.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; itupAvgSize = (<span class="Type">double</span>) buildstate-&gt;indtuplesSize /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">double</span>) buildstate-&gt;indtuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; avgIndexTuplesPerPage = pageFreeSpace / itupAvgSize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recalculate required size of buffers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pagesPerBuffer = <span class="Constant">2</span> * pow(avgIndexTuplesPerPage, levelStep);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">int</span>) rint(pagesPerBuffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Per-tuple callback for table_index_build_scan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L820">&#x200c;</a></span><span class="linkable">gistBuildCallback</span>(Relation index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer tid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tupleIsAlive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate = (<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *) state;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldCtx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldCtx = MemoryContextSwitchTo(buildstate-&gt;giststate-&gt;tempCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* form an index tuple and point it at the heap tuple */<br/></li>
<li></span>&nbsp; &nbsp; itup = <a href="gistutil.c.html#L575" title="access/gist/gistutil.c:575">gistFormTuple</a>(buildstate-&gt;giststate, index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; itup-&gt;t_tid = *tid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update tuple count and total size. */<br/></li>
<li></span>&nbsp; &nbsp; buildstate-&gt;indtuples += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; buildstate-&gt;indtuplesSize += IndexTupleSize(itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> In buffering builds, the tempCxt is also reset down inside<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1297" title="access/gist/gistbuild.c:1297">gistProcessEmptyingQueue</a>().&nbsp; This is not great because it risks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * confusion and possible use of dangling pointers (for example, itup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might be already freed when control returns here).&nbsp; It's generally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * better that a memory context be &quot;owned&quot; by only one function.&nbsp; However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * currently this isn't causing issues so it doesn't seem worth the amount<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of refactoring that would be needed to avoid it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (buildstate-&gt;buildMode == GIST_BUFFERING_ACTIVE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have buffers, so use them. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L907" title="access/gist/gistbuild.c:907">gistBufferingBuildInsert</a>(buildstate, itup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's no buffers (yet). Since we already have the index relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locked, we call <a href="gist.c.html#L634" title="access/gist/gist.c:634">gistdoinsert</a> directly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="gist.c.html#L634" title="access/gist/gist.c:634">gistdoinsert</a>(index, itup, buildstate-&gt;freespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buildstate-&gt;giststate, buildstate-&gt;heaprel, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldCtx);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(buildstate-&gt;giststate-&gt;tempCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (buildstate-&gt;buildMode == GIST_BUFFERING_ACTIVE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buildstate-&gt;indtuples % <a href="#L60" title="access/gist/gistbuild.c:60">BUFFERING_MODE_TUPLE_SIZE_STATS_TARGET</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust the target buffer size <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buildstate-&gt;gfbb-&gt;pagesPerBuffer =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L787" title="access/gist/gistbuild.c:787">calculatePagesPerBuffer</a>(buildstate, buildstate-&gt;gfbb-&gt;levelStep);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In 'auto' mode, check if the index has grown too large to fit in cache,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and switch to buffering mode if it has.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To avoid excessive calls to <a href="../../storage/smgr/smgr.c.html#L655" title="storage/smgr/smgr.c:655">smgrnblocks</a>(), only check this every<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L52" title="access/gist/gistbuild.c:52">BUFFERING_MODE_SWITCH_CHECK_STEP</a> index tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In 'stats' state, switch as soon as we have seen enough tuples to have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some idea of the average tuple size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((buildstate-&gt;buildMode == GIST_BUFFERING_AUTO &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buildstate-&gt;indtuples % <a href="#L52" title="access/gist/gistbuild.c:52">BUFFERING_MODE_SWITCH_CHECK_STEP</a> == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../optimizer/path/costsize.c.html#L128" title="optimizer/path/costsize.c:128">effective_cache_size</a> &lt; <a href="../../storage/smgr/smgr.c.html#L655" title="storage/smgr/smgr.c:655">smgrnblocks</a>(RelationGetSmgr(index),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAIN_FORKNUM)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (buildstate-&gt;buildMode == GIST_BUFFERING_STATS &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buildstate-&gt;indtuples &gt;= <a href="#L60" title="access/gist/gistbuild.c:60">BUFFERING_MODE_TUPLE_SIZE_STATS_TARGET</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Index doesn't fit in effective cache anymore. Try to switch to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffering build mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L626" title="access/gist/gistbuild.c:626">gistInitBuffering</a>(buildstate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> function for buffering index build.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L907">&#x200c;</a></span><span class="linkable">gistBufferingBuildInsert</span>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate, IndexTuple itup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> the tuple to buffers. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L923" title="access/gist/gistbuild.c:923">gistProcessItup</a>(buildstate, itup, <span class="Constant">0</span>, buildstate-&gt;gfbb-&gt;rootlevel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we filled up (half of a) buffer, process buffer emptying. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1297" title="access/gist/gistbuild.c:1297">gistProcessEmptyingQueue</a>(buildstate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process an index tuple. Runs the tuple down the tree until we reach a leaf<br/></li>
<li></span><span class="Comment"> * page or node buffer, and inserts the tuple there. Returns true if we have<br/></li>
<li></span><span class="Comment"> * to stop buffer emptying process (because one of child buffers can't take<br/></li>
<li></span><span class="Comment"> * index tuples anymore).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L923">&#x200c;</a></span><span class="linkable">gistProcessItup</span>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate, IndexTuple itup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber startblkno, <span class="Type">int</span> startlevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTSTATE&nbsp; *giststate = buildstate-&gt;giststate;<br/></li>
<li>&nbsp; &nbsp; GISTBuildBuffers *gfbb = buildstate-&gt;gfbb;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; indexrel = buildstate-&gt;indexrel;<br/></li>
<li>&nbsp; &nbsp; BlockNumber childblkno;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; level;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber downlinkoffnum = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; BlockNumber parentblkno = InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop until we reach a leaf page (level == 0) or a level with buffers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (not including the level we start at, because we would otherwise make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no progress).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; blkno = startblkno;<br/></li>
<li>&nbsp; &nbsp; level = startlevel;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; idxtuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber childoffnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Have we reached a level with buffers? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (LEVEL_HAS_BUFFERS(level, gfbb) &amp;&amp; level != startlevel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Have we reached a leaf page? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (level == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Nope. Descend down to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> level then. Choose a child to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * descend down to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(indexrel, blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIST_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; childoffnum = <a href="gistutil.c.html#L374" title="access/gist/gistutil.c:374">gistchoose</a>(indexrel, page, itup, giststate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(page, childoffnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idxtuple = (IndexTuple) PageGetItem(page, iid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; childblkno = ItemPointerGetBlockNumber(&amp;(idxtuple-&gt;t_tid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (level &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1528" title="access/gist/gistbuild.c:1528">gistMemorizeParent</a>(buildstate, childblkno, blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that the key representing the target child node is consistent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with the key we're inserting. Update it if it's not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newtup = <a href="gistutil.c.html#L316" title="access/gist/gistutil.c:316">gistgetadjusted</a>(indexrel, idxtuple, itup, giststate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newtup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno = <a href="#L1054" title="access/gist/gistbuild.c:1054">gistbufferinginserttuples</a>(buildstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;newtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; childoffnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidBlockNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOffsetNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L1054" title="access/gist/gistbuild.c:1054">gistbufferinginserttuples</a>() released the buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Descend to the child */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; parentblkno = blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blkno = childblkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; downlinkoffnum = childoffnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(level &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; level--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (LEVEL_HAS_BUFFERS(level, gfbb))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've reached level with buffers. Place the index tuple to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffer, and add the buffer to the emptying queue if it overflows.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; GISTNodeBuffer *childNodeBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find the buffer or create a new one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; childNodeBuffer = <a href="gistbuildbuffers.c.html#L113" title="access/gist/gistbuildbuffers.c:113">gistGetNodeBuffer</a>(gfbb, giststate, blkno, level);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add index tuple to it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="gistbuildbuffers.c.html#L336" title="access/gist/gistbuildbuffers.c:336">gistPushItupToNodeBuffer</a>(gfbb, childNodeBuffer, itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BUFFER_OVERFLOWED(childNodeBuffer, gfbb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've reached a leaf page. Place the tuple here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(level == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(indexrel, blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIST_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1054" title="access/gist/gistbuild.c:1054">gistbufferinginserttuples</a>(buildstate, buffer, level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;itup, <span class="Constant">1</span>, InvalidOffsetNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentblkno, downlinkoffnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L1054" title="access/gist/gistbuild.c:1054">gistbufferinginserttuples</a>() released the buffer */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> tuples to a given page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is analogous with <a href="gist.c.html#L1282" title="access/gist/gist.c:1282">gistinserttuples</a>() in the regular insertion code.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the block number of the page where the (first) new or updated tuple<br/></li>
<li></span><span class="Comment"> * was inserted. Usually that's the original page, but might be a sibling page<br/></li>
<li></span><span class="Comment"> * if the original page was split.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller should hold a lock on 'buffer' on entry. This function will unlock<br/></li>
<li></span><span class="Comment"> * and unpin it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BlockNumber<br/></li>
<li><a id="L1054">&#x200c;</a><span class="linkable">gistbufferinginserttuples</span>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate, Buffer buffer, <span class="Type">int</span> level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple *itup, <span class="Type">int</span> ntup, OffsetNumber oldoffnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber parentblk, OffsetNumber downlinkoffnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTBuildBuffers *gfbb = buildstate-&gt;gfbb;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *splitinfo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_split;<br/></li>
<li>&nbsp; &nbsp; BlockNumber placed_to_blk = InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; is_split = <a href="gist.c.html#L225" title="access/gist/gist.c:225">gistplacetopage</a>(buildstate-&gt;indexrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buildstate-&gt;freespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buildstate-&gt;giststate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; itup, ntup, oldoffnum, &amp;placed_to_blk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidBuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;splitinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buildstate-&gt;heaprel, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is a root split, update the root path item kept in memory. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensures that all path stacks are always complete, including all parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nodes up to the root. That simplifies the algorithm to re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_split &amp;&amp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer) == GIST_ROOT_BLKNO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber maxoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(level == gfbb-&gt;rootlevel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gfbb-&gt;rootlevel++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;splitting GiST root page, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> </span><span class="Special">%d</span><span class="Constant"> levels deep&quot;</span>, gfbb-&gt;rootlevel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All the downlinks on the old root page are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> on one of the child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pages. Visit all the new child pages to memorize the parents of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * grandchildren.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gfbb-&gt;rootlevel &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (off = FirstOffsetNumber; off &lt;= maxoff; off++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(page, off);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; idxtuple = (IndexTuple) PageGetItem(page, iid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber childblkno = ItemPointerGetBlockNumber(&amp;(idxtuple-&gt;t_tid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; childbuf = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(buildstate-&gt;indexrel, childblkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(childbuf, GIST_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1544" title="access/gist/gistbuild.c:1544">gistMemorizeAllDownlinks</a>(buildstate, childbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(childbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also remember that the parent of the new child page is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * root block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1528" title="access/gist/gistbuild.c:1528">gistMemorizeParent</a>(buildstate, childblkno, GIST_ROOT_BLKNO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (splitinfo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> the downlinks to the parent. This is analogous with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="gist.c.html#L1342" title="access/gist/gist.c:1342">gistfinishsplit</a>() in the regular insertion code, but the locking is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * simpler, and we have to maintain the buffers on <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> nodes and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the parent map.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple *downlinks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndownlinks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; parentBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parent may have changed since we memorized this path. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; parentBuffer =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1223" title="access/gist/gistbuild.c:1223">gistBufferingFindCorrectParent</a>(buildstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;parentblk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;downlinkoffnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there's a buffer associated with this page, that needs to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * split too. <a href="gistbuildbuffers.c.html#L533" title="access/gist/gistbuildbuffers.c:533">gistRelocateBuildBuffersOnSplit</a>() will also adjust the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * downlinks in 'splitinfo', to make sure they're consistent not only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with the tuples already on the pages, but also the tuples in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffers that will eventually be inserted to them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="gistbuildbuffers.c.html#L533" title="access/gist/gistbuildbuffers.c:533">gistRelocateBuildBuffersOnSplit</a>(gfbb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buildstate-&gt;giststate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buildstate-&gt;indexrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer, splitinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create an array of all the downlink tuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ndownlinks = list_length(splitinfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; downlinks = (IndexTuple *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTuple) * ndownlinks);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, splitinfo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GISTPageSplitInfo *splitinfo = lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember the parent of each new child page in our parent map.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This assumes that the downlinks fit on the parent page. If the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent page is split, too, when we recurse up to insert the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * downlinks, the recursive <a href="#L1054" title="access/gist/gistbuild.c:1054">gistbufferinginserttuples</a>() call will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * update the map again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (level &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1528" title="access/gist/gistbuild.c:1528">gistMemorizeParent</a>(buildstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(splitinfo-&gt;buf),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(parentBuffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also update the parent map for all the downlinks that got moved<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to a different page. (actually this also loops through the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * downlinks that stayed on the original page, but it does no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * harm).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (level &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1544" title="access/gist/gistbuild.c:1544">gistMemorizeAllDownlinks</a>(buildstate, splitinfo-&gt;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since there's no concurrent access, we can release the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * level buffers immediately. This includes the original page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(splitinfo-&gt;buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; downlinks[i++] = splitinfo-&gt;downlink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> them into parent. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1054" title="access/gist/gistbuild.c:1054">gistbufferinginserttuples</a>(buildstate, parentBuffer, level + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; downlinks, ndownlinks, downlinkoffnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidBlockNumber, InvalidOffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(splitinfo);&nbsp; &nbsp; <span class="Comment">/* we don't need this anymore */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> placed_to_blk;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find the downlink pointing to a child page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'childblkno' indicates the child page to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the parent for. 'level' is<br/></li>
<li></span><span class="Comment"> * the level of the child. On entry, *parentblkno and *downlinkoffnum can<br/></li>
<li></span><span class="Comment"> * point to a location where the downlink used to be - we will check that<br/></li>
<li></span><span class="Comment"> * location first, and save some cycles if it hasn't moved. The function<br/></li>
<li></span><span class="Comment"> * returns a buffer containing the downlink, exclusively-locked, and<br/></li>
<li></span><span class="Comment"> * *parentblkno and *downlinkoffnum are set to the real location of the<br/></li>
<li></span><span class="Comment"> * downlink.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the child page is a leaf (level == 0), the caller must supply a correct<br/></li>
<li></span><span class="Comment"> * parentblkno. Otherwise we use the parent map <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the parent<br/></li>
<li></span><span class="Comment"> * block.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function serves the same purpose as <a href="gist.c.html#L1022" title="access/gist/gist.c:1022">gistFindCorrectParent</a>() during<br/></li>
<li></span><span class="Comment"> * normal index inserts, but this is simpler because we don't need to deal<br/></li>
<li></span><span class="Comment"> * with concurrent inserts.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Buffer<br/></li>
<li><a id="L1223">&#x200c;</a><span class="linkable">gistBufferingFindCorrectParent</span>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber childblkno, <span class="Type">int</span> level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber *parentblkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber *downlinkoffnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber parent;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber maxoff;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber off;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (level &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent = <a href="#L1565" title="access/gist/gistbuild.c:1565">gistGetParent</a>(buildstate, childblkno);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For a leaf page, the caller must supply a correct parent block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * number.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*parentblkno == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no parent buffer provided of child </span><span class="Special">%u</span><span class="Constant">&quot;</span>, childblkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent = *parentblkno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(buildstate-&gt;indexrel, parent);<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIST_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="gistutil.c.html#L785" title="access/gist/gistutil.c:785">gistcheckpage</a>(buildstate-&gt;indexrel, buffer);<br/></li>
<li>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if it was not moved */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parent == *parentblkno &amp;&amp; *parentblkno != InvalidBlockNumber &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *downlinkoffnum != InvalidOffsetNumber &amp;&amp; *downlinkoffnum &lt;= maxoff)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(page, *downlinkoffnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; idxtuple = (IndexTuple) PageGetItem(page, iid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemPointerGetBlockNumber(&amp;(idxtuple-&gt;t_tid)) == childblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Still there */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Downlink was not at the offset where it used to be. Scan the page to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it. During normal gist insertions, it might've moved to another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page, to the right, but during a buffering build, we keep track of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent of each page in the lookup table so we should always know what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page it's on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (off = FirstOffsetNumber; off &lt;= maxoff; off = OffsetNumberNext(off))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(page, off);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; idxtuple = (IndexTuple) PageGetItem(page, iid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemPointerGetBlockNumber(&amp;(idxtuple-&gt;t_tid)) == childblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* yes!!, found it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *downlinkoffnum = off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> parent for block </span><span class="Special">%u</span><span class="Constant">&quot;</span>, childblkno);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidBuffer;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process buffers emptying stack. Emptying of one buffer can cause emptying<br/></li>
<li></span><span class="Comment"> * of other buffers. This function iterates until this cascading emptying<br/></li>
<li></span><span class="Comment"> * process finished, e.g. until buffers emptying stack is empty.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1297">&#x200c;</a></span><span class="linkable">gistProcessEmptyingQueue</span>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTBuildBuffers *gfbb = buildstate-&gt;gfbb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Iterate while we have elements in buffers emptying stack. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (gfbb-&gt;bufferEmptyingQueue != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GISTNodeBuffer *emptyingNodeBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get node buffer from emptying stack. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; emptyingNodeBuffer = (GISTNodeBuffer *) linitial(gfbb-&gt;bufferEmptyingQueue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gfbb-&gt;bufferEmptyingQueue = <a href="../../nodes/list.c.html#L943" title="nodes/list.c:943">list_delete_first</a>(gfbb-&gt;bufferEmptyingQueue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; emptyingNodeBuffer-&gt;queuedForEmptying = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are going to load last pages of buffers where emptying will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to. So let's unload <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> previously loaded buffers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="gistbuildbuffers.c.html#L272" title="access/gist/gistbuildbuffers.c:272">gistUnloadNodeBuffers</a>(gfbb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pop tuples from the buffer and run them down to the buffers at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> level, or leaf pages. We continue until one of the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * level buffers fills up, or this buffer runs empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In Arge et al's paper, the buffer emptying is stopped after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processing 1/2 node buffer worth of tuples, to avoid overfilling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> level buffers. However, it's more efficient to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keep going until one of the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> level buffers actually fills up,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so that's what we do. This doesn't need to be exact, if a buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overfills by a few tuples, there's no harm done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> index tuple from the buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="gistbuildbuffers.c.html#L406" title="access/gist/gistbuildbuffers.c:406">gistPopItupFromNodeBuffer</a>(gfbb, emptyingNodeBuffer, &amp;itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Run it down to the underlying node buffer or leaf page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: it's possible that the buffer we're emptying splits as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result of this call. If that happens, our emptyingNodeBuffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * points to the left half of the split. After split, it's very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * likely that the new left buffer is no longer over the half-full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * threshold, but we might as well keep flushing tuples from it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * until we fill a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L923" title="access/gist/gistbuild.c:923">gistProcessItup</a>(buildstate, itup, emptyingNodeBuffer-&gt;nodeBlocknum, emptyingNodeBuffer-&gt;level))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> level buffer filled up. Stop emptying this buffer,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to avoid overflowing the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> level buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Free all the memory allocated during index tuple processing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(buildstate-&gt;giststate-&gt;tempCxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Empty all node buffers, from top to bottom. This is done at the end of<br/></li>
<li></span><span class="Comment"> * index build to flush all remaining tuples to the index.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: This destroys the buffersOnLevels lists, so the buffers should not<br/></li>
<li></span><span class="Comment"> * be inserted to after this call.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1370">&#x200c;</a></span><span class="linkable">gistEmptyAllBuffers</span>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GISTBuildBuffers *gfbb = buildstate-&gt;gfbb;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldCtx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldCtx = MemoryContextSwitchTo(buildstate-&gt;giststate-&gt;tempCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Iterate through the levels from top to bottom.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = gfbb-&gt;buffersOnLevelsLen - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Empty all buffers on this level. Note that new buffers can pop up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the list during the processing, as a result of page splits, so a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * simple walk through the list won't work. We remove buffers from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list when we see them empty; a buffer can't become non-empty once<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's been fully emptied.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (gfbb-&gt;buffersOnLevels[i] != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GISTNodeBuffer *nodeBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodeBuffer = (GISTNodeBuffer *) linitial(gfbb-&gt;buffersOnLevels[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nodeBuffer-&gt;blocksCount != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add this buffer to the emptying queue, and proceed to empty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!nodeBuffer-&gt;queuedForEmptying)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(gfbb-&gt;context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodeBuffer-&gt;queuedForEmptying = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gfbb-&gt;bufferEmptyingQueue =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(nodeBuffer, gfbb-&gt;bufferEmptyingQueue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(buildstate-&gt;giststate-&gt;tempCxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1297" title="access/gist/gistbuild.c:1297">gistProcessEmptyingQueue</a>(buildstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gfbb-&gt;buffersOnLevels[i] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L943" title="nodes/list.c:943">list_delete_first</a>(gfbb-&gt;buffersOnLevels[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;emptied all buffers at level </span><span class="Special">%d</span><span class="Constant">&quot;</span>, i);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldCtx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the depth of the GiST index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1425">&#x200c;</a></span><span class="linkable">gistGetMaxLevel</span>(Relation index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxLevel;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Traverse down the tree, starting from the root, until we hit the leaf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; maxLevel = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; blkno = GIST_ROOT_BLKNO;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(index, blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's no concurrent access during index build, so locking is just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pro forma.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, GIST_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GistPageIsLeaf(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We hit the bottom, so we're done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pick the first downlink on the page, and follow it. It doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matter which downlink we choose, the tree has the same depth<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * everywhere, so we just pick the first one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageGetItemId(page, FirstOffsetNumber));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blkno = ItemPointerGetBlockNumber(&amp;(itup-&gt;t_tid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're going down on the tree. It means that there is yet one more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * level in the tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; maxLevel++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> maxLevel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Routines for managing the parent map.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Whenever a page is split, we need to insert the downlinks into the parent.<br/></li>
<li></span><span class="Comment"> * We need to somehow <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the parent page to do that. In normal insertions,<br/></li>
<li></span><span class="Comment"> * we keep a stack of nodes visited when we descend the tree. However, in<br/></li>
<li></span><span class="Comment"> * buffering build, we can start descending the tree from <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> node,<br/></li>
<li></span><span class="Comment"> * when we empty a buffer by cascading tuples to its children. So we don't<br/></li>
<li></span><span class="Comment"> * have a full stack up to the root available at that time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * So instead, we maintain a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table to track the parent of every <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a><br/></li>
<li></span><span class="Comment"> * page. We don't need to track the parents of leaf nodes, however. Whenever<br/></li>
<li></span><span class="Comment"> * we insert to a leaf, we've just descended down from its parent, so we know<br/></li>
<li></span><span class="Comment"> * its immediate parent already. This helps a lot to limit the memory used<br/></li>
<li></span><span class="Comment"> * by this <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Whenever an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> node is split, the parent map needs to be updated.<br/></li>
<li></span><span class="Comment"> * the parent of the new child page needs to be recorded, and also the<br/></li>
<li></span><span class="Comment"> * entries for all page whose downlinks are moved to a new page at the split<br/></li>
<li></span><span class="Comment"> * needs to be updated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also update the parent map whenever we descend the tree. That might seem<br/></li>
<li></span><span class="Comment"> * unnecessary, because we maintain the map whenever a downlink is moved or<br/></li>
<li></span><span class="Comment"> * created, but it is needed because we switch to buffering mode after<br/></li>
<li></span><span class="Comment"> * creating a tree with regular index inserts. Any pages created <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * switching to buffering mode will not be present in the parent map initially,<br/></li>
<li></span><span class="Comment"> * but will be added there the first time we visit them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber childblkno;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber parentblkno;<br/></li>
<li><a id="L1511">&#x200c;</a>} <span class="linkable">ParentMapEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1514">&#x200c;</a></span><span class="linkable">gistInitParentMap</span>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hashCtl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hashCtl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BlockNumber);<br/></li>
<li>&nbsp; &nbsp; hashCtl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L1511" title="access/gist/gistbuild.c:1511">ParentMapEntry</a>);<br/></li>
<li>&nbsp; &nbsp; hashCtl.hcxt = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; buildstate-&gt;parentMap = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;<a href="#L179" title="access/gist/gistbuild.c:179">gistbuild</a> parent map&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1024</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hashCtl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1528">&#x200c;</a></span><span class="linkable">gistMemorizeParent</span>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate, BlockNumber child, BlockNumber parent)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1511" title="access/gist/gistbuild.c:1511">ParentMapEntry</a> *entry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry = (<a href="#L1511" title="access/gist/gistbuild.c:1511">ParentMapEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(buildstate-&gt;parentMap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;child,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; entry-&gt;parentblkno = parent;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Scan all downlinks on a page, and memorize their parent.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1544">&#x200c;</a></span><span class="linkable">gistMemorizeAllDownlinks</span>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate, Buffer parentbuf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber maxoff;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber off;<br/></li>
<li>&nbsp; &nbsp; BlockNumber parentblkno = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(parentbuf);<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(parentbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!GistPageIsLeaf(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (off = FirstOffsetNumber; off &lt;= maxoff; off++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(page, off);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; idxtuple = (IndexTuple) PageGetItem(page, iid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber childblkno = ItemPointerGetBlockNumber(&amp;(idxtuple-&gt;t_tid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1528" title="access/gist/gistbuild.c:1528">gistMemorizeParent</a>(buildstate, childblkno, parentblkno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> BlockNumber<br/></li>
<li><a id="L1565">&#x200c;</a><span class="linkable">gistGetParent</span>(<a href="#L111" title="access/gist/gistbuild.c:111">GISTBuildState</a> *buildstate, BlockNumber child)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1511" title="access/gist/gistbuild.c:1511">ParentMapEntry</a> *entry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find node buffer in <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; entry = (<a href="#L1511" title="access/gist/gistbuild.c:1511">ParentMapEntry</a> *) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(buildstate-&gt;parentMap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;child,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_FIND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> parent of block </span><span class="Special">%u</span><span class="Constant"> in lookup table&quot;</span>, child);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> entry-&gt;parentblkno;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
