<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/hash/hashpage.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/hash/hashpage.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L992">_hash_alloc_buckets</a></li>
<li><a href="#L277">_hash_dropbuf</a></li>
<li><a href="#L289">_hash_dropscanbuf</a></li>
<li><a href="#L614">_hash_expandtable</a></li>
<li><a href="#L1356">_hash_finish_split</a></li>
<li><a href="#L1559">_hash_getbucketbuf_from_hashkey</a></li>
<li><a href="#L70">_hash_getbuf</a></li>
<li><a href="#L96">_hash_getbuf_with_condlock_cleanup</a></li>
<li><a href="#L239">_hash_getbuf_with_strategy</a></li>
<li><a href="#L1501">_hash_getcachedmetap</a></li>
<li><a href="#L135">_hash_getinitbuf</a></li>
<li><a href="#L198">_hash_getnewbuf</a></li>
<li><a href="#L327">_hash_init</a></li>
<li><a href="#L498">_hash_init_metabuffer</a></li>
<li><a href="#L157">_hash_initbuf</a></li>
<li><a href="#L596">_hash_pageinit</a></li>
<li><a href="#L266">_hash_relbuf</a></li>
<li><a href="#L1073">_hash_splitbucket</a></li>
<li><a href="#L1474">log_split_page</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * hashpage.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Hash table page management code for the Postgres <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> access method<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>/hashpage.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Postgres <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> pages look like ordinary relation pages.&nbsp; The opaque<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; data at high addresses includes information about the page including<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; whether a page is an overflow page or a true bucket, the bucket<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; number, and the block numbers of the preceding and following pages<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; in the same bucket.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The first page in a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> relation, page zero, is special -- it stores<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; information describing the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table; it is referred to as the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &quot;meta page.&quot; Pages one and higher store the actual data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; There are also bitmap pages, which are not manipulated here;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; see hashovfl.c.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/hash_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L992" title="access/hash/hashpage.c:992">_hash_alloc_buckets</a>(Relation rel, BlockNumber firstblock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 nblocks);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1073" title="access/hash/hashpage.c:1073">_hash_splitbucket</a>(Relation rel, Buffer metabuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bucket obucket, Bucket nbucket,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer obuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer nbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *htab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 maxbucket,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 highmask, uint32 lowmask);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1474" title="access/hash/hashpage.c:1474">log_split_page</a>(Relation rel, Buffer buf);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L70" title="access/hash/hashpage.c:70">_hash_getbuf</a>() -- Get a buffer by block number for read or write.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 'access' must be HASH_READ, HASH_WRITE, or HASH_NOLOCK.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 'flags' is a bitwise OR of the allowed page types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This must be used only to fetch pages that are expected to be valid<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; already.&nbsp; <a href="hashutil.c.html#L210" title="access/hash/hashutil.c:210">_hash_checkpage</a>() is applied using the given flags.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; When this routine returns, the appropriate lock is set on the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; requested buffer and its reference count has been incremented<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (ie, the buffer is &quot;locked and pinned&quot;).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; P_NEW is disallowed because this routine can only be used<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to access pages that are known to be <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the filesystem EOF.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Extending the index should be done with <a href="#L198" title="access/hash/hashpage.c:198">_hash_getnewbuf</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L70">&#x200c;</a><span class="linkable">_hash_getbuf</span>(Relation rel, BlockNumber blkno, <span class="Type">int</span> access, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (blkno == P_NEW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> AM does not use P_NEW&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(rel, blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (access != HASH_NOLOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, access);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ref count and lock type are correct */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="hashutil.c.html#L210" title="access/hash/hashutil.c:210">_hash_checkpage</a>(rel, buf, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L96" title="access/hash/hashpage.c:96">_hash_getbuf_with_condlock_cleanup</a>() -- Try to get a buffer for <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We read the page and try to acquire a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock.&nbsp; If we get it,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; we return the buffer; otherwise, we return InvalidBuffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L96">&#x200c;</a><span class="linkable">_hash_getbuf_with_condlock_cleanup</span>(Relation rel, BlockNumber blkno, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (blkno == P_NEW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> AM does not use P_NEW&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(rel, blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/buffer/bufmgr.c.html#L5326" title="storage/buffer/bufmgr.c:5326">ConditionalLockBufferForCleanup</a>(buf))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ref count and lock type are correct */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="hashutil.c.html#L210" title="access/hash/hashutil.c:210">_hash_checkpage</a>(rel, buf, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L135" title="access/hash/hashpage.c:135">_hash_getinitbuf</a>() -- Get and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a buffer by block number.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This must be used only to fetch pages that are known to be <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the index's filesystem EOF, but are to be filled from scratch.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L596" title="access/hash/hashpage.c:596">_hash_pageinit</a>() is applied automatically.&nbsp; Otherwise it has<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; effects similar to <a href="#L70" title="access/hash/hashpage.c:70">_hash_getbuf</a>() with access = HASH_WRITE.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; When this routine returns, a write lock is set on the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; requested buffer and its reference count has been incremented<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (ie, the buffer is &quot;locked and pinned&quot;).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; P_NEW is disallowed because this routine can only be used<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to access pages that are known to be <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the filesystem EOF.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Extending the index should be done with <a href="#L198" title="access/hash/hashpage.c:198">_hash_getnewbuf</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L135">&#x200c;</a><span class="linkable">_hash_getinitbuf</span>(Relation rel, BlockNumber blkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (blkno == P_NEW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> AM does not use P_NEW&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(rel, MAIN_FORKNUM, blkno, RBM_ZERO_AND_LOCK,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ref count and lock type are correct */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the page */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L596" title="access/hash/hashpage.c:596">_hash_pageinit</a>(BufferGetPage(buf), BufferGetPageSize(buf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L157" title="access/hash/hashpage.c:157">_hash_initbuf</a>() -- Get and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a buffer by bucket number.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L157">&#x200c;</a></span><span class="linkable">_hash_initbuf</span>(Buffer buf, uint32 max_bucket, uint32 num_bucket, uint32 flag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> initpage)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HashPageOpaque pageopaque;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the page */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (initpage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L596" title="access/hash/hashpage.c:596">_hash_pageinit</a>(page, BufferGetPageSize(buf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pageopaque = HashPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set hasho_prevblkno with current hashm_maxbucket. This value will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used to validate cached HashMetaPageData. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1559" title="access/hash/hashpage.c:1559">_hash_getbucketbuf_from_hashkey</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pageopaque-&gt;hasho_prevblkno = max_bucket;<br/></li>
<li>&nbsp; &nbsp; pageopaque-&gt;hasho_nextblkno = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; pageopaque-&gt;hasho_bucket = num_bucket;<br/></li>
<li>&nbsp; &nbsp; pageopaque-&gt;hasho_flag = flag;<br/></li>
<li>&nbsp; &nbsp; pageopaque-&gt;hasho_page_id = HASHO_PAGE_ID;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L198" title="access/hash/hashpage.c:198">_hash_getnewbuf</a>() -- Get a new page at the end of the index.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This has the same API as <a href="#L135" title="access/hash/hashpage.c:135">_hash_getinitbuf</a>, except that we are adding<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a page to the index, and hence expect the page to be past the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; logical EOF.&nbsp; (However, we have to support the case where it isn't,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; since a prior try might have crashed after extending the filesystem<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; EOF but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> updating the metapage to reflect the added page.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; It is caller's responsibility to ensure that only one process can<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; extend the index at a time.&nbsp; In practice, this function is called<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; only while holding write lock on the metapage, because adding a page<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; is always associated with an update of metapage data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L198">&#x200c;</a><span class="linkable">_hash_getnewbuf</span>(Relation rel, BlockNumber blkno, ForkNumber forkNum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber nblocks = <a href="../../storage/buffer/bufmgr.c.html#L3866" title="storage/buffer/bufmgr.c:3866">RelationGetNumberOfBlocksInFork</a>(rel, forkNum);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (blkno == P_NEW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> AM does not use P_NEW&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (blkno &gt; nblocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;access to noncontiguous page in <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* smgr insists we explicitly extend the relation */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (blkno == nblocks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L845" title="storage/buffer/bufmgr.c:845">ExtendBufferedRel</a>(BMR_REL(rel), forkNum, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EB_LOCK_FIRST | EB_SKIP_EXTENSION_LOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf) != blkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> relation size: </span><span class="Special">%u</span><span class="Constant">, should be </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf), blkno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(rel, forkNum, blkno, RBM_ZERO_AND_LOCK,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ref count and lock type are correct */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the page */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L596" title="access/hash/hashpage.c:596">_hash_pageinit</a>(BufferGetPage(buf), BufferGetPageSize(buf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L239" title="access/hash/hashpage.c:239">_hash_getbuf_with_strategy</a>() -- Get a buffer with nondefault strategy.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is identical to <a href="#L70" title="access/hash/hashpage.c:70">_hash_getbuf</a>() but also allows a buffer access<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; strategy to be specified.&nbsp; We use this for VACUUM operations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L239">&#x200c;</a><span class="linkable">_hash_getbuf_with_strategy</span>(Relation rel, BlockNumber blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> access, <span class="Type">int</span> flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BufferAccessStrategy bstrategy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (blkno == P_NEW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> AM does not use P_NEW&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(rel, MAIN_FORKNUM, blkno, RBM_NORMAL, bstrategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (access != HASH_NOLOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, access);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ref count and lock type are correct */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="hashutil.c.html#L210" title="access/hash/hashutil.c:210">_hash_checkpage</a>(rel, buf, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L266" title="access/hash/hashpage.c:266">_hash_relbuf</a>() -- release a locked buffer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Lock and pin (refcount) are both dropped.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L266">&#x200c;</a></span><span class="linkable">_hash_relbuf</span>(Relation rel, Buffer buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L277" title="access/hash/hashpage.c:277">_hash_dropbuf</a>() -- release an unlocked buffer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used to unpin a buffer on which we hold no lock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L277">&#x200c;</a></span><span class="linkable">_hash_dropbuf</span>(Relation rel, Buffer buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L289" title="access/hash/hashpage.c:289">_hash_dropscanbuf</a>() -- release buffers used in scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine unpins the buffers used during scan on which we<br/></li>
<li></span><span class="Comment"> * hold no lock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L289">&#x200c;</a></span><span class="linkable">_hash_dropscanbuf</span>(Relation rel, HashScanOpaque so)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release pin we hold on primary bucket page */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(so-&gt;hashso_bucket_buf) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;hashso_bucket_buf != so-&gt;currPos.buf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L277" title="access/hash/hashpage.c:277">_hash_dropbuf</a>(rel, so-&gt;hashso_bucket_buf);<br/></li>
<li>&nbsp; &nbsp; so-&gt;hashso_bucket_buf = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release pin we hold on primary bucket page&nbsp; of bucket being split */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(so-&gt;hashso_split_bucket_buf) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;hashso_split_bucket_buf != so-&gt;currPos.buf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L277" title="access/hash/hashpage.c:277">_hash_dropbuf</a>(rel, so-&gt;hashso_split_bucket_buf);<br/></li>
<li>&nbsp; &nbsp; so-&gt;hashso_split_bucket_buf = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pin we still hold */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(so-&gt;currPos.buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L277" title="access/hash/hashpage.c:277">_hash_dropbuf</a>(rel, so-&gt;currPos.buf);<br/></li>
<li>&nbsp; &nbsp; so-&gt;currPos.buf = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reset split scan */<br/></li>
<li></span>&nbsp; &nbsp; so-&gt;hashso_buc_populated = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; so-&gt;hashso_buc_split = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L327" title="access/hash/hashpage.c:327">_hash_init</a>() -- Initialize the metadata page of a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> index,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the initial buckets, and the initial bitmap page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The initial number of buckets is dependent on num_tuples, an estimate<br/></li>
<li></span><span class="Comment"> * of the number of tuples to be loaded into the index initially.&nbsp; The<br/></li>
<li></span><span class="Comment"> * chosen number of buckets is returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We are fairly cavalier about locking here, since we know that no one else<br/></li>
<li></span><span class="Comment"> * could be accessing this index.&nbsp; In particular the rule about not holding<br/></li>
<li></span><span class="Comment"> * multiple buffer locks is ignored.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint32<br/></li>
<li><a id="L327">&#x200c;</a><span class="linkable">_hash_init</span>(Relation rel, <span class="Type">double</span> num_tuples, ForkNumber forkNum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuf;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; bitmapbuf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; pg;<br/></li>
<li>&nbsp; &nbsp; HashMetaPage metap;<br/></li>
<li>&nbsp; &nbsp; RegProcedure procid;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; data_width;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; item_width;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; ffactor;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; num_buckets;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; use_wal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* safety check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/buffer/bufmgr.c.html#L3866" title="storage/buffer/bufmgr.c:3866">RelationGetNumberOfBlocksInFork</a>(rel, forkNum) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> non-empty <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WAL log creation of pages if the relation is persistent, or this is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * init fork.&nbsp; Init forks for unlogged relations always need to be WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * logged.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; use_wal = RelationNeedsWAL(rel) || forkNum == INIT_FORKNUM;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the target fill factor (in tuples per bucket) for this index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The idea is to make the fill factor correspond to pages about as full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as the user-settable fillfactor parameter says.&nbsp; We can compute it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exactly since the index datatype (i.e. uint32 <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key) is fixed-width.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; data_width = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li>&nbsp; &nbsp; item_width = MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData)) + MAXALIGN(data_width) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* include the line pointer */<br/></li>
<li></span>&nbsp; &nbsp; ffactor = HashGetTargetPageUsage(rel) / item_width;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* keep to a sane <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ffactor &lt; <span class="Constant">10</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ffactor = <span class="Constant">10</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; procid = <a href="../index/indexam.c.html#L826" title="access/index/indexam.c:826">index_getprocid</a>(rel, <span class="Constant">1</span>, HASHSTANDARD_PROC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the metapage, the first N bucket pages, and the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bitmap page in sequence, using <a href="#L198" title="access/hash/hashpage.c:198">_hash_getnewbuf</a> to cause <a href="../../storage/smgr/smgr.c.html#L535" title="storage/smgr/smgr.c:535">smgrextend</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls to occur.&nbsp; This ensures that the smgr level has the right idea of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the physical index length.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Critical section not required, because on error the creation of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whole relation will be rolled back.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; metabuf = <a href="#L198" title="access/hash/hashpage.c:198">_hash_getnewbuf</a>(rel, HASH_METAPAGE, forkNum);<br/></li>
<li>&nbsp; &nbsp; <a href="#L498" title="access/hash/hashpage.c:498">_hash_init_metabuffer</a>(metabuf, num_tuples, procid, ffactor, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(metabuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg = BufferGetPage(metabuf);<br/></li>
<li>&nbsp; &nbsp; metap = HashPageGetMeta(pg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (use_wal)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_hash_init_meta_page xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.num_tuples = num_tuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.procid = metap-&gt;hashm_procid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.ffactor = metap-&gt;hashm_ffactor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfHashInitMetaPage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, metabuf, REGBUF_WILL_INIT | REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HASH_ID, XLOG_HASH_INIT_META_PAGE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(BufferGetPage(metabuf), recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; num_buckets = metap-&gt;hashm_maxbucket + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release buffer lock on the metapage while we <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> buckets.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, we'll be in interrupt holdoff and the CHECK_FOR_INTERRUPTS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * won't accomplish anything.&nbsp; It's a bad idea to hold buffer locks for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * long intervals in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, since that can block the bgwriter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize and WAL Log the first N buckets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_buckets; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allow interrupts, in case N is huge */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blkno = BUCKET_TO_BLKNO(metap, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L198" title="access/hash/hashpage.c:198">_hash_getnewbuf</a>(rel, blkno, forkNum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L157" title="access/hash/hashpage.c:157">_hash_initbuf</a>(buf, metap-&gt;hashm_maxbucket, i, LH_BUCKET_PAGE, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (use_wal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L1143" title="access/transam/xloginsert.c:1143">log_newpage</a>(&amp;rel-&gt;rd_locator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forkNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferGetPage(buf),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L266" title="access/hash/hashpage.c:266">_hash_relbuf</a>(rel, buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now reacquire buffer lock on metapage */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize bitmap page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bitmapbuf = <a href="#L198" title="access/hash/hashpage.c:198">_hash_getnewbuf</a>(rel, num_buckets + <span class="Constant">1</span>, forkNum);<br/></li>
<li>&nbsp; &nbsp; <a href="hashovfl.c.html#L777" title="access/hash/hashovfl.c:777">_hash_initbitmapbuffer</a>(bitmapbuf, metap-&gt;hashm_bmsize, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(bitmapbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add the new bitmap page to the metapage's list of bitmaps */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* metapage already has a write lock */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (metap-&gt;hashm_nmaps &gt;= HASH_MAX_BITMAPS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of overflow pages in <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metap-&gt;hashm_mapp[metap-&gt;hashm_nmaps] = num_buckets + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metap-&gt;hashm_nmaps++;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(metabuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (use_wal)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_hash_init_bitmap_page xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.bmsize = metap-&gt;hashm_bmsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfHashInitBitmapPage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, bitmapbuf, REGBUF_WILL_INIT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is safe only because nobody else can be modifying the index at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this stage; it's only visible to the transaction that is creating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">1</span>, metabuf, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HASH_ID, XLOG_HASH_INIT_BITMAP_PAGE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(BufferGetPage(bitmapbuf), recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(BufferGetPage(metabuf), recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* all done */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L266" title="access/hash/hashpage.c:266">_hash_relbuf</a>(rel, bitmapbuf);<br/></li>
<li>&nbsp; &nbsp; <a href="#L266" title="access/hash/hashpage.c:266">_hash_relbuf</a>(rel, metabuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> num_buckets;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L498" title="access/hash/hashpage.c:498">_hash_init_metabuffer</a>() -- Initialize the metadata page of a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L498">&#x200c;</a></span><span class="linkable">_hash_init_metabuffer</span>(Buffer buf, <span class="Type">double</span> num_tuples, RegProcedure procid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16 ffactor, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> initpage)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HashMetaPage metap;<br/></li>
<li>&nbsp; &nbsp; HashPageOpaque pageopaque;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; dnumbuckets;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; num_buckets;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; spare_index;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; lshift;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Choose the number of initial bucket pages to match the fill factor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * given the estimated number of tuples.&nbsp; We round up the result to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * total number of buckets which has to be allocated <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> using its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hashm_spares <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>. However always force at least 2 bucket pages. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> limit is determined by considerations explained in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L614" title="access/hash/hashpage.c:614">_hash_expandtable</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dnumbuckets = num_tuples / ffactor;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dnumbuckets &lt;= <span class="Constant">2.0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num_buckets = <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (dnumbuckets &gt;= (<span class="Type">double</span>) <span class="Constant">0x40000000</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num_buckets = <span class="Constant">0x40000000</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; num_buckets = <a href="hashutil.c.html#L174" title="access/hash/hashutil.c:174">_hash_get_totalbuckets</a>(<a href="hashutil.c.html#L142" title="access/hash/hashutil.c:142">_hash_spareindex</a>(dnumbuckets));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; spare_index = <a href="hashutil.c.html#L142" title="access/hash/hashutil.c:142">_hash_spareindex</a>(num_buckets);<br/></li>
<li>&nbsp; &nbsp; Assert(spare_index &lt; HASH_MAX_SPLITPOINTS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (initpage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L596" title="access/hash/hashpage.c:596">_hash_pageinit</a>(page, BufferGetPageSize(buf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pageopaque = HashPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; pageopaque-&gt;hasho_prevblkno = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; pageopaque-&gt;hasho_nextblkno = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; pageopaque-&gt;hasho_bucket = InvalidBucket;<br/></li>
<li>&nbsp; &nbsp; pageopaque-&gt;hasho_flag = LH_META_PAGE;<br/></li>
<li>&nbsp; &nbsp; pageopaque-&gt;hasho_page_id = HASHO_PAGE_ID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metap = HashPageGetMeta(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metap-&gt;hashm_magic = HASH_MAGIC;<br/></li>
<li>&nbsp; &nbsp; metap-&gt;hashm_version = HASH_VERSION;<br/></li>
<li>&nbsp; &nbsp; metap-&gt;hashm_ntuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; metap-&gt;hashm_nmaps = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; metap-&gt;hashm_ffactor = ffactor;<br/></li>
<li>&nbsp; &nbsp; metap-&gt;hashm_bsize = HashGetMaxBitmapSize(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> largest bitmap array size that will fit in page size */<br/></li>
<li></span>&nbsp; &nbsp; lshift = pg_leftmost_one_pos32(metap-&gt;hashm_bsize);<br/></li>
<li>&nbsp; &nbsp; Assert(lshift &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; metap-&gt;hashm_bmsize = <span class="Constant">1</span> &lt;&lt; lshift;<br/></li>
<li>&nbsp; &nbsp; metap-&gt;hashm_bmshift = lshift + BYTE_TO_BIT;<br/></li>
<li>&nbsp; &nbsp; Assert((<span class="Constant">1</span> &lt;&lt; BMPG_SHIFT(metap)) == (BMPG_MASK(metap) + <span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Label the index with its primary <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> support function's OID.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pretty useless for normal operation (in fact, hashm_procid is not used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anywhere), but it might be handy for forensic purposes so we keep it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; metap-&gt;hashm_procid = procid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the index with N buckets, 0 .. N-1, occupying physical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * blocks 1 to N.&nbsp; The first freespace bitmap page is in block N+1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; metap-&gt;hashm_maxbucket = num_buckets - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set highmask as <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> immediate ((2 ^ x) - 1), which should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sufficient to cover num_buckets.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; metap-&gt;hashm_highmask = pg_nextpower2_32(num_buckets + <span class="Constant">1</span>) - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; metap-&gt;hashm_lowmask = (metap-&gt;hashm_highmask &gt;&gt; <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemSet(metap-&gt;hashm_spares, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(metap-&gt;hashm_spares));<br/></li>
<li>&nbsp; &nbsp; MemSet(metap-&gt;hashm_mapp, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(metap-&gt;hashm_mapp));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up mapping for one spare page after the initial splitpoints */<br/></li>
<li></span>&nbsp; &nbsp; metap-&gt;hashm_spares[spare_index] = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; metap-&gt;hashm_ovflpoint = spare_index;<br/></li>
<li>&nbsp; &nbsp; metap-&gt;hashm_firstfree = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set pd_lower just past the end of the metadata.&nbsp; This is essential,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because without doing so, metadata will be lost if xlog.c compresses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ((PageHeader) page)-&gt;pd_lower =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">char</span> *) metap + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HashMetaPageData)) - (<span class="Type">char</span> *) page;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L596" title="access/hash/hashpage.c:596">_hash_pageinit</a>() -- Initialize a new <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> index page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L596">&#x200c;</a></span><span class="linkable">_hash_pageinit</span>(Page page, Size size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L42" title="storage/page/bufpage.c:42">PageInit</a>(page, size, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HashPageOpaqueData));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attempt to expand the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table by creating one new bucket.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This will silently do nothing if we don't get <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock on old or<br/></li>
<li></span><span class="Comment"> * new bucket.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Complete the pending splits and remove the tuples from old bucket,<br/></li>
<li></span><span class="Comment"> * if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> left over from the previous split.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must hold a pin, but no lock, on the metapage buffer.<br/></li>
<li></span><span class="Comment"> * The buffer is returned in the same state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L614">&#x200c;</a></span><span class="linkable">_hash_expandtable</span>(Relation rel, Buffer metabuf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HashMetaPage metap;<br/></li>
<li>&nbsp; &nbsp; Bucket&nbsp; &nbsp; &nbsp; &nbsp; old_bucket;<br/></li>
<li>&nbsp; &nbsp; Bucket&nbsp; &nbsp; &nbsp; &nbsp; new_bucket;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; spare_ndx;<br/></li>
<li>&nbsp; &nbsp; BlockNumber start_oblkno;<br/></li>
<li>&nbsp; &nbsp; BlockNumber start_nblkno;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf_nblkno;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf_oblkno;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; opage;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; npage;<br/></li>
<li>&nbsp; &nbsp; HashPageOpaque oopaque;<br/></li>
<li>&nbsp; &nbsp; HashPageOpaque nopaque;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; maxbucket;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; highmask;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; lowmask;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; metap_update_masks = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; metap_update_splitpoint = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">restart_expand</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write-lock the meta page.&nbsp; It used to be necessary to acquire a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * heavyweight lock to begin a split, but that is no longer required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="hashutil.c.html#L210" title="access/hash/hashutil.c:210">_hash_checkpage</a>(rel, metabuf, LH_META_PAGE);<br/></li>
<li>&nbsp; &nbsp; metap = HashPageGetMeta(BufferGetPage(metabuf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check to see if split is still needed; someone else might have already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done one while we waited for the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure this stays in sync with <a href="hashinsert.c.html#L38" title="access/hash/hashinsert.c:38">_hash_doinsert</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (metap-&gt;hashm_ntuples &lt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">double</span>) metap-&gt;hashm_ffactor * (metap-&gt;hashm_maxbucket + <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Can't split anymore if maxbucket has reached its maximum possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ideally we'd allow bucket numbers up to UINT_MAX-1 (no higher because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the calculation maxbucket+1 mustn't overflow).&nbsp; Currently we restrict<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to half that to prevent failure of pg_ceil_log2_32() and insufficient<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space in hashm_spares[].&nbsp; It's moot anyway because an index with 2^32<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buckets would certainly overflow BlockNumber and hence<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L992" title="access/hash/hashpage.c:992">_hash_alloc_buckets</a>() would fail, but if we supported buckets smaller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than a disk block then this would be an independent constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If you change this, see also the maximum initial number of buckets in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L327" title="access/hash/hashpage.c:327">_hash_init</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (metap-&gt;hashm_maxbucket &gt;= (uint32) <span class="Constant">0x7FFFFFFE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine which bucket is to be split, and attempt to take <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the old bucket.&nbsp; If we can't get the lock, give up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock protects us not only against other backends, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * against our own backend as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock is mainly to protect the split from concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inserts. See src/backend/access/<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>/README, Lock Definitions for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * further details.&nbsp; Due to this locking restriction, if there is <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pending scan, the split will give up which is not good, but harmless.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; new_bucket = metap-&gt;hashm_maxbucket + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; old_bucket = (new_bucket &amp; metap-&gt;hashm_lowmask);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; start_oblkno = BUCKET_TO_BLKNO(metap, old_bucket);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf_oblkno = <a href="#L96" title="access/hash/hashpage.c:96">_hash_getbuf_with_condlock_cleanup</a>(rel, start_oblkno, LH_BUCKET_PAGE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!buf_oblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opage = BufferGetPage(buf_oblkno);<br/></li>
<li>&nbsp; &nbsp; oopaque = HashPageGetOpaque(opage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We want to finish the split from a bucket as there is no apparent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * benefit by not doing so and it will make the code complicated to finish<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the split that involves multiple buckets considering the case where new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * split also fails.&nbsp; We don't need to consider the new bucket for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * completing the split here as it is not possible that a re-split of new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bucket starts when there is still a pending split from old bucket.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (H_BUCKET_BEING_SPLIT(oopaque))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy bucket mapping info <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>; refer the comment in code below where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we copy this information <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling <a href="#L1073" title="access/hash/hashpage.c:1073">_hash_splitbucket</a> to see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * why this is okay.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; maxbucket = metap-&gt;hashm_maxbucket;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; highmask = metap-&gt;hashm_highmask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lowmask = metap-&gt;hashm_lowmask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Release the lock on metapage and old_bucket, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> completing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * split.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf_oblkno, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1356" title="access/hash/hashpage.c:1356">_hash_finish_split</a>(rel, metabuf, buf_oblkno, old_bucket, maxbucket,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; highmask, lowmask);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* release the pin on old buffer and retry for expand. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L277" title="access/hash/hashpage.c:277">_hash_dropbuf</a>(rel, buf_oblkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> restart_expand;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clean the tuples remained from the previous split.&nbsp; This operation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requires <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock and we already have one on the old bucket, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * let's do it. We also don't want to allow further splits from the bucket<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * till the garbage of previous split is cleaned.&nbsp; This has two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * advantages; first, it helps in avoiding the bloat due to garbage and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * second is, during <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> of bucket, we are always sure that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * garbage tuples belong to most recently split bucket.&nbsp; On the contrary,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we allow <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> of bucket after meta page is updated to indicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the new split and <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the actual split, the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> operation won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be able to decide whether the tuple has been moved to the newly created<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bucket and ended up deleting such tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (H_NEEDS_SPLIT_CLEANUP(oopaque))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy bucket mapping info <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>; refer to the comment in code below<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * where we copy this information <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling <a href="#L1073" title="access/hash/hashpage.c:1073">_hash_splitbucket</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * see why this is okay.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; maxbucket = metap-&gt;hashm_maxbucket;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; highmask = metap-&gt;hashm_highmask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lowmask = metap-&gt;hashm_lowmask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release the metapage lock. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="hash.c.html#L687" title="access/hash/hash.c:687">hashbucketcleanup</a>(rel, old_bucket, buf_oblkno, start_oblkno, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxbucket, highmask, lowmask, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L277" title="access/hash/hashpage.c:277">_hash_dropbuf</a>(rel, buf_oblkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> restart_expand;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There shouldn't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> active scan on new bucket.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: it is safe to compute the new bucket's blkno here, even though we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * may still need to update the BUCKET_TO_BLKNO mapping.&nbsp; This is because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the current value of hashm_spares[hashm_ovflpoint] correctly shows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where we are going to put a new splitpoint's worth of buckets.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; start_nblkno = BUCKET_TO_BLKNO(metap, new_bucket);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the split point is increasing we need to allocate a new batch of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bucket pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; spare_ndx = <a href="hashutil.c.html#L142" title="access/hash/hashutil.c:142">_hash_spareindex</a>(new_bucket + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (spare_ndx &gt; metap-&gt;hashm_ovflpoint)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; buckets_to_add;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(spare_ndx == metap-&gt;hashm_ovflpoint + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We treat allocation of buckets as a separate WAL-logged action.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Even if we fail after this operation, won't leak bucket pages;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rather, the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> split will consume this space. In <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * without failure we don't use all the space in one split operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buckets_to_add = <a href="hashutil.c.html#L174" title="access/hash/hashutil.c:174">_hash_get_totalbuckets</a>(spare_ndx) - new_bucket;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L992" title="access/hash/hashpage.c:992">_hash_alloc_buckets</a>(rel, start_nblkno, buckets_to_add))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't split due to BlockNumber overflow */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L266" title="access/hash/hashpage.c:266">_hash_relbuf</a>(rel, buf_oblkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Physically allocate the new bucket's primary page.&nbsp; We want to do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> changing the metapage's mapping info, in case we can't get the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disk space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> It doesn't make sense to call <a href="#L198" title="access/hash/hashpage.c:198">_hash_getnewbuf</a> first, zeroing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer, and then only afterwards check whether we have a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, since no scan can be accessing the buffer yet, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accesses will just be from processes like the bgwriter or checkpointer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which don't care about its contents, so it doesn't really matter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; buf_nblkno = <a href="#L198" title="access/hash/hashpage.c:198">_hash_getnewbuf</a>(rel, start_nblkno, MAIN_FORKNUM);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/buffer/bufmgr.c.html#L5382" title="storage/buffer/bufmgr.c:5382">IsBufferCleanupOK</a>(buf_nblkno))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L266" title="access/hash/hashpage.c:266">_hash_relbuf</a>(rel, buf_oblkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L266" title="access/hash/hashpage.c:266">_hash_relbuf</a>(rel, buf_nblkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> fail;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we are scribbling on the pages in the shared buffers, establish a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * critical section.&nbsp; Any failure in this <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> code leaves us with a big<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * problem: the metapage is effectively corrupt but could get written back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Okay to proceed with split.&nbsp; Update the metapage bucket mapping info.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; metap-&gt;hashm_maxbucket = new_bucket;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (new_bucket &gt; metap-&gt;hashm_highmask)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Starting a new doubling */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; metap-&gt;hashm_lowmask = metap-&gt;hashm_highmask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metap-&gt;hashm_highmask = new_bucket | metap-&gt;hashm_lowmask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metap_update_masks = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the split point is increasing we need to adjust the hashm_spares[]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array and hashm_ovflpoint so that future overflow pages will be created<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * beyond this new batch of bucket pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (spare_ndx &gt; metap-&gt;hashm_ovflpoint)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metap-&gt;hashm_spares[spare_ndx] = metap-&gt;hashm_spares[metap-&gt;hashm_ovflpoint];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metap-&gt;hashm_ovflpoint = spare_ndx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metap_update_splitpoint = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(metabuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy bucket mapping info <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>; this saves re-accessing the meta page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inside <a href="#L1073" title="access/hash/hashpage.c:1073">_hash_splitbucket</a>'s inner loop.&nbsp; Note that once we drop the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * split lock, other splits could begin, so these <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> might be out of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * date <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="#L1073" title="access/hash/hashpage.c:1073">_hash_splitbucket</a> finishes.&nbsp; That's okay, since all it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needs is to tell which of these two buckets to map hashkeys into.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; maxbucket = metap-&gt;hashm_maxbucket;<br/></li>
<li>&nbsp; &nbsp; highmask = metap-&gt;hashm_highmask;<br/></li>
<li>&nbsp; &nbsp; lowmask = metap-&gt;hashm_lowmask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opage = BufferGetPage(buf_oblkno);<br/></li>
<li>&nbsp; &nbsp; oopaque = HashPageGetOpaque(opage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark the old bucket to indicate that split is in progress.&nbsp; (At<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operation end, we will clear the split-in-progress flag.)&nbsp; Also, for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * primary bucket page, hasho_prevblkno stores the number of buckets that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * existed as of the last split, so we must update that value here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oopaque-&gt;hasho_flag |= LH_BUCKET_BEING_SPLIT;<br/></li>
<li>&nbsp; &nbsp; oopaque-&gt;hasho_prevblkno = maxbucket;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf_oblkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; npage = BufferGetPage(buf_nblkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the new bucket's primary page and mark it to indicate that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * split is in progress.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nopaque = HashPageGetOpaque(npage);<br/></li>
<li>&nbsp; &nbsp; nopaque-&gt;hasho_prevblkno = maxbucket;<br/></li>
<li>&nbsp; &nbsp; nopaque-&gt;hasho_nextblkno = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; nopaque-&gt;hasho_bucket = new_bucket;<br/></li>
<li>&nbsp; &nbsp; nopaque-&gt;hasho_flag = LH_BUCKET_PAGE | LH_BUCKET_BEING_POPULATED;<br/></li>
<li>&nbsp; &nbsp; nopaque-&gt;hasho_page_id = HASHO_PAGE_ID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf_nblkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_hash_split_allocate_page xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.new_bucket = maxbucket;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.old_bucket_flag = oopaque-&gt;hasho_flag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.new_bucket_flag = nopaque-&gt;hasho_flag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buf_oblkno, REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">1</span>, buf_nblkno, REGBUF_WILL_INIT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">2</span>, metabuf, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (metap_update_masks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLH_SPLIT_META_UPDATE_MASKS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">2</span>, (<span class="Type">char</span> *) &amp;metap-&gt;hashm_lowmask, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">2</span>, (<span class="Type">char</span> *) &amp;metap-&gt;hashm_highmask, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (metap_update_splitpoint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLH_SPLIT_META_UPDATE_SPLITPOINT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">2</span>, (<span class="Type">char</span> *) &amp;metap-&gt;hashm_ovflpoint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">char</span> *) &amp;metap-&gt;hashm_spares[metap-&gt;hashm_ovflpoint],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfHashSplitAllocPage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HASH_ID, XLOG_HASH_SPLIT_ALLOCATE_PAGE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(BufferGetPage(buf_oblkno), recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(BufferGetPage(buf_nblkno), recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(BufferGetPage(metabuf), recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* drop lock, but keep pin */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Relocate <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> to the new bucket */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1073" title="access/hash/hashpage.c:1073">_hash_splitbucket</a>(rel, metabuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_bucket, new_bucket,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf_oblkno, buf_nblkno, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxbucket, highmask, lowmask);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* all done, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> release the pins on primary buckets. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L277" title="access/hash/hashpage.c:277">_hash_dropbuf</a>(rel, buf_oblkno);<br/></li>
<li>&nbsp; &nbsp; <a href="#L277" title="access/hash/hashpage.c:277">_hash_dropbuf</a>(rel, buf_nblkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Here if decide not to split or fail to acquire old bucket lock */<br/></li>
<li></span><span class="Statement">fail</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We didn't write the metapage, so just drop lock */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L992" title="access/hash/hashpage.c:992">_hash_alloc_buckets</a> -- allocate a new splitpoint's worth of bucket pages<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This does not need to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the new bucket pages; we'll do that as<br/></li>
<li></span><span class="Comment"> * each one is used by <a href="#L614" title="access/hash/hashpage.c:614">_hash_expandtable</a>().&nbsp; But we have to extend the logical<br/></li>
<li></span><span class="Comment"> * EOF to the end of the splitpoint; this keeps smgr's idea of the EOF in<br/></li>
<li></span><span class="Comment"> * sync with ours, so that we don't get complaints from smgr.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We do this by writing a page of zeroes at the end of the splitpoint <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment"> * We expect that the filesystem will ensure that the intervening pages read<br/></li>
<li></span><span class="Comment"> * as zeroes too.&nbsp; On many filesystems this &quot;hole&quot; will not be allocated<br/></li>
<li></span><span class="Comment"> * immediately, which means that the index file may end up more fragmented<br/></li>
<li></span><span class="Comment"> * than if we forced it all to be allocated <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>; but since we don't scan<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> indexes sequentially anyway, that probably doesn't matter.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> It's annoying that this code is executed with the metapage lock held.<br/></li>
<li></span><span class="Comment"> * We need to interlock against <a href="hashovfl.c.html#L112" title="access/hash/hashovfl.c:112">_hash_addovflpage</a>() adding a new overflow page<br/></li>
<li></span><span class="Comment"> * concurrently, but it'd likely be better to use <a href="../../storage/lmgr/lmgr.c.html#L430" title="storage/lmgr/lmgr.c:430">LockRelationForExtension</a><br/></li>
<li></span><span class="Comment"> * for the purpose.&nbsp; OTOH, adding a splitpoint is a very infrequent operation,<br/></li>
<li></span><span class="Comment"> * so it may not be worth worrying about.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, or false if allocation failed due to<br/></li>
<li></span><span class="Comment"> * BlockNumber overflow.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L992">&#x200c;</a></span><span class="linkable">_hash_alloc_buckets</span>(Relation rel, BlockNumber firstblock, uint32 nblocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber lastblock;<br/></li>
<li>&nbsp; &nbsp; PGIOAlignedBlock zerobuf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; HashPageOpaque ovflopaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lastblock = firstblock + nblocks - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for overflow in block number calculation; if so, we cannot extend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the index anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lastblock &lt; firstblock || lastblock == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = (Page) zerobuf.data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the page.&nbsp; Just zeroing the page won't work; see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="hashovfl.c.html#L490" title="access/hash/hashovfl.c:490">_hash_freeovflpage</a> for similar usage.&nbsp; We take care to make the special<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space valid for the benefit of tools such as pageinspect.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L596" title="access/hash/hashpage.c:596">_hash_pageinit</a>(page, BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ovflopaque = HashPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ovflopaque-&gt;hasho_prevblkno = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; ovflopaque-&gt;hasho_nextblkno = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; ovflopaque-&gt;hasho_bucket = InvalidBucket;<br/></li>
<li>&nbsp; &nbsp; ovflopaque-&gt;hasho_flag = LH_UNUSED_PAGE;<br/></li>
<li>&nbsp; &nbsp; ovflopaque-&gt;hasho_page_id = HASHO_PAGE_ID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L1143" title="access/transam/xloginsert.c:1143">log_newpage</a>(&amp;rel-&gt;rd_locator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAIN_FORKNUM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastblock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zerobuf.data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1542" title="storage/page/bufpage.c:1542">PageSetChecksumInplace</a>(page, lastblock);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/smgr/smgr.c.html#L535" title="storage/smgr/smgr.c:535">smgrextend</a>(RelationGetSmgr(rel), MAIN_FORKNUM, lastblock, zerobuf.data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1073" title="access/hash/hashpage.c:1073">_hash_splitbucket</a> -- split 'obucket' into 'obucket' and 'nbucket'<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine is used to partition the tuples between old and new bucket and<br/></li>
<li></span><span class="Comment"> * is used to finish the incomplete split operations.&nbsp; To finish the previously<br/></li>
<li></span><span class="Comment"> * interrupted split operation, the caller needs to fill htab.&nbsp; If htab is set,<br/></li>
<li></span><span class="Comment"> * then we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the movement of tuples that exists in htab, otherwise NULL<br/></li>
<li></span><span class="Comment"> * value of htab indicates movement of all the tuples that belong to the new<br/></li>
<li></span><span class="Comment"> * bucket.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We are splitting a bucket that consists of a base bucket page and zero<br/></li>
<li></span><span class="Comment"> * or more overflow (bucket chain) pages.&nbsp; We must relocate tuples that<br/></li>
<li></span><span class="Comment"> * belong in the new bucket.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must hold <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> locks on both buckets to ensure that<br/></li>
<li></span><span class="Comment"> * no one else is trying to access them (see README).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must hold a pin, but no lock, on the metapage buffer.<br/></li>
<li></span><span class="Comment"> * The buffer is returned in the same state.&nbsp; (The metapage is only<br/></li>
<li></span><span class="Comment"> * touched if it becomes necessary to add or remove overflow pages.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Split needs to retain pin on primary bucket pages of both old and new<br/></li>
<li></span><span class="Comment"> * buckets till end of operation.&nbsp; This is to prevent <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> from starting<br/></li>
<li></span><span class="Comment"> * while a split is in progress.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition, the caller must have created the new bucket's base page,<br/></li>
<li></span><span class="Comment"> * which is passed in buffer nbuf, pinned and write-locked.&nbsp; The lock will be<br/></li>
<li></span><span class="Comment"> * released here and pin must be released by the caller.&nbsp; (The API is set up<br/></li>
<li></span><span class="Comment"> * this way because we must do <a href="#L198" title="access/hash/hashpage.c:198">_hash_getnewbuf</a>() <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing the metapage<br/></li>
<li></span><span class="Comment"> * write lock.&nbsp; So instead of passing the new bucket's start block number, we<br/></li>
<li></span><span class="Comment"> * pass an actual buffer.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1073">&#x200c;</a></span><span class="linkable">_hash_splitbucket</span>(Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer metabuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bucket obucket,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bucket nbucket,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer obuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer nbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *htab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 maxbucket,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 highmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 lowmask)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; bucket_obuf;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; bucket_nbuf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; opage;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; npage;<br/></li>
<li>&nbsp; &nbsp; HashPageOpaque oopaque;<br/></li>
<li>&nbsp; &nbsp; HashPageOpaque nopaque;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber itup_offsets[MaxIndexTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itups[MaxIndexTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; all_tups_size = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; nitups = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bucket_obuf = obuf;<br/></li>
<li>&nbsp; &nbsp; opage = BufferGetPage(obuf);<br/></li>
<li>&nbsp; &nbsp; oopaque = HashPageGetOpaque(opage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bucket_nbuf = nbuf;<br/></li>
<li>&nbsp; &nbsp; npage = BufferGetPage(nbuf);<br/></li>
<li>&nbsp; &nbsp; nopaque = HashPageGetOpaque(npage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy the predicate locks from old bucket to new bucket. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L3129" title="storage/lmgr/predicate.c:3129">PredicateLockPageSplit</a>(rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(bucket_obuf),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(bucket_nbuf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Partition the tuples in the old bucket between the old bucket and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new bucket, advancing along the old bucket's overflow bucket chain and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * adding overflow pages to the new bucket as needed.&nbsp; Outer loop iterates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * once per page in old bucket.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber oblkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber ooffnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber omaxoffnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Scan each tuple in old page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; omaxoffnum = PageGetMaxOffsetNumber(opage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (ooffnum = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ooffnum &lt;= omaxoffnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ooffnum = OffsetNumberNext(ooffnum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; itemsz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bucket&nbsp; &nbsp; &nbsp; &nbsp; bucket;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> dead tuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdIsDead(PageGetItemId(opage, ooffnum)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before inserting a tuple, probe the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table containing TIDs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of tuples belonging to new bucket, if we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a match, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> that tuple, else fetch the item's <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key (conveniently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stored in the item) and determine which bucket it <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> belongs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(opage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageGetItemId(opage, ooffnum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (htab)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(htab, &amp;itup-&gt;t_tid, HASH_FIND, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bucket = <a href="hashutil.c.html#L125" title="access/hash/hashutil.c:125">_hash_hashkey2bucket</a>(<a href="hashutil.c.html#L291" title="access/hash/hashutil.c:291">_hash_get_indextuple_hashkey</a>(itup),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxbucket, highmask, lowmask);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bucket == nbucket)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; new_itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make a copy of index tuple as we have to scribble on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_itup = <a href="../common/indextuple.c.html#L547" title="access/common/indextuple.c:547">CopyIndexTuple</a>(itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mark the index tuple as moved by split, such tuples are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * skipped by scan if there is split in progress for a bucket.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_itup-&gt;t_info |= INDEX_MOVED_BY_SPLIT_MASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * insert the tuple into the new bucket.&nbsp; if it doesn't fit on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the current page in the new bucket, we must allocate a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overflow page and place the tuple on that page instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemsz = IndexTupleSize(new_itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemsz = MAXALIGN(itemsz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/page/bufpage.c.html#L934" title="storage/page/bufpage.c:934">PageGetFreeSpaceForMultipleTuples</a>(npage, nitups + <span class="Constant">1</span>) &lt; (all_tups_size + itemsz))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Change the shared buffer state in critical section,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error could make it unrecoverable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="hashinsert.c.html#L331" title="access/hash/hashinsert.c:331">_hash_pgaddmultitup</a>(rel, nbuf, itups, itup_offsets, nitups);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(nbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* log the split operation <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing the lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1474" title="access/hash/hashpage.c:1474">log_split_page</a>(rel, nbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* drop lock, but keep pin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(nbuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* be tidy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitups; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(itups[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitups = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_tups_size = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* chain to a new overflow page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbuf = <a href="hashovfl.c.html#L112" title="access/hash/hashovfl.c:112">_hash_addovflpage</a>(rel, metabuf, nbuf, (nbuf == bucket_nbuf));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npage = BufferGetPage(nbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nopaque = HashPageGetOpaque(npage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itups[nitups++] = new_itup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_tups_size += itemsz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the tuple stays on this page, so nothing to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(bucket == obucket);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oblkno = oopaque-&gt;hasho_nextblkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* retain the pin on the old primary bucket */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (obuf == bucket_obuf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(obuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L266" title="access/hash/hashpage.c:266">_hash_relbuf</a>(rel, obuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Exit loop if no more overflow pages in old bucket */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BlockNumberIsValid(oblkno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Change the shared buffer state in critical section, otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error could make it unrecoverable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="hashinsert.c.html#L331" title="access/hash/hashinsert.c:331">_hash_pgaddmultitup</a>(rel, nbuf, itups, itup_offsets, nitups);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(nbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* log the split operation <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing the lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1474" title="access/hash/hashpage.c:1474">log_split_page</a>(rel, nbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nbuf == bucket_nbuf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(nbuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L266" title="access/hash/hashpage.c:266">_hash_relbuf</a>(rel, nbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* be tidy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nitups; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(itups[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Else, advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> old page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; obuf = <a href="#L70" title="access/hash/hashpage.c:70">_hash_getbuf</a>(rel, oblkno, HASH_READ, LH_OVERFLOW_PAGE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opage = BufferGetPage(obuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oopaque = HashPageGetOpaque(opage);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're at the end of the old bucket chain, so we're done partitioning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the tuples.&nbsp; Mark the old and new buckets to indicate split is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * finished.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To avoid deadlocks due to locking order of buckets, first lock the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bucket and then the new bucket.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(bucket_obuf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; opage = BufferGetPage(bucket_obuf);<br/></li>
<li>&nbsp; &nbsp; oopaque = HashPageGetOpaque(opage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(bucket_nbuf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; npage = BufferGetPage(bucket_nbuf);<br/></li>
<li>&nbsp; &nbsp; nopaque = HashPageGetOpaque(npage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oopaque-&gt;hasho_flag &amp;= ~LH_BUCKET_BEING_SPLIT;<br/></li>
<li>&nbsp; &nbsp; nopaque-&gt;hasho_flag &amp;= ~LH_BUCKET_BEING_POPULATED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * After the split is finished, mark the old bucket to indicate that it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contains deletable tuples.&nbsp; We will clear split-<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> flag after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deleting such tuples either at the end of split or at the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> split<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from old bucket or at the time of <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oopaque-&gt;hasho_flag |= LH_BUCKET_NEEDS_SPLIT_CLEANUP;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> write the buffers, here we don't release the locks as caller is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * responsible to release locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(bucket_obuf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(bucket_nbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_hash_split_complete xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.old_bucket_flag = oopaque-&gt;hasho_flag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.new_bucket_flag = nopaque-&gt;hasho_flag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfHashSplitComplete);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, bucket_obuf, REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">1</span>, bucket_nbuf, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HASH_ID, XLOG_HASH_SPLIT_COMPLETE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(BufferGetPage(bucket_obuf), recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(BufferGetPage(bucket_nbuf), recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If possible, clean up the old bucket.&nbsp; We might not be able to do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if someone else has a pin on it, but if not then we can go ahead.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * isn't absolutely necessary, but it reduces bloat; if we don't do it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, VACUUM will do it eventually, but maybe not until new overflow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages have been allocated.&nbsp; Note that there's no need to clean up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new bucket.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/buffer/bufmgr.c.html#L5382" title="storage/buffer/bufmgr.c:5382">IsBufferCleanupOK</a>(bucket_obuf))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(bucket_nbuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="hash.c.html#L687" title="access/hash/hash.c:687">hashbucketcleanup</a>(rel, obucket, bucket_obuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(bucket_obuf), <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxbucket, highmask, lowmask, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(bucket_nbuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(bucket_obuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1356" title="access/hash/hashpage.c:1356">_hash_finish_split</a>() -- Finish the previously interrupted split operation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To complete the split operation, we form the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table of TIDs in new<br/></li>
<li></span><span class="Comment"> * bucket which is then used by split operation to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> tuples that are<br/></li>
<li></span><span class="Comment"> * already moved <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the split operation was previously interrupted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must hold a pin, but no lock, on the metapage and old bucket's<br/></li>
<li></span><span class="Comment"> * primary page buffer.&nbsp; The buffers are returned in the same state.&nbsp; (The<br/></li>
<li></span><span class="Comment"> * metapage is only touched if it becomes necessary to add or remove overflow<br/></li>
<li></span><span class="Comment"> * pages.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1356">&#x200c;</a></span><span class="linkable">_hash_finish_split</span>(Relation rel, Buffer metabuf, Buffer obuf, Bucket obucket,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 maxbucket, uint32 highmask, uint32 lowmask)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *tidhtab;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; bucket_nbuf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; nbuf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; npage;<br/></li>
<li>&nbsp; &nbsp; BlockNumber nblkno;<br/></li>
<li>&nbsp; &nbsp; BlockNumber bucket_nblkno;<br/></li>
<li>&nbsp; &nbsp; HashPageOpaque npageopaque;<br/></li>
<li>&nbsp; &nbsp; Bucket&nbsp; &nbsp; &nbsp; &nbsp; nbucket;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables used to track TIDs */<br/></li>
<li></span>&nbsp; &nbsp; hash_ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.hcxt = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tidhtab =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;bucket ctids&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">256</span>,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arbitrary initial size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bucket_nblkno = nblkno = <a href="hashutil.c.html#L461" title="access/hash/hashutil.c:461">_hash_get_newblock_from_oldbucket</a>(rel, obucket);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan the new bucket and build <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table of TIDs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber noffnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber nmaxoffnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbuf = <a href="#L70" title="access/hash/hashpage.c:70">_hash_getbuf</a>(rel, nblkno, HASH_READ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LH_BUCKET_PAGE | LH_OVERFLOW_PAGE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remember the primary bucket buffer to acquire <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock on it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nblkno == bucket_nblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bucket_nbuf = nbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; npage = BufferGetPage(nbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; npageopaque = HashPageGetOpaque(npage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Scan each tuple in new page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nmaxoffnum = PageGetMaxOffsetNumber(npage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (noffnum = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; noffnum &lt;= nmaxoffnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; noffnum = OffsetNumberNext(noffnum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch the item's TID and insert it in <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(npage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageGetItemId(npage, noffnum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(tidhtab, &amp;itup-&gt;t_tid, HASH_ENTER, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nblkno = npageopaque-&gt;hasho_nextblkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * release our write lock without modifying buffer and ensure to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * retain the pin on primary bucket.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nbuf == bucket_nbuf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(nbuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L266" title="access/hash/hashpage.c:266">_hash_relbuf</a>(rel, nbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Exit loop if no more overflow pages in new bucket */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BlockNumberIsValid(nblkno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Conditionally get the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock on old and new buckets to perform<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the split operation.&nbsp; If we don't get the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> locks, silently give<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up and <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> insertion on old bucket will try again to complete the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * split.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/buffer/bufmgr.c.html#L5326" title="storage/buffer/bufmgr.c:5326">ConditionalLockBufferForCleanup</a>(obuf))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(tidhtab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/buffer/bufmgr.c.html#L5326" title="storage/buffer/bufmgr.c:5326">ConditionalLockBufferForCleanup</a>(bucket_nbuf))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(obuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(tidhtab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; npage = BufferGetPage(bucket_nbuf);<br/></li>
<li>&nbsp; &nbsp; npageopaque = HashPageGetOpaque(npage);<br/></li>
<li>&nbsp; &nbsp; nbucket = npageopaque-&gt;hasho_bucket;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1073" title="access/hash/hashpage.c:1073">_hash_splitbucket</a>(rel, metabuf, obucket,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbucket, obuf, bucket_nbuf, tidhtab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxbucket, highmask, lowmask);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L277" title="access/hash/hashpage.c:277">_hash_dropbuf</a>(rel, bucket_nbuf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(tidhtab);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1474" title="access/hash/hashpage.c:1474">log_split_page</a>() -- Log the split operation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We log the split operation when the new page in new bucket gets full,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; so we log the entire page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 'buf' must be locked by the caller which is also responsible for unlocking<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1474">&#x200c;</a></span><span class="linkable">log_split_page</span>(Relation rel, Buffer buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buf, REGBUF_FORCE_IMAGE | REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HASH_ID, XLOG_HASH_SPLIT_PAGE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(BufferGetPage(buf), recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1501" title="access/hash/hashpage.c:1501">_hash_getcachedmetap</a>() -- Returns cached metapage data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If metabuf is not InvalidBuffer, caller must hold a pin, but no lock, on<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the metapage.&nbsp; If not set, we'll set it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning if we have to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; refresh the cache, and return with a pin but no lock on it; caller is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; responsible for releasing the pin.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We refresh the cache if it's not initialized yet or force_refresh is true.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HashMetaPage<br/></li>
<li><a id="L1501">&#x200c;</a><span class="linkable">_hash_getcachedmetap</span>(Relation rel, Buffer *metabuf, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> force_refresh)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(metabuf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (force_refresh || rel-&gt;rd_amcache == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cache = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's important that we don't set rd_amcache to an invalid value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Either <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a> or <a href="#L70" title="access/hash/hashpage.c:70">_hash_getbuf</a> could fail, so don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * install a pointer to the newly-allocated storage in the actual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relcache entry until both have succeeded.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_amcache == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache = <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(rel-&gt;rd_indexcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HashMetaPageData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Read the metapage. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(*metabuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*metabuf, BUFFER_LOCK_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *metabuf = <a href="#L70" title="access/hash/hashpage.c:70">_hash_getbuf</a>(rel, HASH_METAPAGE, HASH_READ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LH_META_PAGE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(*metabuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Populate the cache. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_amcache == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_amcache = cache;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(rel-&gt;rd_amcache, HashPageGetMeta(page),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HashMetaPageData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release metapage lock, but keep the pin. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*metabuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (HashMetaPage) rel-&gt;rd_amcache;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1559" title="access/hash/hashpage.c:1559">_hash_getbucketbuf_from_hashkey</a>() -- Get the bucket's buffer for the given<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hashkey.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Bucket pages do not move or get removed once they are allocated. This give<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; us an opportunity to use the previously saved metapage contents to reach<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the target bucket buffer, instead of reading from the metapage every time.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This saves one buffer access every time we want to reach the target bucket<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; buffer, which is very helpful savings in bufmgr traffic and contention.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The access type parameter (HASH_READ or HASH_WRITE) indicates whether the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; bucket buffer has to be locked for reading or writing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The out parameter cachedmetap is set with metapage contents used for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; hashkey to bucket buffer mapping. Some callers need this info to reach the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; old bucket in case of bucket split, see <a href="hashinsert.c.html#L38" title="access/hash/hashinsert.c:38">_hash_doinsert</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L1559">&#x200c;</a><span class="linkable">_hash_getbucketbuf_from_hashkey</span>(Relation rel, uint32 hashkey, <span class="Type">int</span> access,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HashMetaPage *cachedmetap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HashMetaPage metap;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; Bucket&nbsp; &nbsp; &nbsp; &nbsp; bucket;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; HashPageOpaque opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We read from target bucket buffer, hence locking is must. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(access == HASH_READ || access == HASH_WRITE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metap = <a href="#L1501" title="access/hash/hashpage.c:1501">_hash_getcachedmetap</a>(rel, &amp;metabuf, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(metap != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop until we get a lock on the correct target bucket.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compute the target bucket number, and convert to block number.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; bucket = <a href="hashutil.c.html#L125" title="access/hash/hashutil.c:125">_hash_hashkey2bucket</a>(hashkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metap-&gt;hashm_maxbucket,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metap-&gt;hashm_highmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metap-&gt;hashm_lowmask);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blkno = BUCKET_TO_BLKNO(metap, bucket);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch the primary bucket page for the bucket */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L70" title="access/hash/hashpage.c:70">_hash_getbuf</a>(rel, blkno, access, LH_BUCKET_PAGE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque = HashPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(opaque-&gt;hasho_bucket == bucket);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(opaque-&gt;hasho_prevblkno != InvalidBlockNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this bucket hasn't been split, we're done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opaque-&gt;hasho_prevblkno &lt;= metap-&gt;hashm_maxbucket)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Drop lock on this buffer, update cached metapage, and retry. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L266" title="access/hash/hashpage.c:266">_hash_relbuf</a>(rel, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metap = <a href="#L1501" title="access/hash/hashpage.c:1501">_hash_getcachedmetap</a>(rel, &amp;metabuf, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(metap != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(metabuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L277" title="access/hash/hashpage.c:277">_hash_dropbuf</a>(rel, metabuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cachedmetap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *cachedmetap = metap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
