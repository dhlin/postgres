<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/hash/hash.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/hash/hash.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L42">HashBuildState</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L367">hashbeginscan</a></li>
<li><a href="#L687">hashbucketcleanup</a></li>
<li><a href="#L115">hashbuild</a></li>
<li><a href="#L210">hashbuildCallback</a></li>
<li><a href="#L201">hashbuildempty</a></li>
<li><a href="#L462">hashbulkdelete</a></li>
<li><a href="#L431">hashendscan</a></li>
<li><a href="#L335">hashgetbitmap</a></li>
<li><a href="#L283">hashgettuple</a></li>
<li><a href="#L57">hashhandler</a></li>
<li><a href="#L251">hashinsert</a></li>
<li><a href="#L397">hashrescan</a></li>
<li><a href="#L648">hashvacuumcleanup</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Implementation of Margo Seltzer's Hashing package for postgres.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>/<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This file contains only the public interface routines.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/hash_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/progress.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/execnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/plancat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/index_selfuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Working state for <a href="#L115" title="access/hash/hash.c:115">hashbuild</a> and its callback */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <a href="hashsort.c.html#L39" title="access/hash/hashsort.c:39">HSpool</a>&nbsp; &nbsp; &nbsp;&nbsp; *spool;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL if not using spooling */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; indtuples;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* # tuples accepted into index */<br/></li>
<li></span>&nbsp; &nbsp; Relation&nbsp; &nbsp; heapRel;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* heap relation descriptor */<br/></li>
<li><a id="L42">&#x200c;</a></span>} <span class="linkable">HashBuildState</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L210" title="access/hash/hash.c:210">hashbuildCallback</a>(Relation index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer tid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tupleIsAlive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *state);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Hash handler function: return IndexAmRoutine with access method parameters<br/></li>
<li></span><span class="Comment"> * and callbacks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L57">&#x200c;</a><span class="linkable">hashhandler</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexAmRoutine *amroutine = makeNode(IndexAmRoutine);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amstrategies = HTMaxStrategyNumber;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsupport = HASHNProcs;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amoptsprocnum = HASHOPTIONS_PROC;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanorder = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanorderbyop = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanbackward = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanunique = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanmulticol = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amoptionalkey = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsearcharray = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsearchnulls = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amstorage = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amclusterable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ampredlocks = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanparallel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanbuildparallel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcaninclude = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amusemaintenanceworkmem = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsummarizing = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amparallelvacuumoptions =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VACUUM_OPTION_PARALLEL_BULKDEL;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amkeytype = INT4OID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambuild = <a href="#L115" title="access/hash/hash.c:115">hashbuild</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambuildempty = <a href="#L201" title="access/hash/hash.c:201">hashbuildempty</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;aminsert = <a href="#L251" title="access/hash/hash.c:251">hashinsert</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;aminsertcleanup = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambulkdelete = <a href="#L462" title="access/hash/hash.c:462">hashbulkdelete</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amvacuumcleanup = <a href="#L648" title="access/hash/hash.c:648">hashvacuumcleanup</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanreturn = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcostestimate = <a href="../../utils/adt/selfuncs.c.html#L7131" title="utils/adt/selfuncs.c:7131">hashcostestimate</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amoptions = <a href="hashutil.c.html#L275" title="access/hash/hashutil.c:275">hashoptions</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amproperty = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambuildphasename = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;<a href="../index/amapi.c.html#L114" title="access/index/amapi.c:114">amvalidate</a> = <a href="hashvalidate.c.html#L47" title="access/hash/hashvalidate.c:47">hashvalidate</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amadjustmembers = <a href="hashvalidate.c.html#L352" title="access/hash/hashvalidate.c:352">hashadjustmembers</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambeginscan = <a href="#L367" title="access/hash/hash.c:367">hashbeginscan</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amrescan = <a href="#L397" title="access/hash/hash.c:397">hashrescan</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amgettuple = <a href="#L283" title="access/hash/hash.c:283">hashgettuple</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amgetbitmap = <a href="#L335" title="access/hash/hash.c:335">hashgetbitmap</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amendscan = <a href="#L431" title="access/hash/hash.c:431">hashendscan</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ammarkpos = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amrestrpos = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amestimateparallelscan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;aminitparallelscan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amparallelrescan = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(amroutine);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L115" title="access/hash/hash.c:115">hashbuild</a>() -- build a new <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexBuildResult *<br/></li>
<li><a id="L115">&#x200c;</a><span class="linkable">hashbuild</span>(Relation heap, Relation index, IndexInfo *indexInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexBuildResult *result;<br/></li>
<li>&nbsp; &nbsp; BlockNumber relpages;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; reltuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; allvisfrac;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; num_buckets;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; sort_threshold;<br/></li>
<li>&nbsp; &nbsp; <a href="#L42" title="access/hash/hash.c:42">HashBuildState</a> buildstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We expect to be called exactly once for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index relation. If that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not the case, big trouble's what we have.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationGetNumberOfBlocks(index) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already contains data&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(index));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Estimate the number of rows currently present in the table */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../optimizer/util/plancat.c.html#L1041" title="optimizer/util/plancat.c:1041">estimate_rel_size</a>(heap, <span class="Constant">NULL</span>, &amp;relpages, &amp;reltuples, &amp;allvisfrac);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> index metadata page and initial buckets */<br/></li>
<li></span>&nbsp; &nbsp; num_buckets = <a href="hashpage.c.html#L327" title="access/hash/hashpage.c:327">_hash_init</a>(index, reltuples, MAIN_FORKNUM);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we just insert the tuples into the index in scan order, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (assuming their <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> codes are pretty random) there will be no locality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of access to the index, and if the index is bigger than available RAM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then we'll thrash horribly.&nbsp; To prevent that scenario, we can sort the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples by (expected) bucket number.&nbsp; However, such a sort is useless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overhead when the index does fit in RAM.&nbsp; We choose to sort if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initial index size exceeds <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a>, or the number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffers usable for the index, whichever is less.&nbsp; (Limiting by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of buffers should reduce thrashing between PG buffers and kernel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffers, which seems useful even if no physical I/O results.&nbsp; Limiting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> is useful to allow easy testing of the sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * code path, and may be useful to DBAs as an additional control knob.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: this test will need adjustment if a bucket is ever different from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one page.&nbsp; Also, &quot;initial index size&quot; accounting does not include the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * metapage, nor the first bitmap page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sort_threshold = (<a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> * <span class="Constant">1024L</span>) / BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;rd_rel-&gt;relpersistence != RELPERSISTENCE_TEMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sort_threshold = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(sort_threshold, <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sort_threshold = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(sort_threshold, <a href="../../storage/buffer/localbuf.c.html#L42" title="storage/buffer/localbuf.c:42">NLocBuffer</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (num_buckets &gt;= (uint32) sort_threshold)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buildstate.spool = <a href="hashsort.c.html#L60" title="access/hash/hashsort.c:60">_h_spoolinit</a>(heap, index, num_buckets);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buildstate.spool = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prepare to build the index */<br/></li>
<li></span>&nbsp; &nbsp; buildstate.indtuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; buildstate.heapRel = heap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do the heap scan */<br/></li>
<li></span>&nbsp; &nbsp; reltuples = table_index_build_scan(heap, index, indexInfo, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L210" title="access/hash/hash.c:210">hashbuildCallback</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) &amp;buildstate, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_CREATEIDX_TUPLES_TOTAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buildstate.indtuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (buildstate.spool)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sort the tuples and insert them into the index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="hashsort.c.html#L120" title="access/hash/hashsort.c:120">_h_indexbuild</a>(buildstate.spool, buildstate.heapRel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="hashsort.c.html#L99" title="access/hash/hashsort.c:99">_h_spooldestroy</a>(buildstate.spool);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return statistics<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = (IndexBuildResult *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexBuildResult));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;heap_tuples = reltuples;<br/></li>
<li>&nbsp; &nbsp; result-&gt;index_tuples = buildstate.indtuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L201" title="access/hash/hash.c:201">hashbuildempty</a>() -- build an empty <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> index in the initialization fork<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L201">&#x200c;</a></span><span class="linkable">hashbuildempty</span>(Relation index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="hashpage.c.html#L327" title="access/hash/hashpage.c:327">_hash_init</a>(index, <span class="Constant">0</span>, INIT_FORKNUM);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Per-tuple callback for table_index_build_scan<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L210">&#x200c;</a></span><span class="linkable">hashbuildCallback</span>(Relation index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer tid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tupleIsAlive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L42" title="access/hash/hash.c:42">HashBuildState</a> *buildstate = (<a href="#L42" title="access/hash/hash.c:42">HashBuildState</a> *) state;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; index_values[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; index_isnull[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* convert data to a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key; on failure, do not insert anything */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="hashutil.c.html#L318" title="access/hash/hashutil.c:318">_hash_convert_tuple</a>(index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index_values, index_isnull))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Either spool the tuple for sorting, or just put it into the index */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (buildstate-&gt;spool)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="hashsort.c.html#L109" title="access/hash/hashsort.c:109">_h_spool</a>(buildstate-&gt;spool, tid, index_values, index_isnull);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* form an index tuple and point it at the heap tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itup = <a href="../common/indextuple.c.html#L44" title="access/common/indextuple.c:44">index_form_tuple</a>(RelationGetDescr(index),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_values, index_isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup-&gt;t_tid = *tid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="hashinsert.c.html#L38" title="access/hash/hashinsert.c:38">_hash_doinsert</a>(index, itup, buildstate-&gt;heapRel, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(itup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buildstate-&gt;indtuples += <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L251" title="access/hash/hash.c:251">hashinsert</a>() -- insert an index tuple into a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Hash on the heap tuple's key, form an index tuple with <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Find the appropriate location for the new tuple, and put it there.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L251">&#x200c;</a></span><span class="linkable">hashinsert</span>(Relation rel, Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointer ht_ctid, Relation heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexUniqueCheck checkUnique,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> indexUnchanged,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexInfo *indexInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; index_values[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; index_isnull[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* convert data to a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key; on failure, do not insert anything */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="hashutil.c.html#L318" title="access/hash/hashutil.c:318">_hash_convert_tuple</a>(rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index_values, index_isnull))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* form an index tuple and point it at the heap tuple */<br/></li>
<li></span>&nbsp; &nbsp; itup = <a href="../common/indextuple.c.html#L44" title="access/common/indextuple.c:44">index_form_tuple</a>(RelationGetDescr(rel), index_values, index_isnull);<br/></li>
<li>&nbsp; &nbsp; itup-&gt;t_tid = *ht_ctid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="hashinsert.c.html#L38" title="access/hash/hashinsert.c:38">_hash_doinsert</a>(rel, itup, heapRel, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L283" title="access/hash/hash.c:283">hashgettuple</a>() -- Get the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple in the scan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L283">&#x200c;</a></span><span class="linkable">hashgettuple</span>(IndexScanDesc scan, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HashScanOpaque so = (HashScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Hash indexes are always lossy since we store only the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> code */<br/></li>
<li></span>&nbsp; &nbsp; scan-&gt;xs_recheck = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we've already initialized this scan, we can just advance it in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appropriate direction.&nbsp; If we haven't done so yet, we call a routine to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get the first item in the scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!HashScanPosIsValid(so-&gt;currPos))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="hashsearch.c.html#L288" title="access/hash/hashsearch.c:288">_hash_first</a>(scan, dir);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check to see if we should kill the previously-fetched tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;kill_prior_tuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Yes, so remember it for later. (We'll deal with all such tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at once right after leaving the index page or at end of scan.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In case if caller reverses the indexscan direction it is quite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible that the same item might get entered multiple times.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * But, we don't detect that; instead, we just forget <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> excess<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;killedItems == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;killedItems = (<span class="Type">int</span> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(MaxIndexTuplesPerPage * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;numKilled &lt; MaxIndexTuplesPerPage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;killedItems[so-&gt;numKilled++] = so-&gt;currPos.itemIndex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now continue the scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="hashsearch.c.html#L48" title="access/hash/hashsearch.c:48">_hash_next</a>(scan, dir);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L335" title="access/hash/hash.c:335">hashgetbitmap</a>() -- get all tuples at once<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>int64<br/></li>
<li><a id="L335">&#x200c;</a><span class="linkable">hashgetbitmap</span>(IndexScanDesc scan, <a href="../../nodes/tidbitmap.c.html#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HashScanOpaque so = (HashScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; ntids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; HashScanPosItem *currItem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="hashsearch.c.html#L288" title="access/hash/hashsearch.c:288">_hash_first</a>(scan, ForwardScanDirection);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (res)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; currItem = &amp;so-&gt;currPos.items[so-&gt;currPos.itemIndex];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="hashsearch.c.html#L288" title="access/hash/hashsearch.c:288">_hash_first</a> and <a href="hashsearch.c.html#L48" title="access/hash/hashsearch.c:48">_hash_next</a> handle eliminate dead index entries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whenever scan-&gt;ignore_killed_tuples is true.&nbsp; Therefore, there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nothing to do here except add the results to the <a href="../../nodes/tidbitmap.c.html#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/tidbitmap.c.html#L377" title="nodes/tidbitmap.c:377">tbm_add_tuples</a>(tbm, &amp;(currItem-&gt;heapTid), <span class="Constant">1</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ntids++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="hashsearch.c.html#L48" title="access/hash/hashsearch.c:48">_hash_next</a>(scan, ForwardScanDirection);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ntids;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L367" title="access/hash/hash.c:367">hashbeginscan</a>() -- start a scan on a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> index<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexScanDesc<br/></li>
<li><a id="L367">&#x200c;</a><span class="linkable">hashbeginscan</span>(Relation rel, <span class="Type">int</span> nkeys, <span class="Type">int</span> norderbys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; HashScanOpaque so;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no order by operators allowed */<br/></li>
<li></span>&nbsp; &nbsp; Assert(norderbys == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan = <a href="../index/genam.c.html#L78" title="access/index/genam.c:78">RelationGetIndexScan</a>(rel, nkeys, norderbys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; so = (HashScanOpaque) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HashScanOpaqueData));<br/></li>
<li>&nbsp; &nbsp; HashScanPosInvalidate(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; so-&gt;hashso_bucket_buf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; so-&gt;hashso_split_bucket_buf = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; so-&gt;hashso_buc_populated = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; so-&gt;hashso_buc_split = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; so-&gt;killedItems = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; so-&gt;numKilled = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan-&gt;opaque = so;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L397" title="access/hash/hash.c:397">hashrescan</a>() -- rescan an index relation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L397">&#x200c;</a></span><span class="linkable">hashrescan</span>(IndexScanDesc scan, ScanKey scankey, <span class="Type">int</span> nscankeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanKey orderbys, <span class="Type">int</span> norderbys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HashScanOpaque so = (HashScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = scan-&gt;indexRelation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HashScanPosIsValid(so-&gt;currPos))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Before leaving current page, deal with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> killed items */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;numKilled &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="hashutil.c.html#L536" title="access/hash/hashutil.c:536">_hash_kill_items</a>(scan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="hashpage.c.html#L289" title="access/hash/hashpage.c:289">_hash_dropscanbuf</a>(rel, so);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set position invalid (this will cause <a href="hashsearch.c.html#L288" title="access/hash/hashsearch.c:288">_hash_first</a> call) */<br/></li>
<li></span>&nbsp; &nbsp; HashScanPosInvalidate(so-&gt;currPos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update scan key, if a new one is given */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scankey &amp;&amp; scan-&gt;numberOfKeys &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memmove(scan-&gt;keyData,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scankey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;numberOfKeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKeyData));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; so-&gt;hashso_buc_populated = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; so-&gt;hashso_buc_split = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L431" title="access/hash/hash.c:431">hashendscan</a>() -- close down a scan<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L431">&#x200c;</a></span><span class="linkable">hashendscan</span>(IndexScanDesc scan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HashScanOpaque so = (HashScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = scan-&gt;indexRelation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HashScanPosIsValid(so-&gt;currPos))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Before leaving current page, deal with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> killed items */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;numKilled &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="hashutil.c.html#L536" title="access/hash/hashutil.c:536">_hash_kill_items</a>(scan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="hashpage.c.html#L289" title="access/hash/hashpage.c:289">_hash_dropscanbuf</a>(rel, so);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;killedItems != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(so-&gt;killedItems);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(so);<br/></li>
<li>&nbsp; &nbsp; scan-&gt;opaque = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Bulk deletion of all index entries pointing to a set of heap tuples.<br/></li>
<li></span><span class="Comment"> * The set of target tuples is specified via a callback routine that tells<br/></li>
<li></span><span class="Comment"> * whether <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> given heap tuple (identified by ItemPointer) is being deleted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function also deletes the tuples that are moved by split to other<br/></li>
<li></span><span class="Comment"> * bucket.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Result: a <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d struct containing statistical info for VACUUM displays.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexBulkDeleteResult *<br/></li>
<li><a id="L462">&#x200c;</a><span class="linkable">hashbulkdelete</span>(IndexVacuumInfo *info, IndexBulkDeleteResult *stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexBulkDeleteCallback callback, <span class="Type">void</span> *callback_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = info-&gt;index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; tuples_removed;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; num_index_tuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; orig_ntuples;<br/></li>
<li>&nbsp; &nbsp; Bucket&nbsp; &nbsp; &nbsp; &nbsp; orig_maxbucket;<br/></li>
<li>&nbsp; &nbsp; Bucket&nbsp; &nbsp; &nbsp; &nbsp; cur_maxbucket;<br/></li>
<li>&nbsp; &nbsp; Bucket&nbsp; &nbsp; &nbsp; &nbsp; cur_bucket;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; HashMetaPage metap;<br/></li>
<li>&nbsp; &nbsp; HashMetaPage cachedmetap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuples_removed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; num_index_tuples = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need a copy of the metapage so that we can use its hashm_spares[]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to compute bucket page addresses, but a cached copy should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * good enough.&nbsp; (If not, we'll detect that further down and refresh the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cache as necessary.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cachedmetap = <a href="hashpage.c.html#L1501" title="access/hash/hashpage.c:1501">_hash_getcachedmetap</a>(rel, &amp;metabuf, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(cachedmetap != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; orig_maxbucket = cachedmetap-&gt;hashm_maxbucket;<br/></li>
<li>&nbsp; &nbsp; orig_ntuples = cachedmetap-&gt;hashm_ntuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan the buckets that we know exist */<br/></li>
<li></span>&nbsp; &nbsp; cur_bucket = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; cur_maxbucket = orig_maxbucket;<br/></li>
<li><br/></li>
<li><span class="Statement">loop_top</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (cur_bucket &lt;= cur_maxbucket)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber bucket_blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; bucket_buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HashPageOpaque bucket_opaque;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; split_cleanup = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get address of bucket's start page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; bucket_blkno = BUCKET_TO_BLKNO(cachedmetap, cur_bucket);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blkno = bucket_blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to acquire a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock on the primary bucket page to out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wait concurrent scans <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> deleting the dead tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(rel, MAIN_FORKNUM, blkno, RBM_NORMAL, info-&gt;strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5165" title="storage/buffer/bufmgr.c:5165">LockBufferForCleanup</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="hashutil.c.html#L210" title="access/hash/hashutil.c:210">_hash_checkpage</a>(rel, buf, LH_BUCKET_PAGE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bucket_opaque = HashPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the bucket contains tuples that are moved by split, then we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to delete such tuples.&nbsp; We can't delete such tuples if the split<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operation on bucket is not finished as those are needed by scans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!H_BUCKET_BEING_SPLIT(bucket_opaque) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; H_NEEDS_SPLIT_CLEANUP(bucket_opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; split_cleanup = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This bucket might have been split since we last held a lock on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the metapage.&nbsp; If so, hashm_maxbucket, hashm_highmask and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hashm_lowmask might be old enough to cause us to fail to remove<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples left behind by the most recent split.&nbsp; To prevent that,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that the primary page of the target bucket has been locked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (and thus can't be further split), check whether we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * update our cached metapage data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(bucket_opaque-&gt;hasho_prevblkno != InvalidBlockNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bucket_opaque-&gt;hasho_prevblkno &gt; cachedmetap-&gt;hashm_maxbucket)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cachedmetap = <a href="hashpage.c.html#L1501" title="access/hash/hashpage.c:1501">_hash_getcachedmetap</a>(rel, &amp;metabuf, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cachedmetap != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bucket_buf = buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L687" title="access/hash/hash.c:687">hashbucketcleanup</a>(rel, cur_bucket, bucket_buf, blkno, info-&gt;strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cachedmetap-&gt;hashm_maxbucket,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cachedmetap-&gt;hashm_highmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cachedmetap-&gt;hashm_lowmask, &amp;tuples_removed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;num_index_tuples, split_cleanup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; callback, callback_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="hashpage.c.html#L277" title="access/hash/hashpage.c:277">_hash_dropbuf</a>(rel, bucket_buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> bucket */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cur_bucket++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsInvalid(metabuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metabuf = <a href="hashpage.c.html#L70" title="access/hash/hashpage.c:70">_hash_getbuf</a>(rel, HASH_METAPAGE, HASH_NOLOCK, LH_META_PAGE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write-lock metapage and check for split since we started */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; metap = HashPageGetMeta(BufferGetPage(metabuf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cur_maxbucket != metap-&gt;hashm_maxbucket)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There's been a split, so process the additional bucket(s) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cachedmetap = <a href="hashpage.c.html#L1501" title="access/hash/hashpage.c:1501">_hash_getcachedmetap</a>(rel, &amp;metabuf, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(cachedmetap != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cur_maxbucket = cachedmetap-&gt;hashm_maxbucket;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> loop_top;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Okay, we're really done.&nbsp; Update tuple count in metapage. */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (orig_maxbucket == metap-&gt;hashm_maxbucket &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; orig_ntuples == metap-&gt;hashm_ntuples)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No one has split or inserted anything since start of scan, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * believe our count as gospel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; metap-&gt;hashm_ntuples = num_index_tuples;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, our count is untrustworthy since we may have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * double-scanned tuples in split buckets.&nbsp; Proceed by dead-reckoning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Note: we still return estimated_count = false, because using this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * count is better than not updating reltuples at all.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (metap-&gt;hashm_ntuples &gt; tuples_removed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metap-&gt;hashm_ntuples -= tuples_removed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metap-&gt;hashm_ntuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num_index_tuples = metap-&gt;hashm_ntuples;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(metabuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_hash_update_meta_page xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.ntuples = metap-&gt;hashm_ntuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfHashUpdateMetaPage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, metabuf, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HASH_ID, XLOG_HASH_UPDATE_META_PAGE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(BufferGetPage(metabuf), recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="hashpage.c.html#L266" title="access/hash/hashpage.c:266">_hash_relbuf</a>(rel, metabuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* return statistics */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stats == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = (IndexBulkDeleteResult *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexBulkDeleteResult));<br/></li>
<li>&nbsp; &nbsp; stats-&gt;estimated_count = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;num_index_tuples = num_index_tuples;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;tuples_removed += tuples_removed;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L648" title="access/hash/hash.c:648">hashvacuumcleanup</a> will fill in num_pages */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stats;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Post-VACUUM <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Result: a <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d struct containing statistical info for VACUUM displays.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexBulkDeleteResult *<br/></li>
<li><a id="L648">&#x200c;</a><span class="linkable">hashvacuumcleanup</span>(IndexVacuumInfo *info, IndexBulkDeleteResult *stats)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = info-&gt;index;<br/></li>
<li>&nbsp; &nbsp; BlockNumber num_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If <a href="#L462" title="access/hash/hash.c:462">hashbulkdelete</a> wasn't called, return NULL signifying no change */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Note: this covers the analyze_only case too */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stats == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update statistics */<br/></li>
<li></span>&nbsp; &nbsp; num_pages = RelationGetNumberOfBlocks(rel);<br/></li>
<li>&nbsp; &nbsp; stats-&gt;num_pages = num_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stats;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function to perform deletion of index entries from a bucket.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function expects that the caller has acquired a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock on the<br/></li>
<li></span><span class="Comment"> * primary bucket page, and will return with a write lock again held on the<br/></li>
<li></span><span class="Comment"> * primary bucket page.&nbsp; The lock won't necessarily be held continuously,<br/></li>
<li></span><span class="Comment"> * though, because we'll release it when visiting overflow pages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There can't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> concurrent scans in progress when we first enter this<br/></li>
<li></span><span class="Comment"> * function because of the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock we hold on the primary bucket page,<br/></li>
<li></span><span class="Comment"> * but as soon as we release that lock, there might be.&nbsp; If those scans got<br/></li>
<li></span><span class="Comment"> * ahead of our <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> scan, they might see a tuple <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we kill it and<br/></li>
<li></span><span class="Comment"> * wake up only after VACUUM has completed and the TID has been recycled for<br/></li>
<li></span><span class="Comment"> * an unrelated tuple.&nbsp; To avoid that calamity, we prevent scans from passing<br/></li>
<li></span><span class="Comment"> * our <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> scan by locking the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page in the bucket chain <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * releasing the lock on the previous page.&nbsp; (This type of lock chaining is not<br/></li>
<li></span><span class="Comment"> * ideal, so we might want to look for a better solution at some point.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We need to retain a pin on the primary bucket to ensure that no concurrent<br/></li>
<li></span><span class="Comment"> * split can start.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L687">&#x200c;</a></span><span class="linkable">hashbucketcleanup</span>(Relation rel, Bucket cur_bucket, Buffer bucket_buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber bucket_blkno, BufferAccessStrategy bstrategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 maxbucket, uint32 highmask, uint32 lowmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> *tuples_removed, <span class="Type">double</span> *num_index_tuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> split_cleanup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexBulkDeleteCallback callback, <span class="Type">void</span> *callback_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; Bucket&nbsp; &nbsp; &nbsp; &nbsp; new_bucket <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a> = InvalidBucket;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; bucket_dirty = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; blkno = bucket_blkno;<br/></li>
<li>&nbsp; &nbsp; buf = bucket_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (split_cleanup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_bucket = <a href="hashutil.c.html#L494" title="access/hash/hashutil.c:494">_hash_get_newbucket_from_oldbucket</a>(rel, cur_bucket,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowmask, maxbucket);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan each page in bucket */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HashPageOpaque opaque;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber maxoffno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; next_buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber deletable[MaxOffsetNumber];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndeletable = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; retain_pin = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; clear_dead_marking = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque = HashPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Scan each tuple in page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; maxoffno = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (offno = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offno &lt;= maxoffno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offno = OffsetNumberNext(offno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer htup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Bucket&nbsp; &nbsp; &nbsp; &nbsp; bucket;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; kill_tuple = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageGetItemId(page, offno));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; htup = &amp;(itup-&gt;t_tid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To remove the dead tuples, we strictly want to rely on results<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of callback function.&nbsp; refer <a href="../nbtree/nbtree.c.html#L1060" title="access/nbtree/nbtree.c:1060">btvacuumpage</a> for detailed reason.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (callback &amp;&amp; callback(htup, callback_state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kill_tuple = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tuples_removed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tuples_removed += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (split_cleanup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* delete the tuples that are moved by split. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bucket = <a href="hashutil.c.html#L125" title="access/hash/hashutil.c:125">_hash_hashkey2bucket</a>(<a href="hashutil.c.html#L291" title="access/hash/hashutil.c:291">_hash_get_indextuple_hashkey</a>(itup),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxbucket,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; highmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowmask);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark the item for deletion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bucket != cur_bucket)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We expect tuples to either belong to current bucket or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new_bucket.&nbsp; This is ensured because we don't allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * further splits from bucket that contains garbage. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comments in <a href="hashpage.c.html#L614" title="access/hash/hashpage.c:614">_hash_expandtable</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(bucket == new_bucket);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kill_tuple = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (kill_tuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark the item for deletion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deletable[ndeletable++] = offno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we're keeping it, so count it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (num_index_tuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *num_index_tuples += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* retain the pin on primary bucket page till end of bucket scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno == bucket_blkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retain_pin = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retain_pin = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blkno = opaque-&gt;hasho_nextblkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Apply deletions, advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page and write page if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndeletable &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No ereport(ERROR) until changes are logged */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1161" title="storage/page/bufpage.c:1161">PageIndexMultiDelete</a>(page, deletable, ndeletable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bucket_dirty = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Let us mark the page as clean if <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> removes the DEAD tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from an index page. We do this by clearing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LH_PAGE_HAS_DEAD_TUPLES flag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tuples_removed &amp;&amp; *tuples_removed &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; H_HAS_DEAD_TUPLES(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;hasho_flag &amp;= ~LH_PAGE_HAS_DEAD_TUPLES;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clear_dead_marking = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_hash_delete xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.clear_dead_marking = clear_dead_marking;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.is_primary_bucket_page = (buf == bucket_buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfHashDelete);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bucket buffer was not changed, but still needs to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * registered to ensure that we can acquire a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it during replay.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!xlrec.is_primary_bucket_page)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags = REGBUF_STANDARD | REGBUF_NO_IMAGE | REGBUF_NO_CHANGE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, bucket_buf, flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">1</span>, buf, REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">1</span>, (<span class="Type">char</span> *) deletable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndeletable * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HASH_ID, XLOG_HASH_DELETE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(BufferGetPage(buf), recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* bail out if there are no more pages to scan. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BlockNumberIsValid(blkno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; next_buf = <a href="hashpage.c.html#L239" title="access/hash/hashpage.c:239">_hash_getbuf_with_strategy</a>(rel, blkno, HASH_WRITE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LH_OVERFLOW_PAGE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bstrategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * release the lock on previous page after acquiring the lock on <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retain_pin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="hashpage.c.html#L266" title="access/hash/hashpage.c:266">_hash_relbuf</a>(rel, buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = next_buf;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock the bucket page to clear the garbage flag and squeeze the bucket.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the current buffer is same as bucket buffer, then we already have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock on bucket page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (buf != bucket_buf)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="hashpage.c.html#L266" title="access/hash/hashpage.c:266">_hash_relbuf</a>(rel, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(bucket_buf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clear the garbage flag from bucket after deleting the tuples that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * moved by split.&nbsp; We purposefully clear the flag <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> squeeze bucket,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so that after restart, <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> shouldn't again try to delete the moved<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by split tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (split_cleanup)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HashPageOpaque bucket_opaque;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(bucket_buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bucket_opaque = HashPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No ereport(ERROR) until changes are logged */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bucket_opaque-&gt;hasho_flag &amp;= ~LH_BUCKET_NEEDS_SPLIT_CLEANUP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(bucket_buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, bucket_buf, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HASH_ID, XLOG_HASH_SPLIT_CLEANUP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have deleted anything, try to <a href="../../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a> free space.&nbsp; For squeezing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the bucket, we must have a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock, else it can impact the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ordering of tuples for a scan that has started <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bucket_dirty &amp;&amp; <a href="../../storage/buffer/bufmgr.c.html#L5382" title="storage/buffer/bufmgr.c:5382">IsBufferCleanupOK</a>(bucket_buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="hashovfl.c.html#L842" title="access/hash/hashovfl.c:842">_hash_squeezebucket</a>(rel, cur_bucket, bucket_blkno, bucket_buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bstrategy);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(bucket_buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
