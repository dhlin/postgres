<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/hash/hashutil.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/hash/hashutil.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L350">_hash_binsearch</a></li>
<li><a href="#L388">_hash_binsearch_last</a></li>
<li><a href="#L210">_hash_checkpage</a></li>
<li><a href="#L31">_hash_checkqual</a></li>
<li><a href="#L318">_hash_convert_tuple</a></li>
<li><a href="#L82">_hash_datum2hashkey</a></li>
<li><a href="#L102">_hash_datum2hashkey_type</a></li>
<li><a href="#L291">_hash_get_indextuple_hashkey</a></li>
<li><a href="#L461">_hash_get_newblock_from_oldbucket</a></li>
<li><a href="#L494">_hash_get_newbucket_from_oldbucket</a></li>
<li><a href="#L422">_hash_get_oldblock_from_newbucket</a></li>
<li><a href="#L174">_hash_get_totalbuckets</a></li>
<li><a href="#L125">_hash_hashkey2bucket</a></li>
<li><a href="#L536">_hash_kill_items</a></li>
<li><a href="#L142">_hash_spareindex</a></li>
<li><a href="#L275">hashoptions</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L24">CALC_NEW_BUCKET</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * hashutil.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Utility code for Postgres <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> implementation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>/hashutil.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/reloptions.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L24">&#x200c;</a><span class="PreProc">#define <span class="linkable">CALC_NEW_BUCKET</span>(old_bucket, lowmask) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_bucket | (lowmask + </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L31" title="access/hash/hashutil.c:31">_hash_checkqual</a> -- does the index tuple satisfy the scan conditions?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L31">&#x200c;</a></span><span class="linkable">_hash_checkqual</span>(IndexScanDesc scan, IndexTuple itup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently, we can't check <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the scan conditions since we do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have the original index entry value to supply to the sk_func. Always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return true; we expect that <a href="hash.c.html#L283" title="access/hash/hash.c:283">hashgettuple</a> already set the recheck flag<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to make the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> indexscan code do it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc = RelationGetDescr(scan-&gt;indexRelation);<br/></li>
<li>&nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; key = scan-&gt;keyData;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanKeySize = scan-&gt;numberOfKeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (scanKeySize &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; test;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum = index_getattr(itup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;sk_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isNull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* assume sk_func is strict */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;sk_flags &amp; SK_ISNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; test = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;key-&gt;sk_func, key-&gt;sk_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; datum, key-&gt;sk_argument);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!DatumGetBool(test))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scanKeySize--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L82" title="access/hash/hashutil.c:82">_hash_datum2hashkey</a> -- given a Datum, call the index's <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The Datum is assumed to be of the index's column type, so we can use the<br/></li>
<li></span><span class="Comment"> * &quot;primary&quot; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function that's tracked for us by the generic index code.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint32<br/></li>
<li><a id="L82">&#x200c;</a><span class="linkable">_hash_datum2hashkey</span>(Relation rel, Datum key)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *procinfo;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> assumes index has only one attribute */<br/></li>
<li></span>&nbsp; &nbsp; procinfo = <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(rel, <span class="Constant">1</span>, HASHSTANDARD_PROC);<br/></li>
<li>&nbsp; &nbsp; collation = rel-&gt;rd_indcollation[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetUInt32(<a href="../../utils/fmgr/fmgr.c.html#L1129" title="utils/fmgr/fmgr.c:1129">FunctionCall1Coll</a>(procinfo, collation, key));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L102" title="access/hash/hashutil.c:102">_hash_datum2hashkey_type</a> -- given a Datum of a specified type,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> it in a fashion compatible with this index<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is much more expensive than <a href="#L82" title="access/hash/hashutil.c:82">_hash_datum2hashkey</a>, so use it only in<br/></li>
<li></span><span class="Comment"> * cross-type situations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint32<br/></li>
<li><a id="L102">&#x200c;</a><span class="linkable">_hash_datum2hashkey_type</span>(Relation rel, Datum key, Oid keytype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RegProcedure hash_proc;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> assumes index has only one attribute */<br/></li>
<li></span>&nbsp; &nbsp; hash_proc = <a href="../../utils/cache/lsyscache.c.html#L796" title="utils/cache/lsyscache.c:796">get_opfamily_proc</a>(rel-&gt;rd_opfamily[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keytype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keytype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASHSTANDARD_PROC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!RegProcedureIsValid(hash_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing support function </span><span class="Special">%d</span><span class="Constant">(</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) for index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASHSTANDARD_PROC, keytype, keytype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel));<br/></li>
<li>&nbsp; &nbsp; collation = rel-&gt;rd_indcollation[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DatumGetUInt32(<a href="../../utils/fmgr/fmgr.c.html#L1411" title="utils/fmgr/fmgr.c:1411">OidFunctionCall1Coll</a>(hash_proc, collation, key));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L125" title="access/hash/hashutil.c:125">_hash_hashkey2bucket</a> -- determine which bucket the hashkey <a href="../../utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> to.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Bucket<br/></li>
<li><a id="L125">&#x200c;</a><span class="linkable">_hash_hashkey2bucket</span>(uint32 hashkey, uint32 maxbucket,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 highmask, uint32 lowmask)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bucket&nbsp; &nbsp; &nbsp; &nbsp; bucket;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bucket = hashkey &amp; highmask;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bucket &gt; maxbucket)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bucket = bucket &amp; lowmask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> bucket;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L142" title="access/hash/hashutil.c:142">_hash_spareindex</a> -- returns spare index / global splitpoint phase of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bucket<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint32<br/></li>
<li><a id="L142">&#x200c;</a><span class="linkable">_hash_spareindex</span>(uint32 num_bucket)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; splitpoint_group;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; splitpoint_phases;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; splitpoint_group = pg_ceil_log2_32(num_bucket);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (splitpoint_group &lt; HASH_SPLITPOINT_GROUPS_WITH_ONE_PHASE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> splitpoint_group;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* account for single-phase groups */<br/></li>
<li></span>&nbsp; &nbsp; splitpoint_phases = HASH_SPLITPOINT_GROUPS_WITH_ONE_PHASE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* account for multi-phase groups <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> splitpoint_group */<br/></li>
<li></span>&nbsp; &nbsp; splitpoint_phases +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((splitpoint_group - HASH_SPLITPOINT_GROUPS_WITH_ONE_PHASE) &lt;&lt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_SPLITPOINT_PHASE_BITS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* account for phases within current group */<br/></li>
<li></span>&nbsp; &nbsp; splitpoint_phases +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (((num_bucket - <span class="Constant">1</span>) &gt;&gt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (splitpoint_group - (HASH_SPLITPOINT_PHASE_BITS + <span class="Constant">1</span>))) &amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_SPLITPOINT_PHASE_MASK);&nbsp; &nbsp; <span class="Comment">/* to 0-based value. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> splitpoint_phases;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L174" title="access/hash/hashutil.c:174">_hash_get_totalbuckets</a> -- returns total number of buckets allocated till<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the given splitpoint phase.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint32<br/></li>
<li><a id="L174">&#x200c;</a><span class="linkable">_hash_get_totalbuckets</span>(uint32 splitpoint_phase)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; splitpoint_group;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; total_buckets;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; phases_within_splitpoint_group;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (splitpoint_phase &lt; HASH_SPLITPOINT_GROUPS_WITH_ONE_PHASE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Constant">1</span> &lt;&lt; splitpoint_phase);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* get splitpoint's group */<br/></li>
<li></span>&nbsp; &nbsp; splitpoint_group = HASH_SPLITPOINT_GROUPS_WITH_ONE_PHASE;<br/></li>
<li>&nbsp; &nbsp; splitpoint_group +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((splitpoint_phase - HASH_SPLITPOINT_GROUPS_WITH_ONE_PHASE) &gt;&gt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_SPLITPOINT_PHASE_BITS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* account for buckets <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> splitpoint_group */<br/></li>
<li></span>&nbsp; &nbsp; total_buckets = (<span class="Constant">1</span> &lt;&lt; (splitpoint_group - <span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* account for buckets within splitpoint_group */<br/></li>
<li></span>&nbsp; &nbsp; phases_within_splitpoint_group =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (((splitpoint_phase - HASH_SPLITPOINT_GROUPS_WITH_ONE_PHASE) &amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_SPLITPOINT_PHASE_MASK) + <span class="Constant">1</span>); <span class="Comment">/* from 0-based to 1-based */<br/></li>
<li></span>&nbsp; &nbsp; total_buckets +=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (((<span class="Constant">1</span> &lt;&lt; (splitpoint_group - <span class="Constant">1</span>)) &gt;&gt; HASH_SPLITPOINT_PHASE_BITS) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; phases_within_splitpoint_group);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> total_buckets;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L210" title="access/hash/hashutil.c:210">_hash_checkpage</a> -- sanity checks on the format of all <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> pages<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If flags is not zero, it is a bitwise OR of the acceptable page types<br/></li>
<li></span><span class="Comment"> * (<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of hasho_flag &amp; LH_PAGE_TYPE).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L210">&#x200c;</a></span><span class="linkable">_hash_checkpage</span>(Relation rel, Buffer buf, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a> verifies that every newly-read page passes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PageHeaderIsValid, which means it either contains a reasonably sane<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page header or is all-zero.&nbsp; We have to defend against the all-zero<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case, however.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains unexpected zero page at block </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Please REINDEX it.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Additionally check that the special area looks sane.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PageGetSpecialSize(page) != MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HashPageOpaqueData)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains corrupted page at block </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Please REINDEX it.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HashPageOpaque opaque = HashPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((opaque-&gt;hasho_flag &amp; flags) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains corrupted page at block </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Please REINDEX it.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When checking the metapage, also verify magic number and version.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags == LH_META_PAGE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HashMetaPage metap = HashPageGetMeta(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (metap-&gt;hashm_magic != HASH_MAGIC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> index&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (metap-&gt;hashm_version != HASH_VERSION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has wrong <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> version&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Please REINDEX it.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>bytea *<br/></li>
<li><a id="L275">&#x200c;</a><span class="linkable">hashoptions</span>(Datum reloptions, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> validate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> relopt_parse_elt tab[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<span class="Constant">&quot;fillfactor&quot;</span>, RELOPT_TYPE_INT, offsetof(HashOptions, fillfactor)},<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (bytea *) <a href="../common/reloptions.c.html#L1908" title="access/common/reloptions.c:1908">build_reloptions</a>(reloptions, validate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RELOPT_KIND_HASH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HashOptions),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab, lengthof(tab));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L291" title="access/hash/hashutil.c:291">_hash_get_indextuple_hashkey</a> - get the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> index tuple's <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key value<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint32<br/></li>
<li><a id="L291">&#x200c;</a><span class="linkable">_hash_get_indextuple_hashkey</span>(IndexTuple itup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *attp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We assume the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key is the first attribute and can't be null, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this can be done crudely but very very cheaply ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; attp = (<span class="Type">char</span> *) itup + IndexInfoFindDataOffset(itup-&gt;t_info);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> *((uint32 *) attp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L318" title="access/hash/hashutil.c:318">_hash_convert_tuple</a> - convert raw index data to <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs: <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and isnull arrays for the user data column(s)<br/></li>
<li></span><span class="Comment"> * Outputs: <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and isnull arrays for the index tuple, suitable for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; passing to <a href="../common/indextuple.c.html#L44" title="access/common/indextuple.c:44">index_form_tuple</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if not (because there are null <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>).<br/></li>
<li></span><span class="Comment"> * On a false result, the given data need not be indexed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: callers know that the index-column arrays are always of length 1.<br/></li>
<li></span><span class="Comment"> * In principle, there could be more than one input column, though we do not<br/></li>
<li></span><span class="Comment"> * currently support that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L318">&#x200c;</a></span><span class="linkable">_hash_convert_tuple</span>(Relation index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *user_values, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *user_isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *index_values, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *index_isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do not insert null <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> indexes.&nbsp; This is okay because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the only supported search operator is '=', and we assume it is strict.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (user_isnull[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hashkey = <a href="#L82" title="access/hash/hashutil.c:82">_hash_datum2hashkey</a>(index, user_values[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; index_values[<span class="Constant">0</span>] = UInt32GetDatum(hashkey);<br/></li>
<li>&nbsp; &nbsp; index_isnull[<span class="Constant">0</span>] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L350" title="access/hash/hashutil.c:350">_hash_binsearch</a> - Return the offset number in the page where the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; specified <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value should be sought or inserted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use binary search, relying on the assumption that the existing entries<br/></li>
<li></span><span class="Comment"> * are ordered by <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the offset of the first index entry having hashkey &gt;= hash_value,<br/></li>
<li></span><span class="Comment"> * or the page's max offset plus one if hash_value is greater than all<br/></li>
<li></span><span class="Comment"> * existing <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> keys in the page.&nbsp; This is the appropriate place to start<br/></li>
<li></span><span class="Comment"> * a search, or to insert a new item.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>OffsetNumber<br/></li>
<li><a id="L350">&#x200c;</a><span class="linkable">_hash_binsearch</span>(Page page, uint32 hash_value)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop invariant: <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> &lt;= desired place &lt;= <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = PageGetMaxOffsetNumber(page) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = FirstOffsetNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> &gt; <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; off = (<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> + <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>) / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OffsetNumberIsValid(off));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, off));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashkey = <a href="#L291" title="access/hash/hashutil.c:291">_hash_get_indextuple_hashkey</a>(itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hashkey &lt; hash_value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = off + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = off;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L388" title="access/hash/hashutil.c:388">_hash_binsearch_last</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Same as above, except that if there are multiple matching items in the<br/></li>
<li></span><span class="Comment"> * page, we return the offset of the last one instead of the first one,<br/></li>
<li></span><span class="Comment"> * and the possible <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of outputs is 0..maxoffset not 1..maxoffset+1.<br/></li>
<li></span><span class="Comment"> * This is handy for starting a new page in a backwards scan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>OffsetNumber<br/></li>
<li><a id="L388">&#x200c;</a><span class="linkable">_hash_binsearch_last</span>(Page page, uint32 hash_value)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop invariant: <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> &lt;= desired place &lt;= <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = FirstOffsetNumber - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> &gt; <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; off = (<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> + <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> + <span class="Constant">1</span>) / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OffsetNumberIsValid(off));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, off));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashkey = <a href="#L291" title="access/hash/hashutil.c:291">_hash_get_indextuple_hashkey</a>(itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hashkey &gt; hash_value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = off - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = off;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L422" title="access/hash/hashutil.c:422">_hash_get_oldblock_from_newbucket</a>() -- get the block number of a bucket<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; from which current (new) bucket is being split.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BlockNumber<br/></li>
<li><a id="L422">&#x200c;</a><span class="linkable">_hash_get_oldblock_from_newbucket</span>(Relation rel, Bucket new_bucket)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bucket&nbsp; &nbsp; &nbsp; &nbsp; old_bucket;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; mask;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuf;<br/></li>
<li>&nbsp; &nbsp; HashMetaPage metap;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To get the old bucket from the current bucket, we need a mask to modulo<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> half of table.&nbsp; This mask is stored in meta page as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hashm_lowmask, but here we can't rely on the same, because we need a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value of lowmask that was prevalent at the time when bucket split was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * started.&nbsp; Masking the most significant <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of new bucket would give us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * old bucket.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mask = (((uint32) <span class="Constant">1</span>) &lt;&lt; pg_leftmost_one_pos32(new_bucket)) - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; old_bucket = new_bucket &amp; mask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metabuf = <a href="hashpage.c.html#L70" title="access/hash/hashpage.c:70">_hash_getbuf</a>(rel, HASH_METAPAGE, HASH_READ, LH_META_PAGE);<br/></li>
<li>&nbsp; &nbsp; metap = HashPageGetMeta(BufferGetPage(metabuf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; blkno = BUCKET_TO_BLKNO(metap, old_bucket);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="hashpage.c.html#L266" title="access/hash/hashpage.c:266">_hash_relbuf</a>(rel, metabuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> blkno;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L461" title="access/hash/hashutil.c:461">_hash_get_newblock_from_oldbucket</a>() -- get the block number of a bucket<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; that will be generated after split from old bucket.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the new bucket from old bucket based on current table<br/></li>
<li></span><span class="Comment"> * half.&nbsp; It is mainly required to finish the incomplete splits where we are<br/></li>
<li></span><span class="Comment"> * sure that not more than one bucket could have split in progress from old<br/></li>
<li></span><span class="Comment"> * bucket.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BlockNumber<br/></li>
<li><a id="L461">&#x200c;</a><span class="linkable">_hash_get_newblock_from_oldbucket</span>(Relation rel, Bucket old_bucket)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bucket&nbsp; &nbsp; &nbsp; &nbsp; new_bucket;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuf;<br/></li>
<li>&nbsp; &nbsp; HashMetaPage metap;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metabuf = <a href="hashpage.c.html#L70" title="access/hash/hashpage.c:70">_hash_getbuf</a>(rel, HASH_METAPAGE, HASH_READ, LH_META_PAGE);<br/></li>
<li>&nbsp; &nbsp; metap = HashPageGetMeta(BufferGetPage(metabuf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; new_bucket = <a href="#L494" title="access/hash/hashutil.c:494">_hash_get_newbucket_from_oldbucket</a>(rel, old_bucket,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metap-&gt;hashm_lowmask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metap-&gt;hashm_maxbucket);<br/></li>
<li>&nbsp; &nbsp; blkno = BUCKET_TO_BLKNO(metap, new_bucket);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="hashpage.c.html#L266" title="access/hash/hashpage.c:266">_hash_relbuf</a>(rel, metabuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> blkno;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L494" title="access/hash/hashutil.c:494">_hash_get_newbucket_from_oldbucket</a>() -- get the new bucket that will be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; generated after split from current (old) bucket.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the new bucket from old bucket.&nbsp; New bucket can be<br/></li>
<li></span><span class="Comment"> * obtained by OR'ing old bucket with most significant <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of current table<br/></li>
<li></span><span class="Comment"> * half (lowmask passed in this function can be used to identify msb of<br/></li>
<li></span><span class="Comment"> * current table half).&nbsp; There could be multiple buckets that could have<br/></li>
<li></span><span class="Comment"> * been split from current bucket.&nbsp; We need the first such bucket that exists.<br/></li>
<li></span><span class="Comment"> * Caller must ensure that no more than one split has happened from old<br/></li>
<li></span><span class="Comment"> * bucket.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Bucket<br/></li>
<li><a id="L494">&#x200c;</a><span class="linkable">_hash_get_newbucket_from_oldbucket</span>(Relation rel, Bucket old_bucket,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 lowmask, uint32 maxbucket)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Bucket&nbsp; &nbsp; &nbsp; &nbsp; new_bucket;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; new_bucket = <a href="#L24" title="access/hash/hashutil.c:24">CALC_NEW_BUCKET</a>(old_bucket, lowmask);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (new_bucket &gt; maxbucket)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lowmask = lowmask &gt;&gt; <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_bucket = <a href="#L24" title="access/hash/hashutil.c:24">CALC_NEW_BUCKET</a>(old_bucket, lowmask);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> new_bucket;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L536" title="access/hash/hashutil.c:536">_hash_kill_items</a> - set LP_DEAD state for items an indexscan caller has<br/></li>
<li></span><span class="Comment"> * told us were killed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * scan-&gt;opaque, referenced locally through so, contains information about the<br/></li>
<li></span><span class="Comment"> * current page and killed tuples thereon (generally, this should only be<br/></li>
<li></span><span class="Comment"> * called if so-&gt;numKilled &gt; 0).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller does not have a lock on the page and may or may not have the<br/></li>
<li></span><span class="Comment"> * page pinned in a buffer.&nbsp; Note that read-lock is sufficient for setting<br/></li>
<li></span><span class="Comment"> * LP_DEAD status (which is only a hint).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must have pin on bucket buffer, but may or may not have pin<br/></li>
<li></span><span class="Comment"> * on overflow buffer, as indicated by HashScanPosIsPinned(so-&gt;currPos).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We match items by heap TID <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> assuming they are the right ones to<br/></li>
<li></span><span class="Comment"> * delete.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There are never <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> scans active in a bucket at the time VACUUM begins,<br/></li>
<li></span><span class="Comment"> * because VACUUM takes a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock on the primary bucket page and scans<br/></li>
<li></span><span class="Comment"> * hold a pin.&nbsp; A scan can begin after VACUUM leaves the primary bucket page<br/></li>
<li></span><span class="Comment"> * but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it finishes the entire bucket, but it can never pass VACUUM,<br/></li>
<li></span><span class="Comment"> * because VACUUM always locks the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing the lock on<br/></li>
<li></span><span class="Comment"> * the previous one.&nbsp; Therefore, we don't have to worry about accidentally<br/></li>
<li></span><span class="Comment"> * killing a TID that has been reused for an unrelated tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L536">&#x200c;</a></span><span class="linkable">_hash_kill_items</span>(IndexScanDesc scan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HashScanOpaque so = (HashScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = scan-&gt;indexRelation;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; HashPageOpaque opaque;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numKilled = so-&gt;numKilled;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; killedsomething = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; havePin = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(so-&gt;numKilled &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(so-&gt;killedItems != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(HashScanPosIsValid(so-&gt;currPos));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Always reset the scan state, so we don't look for same items on other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; so-&gt;numKilled = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; blkno = so-&gt;currPos.currPage;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HashScanPosIsPinned(so-&gt;currPos))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We already have pin on this buffer, so, all we need to do is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * acquire lock on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; havePin = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = so-&gt;currPos.buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_SHARE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="hashpage.c.html#L70" title="access/hash/hashpage.c:70">_hash_getbuf</a>(rel, blkno, HASH_READ, LH_OVERFLOW_PAGE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; opaque = HashPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numKilled; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemIndex = so-&gt;killedItems[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HashScanPosItem *currItem = &amp;so-&gt;currPos.items[itemIndex];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offnum = currItem-&gt;indexOffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(itemIndex &gt;= so-&gt;currPos.firstItem &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; itemIndex &lt;= so-&gt;currPos.lastItem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (offnum &lt;= maxoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(page, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; ituple = (IndexTuple) PageGetItem(page, iid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;ituple-&gt;t_tid, &amp;currItem-&gt;heapTid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found the item */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemIdMarkDead(iid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; killedsomething = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* out of inner search loop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = OffsetNumberNext(offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since this can be redone later if needed, mark as dirty hint. Whenever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we mark anything LP_DEAD, we also set the page's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LH_PAGE_HAS_DEAD_TUPLES flag, which is likewise just a hint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (killedsomething)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;hasho_flag |= LH_PAGE_HAS_DEAD_TUPLES;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4914" title="storage/buffer/bufmgr.c:4914">MarkBufferDirtyHint</a>(buf, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;hashso_bucket_buf == so-&gt;currPos.buf ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; havePin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(so-&gt;currPos.buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="hashpage.c.html#L266" title="access/hash/hashpage.c:266">_hash_relbuf</a>(rel, buf);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
