<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/hash/hashsearch.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/hash/hashsearch.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L288">_hash_first</a></li>
<li><a href="#L602">_hash_load_qualified_items</a></li>
<li><a href="#L48">_hash_next</a></li>
<li><a href="#L131">_hash_readnext</a></li>
<li><a href="#L446">_hash_readpage</a></li>
<li><a href="#L197">_hash_readprev</a></li>
<li><a href="#L708">_hash_saveitem</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * hashsearch.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; search code for postgres <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>/hashsearch.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L446" title="access/hash/hashsearch.c:446">_hash_readpage</a>(IndexScanDesc scan, Buffer *bufP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanDirection dir);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L602" title="access/hash/hashsearch.c:602">_hash_load_qualified_items</a>(IndexScanDesc scan, Page page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber offnum, ScanDirection dir);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L708" title="access/hash/hashsearch.c:708">_hash_saveitem</a>(HashScanOpaque so, <span class="Type">int</span> itemIndex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offnum, IndexTuple itup);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L131" title="access/hash/hashsearch.c:131">_hash_readnext</a>(IndexScanDesc scan, Buffer *bufp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Page *pagep, HashPageOpaque *opaquep);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L48" title="access/hash/hashsearch.c:48">_hash_next</a>() -- Get the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> item in a scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; On entry, so-&gt;currPos describes the current page, which may<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; be pinned but not locked, and so-&gt;currPos.itemIndex identifies<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; which item was previously returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; On successful exit, scan-&gt;xs_heaptid is set to the TID of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; heap tuple.&nbsp; so-&gt;currPos is updated as needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; On failure exit (no more tuples), we return false with pin<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; held on bucket page but no pins or locks held on overflow<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L48">&#x200c;</a></span><span class="linkable">_hash_next</span>(IndexScanDesc scan, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = scan-&gt;indexRelation;<br/></li>
<li>&nbsp; &nbsp; HashScanOpaque so = (HashScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; HashScanPosItem *currItem;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; end_of_scan = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advance to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple on the current page; or if done, try to read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data from the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> or previous page based on the scan direction. Before<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * moving to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> or previous page make sure that we deal with all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * killed items.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++so-&gt;currPos.itemIndex &gt; so-&gt;currPos.lastItem)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;numKilled &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="hashutil.c.html#L536" title="access/hash/hashutil.c:536">_hash_kill_items</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno = so-&gt;currPos.nextPage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BlockNumberIsValid(blkno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="hashpage.c.html#L70" title="access/hash/hashpage.c:70">_hash_getbuf</a>(rel, blkno, HASH_READ, LH_OVERFLOW_PAGE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L446" title="access/hash/hashsearch.c:446">_hash_readpage</a>(scan, &amp;buf, dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_of_scan = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_of_scan = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (--so-&gt;currPos.itemIndex &lt; so-&gt;currPos.firstItem)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;numKilled &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="hashutil.c.html#L536" title="access/hash/hashutil.c:536">_hash_kill_items</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno = so-&gt;currPos.prevPage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BlockNumberIsValid(blkno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="hashpage.c.html#L70" title="access/hash/hashpage.c:70">_hash_getbuf</a>(rel, blkno, HASH_READ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LH_BUCKET_PAGE | LH_OVERFLOW_PAGE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We always maintain the pin on bucket page for whole scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operation, so releasing the additional pin we have acquired<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf == so-&gt;hashso_bucket_buf ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf == so-&gt;hashso_split_bucket_buf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="hashpage.c.html#L277" title="access/hash/hashpage.c:277">_hash_dropbuf</a>(rel, buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L446" title="access/hash/hashsearch.c:446">_hash_readpage</a>(scan, &amp;buf, dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_of_scan = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end_of_scan = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (end_of_scan)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="hashpage.c.html#L289" title="access/hash/hashpage.c:289">_hash_dropscanbuf</a>(rel, so);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HashScanPosInvalidate(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, itemIndex says what to return */<br/></li>
<li></span>&nbsp; &nbsp; currItem = &amp;so-&gt;currPos.items[so-&gt;currPos.itemIndex];<br/></li>
<li>&nbsp; &nbsp; scan-&gt;xs_heaptid = currItem-&gt;heapTid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page in a bucket, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; If we are scanning the bucket<br/></li>
<li></span><span class="Comment"> * being populated during split operation then this function advances to the<br/></li>
<li></span><span class="Comment"> * bucket being split after the last bucket page of bucket being populated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L131">&#x200c;</a></span><span class="linkable">_hash_readnext</span>(IndexScanDesc scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer *bufp, Page *pagep, HashPageOpaque *opaquep)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = scan-&gt;indexRelation;<br/></li>
<li>&nbsp; &nbsp; HashScanOpaque so = (HashScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; block_found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; blkno = (*opaquep)-&gt;hasho_nextblkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Retain the pin on primary bucket page till the end of scan.&nbsp; Refer the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comments in <a href="#L288" title="access/hash/hashsearch.c:288">_hash_first</a> to know the reason of retaining pin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*bufp == so-&gt;hashso_bucket_buf || *bufp == so-&gt;hashso_split_bucket_buf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*bufp, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="hashpage.c.html#L266" title="access/hash/hashpage.c:266">_hash_relbuf</a>(rel, *bufp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *bufp = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for interrupts while we're not holding <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> buffer lock */<br/></li>
<li></span>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BlockNumberIsValid(blkno))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *bufp = <a href="hashpage.c.html#L70" title="access/hash/hashpage.c:70">_hash_getbuf</a>(rel, blkno, HASH_READ, LH_OVERFLOW_PAGE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block_found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (so-&gt;hashso_buc_populated &amp;&amp; !so-&gt;hashso_buc_split)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end of bucket, scan bucket being split if there was a split in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * progress at the start of scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *bufp = so-&gt;hashso_split_bucket_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffer for bucket being split must be valid as we acquire the pin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the start of scan and retain it till end of scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(BufferIsValid(*bufp));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*bufp, BUFFER_LOCK_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L2584" title="storage/lmgr/predicate.c:2584">PredicateLockPage</a>(rel, <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(*bufp), scan-&gt;xs_snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * setting hashso_buc_split to true indicates that we are scanning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bucket being split.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;hashso_buc_split = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block_found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (block_found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *pagep = BufferGetPage(*bufp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *opaquep = HashPageGetOpaque(*pagep);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Advance to previous page in a bucket, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; If the current scan has<br/></li>
<li></span><span class="Comment"> * started during split operation then this function advances to bucket<br/></li>
<li></span><span class="Comment"> * being populated after the first bucket page of bucket being split.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L197">&#x200c;</a></span><span class="linkable">_hash_readprev</span>(IndexScanDesc scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer *bufp, Page *pagep, HashPageOpaque *opaquep)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = scan-&gt;indexRelation;<br/></li>
<li>&nbsp; &nbsp; HashScanOpaque so = (HashScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; haveprevblk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; blkno = (*opaquep)-&gt;hasho_prevblkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Retain the pin on primary bucket page till the end of scan.&nbsp; Refer the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comments in <a href="#L288" title="access/hash/hashsearch.c:288">_hash_first</a> to know the reason of retaining pin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*bufp == so-&gt;hashso_bucket_buf || *bufp == so-&gt;hashso_split_bucket_buf)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*bufp, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; haveprevblk = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="hashpage.c.html#L266" title="access/hash/hashpage.c:266">_hash_relbuf</a>(rel, *bufp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; haveprevblk = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *bufp = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for interrupts while we're not holding <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> buffer lock */<br/></li>
<li></span>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (haveprevblk)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(BlockNumberIsValid(blkno));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *bufp = <a href="hashpage.c.html#L70" title="access/hash/hashpage.c:70">_hash_getbuf</a>(rel, blkno, HASH_READ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LH_BUCKET_PAGE | LH_OVERFLOW_PAGE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *pagep = BufferGetPage(*bufp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *opaquep = HashPageGetOpaque(*pagep);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We always maintain the pin on bucket page for whole scan operation,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so releasing the additional pin we have acquired here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*bufp == so-&gt;hashso_bucket_buf || *bufp == so-&gt;hashso_split_bucket_buf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="hashpage.c.html#L277" title="access/hash/hashpage.c:277">_hash_dropbuf</a>(rel, *bufp);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (so-&gt;hashso_buc_populated &amp;&amp; so-&gt;hashso_buc_split)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end of bucket, scan bucket being populated if there was a split in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * progress at the start of scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *bufp = so-&gt;hashso_bucket_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffer for bucket being populated must be valid as we acquire the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pin on it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the start of scan and retain it till end of scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(BufferIsValid(*bufp));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*bufp, BUFFER_LOCK_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *pagep = BufferGetPage(*bufp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *opaquep = HashPageGetOpaque(*pagep);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* move to the end of bucket chain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (BlockNumberIsValid((*opaquep)-&gt;hasho_nextblkno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="access/hash/hashsearch.c:131">_hash_readnext</a>(scan, bufp, pagep, opaquep);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * setting hashso_buc_split to false indicates that we are scanning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bucket being populated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;hashso_buc_split = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L288" title="access/hash/hashsearch.c:288">_hash_first</a>() -- Find the first item in a scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the first item (or, if backward scan, the last item) in the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; index that satisfies the qualification associated with the scan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; descriptor.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; On successful exit, if the page containing current index tuple is an<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; overflow page, both pin and lock are released whereas if it is a bucket<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; page then it is pinned but not locked and data about the matching<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; tuple(s) on the page has been loaded into so-&gt;currPos,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;xs_heaptid is set to the heap TID of the current tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; On failure exit (no more tuples), we return false, with pin held on<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; bucket page but no pins or locks held on overflow page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L288">&#x200c;</a></span><span class="linkable">_hash_first</span>(IndexScanDesc scan, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = scan-&gt;indexRelation;<br/></li>
<li>&nbsp; &nbsp; HashScanOpaque so = (HashScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; cur;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashkey;<br/></li>
<li>&nbsp; &nbsp; Bucket&nbsp; &nbsp; &nbsp; &nbsp; bucket;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; HashPageOpaque opaque;<br/></li>
<li>&nbsp; &nbsp; HashScanPosItem *currItem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_count_index_scan(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do not support <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> scans with no index qualification, because we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would have to read the whole index rather than just one bucket. That<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * creates a whole raft of problems, since we haven't got a practical way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to lock all the buckets against splits or compactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;numberOfKeys &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> indexes do not support whole-index scans&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There may be more than one index qual, but we <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> only the first */<br/></li>
<li></span>&nbsp; &nbsp; cur = &amp;scan-&gt;keyData[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We support only single-column <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> indexes */<br/></li>
<li></span>&nbsp; &nbsp; Assert(cur-&gt;sk_attno == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And there's only one operator strategy, too */<br/></li>
<li></span>&nbsp; &nbsp; Assert(cur-&gt;sk_strategy == HTEqualStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the constant in the index qual is NULL, assume it cannot match <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * items in the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_flags &amp; SK_ISNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Okay to compute the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key.&nbsp; We want to do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> acquiring <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * locks, in case a user-defined <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function happens to be slow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If scankey operator is not a cross-type comparison, we can use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cached <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function; otherwise gotta look it up in the catalogs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We support the convention that sk_subtype == InvalidOid means the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * opclass input type; this is a hack to simplify life for <a href="../common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_subtype == rel-&gt;rd_opcintype[<span class="Constant">0</span>] ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cur-&gt;sk_subtype == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashkey = <a href="hashutil.c.html#L82" title="access/hash/hashutil.c:82">_hash_datum2hashkey</a>(rel, cur-&gt;sk_argument);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hashkey = <a href="hashutil.c.html#L102" title="access/hash/hashutil.c:102">_hash_datum2hashkey_type</a>(rel, cur-&gt;sk_argument,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur-&gt;sk_subtype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; so-&gt;hashso_sk_hash = hashkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf = <a href="hashpage.c.html#L1559" title="access/hash/hashpage.c:1559">_hash_getbucketbuf_from_hashkey</a>(rel, hashkey, HASH_READ, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L2584" title="storage/lmgr/predicate.c:2584">PredicateLockPage</a>(rel, <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf), scan-&gt;xs_snapshot);<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; opaque = HashPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; bucket = opaque-&gt;hasho_bucket;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; so-&gt;hashso_bucket_buf = buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a bucket split is in progress, then while scanning the bucket being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * populated, we need to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> tuples that were copied from bucket being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * split.&nbsp; We also need to maintain a pin on the bucket being split to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensure that split-<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> work done by <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> doesn't remove tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from it till this scan is done.&nbsp; We need to maintain a pin on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bucket being populated to ensure that <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> doesn't squeeze that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bucket till this scan is complete; otherwise, the ordering of tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't be maintained during forward and backward scans.&nbsp; Here, we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be cautious about locking order: first, acquire the lock on bucket<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * being split; then, release the lock on it but not the pin; then,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * acquire a lock on bucket being populated and again re-verify whether<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the bucket split is still in progress.&nbsp; Acquiring the lock on bucket<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * being split first ensures that the <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> waits for this scan to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * finish.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (H_BUCKET_BEING_POPULATED(opaque))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber old_blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; old_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; old_blkno = <a href="hashutil.c.html#L422" title="access/hash/hashutil.c:422">_hash_get_oldblock_from_newbucket</a>(rel, bucket);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * release the lock on new bucket and re-acquire it after acquiring<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the lock on old bucket.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; old_buf = <a href="hashpage.c.html#L70" title="access/hash/hashpage.c:70">_hash_getbuf</a>(rel, old_blkno, HASH_READ, LH_BUCKET_PAGE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remember the split bucket buffer so as to use it later for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scanning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;hashso_split_bucket_buf = old_buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(old_buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque = HashPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(opaque-&gt;hasho_bucket == bucket);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (H_BUCKET_BEING_POPULATED(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;hashso_buc_populated = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="hashpage.c.html#L277" title="access/hash/hashpage.c:277">_hash_dropbuf</a>(rel, so-&gt;hashso_split_bucket_buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;hashso_split_bucket_buf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If a backwards scan is requested, move to the end of the chain */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsBackward(dir))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Backward scans that start during split needs to start from end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bucket being split.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (BlockNumberIsValid(opaque-&gt;hasho_nextblkno) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (so-&gt;hashso_buc_populated &amp;&amp; !so-&gt;hashso_buc_split))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="access/hash/hashsearch.c:131">_hash_readnext</a>(scan, &amp;buf, &amp;page, &amp;opaque);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remember which buffer we have pinned, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(BufferIsInvalid(so-&gt;currPos.buf));<br/></li>
<li>&nbsp; &nbsp; so-&gt;currPos.buf = buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> all the tuples satisfying the qualification from a page */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L446" title="access/hash/hashsearch.c:446">_hash_readpage</a>(scan, &amp;buf, dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, itemIndex says what to return */<br/></li>
<li></span>&nbsp; &nbsp; currItem = &amp;so-&gt;currPos.items[so-&gt;currPos.itemIndex];<br/></li>
<li>&nbsp; &nbsp; scan-&gt;xs_heaptid = currItem-&gt;heapTid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if we're here, <a href="#L446" title="access/hash/hashsearch.c:446">_hash_readpage</a> found a valid tuples */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L446" title="access/hash/hashsearch.c:446">_hash_readpage</a>() -- Load data from current index page into so-&gt;currPos<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We scan all the items in the current index page and save them into<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; so-&gt;currPos if it satisfies the qualification. If no matching items<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; are found in the current page, we move to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> or previous page<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; in a bucket chain as indicated by the direction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Return true if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> matching items are found else return false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L446">&#x200c;</a></span><span class="linkable">_hash_readpage</span>(IndexScanDesc scan, Buffer *bufP, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = scan-&gt;indexRelation;<br/></li>
<li>&nbsp; &nbsp; HashScanOpaque so = (HashScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; HashPageOpaque opaque;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; itemIndex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf = *bufP;<br/></li>
<li>&nbsp; &nbsp; Assert(BufferIsValid(buf));<br/></li>
<li>&nbsp; &nbsp; <a href="hashutil.c.html#L210" title="access/hash/hashutil.c:210">_hash_checkpage</a>(rel, buf, LH_BUCKET_PAGE | LH_OVERFLOW_PAGE);<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; opaque = HashPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; so-&gt;currPos.buf = buf;<br/></li>
<li>&nbsp; &nbsp; so-&gt;currPos.currPage = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber prev_blkno = InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* new page, locate starting position by binary search */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = <a href="hashutil.c.html#L350" title="access/hash/hashutil.c:350">_hash_binsearch</a>(page, so-&gt;hashso_sk_hash);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemIndex = <a href="#L602" title="access/hash/hashsearch.c:602">_hash_load_qualified_items</a>(scan, page, offnum, dir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (itemIndex != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> matching tuples in the current page, move to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page. Before leaving the current page, deal with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * killed items.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;numKilled &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="hashutil.c.html#L536" title="access/hash/hashutil.c:536">_hash_kill_items</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is a primary bucket page, hasho_prevblkno is not a real<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * block number.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;currPos.buf == so-&gt;hashso_bucket_buf ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.buf == so-&gt;hashso_split_bucket_buf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_blkno = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_blkno = opaque-&gt;hasho_prevblkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="access/hash/hashsearch.c:131">_hash_readnext</a>(scan, &amp;buf, &amp;page, &amp;opaque);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.buf = buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.currPage = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> and previous block numbers for scrollable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cursors to know the start position and return false<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indicating that no more matching tuples were found. Also,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't reset currPage or lsn, because we expect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="hashutil.c.html#L536" title="access/hash/hashutil.c:536">_hash_kill_items</a> to be called for the old page after this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function returns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.prevPage = prev_blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.nextPage = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.buf = buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.firstItem = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.lastItem = itemIndex - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.itemIndex = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber next_blkno = InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* new page, locate starting position by binary search */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = <a href="hashutil.c.html#L388" title="access/hash/hashutil.c:388">_hash_binsearch_last</a>(page, so-&gt;hashso_sk_hash);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemIndex = <a href="#L602" title="access/hash/hashsearch.c:602">_hash_load_qualified_items</a>(scan, page, offnum, dir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (itemIndex != MaxIndexTuplesPerPage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> matching tuples in the current page, move to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the previous page. Before leaving the current page, deal with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> killed items.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;numKilled &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="hashutil.c.html#L536" title="access/hash/hashutil.c:536">_hash_kill_items</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;currPos.buf == so-&gt;hashso_bucket_buf ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.buf == so-&gt;hashso_split_bucket_buf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_blkno = opaque-&gt;hasho_nextblkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L197" title="access/hash/hashsearch.c:197">_hash_readprev</a>(scan, &amp;buf, &amp;page, &amp;opaque);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.buf = buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.currPage = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> and previous block numbers for scrollable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cursors to know the start position and return false<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indicating that no more matching tuples were found. Also,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't reset currPage or lsn, because we expect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="hashutil.c.html#L536" title="access/hash/hashutil.c:536">_hash_kill_items</a> to be called for the old page after this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function returns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.prevPage = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.nextPage = next_blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.buf = buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.firstItem = itemIndex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.lastItem = MaxIndexTuplesPerPage - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.itemIndex = MaxIndexTuplesPerPage - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;currPos.buf == so-&gt;hashso_bucket_buf ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.buf == so-&gt;hashso_split_bucket_buf)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.prevPage = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.nextPage = opaque-&gt;hasho_nextblkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(so-&gt;currPos.buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.prevPage = opaque-&gt;hasho_prevblkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.nextPage = opaque-&gt;hasho_nextblkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="hashpage.c.html#L266" title="access/hash/hashpage.c:266">_hash_relbuf</a>(rel, so-&gt;currPos.buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.buf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(so-&gt;currPos.firstItem &lt;= so-&gt;currPos.lastItem);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Load all the qualified items from a current index page<br/></li>
<li></span><span class="Comment"> * into so-&gt;currPos. Helper function for <a href="#L446" title="access/hash/hashsearch.c:446">_hash_readpage</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L602">&#x200c;</a></span><span class="linkable">_hash_load_qualified_items</span>(IndexScanDesc scan, Page page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber offnum, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HashScanOpaque so = (HashScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemIndex;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber maxoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* load items[] in ascending order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itemIndex = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (offnum &lt;= maxoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(offnum &gt;= FirstOffsetNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, offnum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the tuples that are moved by split operation for the scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that has started when split was in progress. Also, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples that are marked as dead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((so-&gt;hashso_buc_populated &amp;&amp; !so-&gt;hashso_buc_split &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (itup-&gt;t_info &amp; INDEX_MOVED_BY_SPLIT_MASK)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (scan-&gt;ignore_killed_tuples &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (ItemIdIsDead(PageGetItemId(page, offnum)))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = OffsetNumberNext(offnum);&nbsp; &nbsp; <span class="Comment">/* move forward */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;hashso_sk_hash == <a href="hashutil.c.html#L291" title="access/hash/hashutil.c:291">_hash_get_indextuple_hashkey</a>(itup) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="hashutil.c.html#L31" title="access/hash/hashutil.c:31">_hash_checkqual</a>(scan, itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tuple is qualified, so remember it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L708" title="access/hash/hashsearch.c:708">_hash_saveitem</a>(so, itemIndex, offnum, itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemIndex++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No more matching tuples exist in this page. so, exit while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = OffsetNumberNext(offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(itemIndex &lt;= MaxIndexTuplesPerPage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> itemIndex;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* load items[] in descending order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itemIndex = MaxIndexTuplesPerPage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (offnum &gt;= FirstOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(offnum &lt;= maxoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, offnum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the tuples that are moved by split operation for the scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that has started when split was in progress. Also, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples that are marked as dead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((so-&gt;hashso_buc_populated &amp;&amp; !so-&gt;hashso_buc_split &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (itup-&gt;t_info &amp; INDEX_MOVED_BY_SPLIT_MASK)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (scan-&gt;ignore_killed_tuples &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (ItemIdIsDead(PageGetItemId(page, offnum)))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = OffsetNumberPrev(offnum);&nbsp; &nbsp; <span class="Comment">/* move back */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;hashso_sk_hash == <a href="hashutil.c.html#L291" title="access/hash/hashutil.c:291">_hash_get_indextuple_hashkey</a>(itup) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="hashutil.c.html#L31" title="access/hash/hashutil.c:31">_hash_checkqual</a>(scan, itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemIndex--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tuple is qualified, so remember it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L708" title="access/hash/hashsearch.c:708">_hash_saveitem</a>(so, itemIndex, offnum, itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No more matching tuples exist in this page. so, exit while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = OffsetNumberPrev(offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(itemIndex &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> itemIndex;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Save an index item into so-&gt;currPos.items[itemIndex] */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L708">&#x200c;</a></span><span class="linkable">_hash_saveitem</span>(HashScanOpaque so, <span class="Type">int</span> itemIndex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber offnum, IndexTuple itup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HashScanPosItem *currItem = &amp;so-&gt;currPos.items[itemIndex];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; currItem-&gt;heapTid = itup-&gt;t_tid;<br/></li>
<li>&nbsp; &nbsp; currItem-&gt;indexOffset = offnum;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
