<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/spgist/spgtextproc.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/spgist/spgtextproc.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L87">spgNodePtr</a></li>
<li><a href="#L92">spgNodePtr</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L324">cmpNodePtr</a></li>
<li><a href="#L138">commonPrefix</a></li>
<li><a href="#L113">formTextDatum</a></li>
<li><a href="#L158">searchChar</a></li>
<li><a href="#L184">spg_text_choose</a></li>
<li><a href="#L96">spg_text_config</a></li>
<li><a href="#L426">spg_text_inner_consistent</a></li>
<li><a href="#L574">spg_text_leaf_consistent</a></li>
<li><a href="#L333">spg_text_picksplit</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L70">SPGIST_MAX_PREFIX_LENGTH</a></li>
<li><a href="#L83">SPG_IS_COLLATION_AWARE_STRATEGY</a></li>
<li><a href="#L82">SPG_STRATEGY_ADDITION</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * spgtextproc.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; implementation of radix tree (compressed trie) over text<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In a text_ops SPGiST index, inner tuples can have a prefix which is the<br/></li>
<li></span><span class="Comment"> * common prefix of all strings indexed under that tuple.&nbsp; The node labels<br/></li>
<li></span><span class="Comment"> * represent the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> byte of the string(s) after the prefix.&nbsp; Assuming we<br/></li>
<li></span><span class="Comment"> * always use the <a href="../../regex/rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a> possible prefix, we will get more than one node<br/></li>
<li></span><span class="Comment"> * label unless the prefix length is restricted by <a href="#L70" title="access/spgist/spgtextproc.c:70">SPGIST_MAX_PREFIX_LENGTH</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To reconstruct the indexed string for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index entry, concatenate the<br/></li>
<li></span><span class="Comment"> * inner-tuple <a href="../../regex/regc_lex.c.html#L99" title="regex/regc_lex.c:99">prefixes</a> and node labels starting at the root and working<br/></li>
<li></span><span class="Comment"> * down to the leaf entry, then append the datum in the leaf entry.<br/></li>
<li></span><span class="Comment"> * (While descending the tree, &quot;level&quot; is the number of bytes reconstructed<br/></li>
<li></span><span class="Comment"> * so far.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * However, there are two special cases for node labels: -1 indicates that<br/></li>
<li></span><span class="Comment"> * there are no more bytes after the prefix-so-far, and -2 indicates that we<br/></li>
<li></span><span class="Comment"> * had to split an existing allTheSame tuple (in such a case we have to create<br/></li>
<li></span><span class="Comment"> * a node label that doesn't correspond to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> string byte).&nbsp; In either case,<br/></li>
<li></span><span class="Comment"> * the node label does not contribute anything to the reconstructed string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Previously, we used a node label of zero for both special cases, but<br/></li>
<li></span><span class="Comment"> * this was problematic because one can't tell whether a string ending at<br/></li>
<li></span><span class="Comment"> * the current level can be pushed down into such a child node.&nbsp; For<br/></li>
<li></span><span class="Comment"> * backwards compatibility, we still support such node labels for reading;<br/></li>
<li></span><span class="Comment"> * but no new entries will ever be pushed down into a zero-labeled child.<br/></li>
<li></span><span class="Comment"> * No new entries ever get pushed into a -2-labeled child, either.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src/backend/access/spgist/spgtextproc.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/spgist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_locale.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/varlena.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;varatt.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * In the worst case, an inner tuple in a text radix tree could have as many<br/></li>
<li></span><span class="Comment"> * as 258 nodes (one for each possible byte value, plus the two special<br/></li>
<li></span><span class="Comment"> * cases).&nbsp; Each node can take 16 bytes on MAXALIGN=8 machines.&nbsp; The inner<br/></li>
<li></span><span class="Comment"> * tuple must fit on an index page of size BLCKSZ.&nbsp; Rather than assuming we<br/></li>
<li></span><span class="Comment"> * know the exact amount of overhead imposed by page headers, tuple headers,<br/></li>
<li></span><span class="Comment"> * etc, we leave 100 bytes for that (the actual overhead should be no more<br/></li>
<li></span><span class="Comment"> * than 56 bytes at this writing, so there is slop in this number).<br/></li>
<li></span><span class="Comment"> * So we can safely create <a href="../../regex/regc_lex.c.html#L99" title="regex/regc_lex.c:99">prefixes</a> up to BLCKSZ - 258 * 16 - 100 bytes long.<br/></li>
<li></span><span class="Comment"> * Unfortunately, because 258 * 16 is over 4K, there is no safe prefix length<br/></li>
<li></span><span class="Comment"> * when BLCKSZ is less than 8K; it is always possible to get &quot;SPGiST inner<br/></li>
<li></span><span class="Comment"> * tuple size exceeds maximum&quot; if there are too many distinct <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-byte <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * at a given place in the tree.&nbsp; Since use of nonstandard block sizes appears<br/></li>
<li></span><span class="Comment"> * to be negligible in the field, we just live with that fact for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li></span><span class="Comment"> * choosing a max prefix size of 32 bytes when BLCKSZ is configured smaller<br/></li>
<li></span><span class="Comment"> * than default.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L70">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SPGIST_MAX_PREFIX_LENGTH</span>&nbsp; &nbsp; Max((</span><span class="Type">int</span><span class="PreProc">) (BLCKSZ - </span><span class="Constant">258</span><span class="PreProc"> * </span><span class="Constant">16</span><span class="PreProc"> - </span><span class="Constant">100</span><span class="PreProc">), </span><span class="Constant">32</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Strategy for collation aware operator on text is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to btree strategy<br/></li>
<li></span><span class="Comment"> * plus value of 10.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Current collation aware strategies and their corresponding btree strategies:<br/></li>
<li></span><span class="Comment"> * 11 BTLessStrategyNumber<br/></li>
<li></span><span class="Comment"> * 12 BTLessEqualStrategyNumber<br/></li>
<li></span><span class="Comment"> * 14 BTGreaterEqualStrategyNumber<br/></li>
<li></span><span class="Comment"> * 15 BTGreaterStrategyNumber<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L82">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SPG_STRATEGY_ADDITION</span>&nbsp; &nbsp; (</span><span class="Constant">10</span><span class="PreProc">)<br/></li>
<li><a id="L83">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SPG_IS_COLLATION_AWARE_STRATEGY</span>(s) ((s) &gt; <a href="#L82" title="access/spgist/spgtextproc.c:82">SPG_STRATEGY_ADDITION</a> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;&amp; (s) != RTPrefixStrategyNumber)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Struct for sorting <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in picksplit */<br/></li>
<li><a id="L87">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">spgNodePtr</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; c;<br/></li>
<li><a id="L92">&#x200c;</a>} <span class="linkable">spgNodePtr</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L96">&#x200c;</a><span class="linkable">spg_text_config</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* spgConfigIn *cfgin = (spgConfigIn *) PG_GETARG_POINTER(0); */<br/></li>
<li></span>&nbsp; &nbsp; spgConfigOut *cfg = (spgConfigOut *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cfg-&gt;prefixType = TEXTOID;<br/></li>
<li>&nbsp; &nbsp; cfg-&gt;labelType = INT2OID;<br/></li>
<li>&nbsp; &nbsp; cfg-&gt;canReturnData = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; cfg-&gt;longValuesOK = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* suffixing will shorten long <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Form a text datum from the given not-necessarily-null-terminated string,<br/></li>
<li></span><span class="Comment"> * using short varlena header format if possible<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L113">&#x200c;</a><span class="linkable">formTextDatum</span>(<span class="Type">const</span> <span class="Type">char</span> *data, <span class="Type">int</span> datalen)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; p = (<span class="Type">char</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(datalen + VARHDRSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (datalen + VARHDRSZ_SHORT &lt;= VARATT_SHORT_MAX)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE_SHORT(p, datalen + VARHDRSZ_SHORT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (datalen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(p + VARHDRSZ_SHORT, data, datalen);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(p, datalen + VARHDRSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(p + VARHDRSZ, data, datalen);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(p);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find the length of the common prefix of a and b<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L138">&#x200c;</a></span><span class="linkable">commonPrefix</span>(<span class="Type">const</span> <span class="Type">char</span> *a, <span class="Type">const</span> <span class="Type">char</span> *b, <span class="Type">int</span> lena, <span class="Type">int</span> lenb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (i &lt; lena &amp;&amp; i &lt; lenb &amp;&amp; *a == *b)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> i;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Binary search an array of int16 datums for a match to c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On success, *i gets the match location; on failure, it gets where to insert<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L158">&#x200c;</a></span><span class="linkable">searchChar</span>(Datum *nodeLabels, <span class="Type">int</span> nNodes, int16 c, <span class="Type">int</span> *i)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StopLow = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StopHigh = nNodes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (StopLow &lt; StopHigh)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StopMiddle = (StopLow + StopHigh) &gt;&gt; <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; middle = DatumGetInt16(nodeLabels[StopMiddle]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (c &lt; middle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StopHigh = StopMiddle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (c &gt; middle)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StopLow = StopMiddle + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *i = StopMiddle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *i = StopHigh;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L184">&#x200c;</a><span class="linkable">spg_text_choose</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; spgChooseIn *in = (spgChooseIn *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; spgChooseOut *out = (spgChooseOut *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *inText = DatumGetTextPP(in-&gt;datum);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *inStr = VARDATA_ANY(inText);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inSize = VARSIZE_ANY_EXHDR(inText);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *prefixStr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefixSize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commonLen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; nodeChar = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for prefix match, set nodeChar to first byte after prefix */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;hasPrefix)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *prefixText = DatumGetTextPP(in-&gt;prefixDatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prefixStr = VARDATA_ANY(prefixText);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prefixSize = VARSIZE_ANY_EXHDR(prefixText);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; commonLen = <a href="#L138" title="access/spgist/spgtextproc.c:138">commonPrefix</a>(inStr + in-&gt;level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prefixStr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inSize - in-&gt;level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prefixSize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (commonLen == prefixSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (inSize - in-&gt;level &gt; commonLen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodeChar = *(<span class="Type">unsigned</span> <span class="Type">char</span> *) (inStr + in-&gt;level + commonLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodeChar = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must split tuple because incoming value doesn't match prefix */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;resultType = spgSplitTuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (commonLen == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.splitTuple.prefixHasPrefix = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.splitTuple.prefixHasPrefix = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.splitTuple.prefixPrefixDatum =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L113" title="access/spgist/spgtextproc.c:113">formTextDatum</a>(prefixStr, commonLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.splitTuple.prefixNNodes = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.splitTuple.prefixNodeLabels =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Datum *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.splitTuple.prefixNodeLabels[<span class="Constant">0</span>] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int16GetDatum(*(<span class="Type">unsigned</span> <span class="Type">char</span> *) (prefixStr + commonLen));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.splitTuple.childNodeN = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prefixSize - commonLen == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.splitTuple.postfixHasPrefix = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.splitTuple.postfixHasPrefix = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.splitTuple.postfixPrefixDatum =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L113" title="access/spgist/spgtextproc.c:113">formTextDatum</a>(prefixStr + commonLen + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefixSize - commonLen - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (inSize &gt; in-&gt;level)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nodeChar = *(<span class="Type">unsigned</span> <span class="Type">char</span> *) (inStr + in-&gt;level);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nodeChar = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up nodeChar in the node label array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L158" title="access/spgist/spgtextproc.c:158">searchChar</a>(in-&gt;nodeLabels, in-&gt;nNodes, nodeChar, &amp;i))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Descend to existing node.&nbsp; (If in-&gt;allTheSame, the core code will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ignore our nodeN specification here, but that's OK.&nbsp; We still have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to provide the correct levelAdd and restDatum <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, and those are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same regardless of which node gets chosen by core.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; levelAdd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;resultType = spgMatchNode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.matchNode.nodeN = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; levelAdd = commonLen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nodeChar &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; levelAdd++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.matchNode.levelAdd = levelAdd;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (inSize - in-&gt;level - levelAdd &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.matchNode.restDatum =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L113" title="access/spgist/spgtextproc.c:113">formTextDatum</a>(inStr + in-&gt;level + levelAdd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inSize - in-&gt;level - levelAdd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.matchNode.restDatum =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L113" title="access/spgist/spgtextproc.c:113">formTextDatum</a>(<span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (in-&gt;allTheSame)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Can't use AddNode action, so split the tuple.&nbsp; The <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> tuple has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same prefix as <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> and uses a dummy node label -2 for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> tuple.&nbsp; The <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> tuple has no prefix and the same node<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * labels as the original tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: it might seem tempting to shorten the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> tuple's prefix,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if it has one, then use its last byte as label for the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * But that doesn't win since we know the incoming value matches the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whole prefix: we'd just end up splitting the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> tuple again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;resultType = spgSplitTuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.splitTuple.prefixHasPrefix = in-&gt;hasPrefix;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.splitTuple.prefixPrefixDatum = in-&gt;prefixDatum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.splitTuple.prefixNNodes = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.splitTuple.prefixNodeLabels = (Datum *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.splitTuple.prefixNodeLabels[<span class="Constant">0</span>] = Int16GetDatum(-<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.splitTuple.childNodeN = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.splitTuple.postfixHasPrefix = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add a node for the not-previously-seen nodeChar value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;resultType = spgAddNode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.<a href="spgdoinsert.c.html#L80" title="access/spgist/spgdoinsert.c:80">addNode</a>.nodeLabel = Int16GetDatum(nodeChar);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;result.<a href="spgdoinsert.c.html#L80" title="access/spgist/spgdoinsert.c:80">addNode</a>.nodeN = i;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* qsort comparator to sort <a href="#L87" title="access/spgist/spgtextproc.c:87">spgNodePtr</a> structs by &quot;c&quot; */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L324">&#x200c;</a></span><span class="linkable">cmpNodePtr</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L87" title="access/spgist/spgtextproc.c:87">spgNodePtr</a> *aa = (<span class="Type">const</span> <a href="#L87" title="access/spgist/spgtextproc.c:87">spgNodePtr</a> *) a;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L87" title="access/spgist/spgtextproc.c:87">spgNodePtr</a> *bb = (<span class="Type">const</span> <a href="#L87" title="access/spgist/spgtextproc.c:87">spgNodePtr</a> *) b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_cmp_s16(aa-&gt;c, bb-&gt;c);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L333">&#x200c;</a><span class="linkable">spg_text_picksplit</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; spgPickSplitIn *in = (spgPickSplitIn *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; spgPickSplitOut *out = (spgPickSplitOut *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *text0 = DatumGetTextPP(in-&gt;datums[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commonLen;<br/></li>
<li>&nbsp; &nbsp; <a href="#L87" title="access/spgist/spgtextproc.c:87">spgNodePtr</a> *nodes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Identify <a href="../../regex/rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a> common prefix, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; commonLen = VARSIZE_ANY_EXHDR(text0);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; in-&gt;nTuples &amp;&amp; commonLen &gt; <span class="Constant">0</span>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *texti = DatumGetTextPP(in-&gt;datums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <a href="#L138" title="access/spgist/spgtextproc.c:138">commonPrefix</a>(VARDATA_ANY(text0),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARDATA_ANY(texti),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(text0),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(texti));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tmp &lt; commonLen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commonLen = tmp;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Limit the prefix length, if necessary, to ensure that the resulting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inner tuple will fit on a page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; commonLen = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(commonLen, <a href="#L70" title="access/spgist/spgtextproc.c:70">SPGIST_MAX_PREFIX_LENGTH</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set node prefix to be that string, if it's not empty */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (commonLen == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;hasPrefix = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;hasPrefix = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;prefixDatum = <a href="#L113" title="access/spgist/spgtextproc.c:113">formTextDatum</a>(VARDATA_ANY(text0), commonLen);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract the node label (first non-common byte) from each value */<br/></li>
<li></span>&nbsp; &nbsp; nodes = (<a href="#L87" title="access/spgist/spgtextproc.c:87">spgNodePtr</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L87" title="access/spgist/spgtextproc.c:87">spgNodePtr</a>) * in-&gt;nTuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; in-&gt;nTuples; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *texti = DatumGetTextPP(in-&gt;datums[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (commonLen &lt; VARSIZE_ANY_EXHDR(texti))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodes[i].c = *(<span class="Type">unsigned</span> <span class="Type">char</span> *) (VARDATA_ANY(texti) + commonLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodes[i].c = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* use -1 if string is all common */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nodes[i].i = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nodes[i].d = in-&gt;datums[i];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sort by label <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> so that we can group the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into nodes.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also ensures that the nodes are ordered by label value, allowing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use of binary search in <a href="#L158" title="access/spgist/spgtextproc.c:158">searchChar</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qsort(nodes, in-&gt;nTuples, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*nodes), <a href="#L324" title="access/spgist/spgtextproc.c:324">cmpNodePtr</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And emit results */<br/></li>
<li></span>&nbsp; &nbsp; out-&gt;nNodes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; out-&gt;nodeLabels = (Datum *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * in-&gt;nTuples);<br/></li>
<li>&nbsp; &nbsp; out-&gt;mapTuplesToNodes = (<span class="Type">int</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * in-&gt;nTuples);<br/></li>
<li>&nbsp; &nbsp; out-&gt;leafTupleDatums = (Datum *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * in-&gt;nTuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; in-&gt;nTuples; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *texti = DatumGetTextPP(nodes[i].d);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; leafD;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == <span class="Constant">0</span> || nodes[i].c != nodes[i - <span class="Constant">1</span>].c)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;nodeLabels[out-&gt;nNodes] = Int16GetDatum(nodes[i].c);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;nNodes++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (commonLen &lt; VARSIZE_ANY_EXHDR(texti))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leafD = <a href="#L113" title="access/spgist/spgtextproc.c:113">formTextDatum</a>(VARDATA_ANY(texti) + commonLen + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARSIZE_ANY_EXHDR(texti) - commonLen - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leafD = <a href="#L113" title="access/spgist/spgtextproc.c:113">formTextDatum</a>(<span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;leafTupleDatums[nodes[i].i] = leafD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;mapTuplesToNodes[nodes[i].i] = out-&gt;nNodes - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L426">&#x200c;</a><span class="linkable">spg_text_inner_consistent</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; spgInnerConsistentIn *in = (spgInnerConsistentIn *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; spgInnerConsistentOut *out = (spgInnerConsistentOut *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; collate_is_c = <a href="../../utils/adt/pg_locale.c.html#L1317" title="utils/adt/pg_locale.c:1317">lc_collate_is_c</a>(PG_GET_COLLATION());<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *reconstructedValue;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *reconstrText;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxReconstrLen;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *prefixText = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefixSize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reconstruct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> represented at this tuple, including parent data,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prefix of this tuple if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, and the node label if it's non-dummy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in-&gt;level should be the length of the previously reconstructed value,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and the number of bytes added here is prefixSize or prefixSize + 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we assume that in-&gt;reconstructedValue isn't toasted and doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have a short varlena header.&nbsp; This is okay because it must have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * created by a previous invocation of this routine, and we always emit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * long-format reconstructed <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; reconstructedValue = (text *) DatumGetPointer(in-&gt;reconstructedValue);<br/></li>
<li>&nbsp; &nbsp; Assert(reconstructedValue == <span class="Constant">NULL</span> ? in-&gt;level == <span class="Constant">0</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(reconstructedValue) == in-&gt;level);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxReconstrLen = in-&gt;level + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;hasPrefix)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prefixText = DatumGetTextPP(in-&gt;prefixDatum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prefixSize = VARSIZE_ANY_EXHDR(prefixText);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxReconstrLen += prefixSize;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; reconstrText = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARHDRSZ + maxReconstrLen);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(reconstrText, VARHDRSZ + maxReconstrLen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;level)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(VARDATA(reconstrText),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARDATA(reconstructedValue),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; in-&gt;level);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prefixSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(((<span class="Type">char</span> *) VARDATA(reconstrText)) + in-&gt;level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARDATA_ANY(prefixText),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prefixSize);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* last byte of reconstrText will be filled in below */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan the child nodes.&nbsp; For each one, complete the reconstructed value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and see if it's consistent with the query.&nbsp; If so, emit an entry into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the output arrays.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; out-&gt;nodeNumbers = (<span class="Type">int</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * in-&gt;nNodes);<br/></li>
<li>&nbsp; &nbsp; out-&gt;levelAdds = (<span class="Type">int</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * in-&gt;nNodes);<br/></li>
<li>&nbsp; &nbsp; out-&gt;reconstructedValues = (Datum *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * in-&gt;nNodes);<br/></li>
<li>&nbsp; &nbsp; out-&gt;nNodes = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; in-&gt;nNodes; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; nodeChar = DatumGetInt16(in-&gt;nodeLabels[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisLen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If nodeChar is a dummy value, don't include it in data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nodeChar &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisLen = maxReconstrLen - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">unsigned</span> <span class="Type">char</span> *) VARDATA(reconstrText))[maxReconstrLen - <span class="Constant">1</span>] = nodeChar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisLen = maxReconstrLen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; in-&gt;nkeys; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StrategyNumber strategy = in-&gt;scankeys[j].sk_strategy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *inText;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inSize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a collation-aware operator, but the collation is C, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can treat it as non-collation-aware.&nbsp; With non-C collation we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to traverse whole tree :-( so there's no point in making<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> check here.&nbsp; (Note also that our reconstructed value may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * well end with a partial multibyte character, so that applying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> encoding-sensitive test to it would be risky anyhow.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L83" title="access/spgist/spgtextproc.c:83">SPG_IS_COLLATION_AWARE_STRATEGY</a>(strategy))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (collate_is_c)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strategy -= <a href="#L82" title="access/spgist/spgtextproc.c:82">SPG_STRATEGY_ADDITION</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inText = DatumGetTextPP(in-&gt;scankeys[j].sk_argument);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inSize = VARSIZE_ANY_EXHDR(inText);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = memcmp(VARDATA(reconstrText), VARDATA_ANY(inText),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(inSize, thisLen));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (strategy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r != <span class="Constant">0</span> || inSize &lt; thisLen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTPrefixStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized strategy number: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; in-&gt;scankeys[j].sk_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!res)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no need to consider remaining conditions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;nodeNumbers[out-&gt;nNodes] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;levelAdds[out-&gt;nNodes] = thisLen - in-&gt;level;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(reconstrText, VARHDRSZ + thisLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;reconstructedValues[out-&gt;nNodes] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(PointerGetDatum(reconstrText), <span class="Constant">false</span>, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;nNodes++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L574">&#x200c;</a><span class="linkable">spg_text_leaf_consistent</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; spgLeafConsistentIn *in = (spgLeafConsistentIn *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; spgLeafConsistentOut *out = (spgLeafConsistentOut *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; level = in-&gt;level;<br/></li>
<li>&nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *leafValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *reconstrValue = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *fullValue;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fullLen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* all tests are exact */<br/></li>
<li></span>&nbsp; &nbsp; out-&gt;recheck = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; leafValue = DatumGetTextPP(in-&gt;leafDatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* As above, in-&gt;reconstructedValue isn't toasted or short. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (DatumGetPointer(in-&gt;reconstructedValue))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reconstrValue = (text *) DatumGetPointer(in-&gt;reconstructedValue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(reconstrValue == <span class="Constant">NULL</span> ? level == <span class="Constant">0</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(reconstrValue) == level);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reconstruct the full string represented by this leaf tuple */<br/></li>
<li></span>&nbsp; &nbsp; fullLen = level + VARSIZE_ANY_EXHDR(leafValue);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (VARSIZE_ANY_EXHDR(leafValue) == <span class="Constant">0</span> &amp;&amp; level &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fullValue = VARDATA(reconstrValue);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;leafValue = PointerGetDatum(reconstrValue);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *fullText = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(VARHDRSZ + fullLen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_VARSIZE(fullText, VARHDRSZ + fullLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fullValue = VARDATA(fullText);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (level)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(fullValue, VARDATA(reconstrValue), level);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VARSIZE_ANY_EXHDR(leafValue) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(fullValue + level, VARDATA_ANY(leafValue),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARSIZE_ANY_EXHDR(leafValue));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;leafValue = PointerGetDatum(fullText);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform the required comparison(s) */<br/></li>
<li></span>&nbsp; &nbsp; res = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; in-&gt;nkeys; j++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StrategyNumber strategy = in-&gt;scankeys[j].sk_strategy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *query = DatumGetTextPP(in-&gt;scankeys[j].sk_argument);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryLen = VARSIZE_ANY_EXHDR(query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strategy == RTPrefixStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if level &gt;= length of query then reconstrValue must begin with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query (prefix) string, so we don't need to check it again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = (level &gt;= queryLen) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetBool(<a href="../../utils/fmgr/fmgr.c.html#L812" title="utils/fmgr/fmgr.c:812">DirectFunctionCall2Coll</a>(<a href="../../utils/adt/varlena.c.html#L1791" title="utils/adt/varlena.c:1791">text_starts_with</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; out-&gt;leafValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(query)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!res)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no need to consider remaining conditions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L83" title="access/spgist/spgtextproc.c:83">SPG_IS_COLLATION_AWARE_STRATEGY</a>(strategy))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Collation-aware comparison */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strategy -= <a href="#L82" title="access/spgist/spgtextproc.c:82">SPG_STRATEGY_ADDITION</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If asserts enabled, verify encoding of reconstructed string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../utils/mb/mbutils.c.html#L1556" title="utils/mb/mbutils.c:1556">pg_verifymbstr</a>(fullValue, fullLen, <span class="Constant">false</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = <a href="../../utils/adt/varlena.c.html#L1539" title="utils/adt/varlena.c:1539">varstr_cmp</a>(fullValue, fullLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VARDATA_ANY(query), queryLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_GET_COLLATION());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Non-collation-aware comparison */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = memcmp(fullValue, VARDATA_ANY(query), <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(queryLen, fullLen));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (queryLen &gt; fullLen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (queryLen &lt; fullLen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (strategy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = (r &lt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = (r &lt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = (r == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = (r &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = (r &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized strategy number: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; in-&gt;scankeys[j].sk_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!res)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no need to consider remaining conditions */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(res);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
