<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/spgist/spgvacuum.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/spgist/spgvacuum.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L40">spgBulkDeleteState</a></li>
<li><a href="#L53">spgBulkDeleteState</a></li>
<li><a href="#L32">spgVacPendingItem</a></li>
<li><a href="#L37">spgVacPendingItem</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L925">dummy_callback</a></li>
<li><a href="#L63">spgAddPendingTID</a></li>
<li><a href="#L89">spgClearPendingList</a></li>
<li><a href="#L905">spgbulkdelete</a></li>
<li><a href="#L681">spgprocesspending</a></li>
<li><a href="#L936">spgvacuumcleanup</a></li>
<li><a href="#L610">spgvacuumpage</a></li>
<li><a href="#L793">spgvacuumscan</a></li>
<li><a href="#L125">vacuumLeafPage</a></li>
<li><a href="#L406">vacuumLeafRoot</a></li>
<li><a href="#L491">vacuumRedirectAndPlaceholder</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * spgvacuum.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> for SP-GiST<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src/backend/access/spgist/spgvacuum.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/spgist_private.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/spgxlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/indexfsm.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* Entry in pending-list of TIDs we need to revisit */<br/></li>
<li><a id="L32">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">spgVacPendingItem</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ItemPointerData tid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* redirection target to visit */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; done;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* have we dealt with this? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L32" title="access/spgist/spgvacuum.c:32">spgVacPendingItem</a> *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>; <span class="Comment">/* list link */<br/></li>
<li><a id="L37">&#x200c;</a></span>} <span class="linkable">spgVacPendingItem</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Local state for <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> operations */<br/></li>
<li><a id="L40">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">spgBulkDeleteState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Parameters passed in to <a href="#L793" title="access/spgist/spgvacuum.c:793">spgvacuumscan</a> */<br/></li>
<li></span>&nbsp; &nbsp; IndexVacuumInfo *info;<br/></li>
<li>&nbsp; &nbsp; IndexBulkDeleteResult *stats;<br/></li>
<li>&nbsp; &nbsp; IndexBulkDeleteCallback callback;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *callback_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Additional working state */<br/></li>
<li></span>&nbsp; &nbsp; SpGistState spgstate;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for SPGiST operations that need one */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L32" title="access/spgist/spgvacuum.c:32">spgVacPendingItem</a> *pendingList; <span class="Comment">/* TIDs we need to (re)visit */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId myXmin;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for detecting newly-added redirects */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber lastFilledBlock;&nbsp; &nbsp; <span class="Comment">/* last non-deletable block */<br/></li>
<li><a id="L53">&#x200c;</a></span>} <span class="linkable">spgBulkDeleteState</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add TID to pendingList, but only if not already present.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that new items are always appended at the end of the list; this<br/></li>
<li></span><span class="Comment"> * ensures that scans of the list don't <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> items added during the scan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L63">&#x200c;</a></span><span class="linkable">spgAddPendingTID</span>(<a href="#L40" title="access/spgist/spgvacuum.c:40">spgBulkDeleteState</a> *bds, ItemPointer tid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L32" title="access/spgist/spgvacuum.c:32">spgVacPendingItem</a> *pitem;<br/></li>
<li>&nbsp; &nbsp; <a href="#L32" title="access/spgist/spgvacuum.c:32">spgVacPendingItem</a> **listLink;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* search the list for pre-existing entry */<br/></li>
<li></span>&nbsp; &nbsp; listLink = &amp;bds-&gt;pendingList;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (*listLink != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pitem = *listLink;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(tid, &amp;pitem-&gt;tid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* already in list, do nothing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; listLink = &amp;pitem-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not there, so append new entry */<br/></li>
<li></span>&nbsp; &nbsp; pitem = (<a href="#L32" title="access/spgist/spgvacuum.c:32">spgVacPendingItem</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L32" title="access/spgist/spgvacuum.c:32">spgVacPendingItem</a>));<br/></li>
<li>&nbsp; &nbsp; pitem-&gt;tid = *tid;<br/></li>
<li>&nbsp; &nbsp; pitem-&gt;done = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pitem-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; *listLink = pitem;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Clear pendingList<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L89">&#x200c;</a></span><span class="linkable">spgClearPendingList</span>(<a href="#L40" title="access/spgist/spgvacuum.c:40">spgBulkDeleteState</a> *bds)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L32" title="access/spgist/spgvacuum.c:32">spgVacPendingItem</a> *pitem;<br/></li>
<li>&nbsp; &nbsp; <a href="#L32" title="access/spgist/spgvacuum.c:32">spgVacPendingItem</a> *nitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (pitem = bds-&gt;pendingList; pitem != <span class="Constant">NULL</span>; pitem = nitem)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nitem = pitem-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* All items in list should have been dealt with */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(pitem-&gt;done);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pitem);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; bds-&gt;pendingList = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Vacuum a regular (non-root) leaf page<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We must delete tuples that are targeted for deletion by the VACUUM,<br/></li>
<li></span><span class="Comment"> * but not move <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples that are referenced by outside links; we assume<br/></li>
<li></span><span class="Comment"> * those are the ones that are heads of chains.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a REDIRECT that was made by a concurrently-running transaction,<br/></li>
<li></span><span class="Comment"> * we must add its target TID to pendingList.&nbsp; (We don't try to visit the<br/></li>
<li></span><span class="Comment"> * target immediately, first because we don't want VACUUM locking more than<br/></li>
<li></span><span class="Comment"> * one buffer at a time, and second because the duplicate-filtering logic<br/></li>
<li></span><span class="Comment"> * in <a href="#L63" title="access/spgist/spgvacuum.c:63">spgAddPendingTID</a> is useful to ensure we can't get caught in an infinite<br/></li>
<li></span><span class="Comment"> * loop in the face of continuous concurrent insertions.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If forPending is true, we are examining the page as a consequence of<br/></li>
<li></span><span class="Comment"> * chasing a redirect link, not as part of the normal sequential scan.<br/></li>
<li></span><span class="Comment"> * We still <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> the page normally, but we don't increment the stats<br/></li>
<li></span><span class="Comment"> * about live tuples; else we'd double-count those tuples, since the page<br/></li>
<li></span><span class="Comment"> * has been or will be visited in the sequential scan as well.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L125">&#x200c;</a></span><span class="linkable">vacuumLeafPage</span>(<a href="#L40" title="access/spgist/spgvacuum.c:40">spgBulkDeleteState</a> *bds, Relation index, Buffer buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forPending)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; spgxlogVacuumLeaf xlrec;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber toDead[MaxIndexTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; OffsetNumber toPlaceholder[MaxIndexTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; OffsetNumber moveSrc[MaxIndexTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; OffsetNumber moveDest[MaxIndexTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; OffsetNumber chainSrc[MaxIndexTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; OffsetNumber chainDest[MaxIndexTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; OffsetNumber predecessor[MaxIndexTuplesPerPage + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; deletable[MaxIndexTuplesPerPage + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nDeletable;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max = PageGetMaxOffsetNumber(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(predecessor, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(predecessor));<br/></li>
<li>&nbsp; &nbsp; memset(deletable, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(deletable));<br/></li>
<li>&nbsp; &nbsp; nDeletable = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan page, identify tuples to delete, accumulate stats */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= max; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpGistLeafTuple lt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt = (SpGistLeafTuple) PageGetItem(page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PageGetItemId(page, i));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;tupstate == SPGIST_LIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemPointerIsValid(&amp;lt-&gt;heapPtr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bds-&gt;callback(&amp;lt-&gt;heapPtr, bds-&gt;callback_state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bds-&gt;stats-&gt;tuples_removed += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deletable[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nDeletable++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!forPending)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bds-&gt;stats-&gt;num_index_tuples += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Form predecessor map, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (SGLT_GET_NEXTOFFSET(lt) != InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* paranoia about corrupted chain links */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (SGLT_GET_NEXTOFFSET(lt) &lt; FirstOffsetNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SGLT_GET_NEXTOFFSET(lt) &gt; max ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; predecessor[SGLT_GET_NEXTOFFSET(lt)] != InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;inconsistent tuple chain links in page </span><span class="Special">%u</span><span class="Constant"> of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(index));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; predecessor[SGLT_GET_NEXTOFFSET(lt)] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (lt-&gt;tupstate == SPGIST_REDIRECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpGistDeadTuple dt = (SpGistDeadTuple) lt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(SGLT_GET_NEXTOFFSET(dt) == InvalidOffsetNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemPointerIsValid(&amp;dt-&gt;pointer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add target TID to pending list if the redirection could have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happened since VACUUM started.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we could make a tighter test by seeing if the xid is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;running&quot; according to the active snapshot; but snapmgr.c<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doesn't currently export a suitable API, and it's not entirely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clear that a tighter test is worth the cycles anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(dt-&gt;xid, bds-&gt;myXmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L63" title="access/spgist/spgvacuum.c:63">spgAddPendingTID</a>(bds, &amp;dt-&gt;pointer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(SGLT_GET_NEXTOFFSET(lt) == InvalidOffsetNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nDeletable == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing more to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Figure out exactly what we have to do.&nbsp; We do this separately from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actually modifying the page, mainly so that we have a representation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that can be dumped into WAL and then the replay code can do exactly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same thing.&nbsp; The output of this step consists of six arrays<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * describing four kinds of operations, to be performed in this order:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * toDead[]: tuple numbers to be replaced with DEAD tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * toPlaceholder[]: tuple numbers to be replaced with PLACEHOLDER tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * moveSrc[]: tuple numbers that need to be relocated to another offset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (replacing the tuple there) and then replaced with PLACEHOLDER tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * moveDest[]: new locations for moveSrc tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chainSrc[]: tuple numbers whose chain links (nextOffset) need updates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chainDest[]: new <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of nextOffset for chainSrc members<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's easiest to figure out what we have to do by processing tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chains, so we iterate over all the tuples (not just the deletable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ones!) to identify chain heads, then chase down each chain and make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * work item entries for deletable tuples within the chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; xlrec.nDead = xlrec.nPlaceholder = xlrec.nMove = xlrec.nChain = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= max; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpGistLeafTuple head;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; interveningDeletable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber prevLive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; head = (SpGistLeafTuple) PageGetItem(page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PageGetItemId(page, i));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (head-&gt;tupstate != SPGIST_LIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't be a chain member */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (predecessor[i] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not a chain head */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; interveningDeletable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prevLive = deletable[i] ? InvalidOffsetNumber : i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* scan down the chain ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; j = SGLT_GET_NEXTOFFSET(head);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (j != InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpGistLeafTuple lt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lt = (SpGistLeafTuple) PageGetItem(page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PageGetItemId(page, j));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;tupstate != SPGIST_LIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all tuples in chain should be live */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected SPGiST tuple state: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lt-&gt;tupstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (deletable[j])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This tuple should be replaced by a placeholder */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toPlaceholder[xlrec.nPlaceholder] = j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.nPlaceholder++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* previous live tuple's chain link will need an update */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interveningDeletable = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (prevLive == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is the first live tuple in the chain.&nbsp; It has to move<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the head position.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; moveSrc[xlrec.nMove] = j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; moveDest[xlrec.nMove] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.nMove++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Chain updates will be applied after the move */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevLive = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interveningDeletable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Second or later live tuple.&nbsp; Arrange to re-chain it to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previous live one, if there was a gap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (interveningDeletable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chainSrc[xlrec.nChain] = prevLive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chainDest[xlrec.nChain] = j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.nChain++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevLive = j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interveningDeletable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = SGLT_GET_NEXTOFFSET(lt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prevLive == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The chain is entirely removable, so we need a DEAD tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toDead[xlrec.nDead] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.nDead++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (interveningDeletable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* One or more deletions at end of chain, so close it off */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chainSrc[xlrec.nChain] = prevLive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chainDest[xlrec.nChain] = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.nChain++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity check ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nDeletable != xlrec.nDead + xlrec.nPlaceholder + xlrec.nMove)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;inconsistent counts of deletable tuples&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do the updates */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="spgdoinsert.c.html#L131" title="access/spgist/spgdoinsert.c:131">spgPageIndexMultiDelete</a>(&amp;bds-&gt;spgstate, page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toDead, xlrec.nDead,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SPGIST_DEAD, SPGIST_DEAD,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidBlockNumber, InvalidOffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="spgdoinsert.c.html#L131" title="access/spgist/spgdoinsert.c:131">spgPageIndexMultiDelete</a>(&amp;bds-&gt;spgstate, page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toPlaceholder, xlrec.nPlaceholder,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SPGIST_PLACEHOLDER, SPGIST_PLACEHOLDER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidBlockNumber, InvalidOffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We implement the move step by swapping the line pointers of the source<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and target tuples, then replacing the newly-source tuples with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * placeholders.&nbsp; This is perhaps unduly friendly with the page data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * representation, but it's fast and doesn't risk page overflow when a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple to be relocated is large.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; xlrec.nMove; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; idSrc = PageGetItemId(page, moveSrc[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; idDest = PageGetItemId(page, moveDest[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemIdData&nbsp; &nbsp; tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp = *idSrc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *idSrc = *idDest;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *idDest = tmp;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="spgdoinsert.c.html#L131" title="access/spgist/spgdoinsert.c:131">spgPageIndexMultiDelete</a>(&amp;bds-&gt;spgstate, page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; moveSrc, xlrec.nMove,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SPGIST_PLACEHOLDER, SPGIST_PLACEHOLDER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidBlockNumber, InvalidOffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; xlrec.nChain; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpGistLeafTuple lt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt = (SpGistLeafTuple) PageGetItem(page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PageGetItemId(page, chainSrc[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(lt-&gt;tupstate == SPGIST_LIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SGLT_SET_NEXTOFFSET(lt, chainDest[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(index))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; STORE_STATE(&amp;bds-&gt;spgstate, xlrec.stateSrc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfSpgxlogVacuumLeaf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(xlrec) should be a multiple of <a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(OffsetNumber) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) toDead, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber) * xlrec.nDead);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) toPlaceholder, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber) * xlrec.nPlaceholder);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) moveSrc, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber) * xlrec.nMove);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) moveDest, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber) * xlrec.nMove);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) chainSrc, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber) * xlrec.nChain);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) chainDest, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber) * xlrec.nChain);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buffer, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_SPGIST_ID, XLOG_SPGIST_VACUUM_LEAF);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Vacuum a root page when it is also a leaf<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On the root, we just delete <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dead leaf tuples; no fancy business<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L406">&#x200c;</a></span><span class="linkable">vacuumLeafRoot</span>(<a href="#L40" title="access/spgist/spgvacuum.c:40">spgBulkDeleteState</a> *bds, Relation index, Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; spgxlogVacuumRoot xlrec;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber toDelete[MaxIndexTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; OffsetNumber i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max = PageGetMaxOffsetNumber(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec.nDelete = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan page, identify tuples to delete, accumulate stats */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = FirstOffsetNumber; i &lt;= max; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpGistLeafTuple lt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt = (SpGistLeafTuple) PageGetItem(page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PageGetItemId(page, i));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lt-&gt;tupstate == SPGIST_LIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemPointerIsValid(&amp;lt-&gt;heapPtr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bds-&gt;callback(&amp;lt-&gt;heapPtr, bds-&gt;callback_state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bds-&gt;stats-&gt;tuples_removed += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toDelete[xlrec.nDelete] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.nDelete++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bds-&gt;stats-&gt;num_index_tuples += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all tuples on root should be live */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected SPGiST tuple state: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lt-&gt;tupstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xlrec.nDelete == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing more to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do the update */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The tuple numbers are in order, so we can use <a href="../../storage/page/bufpage.c.html#L1161" title="storage/page/bufpage.c:1161">PageIndexMultiDelete</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1161" title="storage/page/bufpage.c:1161">PageIndexMultiDelete</a>(page, toDelete, xlrec.nDelete);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(index))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepare WAL record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; STORE_STATE(&amp;bds-&gt;spgstate, xlrec.stateSrc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfSpgxlogVacuumRoot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(xlrec) should be a multiple of <a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(OffsetNumber) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) toDelete,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber) * xlrec.nDelete);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buffer, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_SPGIST_ID, XLOG_SPGIST_VACUUM_ROOT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Clean up redirect and placeholder tuples on the given page<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Redirect tuples can be marked placeholder once they're old enough.<br/></li>
<li></span><span class="Comment"> * Placeholder tuples can be removed if it won't change the offsets of<br/></li>
<li></span><span class="Comment"> * non-placeholder ones.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike the routines above, this works on both leaf and inner pages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L491">&#x200c;</a></span><span class="linkable">vacuumRedirectAndPlaceholder</span>(Relation index, Relation heaprel, Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; SpGistPageOpaque opaque = SpGistPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; OffsetNumber i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max = PageGetMaxOffsetNumber(page),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstPlaceholder = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasNonPlaceholder = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasUpdate = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber itemToPlaceholder[MaxIndexTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; OffsetNumber itemnos[MaxIndexTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; spgxlogVacuumRedirect xlrec;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a> *vistest;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec.isCatalogRel = RelationIsAccessibleInLogicalDecoding(heaprel);<br/></li>
<li>&nbsp; &nbsp; xlrec.nToPlaceholder = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; xlrec.snapshotConflictHorizon = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vistest = <a href="../../storage/ipc/procarray.c.html#L4091" title="storage/ipc/procarray.c:4091">GlobalVisTestFor</a>(heaprel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan backwards to convert old redirection tuples to placeholder tuples,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and identify location of last non-placeholder tuple while at it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = max;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; i &gt;= FirstOffsetNumber &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (opaque-&gt;nRedirection &gt; <span class="Constant">0</span> || !hasNonPlaceholder);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpGistDeadTuple dt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dt = (SpGistDeadTuple) PageGetItem(page, PageGetItemId(page, i));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dt-&gt;tupstate == SPGIST_REDIRECT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L4248" title="storage/ipc/procarray.c:4248">GlobalVisTestIsRemovableXid</a>(vistest, dt-&gt;xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dt-&gt;tupstate = SPGIST_PLACEHOLDER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(opaque-&gt;nRedirection &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;nRedirection--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;nPlaceholder++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remember newest XID among the removed redirects */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(xlrec.snapshotConflictHorizon) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xlrec.snapshotConflictHorizon, dt-&gt;xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.snapshotConflictHorizon = dt-&gt;xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSetInvalid(&amp;dt-&gt;pointer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemToPlaceholder[xlrec.nToPlaceholder] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.nToPlaceholder++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasUpdate = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dt-&gt;tupstate == SPGIST_PLACEHOLDER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!hasNonPlaceholder)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstPlaceholder = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hasNonPlaceholder = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Any placeholder tuples at the end of page can safely be removed.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't remove ones <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the last non-placeholder, though, because we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't alter the offset numbers of non-placeholder tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (firstPlaceholder != InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We do not store this array to rdata because it's easy to recreate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = firstPlaceholder; i &lt;= max; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemnos[i - firstPlaceholder] = i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = max - firstPlaceholder + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(opaque-&gt;nPlaceholder &gt;= i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;nPlaceholder -= i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The array is surely sorted, so can use <a href="../../storage/page/bufpage.c.html#L1161" title="storage/page/bufpage.c:1161">PageIndexMultiDelete</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1161" title="storage/page/bufpage.c:1161">PageIndexMultiDelete</a>(page, itemnos, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hasUpdate = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec.firstPlaceholder = firstPlaceholder;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hasUpdate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hasUpdate &amp;&amp; RelationNeedsWAL(index))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfSpgxlogVacuumRedirect);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) itemToPlaceholder,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber) * xlrec.nToPlaceholder);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buffer, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_SPGIST_ID, XLOG_SPGIST_VACUUM_REDIRECT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process one page during a bulkdelete scan<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L610">&#x200c;</a></span><span class="linkable">spgvacuumpage</span>(<a href="#L40" title="access/spgist/spgvacuum.c:40">spgBulkDeleteState</a> *bds, BlockNumber blkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; index = bds-&gt;info-&gt;index;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* call <a href="../../commands/vacuum.c.html#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a> while not holding <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> buffer lock */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(index, MAIN_FORKNUM, blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RBM_NORMAL, bds-&gt;info-&gt;strategy);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We found an all-zero page, which could happen if the database<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * crashed just after extending the file.&nbsp; Recycle it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (PageIsEmpty(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (SpGistPageIsLeaf(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (SpGistBlockIsRoot(blkno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L406" title="access/spgist/spgvacuum.c:406">vacuumLeafRoot</a>(bds, index, buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no need for <a href="#L491" title="access/spgist/spgvacuum.c:491">vacuumRedirectAndPlaceholder</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L125" title="access/spgist/spgvacuum.c:125">vacuumLeafPage</a>(bds, index, buffer, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L491" title="access/spgist/spgvacuum.c:491">vacuumRedirectAndPlaceholder</a>(index, bds-&gt;info-&gt;heaprel, buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* inner page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L491" title="access/spgist/spgvacuum.c:491">vacuumRedirectAndPlaceholder</a>(index, bds-&gt;info-&gt;heaprel, buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The root pages must never be deleted, nor marked as available in FSM,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because we don't want them ever returned by a search for a place to put<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a new tuple.&nbsp; Otherwise, check for empty page, and make sure the FSM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * knows about it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!SpGistBlockIsRoot(blkno))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(page) || PageIsEmpty(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/indexfsm.c.html#L52" title="storage/freespace/indexfsm.c:52">RecordFreeIndexPage</a>(index, blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bds-&gt;stats-&gt;pages_deleted++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="spgutils.c.html#L654" title="access/spgist/spgutils.c:654">SpGistSetLastUsedPage</a>(index, buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bds-&gt;lastFilledBlock = blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process the pending-TID list between pages of the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> scan<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L681">&#x200c;</a></span><span class="linkable">spgprocesspending</span>(<a href="#L40" title="access/spgist/spgvacuum.c:40">spgBulkDeleteState</a> *bds)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; index = bds-&gt;info-&gt;index;<br/></li>
<li>&nbsp; &nbsp; <a href="#L32" title="access/spgist/spgvacuum.c:32">spgVacPendingItem</a> *pitem;<br/></li>
<li>&nbsp; &nbsp; <a href="#L32" title="access/spgist/spgvacuum.c:32">spgVacPendingItem</a> *nitem;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (pitem = bds-&gt;pendingList; pitem != <span class="Constant">NULL</span>; pitem = pitem-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pitem-&gt;done)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore already-done items */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* call <a href="../../commands/vacuum.c.html#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a> while not holding <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> buffer lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* examine the referenced page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; blkno = ItemPointerGetBlockNumber(&amp;pitem-&gt;tid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(index, MAIN_FORKNUM, blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RBM_NORMAL, bds-&gt;info-&gt;strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(page) || SpGistPageIsDeleted(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Probably shouldn't happen, but ignore it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (SpGistPageIsLeaf(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (SpGistBlockIsRoot(blkno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this should definitely not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;redirection leads to root page of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(index));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* deal with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> deletable tuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L125" title="access/spgist/spgvacuum.c:125">vacuumLeafPage</a>(bds, index, buffer, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* might as well do this while we are here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L491" title="access/spgist/spgvacuum.c:491">vacuumRedirectAndPlaceholder</a>(index, bds-&gt;info-&gt;heaprel, buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="spgutils.c.html#L654" title="access/spgist/spgutils.c:654">SpGistSetLastUsedPage</a>(index, buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can mark as done not only this item, but <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> later ones<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointing at the same page, since we vacuumed the whole page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pitem-&gt;done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (nitem = pitem-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>; nitem != <span class="Constant">NULL</span>; nitem = nitem-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemPointerGetBlockNumber(&amp;nitem-&gt;tid) == blkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitem-&gt;done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On an inner page, visit the referenced inner tuple and add all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its downlinks to the pending list.&nbsp; We might have pending items<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for more than one inner tuple on the same page (in fact this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pretty likely given the way space allocation works), so get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them all while we are here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (nitem = pitem; nitem != <span class="Constant">NULL</span>; nitem = nitem-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nitem-&gt;done)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemPointerGetBlockNumber(&amp;nitem-&gt;tid) == blkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpGistInnerTuple innerTuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset = ItemPointerGetOffsetNumber(&amp;nitem-&gt;tid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; innerTuple = (SpGistInnerTuple) PageGetItem(page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageGetItemId(page, offset));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (innerTuple-&gt;tupstate == SPGIST_LIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpGistNodeTuple node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SGITITERATE(innerTuple, i, node)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemPointerIsValid(&amp;node-&gt;t_tid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L63" title="access/spgist/spgvacuum.c:63">spgAddPendingTID</a>(bds, &amp;node-&gt;t_tid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (innerTuple-&gt;tupstate == SPGIST_REDIRECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* transfer attention to redirect point */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L63" title="access/spgist/spgvacuum.c:63">spgAddPendingTID</a>(bds,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;((SpGistDeadTuple) innerTuple)-&gt;pointer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected SPGiST tuple state: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; innerTuple-&gt;tupstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitem-&gt;done = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L89" title="access/spgist/spgvacuum.c:89">spgClearPendingList</a>(bds);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform a bulkdelete scan<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L793">&#x200c;</a></span><span class="linkable">spgvacuumscan</span>(<a href="#L40" title="access/spgist/spgvacuum.c:40">spgBulkDeleteState</a> *bds)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; index = bds-&gt;info-&gt;index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needLock;<br/></li>
<li>&nbsp; &nbsp; BlockNumber num_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finish setting up <a href="#L40" title="access/spgist/spgvacuum.c:40">spgBulkDeleteState</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="spgutils.c.html#L340" title="access/spgist/spgutils.c:340">initSpGistState</a>(&amp;bds-&gt;spgstate, index);<br/></li>
<li>&nbsp; &nbsp; bds-&gt;pendingList = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; bds-&gt;myXmin = <a href="../../utils/time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>()-&gt;xmin;<br/></li>
<li>&nbsp; &nbsp; bds-&gt;lastFilledBlock = SPGIST_LAST_FIXED_BLKNO;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset counts that will be incremented during the scan; needed in case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of multiple scans during a single VACUUM command<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bds-&gt;stats-&gt;estimated_count = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; bds-&gt;stats-&gt;num_index_tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; bds-&gt;stats-&gt;pages_deleted = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> locking for new or temp relations */<br/></li>
<li></span>&nbsp; &nbsp; needLock = !RELATION_IS_LOCAL(index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The outer loop iterates over all index pages except the metapage, in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * physical order (we hope the kernel will cooperate in providing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read-ahead for speed).&nbsp; It is critical that we visit all leaf pages,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * including ones added after we start the scan, else we might fail to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * delete some deletable tuples.&nbsp; See more extensive comments about this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="../nbtree/nbtree.c.html#L926" title="access/nbtree/nbtree.c:926">btvacuumscan</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; blkno = SPGIST_METAPAGE_BLKNO + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the current relation length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L430" title="storage/lmgr/lmgr.c:430">LockRelationForExtension</a>(index, ExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num_pages = RelationGetNumberOfBlocks(index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L480" title="storage/lmgr/lmgr.c:480">UnlockRelationForExtension</a>(index, ExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Quit if we've scanned the whole relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno &gt;= num_pages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Iterate over pages, then loop back to recheck length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; blkno &lt; num_pages; blkno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L610" title="access/spgist/spgvacuum.c:610">spgvacuumpage</a>(bds, blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* empty the pending-list after each page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bds-&gt;pendingList != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L681" title="access/spgist/spgvacuum.c:681">spgprocesspending</a>(bds);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Propagate local lastUsedPages cache to metablock */<br/></li>
<li></span>&nbsp; &nbsp; <a href="spgutils.c.html#L431" title="access/spgist/spgutils.c:431">SpGistUpdateMetaPage</a>(index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we found <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> empty pages (and recorded them in the FSM), then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * forcibly update the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level FSM pages to ensure that searchers can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> them.&nbsp; It's possible that the pages were also found during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previous scans and so this is a waste of time, but it's cheap enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relative to scanning the index that it shouldn't matter much, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * making sure that free pages are available sooner not later seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worthwhile.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that if no empty pages exist, we don't bother vacuuming the FSM at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bds-&gt;stats-&gt;pages_deleted &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/indexfsm.c.html#L71" title="storage/freespace/indexfsm.c:71">IndexFreeSpaceMapVacuum</a>(index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Truncate index if possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> disabled because it's unsafe due to possible concurrent inserts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We'd have to rescan the pages to make sure they're still empty, and it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't seem worth it.&nbsp; Note that btree doesn't do this either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Another reason not to truncate is that it could invalidate the cached<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages-with-freespace pointers in the metapage and other backends'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation caches, that is leave them pointing to nonexistent pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Adding RelationGetNumberOfBlocks calls to protect the places that use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those pointers would be unduly expensive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (num_pages &gt; bds-&gt;lastFilledBlock + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber lastBlock = num_pages - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num_pages = bds-&gt;lastFilledBlock + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/storage.c.html#L288" title="catalog/storage.c:288">RelationTruncate</a>(index, num_pages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bds-&gt;stats-&gt;pages_removed += lastBlock - bds-&gt;lastFilledBlock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bds-&gt;stats-&gt;pages_deleted -= lastBlock - bds-&gt;lastFilledBlock;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report final stats */<br/></li>
<li></span>&nbsp; &nbsp; bds-&gt;stats-&gt;num_pages = num_pages;<br/></li>
<li>&nbsp; &nbsp; bds-&gt;stats-&gt;pages_newly_deleted = bds-&gt;stats-&gt;pages_deleted;<br/></li>
<li>&nbsp; &nbsp; bds-&gt;stats-&gt;pages_free = bds-&gt;stats-&gt;pages_deleted;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Bulk deletion of all index entries pointing to a set of heap tuples.<br/></li>
<li></span><span class="Comment"> * The set of target tuples is specified via a callback routine that tells<br/></li>
<li></span><span class="Comment"> * whether <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> given heap tuple (identified by ItemPointer) is being deleted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Result: a <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d struct containing statistical info for VACUUM displays.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexBulkDeleteResult *<br/></li>
<li><a id="L905">&#x200c;</a><span class="linkable">spgbulkdelete</span>(IndexVacuumInfo *info, IndexBulkDeleteResult *stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexBulkDeleteCallback callback, <span class="Type">void</span> *callback_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L40" title="access/spgist/spgvacuum.c:40">spgBulkDeleteState</a> bds;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate stats if first time through, else re-use existing struct */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stats == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = (IndexBulkDeleteResult *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexBulkDeleteResult));<br/></li>
<li>&nbsp; &nbsp; bds.info = info;<br/></li>
<li>&nbsp; &nbsp; bds.stats = stats;<br/></li>
<li>&nbsp; &nbsp; bds.callback = callback;<br/></li>
<li>&nbsp; &nbsp; bds.callback_state = callback_state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L793" title="access/spgist/spgvacuum.c:793">spgvacuumscan</a>(&amp;bds);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stats;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Dummy callback to delete no tuples during <a href="#L936" title="access/spgist/spgvacuum.c:936">spgvacuumcleanup</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L925">&#x200c;</a></span><span class="linkable">dummy_callback</span>(ItemPointer itemptr, <span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Post-VACUUM <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Result: a <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d struct containing statistical info for VACUUM displays.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexBulkDeleteResult *<br/></li>
<li><a id="L936">&#x200c;</a><span class="linkable">spgvacuumcleanup</span>(IndexVacuumInfo *info, IndexBulkDeleteResult *stats)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L40" title="access/spgist/spgvacuum.c:40">spgBulkDeleteState</a> bds;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No-op in ANALYZE ONLY mode */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (info-&gt;analyze_only)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> stats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't need to scan the index if there was a preceding bulkdelete<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pass.&nbsp; Otherwise, make a pass that won't delete <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> live tuples, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might still accomplish useful stuff with redirect/placeholder <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and/or FSM housekeeping, and in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case will provide stats.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stats == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = (IndexBulkDeleteResult *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexBulkDeleteResult));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bds.info = info;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bds.stats = stats;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bds.callback = <a href="#L925" title="access/spgist/spgvacuum.c:925">dummy_callback</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bds.callback_state = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L793" title="access/spgist/spgvacuum.c:793">spgvacuumscan</a>(&amp;bds);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's quite possible for us to be fooled by concurrent tuple moves into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * double-counting some index tuples, so disbelieve <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> total that exceeds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the underlying heap's count ... if we know that accurately.&nbsp; Otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this might just make matters worse.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!info-&gt;estimated_count)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stats-&gt;num_index_tuples &gt; info-&gt;num_heap_tuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;num_index_tuples = info-&gt;num_heap_tuples;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stats;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
