<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/spgist/spgutils.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/spgist/spgutils.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L115">GetIndexInputType</a></li>
<li><a href="#L550">SpGistGetBuffer</a></li>
<li><a href="#L760">SpGistGetInnerTypeSize</a></li>
<li><a href="#L799">SpGistGetLeafTupleSize</a></li>
<li><a href="#L703">SpGistInitBuffer</a></li>
<li><a href="#L713">SpGistInitMetapage</a></li>
<li><a href="#L689">SpGistInitPage</a></li>
<li><a href="#L375">SpGistNewBuffer</a></li>
<li><a href="#L1185">SpGistPageAddNewItem</a></li>
<li><a href="#L654">SpGistSetLastUsedPage</a></li>
<li><a href="#L431">SpGistUpdateMetaPage</a></li>
<li><a href="#L494">allocNewBuffer</a></li>
<li><a href="#L160">fillTypeDesc</a></li>
<li><a href="#L309">getSpGistTupleDesc</a></li>
<li><a href="#L340">initSpGistState</a></li>
<li><a href="#L778">memcpyInnerDatum</a></li>
<li><a href="#L1097">spgDeformLeafTuple</a></li>
<li><a href="#L1142">spgExtractNodeLabels</a></li>
<li><a href="#L1066">spgFormDeadTuple</a></li>
<li><a href="#L983">spgFormInnerTuple</a></li>
<li><a href="#L852">spgFormLeafTuple</a></li>
<li><a href="#L941">spgFormNodeTuple</a></li>
<li><a href="#L182">spgGetCache</a></li>
<li><a href="#L44">spghandler</a></li>
<li><a href="#L740">spgoptions</a></li>
<li><a href="#L1280">spgproperty</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L471">GET_LUP</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * spgutils.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; various support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for SP-GiST<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src/backend/access/spgist/spgutils.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/<a href="../index/amapi.c.html#L114" title="access/index/amapi.c:114">amvalidate</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/reloptions.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/spgist_private.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/toast_compression.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_amop.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_coerce.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/indexfsm.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/catcache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/index_selfuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SP-GiST handler function: return IndexAmRoutine with access method parameters<br/></li>
<li></span><span class="Comment"> * and callbacks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L44">&#x200c;</a><span class="linkable">spghandler</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexAmRoutine *amroutine = makeNode(IndexAmRoutine);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amstrategies = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsupport = SPGISTNProc;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amoptsprocnum = SPGIST_OPTIONS_PROC;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanorder = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanorderbyop = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanbackward = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanunique = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanmulticol = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amoptionalkey = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsearcharray = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsearchnulls = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amstorage = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amclusterable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ampredlocks = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanparallel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanbuildparallel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcaninclude = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amusemaintenanceworkmem = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsummarizing = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amparallelvacuumoptions =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VACUUM_OPTION_PARALLEL_BULKDEL | VACUUM_OPTION_PARALLEL_COND_CLEANUP;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amkeytype = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambuild = <a href="spginsert.c.html#L73" title="access/spgist/spginsert.c:73">spgbuild</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambuildempty = <a href="spginsert.c.html#L154" title="access/spgist/spginsert.c:154">spgbuildempty</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;aminsert = <a href="spginsert.c.html#L183" title="access/spgist/spginsert.c:183">spginsert</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;aminsertcleanup = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambulkdelete = <a href="spgvacuum.c.html#L905" title="access/spgist/spgvacuum.c:905">spgbulkdelete</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amvacuumcleanup = <a href="spgvacuum.c.html#L936" title="access/spgist/spgvacuum.c:936">spgvacuumcleanup</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanreturn = <a href="spgscan.c.html#L1083" title="access/spgist/spgscan.c:1083">spgcanreturn</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcostestimate = <a href="../../utils/adt/selfuncs.c.html#L7228" title="utils/adt/selfuncs.c:7228">spgcostestimate</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amoptions = <a href="#L740" title="access/spgist/spgutils.c:740">spgoptions</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amproperty = <a href="#L1280" title="access/spgist/spgutils.c:1280">spgproperty</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambuildphasename = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;<a href="../index/amapi.c.html#L114" title="access/index/amapi.c:114">amvalidate</a> = <a href="spgvalidate.c.html#L39" title="access/spgist/spgvalidate.c:39">spgvalidate</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amadjustmembers = <a href="spgvalidate.c.html#L332" title="access/spgist/spgvalidate.c:332">spgadjustmembers</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambeginscan = <a href="spgscan.c.html#L304" title="access/spgist/spgscan.c:304">spgbeginscan</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amrescan = <a href="spgscan.c.html#L380" title="access/spgist/spgscan.c:380">spgrescan</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amgettuple = <a href="spgscan.c.html#L1026" title="access/spgist/spgscan.c:1026">spggettuple</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amgetbitmap = <a href="spgscan.c.html#L942" title="access/spgist/spgscan.c:942">spggetbitmap</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amendscan = <a href="spgscan.c.html#L429" title="access/spgist/spgscan.c:429">spgendscan</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ammarkpos = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amrestrpos = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amestimateparallelscan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;aminitparallelscan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amparallelrescan = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(amroutine);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L115" title="access/spgist/spgutils.c:115">GetIndexInputType</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determine the nominal input data type for an index column<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We define the &quot;nominal&quot; input type as the associated opclass's opcintype,<br/></li>
<li></span><span class="Comment"> * or if that is a polymorphic type, the base type of the heap column or<br/></li>
<li></span><span class="Comment"> * expression that is the index's input.&nbsp; The reason for preferring the<br/></li>
<li></span><span class="Comment"> * opcintype is that non-polymorphic opclasses probably don't want to hear<br/></li>
<li></span><span class="Comment"> * about binary-compatible input types.&nbsp; For instance, if a text opclass<br/></li>
<li></span><span class="Comment"> * is being used with a <a href="../../utils/adt/varchar.c.html#L609" title="utils/adt/varchar.c:609">varchar</a> heap column, we want to report &quot;text&quot; not<br/></li>
<li></span><span class="Comment"> * &quot;<a href="../../utils/adt/varchar.c.html#L609" title="utils/adt/varchar.c:609">varchar</a>&quot;.&nbsp; Likewise, opclasses don't want to hear about domain types,<br/></li>
<li></span><span class="Comment"> * so if we do consult the actual input type, we make sure to flatten domains.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At some point maybe this should go somewhere else, but it's not clear<br/></li>
<li></span><span class="Comment"> * if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other index AMs have a use for it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Oid<br/></li>
<li><a id="L115">&#x200c;</a><span class="linkable">GetIndexInputType</span>(Relation index, AttrNumber indexcol)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcintype;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; heapcol;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexprs;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *indexpr_item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(index-&gt;rd_index != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(indexcol &gt; <span class="Constant">0</span> &amp;&amp; indexcol &lt;= index-&gt;rd_index-&gt;indnkeyatts);<br/></li>
<li>&nbsp; &nbsp; opcintype = index-&gt;rd_opcintype[indexcol - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!IsPolymorphicType(opcintype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> opcintype;<br/></li>
<li>&nbsp; &nbsp; heapcol = index-&gt;rd_index-&gt;indkey.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[indexcol - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (heapcol != <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Simple index column? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/cache/lsyscache.c.html#L2521" title="utils/cache/lsyscache.c:2521">getBaseType</a>(<a href="../../utils/cache/lsyscache.c.html#L913" title="utils/cache/lsyscache.c:913">get_atttype</a>(index-&gt;rd_index-&gt;indrelid, heapcol));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the index expressions are already cached, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/cache/relcache.c.html#L5025" title="utils/cache/relcache.c:5025">RelationGetIndexExpressions</a>, as it will make a copy which is overkill.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're not going to modify the trees, and we're not going to do anything<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that would invalidate the relcache entry <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we're done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;rd_indexprs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexprs = index-&gt;rd_indexprs;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; indexprs = <a href="../../utils/cache/relcache.c.html#L5025" title="utils/cache/relcache.c:5025">RelationGetIndexExpressions</a>(index);<br/></li>
<li>&nbsp; &nbsp; indexpr_item = list_head(indexprs);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">1</span>; i &lt;= index-&gt;rd_index-&gt;indnkeyatts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;rd_index-&gt;indkey.<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i - <span class="Constant">1</span>] == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expression column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexpr_item == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;wrong number of index expressions&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == indexcol)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/cache/lsyscache.c.html#L2521" title="utils/cache/lsyscache.c:2521">getBaseType</a>(<a href="../../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) lfirst(indexpr_item)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexpr_item = lnext(indexprs, indexpr_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;wrong number of index expressions&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Fill in a SpGistTypeDesc struct with info about the specified data type */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L160">&#x200c;</a></span><span class="linkable">fillTypeDesc</span>(SpGistTypeDesc *desc, Oid type)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; Form_pg_type typtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; desc-&gt;type = type;<br/></li>
<li>&nbsp; &nbsp; tp = <a href="../../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(type));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, type);<br/></li>
<li>&nbsp; &nbsp; typtup = (Form_pg_type) GETSTRUCT(tp);<br/></li>
<li>&nbsp; &nbsp; desc-&gt;attlen = typtup-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; desc-&gt;attbyval = typtup-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; desc-&gt;attalign = typtup-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; desc-&gt;attstorage = typtup-&gt;typstorage;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch local cache of AM-specific info about the index, initializing it<br/></li>
<li></span><span class="Comment"> * if necessary<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>SpGistCache *<br/></li>
<li><a id="L182">&#x200c;</a><span class="linkable">spgGetCache</span>(Relation index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpGistCache *cache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;rd_amcache == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atttype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; spgConfigIn in;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *procinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache = <a href="../../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(index-&gt;rd_indexcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SpGistCache));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SPGiST must have one key column and can also have INCLUDE columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(IndexRelationGetNumberOfKeyAttributes(index) == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(IndexRelationGetNumberOfAttributes(index) &lt;= INDEX_MAX_KEYS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get the actual (well, nominal) data type of the key column.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pass this to the opclass config function so that polymorphic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * opclasses are possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; atttype = <a href="#L115" title="access/spgist/spgutils.c:115">GetIndexInputType</a>(index, spgKeyColumn + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Call the config function to get config info for the opclass */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; in.attType = atttype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; procinfo = <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(index, <span class="Constant">1</span>, SPGIST_CONFIG_PROC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(procinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;rd_indcollation[spgKeyColumn],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(&amp;in),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(&amp;cache-&gt;config));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If leafType isn't specified, use the declared index column type,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which index.c will have derived from the opclass's opcintype.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Although we <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> make <a href="spgvalidate.c.html#L39" title="access/spgist/spgvalidate.c:39">spgvalidate</a>.c warn if these aren't the same,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * old user-defined opclasses may not set the STORAGE parameter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * correctly, so believe leafType if it's given.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(cache-&gt;config.leafType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;config.leafType =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDescAttr(RelationGetDescr(index), spgKeyColumn)-&gt;atttypid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If index column type is binary-coercible to atttype (for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * example, it's a domain over atttype), treat it as plain atttype<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to avoid thinking we need to compress.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;config.leafType != atttype &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../parser/parse_coerce.c.html#L2995" title="parser/parse_coerce.c:2995">IsBinaryCoercible</a>(cache-&gt;config.leafType, atttype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;config.leafType = atttype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the information we need about each relevant datatype */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/spgist/spgutils.c:160">fillTypeDesc</a>(&amp;cache-&gt;attType, atttype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cache-&gt;config.leafType != atttype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(<a href="../index/indexam.c.html#L826" title="access/index/indexam.c:826">index_getprocid</a>(index, <span class="Constant">1</span>, SPGIST_COMPRESS_PROC)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;compress method must be defined when leaf type is different from input type&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/spgist/spgutils.c:160">fillTypeDesc</a>(&amp;cache-&gt;attLeafType, cache-&gt;config.leafType);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Save lookups in this common case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;attLeafType = cache-&gt;attType;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/spgist/spgutils.c:160">fillTypeDesc</a>(&amp;cache-&gt;attPrefixType, cache-&gt;config.prefixType);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/spgist/spgutils.c:160">fillTypeDesc</a>(&amp;cache-&gt;attLabelType, cache-&gt;config.labelType);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Finally, if it's a real index (not a partitioned one), get the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lastUsedPages data from the metapage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_INDEX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpGistMetaPageData *metadata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metabuffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(index, SPGIST_METAPAGE_BLKNO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuffer, BUFFER_LOCK_SHARE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metadata = SpGistPageGetMeta(BufferGetPage(metabuffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (metadata-&gt;magicNumber != SPGIST_MAGIC_NUMBER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not an SP-GiST index&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(index));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;lastUsedPages = metadata-&gt;lastUsedPages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(metabuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index-&gt;rd_amcache = (<span class="Type">void</span> *) cache;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* assume it's up to date */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cache = (SpGistCache *) index-&gt;rd_amcache;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cache;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute a tuple descriptor for leaf tuples or index-only-scan result tuples.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can use the relcache's tupdesc as-is in many cases, and it's always<br/></li>
<li></span><span class="Comment"> * OK so far as <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> INCLUDE columns are concerned.&nbsp; However, the entry for<br/></li>
<li></span><span class="Comment"> * the key column has to match leafType in the first case or attType in the<br/></li>
<li></span><span class="Comment"> * second case.&nbsp; While the relcache's tupdesc *should* show leafType, this<br/></li>
<li></span><span class="Comment"> * might not hold for legacy user-defined opclasses, since <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> v14 they<br/></li>
<li></span><span class="Comment"> * were not allowed to declare their true storage type in CREATE OPCLASS.<br/></li>
<li></span><span class="Comment"> * Also, attType can be different from what is in the relcache.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function gives back either a pointer to the relcache's tupdesc<br/></li>
<li></span><span class="Comment"> * if that is suitable, or a <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d copy that's been adjusted to match<br/></li>
<li></span><span class="Comment"> * the specified key column type.&nbsp; We can avoid doing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> catalog lookups<br/></li>
<li></span><span class="Comment"> * here by insisting that the caller pass an SpGistTypeDesc not just an OID.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TupleDesc<br/></li>
<li><a id="L309">&#x200c;</a><span class="linkable">getSpGistTupleDesc</span>(Relation index, SpGistTypeDesc *keyType)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; outTupDesc;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute att;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (keyType-&gt;type ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDescAttr(RelationGetDescr(index), spgKeyColumn)-&gt;atttypid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outTupDesc = RelationGetDescr(index);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; outTupDesc = <a href="../common/tupdesc.c.html#L133" title="access/common/tupdesc.c:133">CreateTupleDescCopy</a>(RelationGetDescr(index));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att = TupleDescAttr(outTupDesc, spgKeyColumn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It's sufficient to update the type-dependent fields of the column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; att-&gt;atttypid = keyType-&gt;type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att-&gt;atttypmod = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attlen = keyType-&gt;attlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attbyval = keyType-&gt;attbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attalign = keyType-&gt;attalign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attstorage = keyType-&gt;attstorage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We shouldn't need to bother with making these valid: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attcompression = InvalidCompressionMethod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att-&gt;attcollation = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In case we changed typlen, we'd better reset following offsets */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = spgFirstIncludeColumn; i &lt; outTupDesc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDescAttr(outTupDesc, i)-&gt;attcacheoff = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> outTupDesc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Initialize SpGistState for working with the given index */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L340">&#x200c;</a></span><span class="linkable">initSpGistState</span>(SpGistState *state, Relation index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpGistCache *cache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;index = index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get cached static information about index */<br/></li>
<li></span>&nbsp; &nbsp; cache = <a href="#L182" title="access/spgist/spgutils.c:182">spgGetCache</a>(index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;config = cache-&gt;config;<br/></li>
<li>&nbsp; &nbsp; state-&gt;attType = cache-&gt;attType;<br/></li>
<li>&nbsp; &nbsp; state-&gt;attLeafType = cache-&gt;attLeafType;<br/></li>
<li>&nbsp; &nbsp; state-&gt;attPrefixType = cache-&gt;attPrefixType;<br/></li>
<li>&nbsp; &nbsp; state-&gt;attLabelType = cache-&gt;attLabelType;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure we have a valid descriptor for leaf tuples */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;leafTupDesc = <a href="#L309" title="access/spgist/spgutils.c:309">getSpGistTupleDesc</a>(state-&gt;index, &amp;state-&gt;attLeafType);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make workspace for constructing dead tuples */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;deadTupleStorage = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(SGDTSIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set XID to use in redirection tuples */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;myXid = <a href="../transam/xact.c.html#L438" title="access/transam/xact.c:438">GetTopTransactionIdIfAny</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assume we're not in an index build (<a href="spginsert.c.html#L73" title="access/spgist/spginsert.c:73">spgbuild</a> will override) */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;isBuild = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate a new page (either by recycling, or by extending the index file).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned buffer is already pinned and exclusive-locked.<br/></li>
<li></span><span class="Comment"> * Caller is responsible for initializing the page by calling <a href="#L703" title="access/spgist/spgutils.c:703">SpGistInitBuffer</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L375">&#x200c;</a><span class="linkable">SpGistNewBuffer</span>(Relation index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First, try to get a page from FSM */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno = <a href="../../storage/freespace/indexfsm.c.html#L38" title="storage/freespace/indexfsm.c:38">GetFreeIndexPage</a>(index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing known to FSM */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The fixed pages shouldn't ever be listed in FSM, but just in case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one is, ignore it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (SpGistBlockIsFixed(blkno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(index, blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to guard against the possibility that someone else already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recycled this page; the buffer may be locked if so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/buffer/bufmgr.c.html#L5111" title="storage/buffer/bufmgr.c:5111">ConditionalLockBuffer</a>(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buffer;&nbsp; &nbsp; <span class="Comment">/* OK to use, if never initialized */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (SpGistPageIsDeleted(page) || PageIsEmpty(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buffer;&nbsp; &nbsp; <span class="Comment">/* OK to use */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't use it, so release buffer and try again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L845" title="storage/buffer/bufmgr.c:845">ExtendBufferedRel</a>(BMR_REL(index), MAIN_FORKNUM, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EB_LOCK_FIRST);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update index metapage's lastUsedPages info from local cache, if possible<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Updating meta page isn't critical for index working, so<br/></li>
<li></span><span class="Comment"> * 1 use <a href="../../storage/buffer/bufmgr.c.html#L5111" title="storage/buffer/bufmgr.c:5111">ConditionalLockBuffer</a> to improve concurrency<br/></li>
<li></span><span class="Comment"> * 2 don't WAL-log metabuffer changes to decrease WAL traffic<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L431">&#x200c;</a></span><span class="linkable">SpGistUpdateMetaPage</span>(Relation index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpGistCache *cache = (SpGistCache *) index-&gt;rd_amcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cache != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metabuffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(index, SPGIST_METAPAGE_BLKNO);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/buffer/bufmgr.c.html#L5111" title="storage/buffer/bufmgr.c:5111">ConditionalLockBuffer</a>(metabuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; metapage = BufferGetPage(metabuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpGistMetaPageData *metadata = SpGistPageGetMeta(metapage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metadata-&gt;lastUsedPages = cache-&gt;lastUsedPages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set pd_lower just past the end of the metadata.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * essential, because without doing so, metadata will be lost if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xlog.c compresses the page.&nbsp; (We must do this here because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pre-v11 versions of PG did not set the metapage's pd_lower<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * correctly, so a pg_upgraded index might contain the wrong<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((PageHeader) metapage)-&gt;pd_lower =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">char</span> *) metadata + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SpGistMetaPageData)) - (<span class="Type">char</span> *) metapage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(metabuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(metabuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(metabuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Macro to <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> proper <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of lastUsedPages cache depending on flags */<br/></li>
<li></span><span class="Comment">/* Masking flags with SPGIST_CACHED_PAGES is just for paranoia's sake */<br/></li>
<li><a id="L471">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">GET_LUP</span>(c, f)&nbsp; (&amp;(c)-&gt;lastUsedPages.cachedPage[((</span><span class="Type">unsigned</span><span class="PreProc"> </span><span class="Type">int</span><span class="PreProc">) (f)) % SPGIST_CACHED_PAGES])<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a new buffer of the type and parity specified by<br/></li>
<li></span><span class="Comment"> * flags.&nbsp; The returned buffer is already pinned and exclusive-locked.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When requesting an inner page, if we get one with the wrong parity,<br/></li>
<li></span><span class="Comment"> * we just release the buffer and try again.&nbsp; We will get a different page<br/></li>
<li></span><span class="Comment"> * because <a href="../../storage/freespace/indexfsm.c.html#L38" title="storage/freespace/indexfsm.c:38">GetFreeIndexPage</a> will have marked the page used in FSM.&nbsp; The page<br/></li>
<li></span><span class="Comment"> * is entered in our local lastUsedPages cache, so there's some hope of<br/></li>
<li></span><span class="Comment"> * making use of it later in this session, but otherwise we rely on VACUUM<br/></li>
<li></span><span class="Comment"> * to eventually re-enter the page in FSM, making it available for recycling.<br/></li>
<li></span><span class="Comment"> * Note that such a page does not get marked dirty here, so unless it's used<br/></li>
<li></span><span class="Comment"> * fairly soon, the buffer will just get discarded and the page will remain<br/></li>
<li></span><span class="Comment"> * as it was on disk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When we return a buffer to the caller, the page is *not* entered into<br/></li>
<li></span><span class="Comment"> * the lastUsedPages cache; we expect the caller will do so after it's taken<br/></li>
<li></span><span class="Comment"> * whatever space it will use.&nbsp; This is because after the caller has used up<br/></li>
<li></span><span class="Comment"> * some space, the page might have less space than whatever was cached already<br/></li>
<li></span><span class="Comment"> * so we'd rather not trash the old cache entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Buffer<br/></li>
<li><a id="L494">&#x200c;</a><span class="linkable">allocNewBuffer</span>(Relation index, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpGistCache *cache = <a href="#L182" title="access/spgist/spgutils.c:182">spgGetCache</a>(index);<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; pageflags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (GBUF_REQ_LEAF(flags))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageflags |= SPGIST_LEAF;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (GBUF_REQ_NULLS(flags))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageflags |= SPGIST_NULLS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="#L375" title="access/spgist/spgutils.c:375">SpGistNewBuffer</a>(index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L703" title="access/spgist/spgutils.c:703">SpGistInitBuffer</a>(buffer, pageflags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pageflags &amp; SPGIST_LEAF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Leaf pages have no parity concerns, so just use it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkFlags = GBUF_INNER_PARITY(blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; GBUF_PARITY_MASK) == blkFlags)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Page has right parity, use it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Page has wrong parity, record it in cache and try again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pageflags &amp; SPGIST_NULLS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkFlags |= GBUF_NULLS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;lastUsedPages.cachedPage[blkFlags].blkno = blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache-&gt;lastUsedPages.cachedPage[blkFlags].freeSpace =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L958" title="storage/page/bufpage.c:958">PageGetExactFreeSpace</a>(BufferGetPage(buffer));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get a buffer of the type and parity specified by flags, having at least<br/></li>
<li></span><span class="Comment"> * as much free space as indicated by needSpace.&nbsp; We use the lastUsedPages<br/></li>
<li></span><span class="Comment"> * cache to assign the same buffer previously requested when possible.<br/></li>
<li></span><span class="Comment"> * The returned buffer is already pinned and exclusive-locked.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *isNew is set true if the page was initialized here, false if it was<br/></li>
<li></span><span class="Comment"> * already valid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L550">&#x200c;</a><span class="linkable">SpGistGetBuffer</span>(Relation index, <span class="Type">int</span> flags, <span class="Type">int</span> needSpace, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isNew)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpGistCache *cache = <a href="#L182" title="access/spgist/spgutils.c:182">spgGetCache</a>(index);<br/></li>
<li>&nbsp; &nbsp; SpGistLastUsedPage *lup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Bail out if even an empty page wouldn't meet the demand */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (needSpace &gt; SPGIST_PAGE_CAPACITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;desired SPGiST tuple size is too big&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If possible, increase the space request to include relation's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fillfactor.&nbsp; This ensures that when we add unrelated tuples to a page,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we try to keep 100-fillfactor% available for adding tuples that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * related to the ones already on it.&nbsp; But fillfactor mustn't cause an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error for requests that would otherwise be legal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; needSpace += SpGistGetTargetPageFreeSpace(index);<br/></li>
<li>&nbsp; &nbsp; needSpace = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(needSpace, SPGIST_PAGE_CAPACITY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the cache entry for this flags setting */<br/></li>
<li></span>&nbsp; &nbsp; lup = <a href="#L471" title="access/spgist/spgutils.c:471">GET_LUP</a>(cache, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we have nothing cached, just turn it over to <a href="#L494" title="access/spgist/spgutils.c:494">allocNewBuffer</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lup-&gt;blkno == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isNew = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L494" title="access/spgist/spgutils.c:494">allocNewBuffer</a>(index, flags);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fixed pages should never be in cache */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!SpGistBlockIsFixed(lup-&gt;blkno));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If cached freeSpace isn't enough, don't bother looking at the page */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lup-&gt;freeSpace &gt;= needSpace)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(index, lup-&gt;blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/buffer/bufmgr.c.html#L5111" title="storage/buffer/bufmgr.c:5111">ConditionalLockBuffer</a>(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffer is locked by another process, so return a new buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isNew = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L494" title="access/spgist/spgutils.c:494">allocNewBuffer</a>(index, flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(page) || SpGistPageIsDeleted(page) || PageIsEmpty(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; pageflags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GBUF_REQ_LEAF(flags))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageflags |= SPGIST_LEAF;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GBUF_REQ_NULLS(flags))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageflags |= SPGIST_NULLS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L703" title="access/spgist/spgutils.c:703">SpGistInitBuffer</a>(buffer, pageflags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lup-&gt;freeSpace = <a href="../../storage/page/bufpage.c.html#L958" title="storage/page/bufpage.c:958">PageGetExactFreeSpace</a>(page) - needSpace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isNew = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that page is of right type and has enough space.&nbsp; We must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recheck this since our cache isn't necessarily up to date.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((GBUF_REQ_LEAF(flags) ? SpGistPageIsLeaf(page) : !SpGistPageIsLeaf(page)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (GBUF_REQ_NULLS(flags) ? SpGistPageStoresNulls(page) : !SpGistPageStoresNulls(page)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freeSpace = <a href="../../storage/page/bufpage.c.html#L958" title="storage/page/bufpage.c:958">PageGetExactFreeSpace</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (freeSpace &gt;= needSpace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Success, update freespace info and return the buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lup-&gt;freeSpace = freeSpace - needSpace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *isNew = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fallback to allocation of new buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No success with cache, so return a new buffer */<br/></li>
<li></span>&nbsp; &nbsp; *isNew = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L494" title="access/spgist/spgutils.c:494">allocNewBuffer</a>(index, flags);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update lastUsedPages cache when done modifying a page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We update the appropriate cache entry if it already contained this page<br/></li>
<li></span><span class="Comment"> * (its freeSpace is likely obsolete), or if this page has more space than<br/></li>
<li></span><span class="Comment"> * whatever we had cached.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L654">&#x200c;</a></span><span class="linkable">SpGistSetLastUsedPage</span>(Relation index, Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpGistCache *cache = <a href="#L182" title="access/spgist/spgutils.c:182">spgGetCache</a>(index);<br/></li>
<li>&nbsp; &nbsp; SpGistLastUsedPage *lup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freeSpace;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Never enter fixed pages (root pages) in cache, though */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (SpGistBlockIsFixed(blkno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (SpGistPageIsLeaf(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags = GBUF_LEAF;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; flags = GBUF_INNER_PARITY(blkno);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (SpGistPageStoresNulls(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags |= GBUF_NULLS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lup = <a href="#L471" title="access/spgist/spgutils.c:471">GET_LUP</a>(cache, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; freeSpace = <a href="../../storage/page/bufpage.c.html#L958" title="storage/page/bufpage.c:958">PageGetExactFreeSpace</a>(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lup-&gt;blkno == InvalidBlockNumber || lup-&gt;blkno == blkno ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lup-&gt;freeSpace &lt; freeSpace)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lup-&gt;blkno = blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lup-&gt;freeSpace = freeSpace;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize an SPGiST page to empty, with specified flags<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L689">&#x200c;</a></span><span class="linkable">SpGistInitPage</span>(Page page, uint16 f)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpGistPageOpaque opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L42" title="storage/page/bufpage.c:42">PageInit</a>(page, BLCKSZ, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SpGistPageOpaqueData));<br/></li>
<li>&nbsp; &nbsp; opaque = SpGistPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; opaque-&gt;flags = f;<br/></li>
<li>&nbsp; &nbsp; opaque-&gt;spgist_page_id = SPGIST_PAGE_ID;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize a buffer's page to empty, with specified flags<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L703">&#x200c;</a></span><span class="linkable">SpGistInitBuffer</span>(Buffer b, uint16 f)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(BufferGetPageSize(b) == BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; <a href="#L689" title="access/spgist/spgutils.c:689">SpGistInitPage</a>(BufferGetPage(b), f);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize metadata page<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L713">&#x200c;</a></span><span class="linkable">SpGistInitMetapage</span>(Page page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpGistMetaPageData *metadata;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L689" title="access/spgist/spgutils.c:689">SpGistInitPage</a>(page, SPGIST_META);<br/></li>
<li>&nbsp; &nbsp; metadata = SpGistPageGetMeta(page);<br/></li>
<li>&nbsp; &nbsp; memset(metadata, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SpGistMetaPageData));<br/></li>
<li>&nbsp; &nbsp; metadata-&gt;magicNumber = SPGIST_MAGIC_NUMBER;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> last-used-page cache to empty */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; SPGIST_CACHED_PAGES; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metadata-&gt;lastUsedPages.cachedPage[i].blkno = InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set pd_lower just past the end of the metadata.&nbsp; This is essential,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because without doing so, metadata will be lost if xlog.c compresses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ((PageHeader) page)-&gt;pd_lower =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">char</span> *) metadata + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SpGistMetaPageData)) - (<span class="Type">char</span> *) page;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * reloptions processing for SPGiST<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>bytea *<br/></li>
<li><a id="L740">&#x200c;</a><span class="linkable">spgoptions</span>(Datum reloptions, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> validate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> relopt_parse_elt tab[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<span class="Constant">&quot;fillfactor&quot;</span>, RELOPT_TYPE_INT, offsetof(SpGistOptions, fillfactor)},<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (bytea *) <a href="../common/reloptions.c.html#L1908" title="access/common/reloptions.c:1908">build_reloptions</a>(reloptions, validate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RELOPT_KIND_SPGIST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SpGistOptions),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab, lengthof(tab));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the space needed to store a non-null datum of the indicated type<br/></li>
<li></span><span class="Comment"> * in an inner tuple (that is, as a prefix or node label).<br/></li>
<li></span><span class="Comment"> * Note the result is already rounded up to a MAXALIGN boundary.<br/></li>
<li></span><span class="Comment"> * Here we follow the convention that pass-by-val types are just stored<br/></li>
<li></span><span class="Comment"> * in their Datum representation (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> <a href="#L778" title="access/spgist/spgutils.c:778">memcpyInnerDatum</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">unsigned</span> <span class="Type">int<br/></li>
<li><a id="L760">&#x200c;</a></span><span class="linkable">SpGistGetInnerTypeSize</span>(SpGistTypeDesc *att, Datum datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attbyval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (att-&gt;attlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size = att-&gt;attlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; size = VARSIZE_ANY(datum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> MAXALIGN(size);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy the given non-null datum to *target, in the inner-tuple case<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L778">&#x200c;</a></span><span class="linkable">memcpyInnerDatum</span>(<span class="Type">void</span> *target, SpGistTypeDesc *att, Datum datum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (att-&gt;attbyval)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(target, &amp;datum, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size = (att-&gt;attlen &gt; <span class="Constant">0</span>) ? att-&gt;attlen : VARSIZE_ANY(datum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(target, DatumGetPointer(datum), size);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute space required for a leaf tuple holding the given data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This must match the size-calculation portion of <a href="#L852" title="access/spgist/spgutils.c:852">spgFormLeafTuple</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L799">&#x200c;</a><span class="linkable">SpGistGetLeafTupleSize</span>(TupleDesc tupleDescriptor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> Datum *datums, <span class="Type">const</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnulls)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; data_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needs_null_mask = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts = tupleDescriptor-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Decide whether we need a nulls bitmask.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is only a key attribute (natts == 1), never use a bitmask, for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compatibility with the pre-v14 layout of leaf tuples.&nbsp; Otherwise, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need one if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> attribute is null.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (natts &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needs_null_mask = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate size of the data part; same as for heap tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; data_size = <a href="../common/heaptuple.c.html#L215" title="access/common/heaptuple.c:215">heap_compute_data_size</a>(tupleDescriptor, datums, isnulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute total size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; size = SGLTHDRSZ(needs_null_mask);<br/></li>
<li>&nbsp; &nbsp; size += data_size;<br/></li>
<li>&nbsp; &nbsp; size = MAXALIGN(size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure that we can replace the tuple with a dead tuple later. This test<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is unnecessary when there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-null attributes, but be safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (size &lt; SGDTSIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size = SGDTSIZE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Construct a leaf tuple containing the given heap TID and datum <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>SpGistLeafTuple<br/></li>
<li><a id="L852">&#x200c;</a><span class="linkable">spgFormLeafTuple</span>(SpGistState *state, ItemPointer heapPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> Datum *datums, <span class="Type">const</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnulls)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpGistLeafTuple tup;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupleDescriptor = state-&gt;leafTupDesc;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; hoff;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; data_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needs_null_mask = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts = tupleDescriptor-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ptr to tuple data */<br/></li>
<li></span>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; tupmask = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* unused <a href="../common/heaptuple.c.html#L400" title="access/common/heaptuple.c:400">heap_fill_tuple</a> output */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Decide whether we need a nulls bitmask.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is only a key attribute (natts == 1), never use a bitmask, for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compatibility with the pre-v14 layout of leaf tuples.&nbsp; Otherwise, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need one if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> attribute is null.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (natts &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isnulls[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needs_null_mask = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate size of the data part; same as for heap tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; data_size = <a href="../common/heaptuple.c.html#L215" title="access/common/heaptuple.c:215">heap_compute_data_size</a>(tupleDescriptor, datums, isnulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute total size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hoff = SGLTHDRSZ(needs_null_mask);<br/></li>
<li>&nbsp; &nbsp; size = hoff + data_size;<br/></li>
<li>&nbsp; &nbsp; size = MAXALIGN(size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure that we can replace the tuple with a dead tuple later. This test<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is unnecessary when there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-null attributes, but be safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (size &lt; SGDTSIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size = SGDTSIZE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, form the tuple */<br/></li>
<li></span>&nbsp; &nbsp; tup = (SpGistLeafTuple) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tup-&gt;size = size;<br/></li>
<li>&nbsp; &nbsp; SGLT_SET_NEXTOFFSET(tup, InvalidOffsetNumber);<br/></li>
<li>&nbsp; &nbsp; tup-&gt;heapPtr = *heapPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = (<span class="Type">char</span> *) tup + hoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (needs_null_mask)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *bp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ptr to null bitmap in tuple */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set nullmask presence <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in SpGistLeafTuple header */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SGLT_SET_HASNULLMASK(tup, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fill the data area and null mask */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; bp = (bits8 *) ((<span class="Type">char</span> *) tup + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SpGistLeafTupleData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/heaptuple.c.html#L400" title="access/common/heaptuple.c:400">heap_fill_tuple</a>(tupleDescriptor, datums, isnulls, tp, data_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tupmask, bp);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (natts &gt; <span class="Constant">1</span> || !isnulls[spgKeyColumn])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fill data area only */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/heaptuple.c.html#L400" title="access/common/heaptuple.c:400">heap_fill_tuple</a>(tupleDescriptor, datums, isnulls, tp, data_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;tupmask, (bits8 *) <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* otherwise we have no data, nor a bitmap, to fill */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tup;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Construct a node (to go into an inner tuple) containing the given label<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the node's downlink is just set invalid here.&nbsp; Caller will fill<br/></li>
<li></span><span class="Comment"> * it in later.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>SpGistNodeTuple<br/></li>
<li><a id="L941">&#x200c;</a><span class="linkable">spgFormNodeTuple</span>(SpGistState *state, Datum label, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpGistNodeTuple tup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">short</span> infomask = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* compute space needed (note result is already maxaligned) */<br/></li>
<li></span>&nbsp; &nbsp; size = SGNTHDRSZ;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size += <a href="#L760" title="access/spgist/spgutils.c:760">SpGistGetInnerTypeSize</a>(&amp;state-&gt;attLabelType, label);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Here we make sure that the size will fit in the field reserved for it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in t_info.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((size &amp; INDEX_SIZE_MASK) != size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index row requires </span><span class="Special">%zu</span><span class="Constant"> bytes, maximum size is </span><span class="Special">%zu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Size) size, (Size) INDEX_SIZE_MASK)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tup = (SpGistNodeTuple) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; infomask |= INDEX_NULL_MASK;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't bother setting the INDEX_VAR_MASK <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> */<br/></li>
<li></span>&nbsp; &nbsp; infomask |= size;<br/></li>
<li>&nbsp; &nbsp; tup-&gt;t_info = infomask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The TID field will be filled in later */<br/></li>
<li></span>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;tup-&gt;t_tid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L778" title="access/spgist/spgutils.c:778">memcpyInnerDatum</a>(SGNTDATAPTR(tup), &amp;state-&gt;attLabelType, label);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tup;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Construct an inner tuple containing the given prefix and node array<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>SpGistInnerTuple<br/></li>
<li><a id="L983">&#x200c;</a><span class="linkable">spgFormInnerTuple</span>(SpGistState *state, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> hasPrefix, Datum prefix,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nNodes, SpGistNodeTuple *nodes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpGistInnerTuple tup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> prefixSize;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute size needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hasPrefix)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prefixSize = <a href="#L760" title="access/spgist/spgutils.c:760">SpGistGetInnerTypeSize</a>(&amp;state-&gt;attPrefixType, prefix);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; prefixSize = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = SGITHDRSZ + prefixSize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note: we rely on node tuple sizes to be maxaligned already */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nNodes; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size += IndexTupleSize(nodes[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure that we can replace the tuple with a dead tuple later.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * test is unnecessary given current tuple layouts, but let's be safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (size &lt; SGDTSIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; size = SGDTSIZE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Inner tuple should be small enough to fit on a page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (size &gt; SPGIST_PAGE_CAPACITY - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;SP-GiST inner tuple size </span><span class="Special">%zu</span><span class="Constant"> exceeds maximum </span><span class="Special">%zu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Size) size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SPGIST_PAGE_CAPACITY - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Values larger than a buffer page cannot be indexed.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for overflow of header fields --- probably can't fail if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above succeeded, but let's be paranoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (size &gt; SGITMAXSIZE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prefixSize &gt; SGITMAXPREFIXSIZE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nNodes &gt; SGITMAXNNODES)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;SPGiST inner tuple header field is too small&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, form the tuple */<br/></li>
<li></span>&nbsp; &nbsp; tup = (SpGistInnerTuple) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tup-&gt;nNodes = nNodes;<br/></li>
<li>&nbsp; &nbsp; tup-&gt;prefixSize = prefixSize;<br/></li>
<li>&nbsp; &nbsp; tup-&gt;size = size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hasPrefix)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L778" title="access/spgist/spgutils.c:778">memcpyInnerDatum</a>(SGITDATAPTR(tup), &amp;state-&gt;attPrefixType, prefix);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ptr = (<span class="Type">char</span> *) SGITNODEPTR(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nNodes; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpGistNodeTuple node = nodes[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, node, IndexTupleSize(node));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += IndexTupleSize(node);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tup;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Construct a &quot;dead&quot; tuple to replace a tuple being deleted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The state can be SPGIST_REDIRECT, SPGIST_DEAD, or SPGIST_PLACEHOLDER.<br/></li>
<li></span><span class="Comment"> * For a REDIRECT tuple, a pointer (blkno+offset) must be supplied, and<br/></li>
<li></span><span class="Comment"> * the xid field is filled in automatically.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called in critical sections, so we don't use <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>; the tuple<br/></li>
<li></span><span class="Comment"> * is built in preallocated storage.&nbsp; It should be copied <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> another<br/></li>
<li></span><span class="Comment"> * call with different parameters can occur.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>SpGistDeadTuple<br/></li>
<li><a id="L1066">&#x200c;</a><span class="linkable">spgFormDeadTuple</span>(SpGistState *state, <span class="Type">int</span> tupstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber blkno, OffsetNumber offnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpGistDeadTuple tuple = (SpGistDeadTuple) state-&gt;deadTupleStorage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple-&gt;tupstate = tupstate;<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;size = SGDTSIZE;<br/></li>
<li>&nbsp; &nbsp; SGLT_SET_NEXTOFFSET(tuple, InvalidOffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tupstate == SPGIST_REDIRECT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSet(&amp;tuple-&gt;pointer, blkno, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsValid(state-&gt;myXid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple-&gt;xid = state-&gt;myXid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSetInvalid(&amp;tuple-&gt;pointer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple-&gt;xid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert an SPGiST leaf tuple into Datum/isnull arrays.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must allocate sufficient storage for the output arrays.<br/></li>
<li></span><span class="Comment"> * (INDEX_MAX_KEYS entries should be enough.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1097">&#x200c;</a></span><span class="linkable">spgDeformLeafTuple</span>(SpGistLeafTuple tup, TupleDesc tupleDescriptor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *datums, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnulls, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> keyColumnIsNull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasNullsMask = SGLT_GET_HASNULLMASK(tup);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ptr to tuple data */<br/></li>
<li></span>&nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *bp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ptr to null bitmap in tuple */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (keyColumnIsNull &amp;&amp; tupleDescriptor-&gt;natts == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Trivial case: there is only the key attribute and we're in a nulls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tree.&nbsp; The hasNullsMask <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in the tuple header should not be set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (and thus we can't use <a href="../common/indextuple.c.html#L479" title="access/common/indextuple.c:479">index_deform_tuple_internal</a>), but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nonetheless the result is NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: currently this is dead code, because noplace calls this when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there is only the key attribute.&nbsp; But we should cover the case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!hasNullsMask);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datums[spgKeyColumn] = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isnulls[spgKeyColumn] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp = (<span class="Type">char</span> *) tup + SGLTHDRSZ(hasNullsMask);<br/></li>
<li>&nbsp; &nbsp; bp = (bits8 *) ((<span class="Type">char</span> *) tup + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SpGistLeafTupleData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../common/indextuple.c.html#L479" title="access/common/indextuple.c:479">index_deform_tuple_internal</a>(tupleDescriptor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datums, isnulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tp, bp, hasNullsMask);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Key column isnull value from the tuple should be consistent with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keyColumnIsNull flag from the caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(keyColumnIsNull == isnulls[spgKeyColumn]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract the label datums of the nodes within innerTuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns NULL if label datums are NULLs<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum *<br/></li>
<li><a id="L1142">&#x200c;</a><span class="linkable">spgExtractNodeLabels</span>(SpGistState *state, SpGistInnerTuple innerTuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *nodeLabels;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; SpGistNodeTuple node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Either all the labels must be NULL, or <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>. */<br/></li>
<li></span>&nbsp; &nbsp; node = SGITNODEPTR(innerTuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IndexTupleHasNulls(node))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SGITITERATE(innerTuple, i, node)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IndexTupleHasNulls(node))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;some but not all node labels are null in SPGiST inner tuple&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* They're all null, so just return NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nodeLabels = (Datum *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * innerTuple-&gt;nNodes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SGITITERATE(innerTuple, i, node)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IndexTupleHasNulls(node))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;some but not all node labels are null in SPGiST inner tuple&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nodeLabels[i] = SGNTDATUM(node, state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> nodeLabels;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add a new item to the page, replacing a PLACEHOLDER item if possible.<br/></li>
<li></span><span class="Comment"> * Return the location it's inserted at, or InvalidOffsetNumber on failure.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If startOffset isn't NULL, we start searching for placeholders at<br/></li>
<li></span><span class="Comment"> * *startOffset, and update that to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> place to search.&nbsp; This is just<br/></li>
<li></span><span class="Comment"> * an optimization for repeated insertions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If errorOK is false, we throw error when there's not enough room,<br/></li>
<li></span><span class="Comment"> * rather than returning InvalidOffsetNumber.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>OffsetNumber<br/></li>
<li><a id="L1185">&#x200c;</a><span class="linkable">SpGistPageAddNewItem</span>(SpGistState *state, Page page, Item item, Size size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber *startOffset, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> errorOK)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpGistPageOpaque opaque = SpGistPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; OffsetNumber i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (opaque-&gt;nPlaceholder &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L958" title="storage/page/bufpage.c:958">PageGetExactFreeSpace</a>(page) + SGDTSIZE &gt;= MAXALIGN(size))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to replace a placeholder */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offnum = InvalidOffsetNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (startOffset &amp;&amp; *startOffset != InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = *startOffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; i &lt;= maxoff; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpGistDeadTuple it = (SpGistDeadTuple) PageGetItem(page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PageGetItemId(page, i));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (it-&gt;tupstate == SPGIST_PLACEHOLDER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done if we found a placeholder */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum != InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (startOffset &amp;&amp; *startOffset != InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Hint was no good, re-search from beginning */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *startOffset = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Hmm, no placeholder found? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;nPlaceholder = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum != InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Replace the placeholder tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1052" title="storage/page/bufpage.c:1052">PageIndexTupleDelete</a>(page, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = PageAddItem(page, item, size, offnum, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should not have failed given the size check at the top of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the function, but test anyway.&nbsp; If we did fail, we must PANIC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because we've already deleted the placeholder tuple, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there's no other way to keep the damage from getting to disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum != InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(opaque-&gt;nPlaceholder &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;nPlaceholder--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (startOffset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *startOffset = offnum + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;failed to add item of size </span><span class="Special">%zu</span><span class="Constant"> to SPGiST index page&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No luck in replacing a placeholder, so just add it to the page */<br/></li>
<li></span>&nbsp; &nbsp; offnum = PageAddItem(page, item, size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOffsetNumber, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (offnum == InvalidOffsetNumber &amp;&amp; !errorOK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add item of size </span><span class="Special">%zu</span><span class="Constant"> to SPGiST index page&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> offnum;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1280" title="access/spgist/spgutils.c:1280">spgproperty</a>() -- Check boolean properties of indexes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is optional for most AMs, but is required for SP-GiST because the core<br/></li>
<li></span><span class="Comment"> * property code doesn't support AMPROP_DISTANCE_ORDERABLE.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1280">&#x200c;</a></span><span class="linkable">spgproperty</span>(Oid index_oid, <span class="Type">int</span> attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexAMProperty prop, <span class="Type">const</span> <span class="Type">char</span> *propname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *res, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opclass,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcintype;<br/></li>
<li>&nbsp; &nbsp; CatCList&nbsp;&nbsp; *catlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Only answer column-level inquiries */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (prop)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPROP_DISTANCE_ORDERABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently, SP-GiST distance-ordered scans require that there be a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * distance operator in the opclass with the default types. So we assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that if such an operator exists, then there's a reason for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First we need to know the column's opclass. */<br/></li>
<li></span>&nbsp; &nbsp; opclass = <a href="../../utils/cache/lsyscache.c.html#L3512" title="utils/cache/lsyscache.c:3512">get_index_column_opclass</a>(index_oid, attno);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(opclass))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now look up the opclass family and input datatype. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/cache/lsyscache.c.html#L1235" title="utils/cache/lsyscache.c:1235">get_opclass_opfamily_and_input_type</a>(opclass, &amp;opfamily, &amp;opcintype))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we can check whether the operator is provided. */<br/></li>
<li></span>&nbsp; &nbsp; catlist = SearchSysCacheList1(AMOPSTRATEGY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(opfamily));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *res = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; catlist-&gt;n_members; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; amoptup = &amp;catlist-&gt;members[i]-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_amop amopform = (Form_pg_amop) GETSTRUCT(amoptup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (amopform-&gt;amoppurpose == AMOP_ORDER &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (amopform-&gt;amoplefttype == opcintype ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; amopform-&gt;amoprighttype == opcintype) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../index/amvalidate.c.html#L271" title="access/index/amvalidate.c:271">opfamily_can_sort_type</a>(amopform-&gt;amopsortfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/cache/lsyscache.c.html#L1333" title="utils/cache/lsyscache.c:1333">get_op_rettype</a>(amopform-&gt;amopopr)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *res = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ReleaseSysCacheList(catlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *isnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
