<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/spgist/spgkdtreeproc.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/spgist/spgkdtreeproc.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L78">SortedPoint</a></li>
<li><a href="#L82">SortedPoint</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L41">getSide</a></li>
<li><a href="#L54">spg_kd_choose</a></li>
<li><a href="#L28">spg_kd_config</a></li>
<li><a href="#L160">spg_kd_inner_consistent</a></li>
<li><a href="#L108">spg_kd_picksplit</a></li>
<li><a href="#L85">x_cmp</a></li>
<li><a href="#L96">y_cmp</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * spgkdtreeproc.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; implementation of k-d tree over points for SP-GiST<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; src/backend/access/spgist/spgkdtreeproc.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/spgist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/spgist_private.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/stratnum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/float.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/geo_decls.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L28">&#x200c;</a><span class="linkable">spg_kd_config</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* spgConfigIn *cfgin = (spgConfigIn *) PG_GETARG_POINTER(0); */<br/></li>
<li></span>&nbsp; &nbsp; spgConfigOut *cfg = (spgConfigOut *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cfg-&gt;prefixType = FLOAT8OID;<br/></li>
<li>&nbsp; &nbsp; cfg-&gt;labelType = VOIDOID;&nbsp; &nbsp; <span class="Comment">/* we don't need node labels */<br/></li>
<li></span>&nbsp; &nbsp; cfg-&gt;canReturnData = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; cfg-&gt;longValuesOK = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L41">&#x200c;</a></span><span class="linkable">getSide</span>(<span class="Type">double</span> coord, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isX, Point *tst)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; tstcoord = (isX) ? tst-&gt;x : tst-&gt;y;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (coord == tstcoord)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (coord &gt; tstcoord)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L54">&#x200c;</a><span class="linkable">spg_kd_choose</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; spgChooseIn *in = (spgChooseIn *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; spgChooseOut *out = (spgChooseOut *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *inPoint = DatumGetPointP(in-&gt;datum);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; coord;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;allTheSame)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;allTheSame should not occur for k-d trees&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(in-&gt;hasPrefix);<br/></li>
<li>&nbsp; &nbsp; coord = DatumGetFloat8(in-&gt;prefixDatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(in-&gt;nNodes == <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; out-&gt;resultType = spgMatchNode;<br/></li>
<li>&nbsp; &nbsp; out-&gt;result.matchNode.nodeN =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L41" title="access/spgist/spgkdtreeproc.c:41">getSide</a>(coord, in-&gt;level % <span class="Constant">2</span>, inPoint) &gt; <span class="Constant">0</span>) ? <span class="Constant">0</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; out-&gt;result.matchNode.levelAdd = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; out-&gt;result.matchNode.restDatum = PointPGetDatum(inPoint);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L78">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SortedPoint</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><a id="L82">&#x200c;</a>} <span class="linkable">SortedPoint</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L85">&#x200c;</a></span><span class="linkable">x_cmp</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="access/spgist/spgkdtreeproc.c:78">SortedPoint</a> *pa = (<a href="#L78" title="access/spgist/spgkdtreeproc.c:78">SortedPoint</a> *) a;<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="access/spgist/spgkdtreeproc.c:78">SortedPoint</a> *pb = (<a href="#L78" title="access/spgist/spgkdtreeproc.c:78">SortedPoint</a> *) b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pa-&gt;p-&gt;x == pb-&gt;p-&gt;x)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (pa-&gt;p-&gt;x &gt; pb-&gt;p-&gt;x) ? <span class="Constant">1</span> : -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L96">&#x200c;</a></span><span class="linkable">y_cmp</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="access/spgist/spgkdtreeproc.c:78">SortedPoint</a> *pa = (<a href="#L78" title="access/spgist/spgkdtreeproc.c:78">SortedPoint</a> *) a;<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="access/spgist/spgkdtreeproc.c:78">SortedPoint</a> *pb = (<a href="#L78" title="access/spgist/spgkdtreeproc.c:78">SortedPoint</a> *) b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pa-&gt;p-&gt;y == pb-&gt;p-&gt;y)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (pa-&gt;p-&gt;y &gt; pb-&gt;p-&gt;y) ? <span class="Constant">1</span> : -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L108">&#x200c;</a><span class="linkable">spg_kd_picksplit</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; spgPickSplitIn *in = (spgPickSplitIn *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; spgPickSplitOut *out = (spgPickSplitOut *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; middle;<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="access/spgist/spgkdtreeproc.c:78">SortedPoint</a> *sorted;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; coord;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sorted = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*sorted) * in-&gt;nTuples);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; in-&gt;nTuples; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sorted[i].p = DatumGetPointP(in-&gt;datums[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sorted[i].i = i;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qsort(sorted, in-&gt;nTuples, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*sorted),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (in-&gt;level % <span class="Constant">2</span>) ? <a href="#L85" title="access/spgist/spgkdtreeproc.c:85">x_cmp</a> : <a href="#L96" title="access/spgist/spgkdtreeproc.c:96">y_cmp</a>);<br/></li>
<li>&nbsp; &nbsp; middle = in-&gt;nTuples &gt;&gt; <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; coord = (in-&gt;level % <span class="Constant">2</span>) ? sorted[middle].p-&gt;x : sorted[middle].p-&gt;y;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; out-&gt;hasPrefix = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; out-&gt;prefixDatum = <a href="../../utils/fmgr/fmgr.c.html#L1816" title="utils/fmgr/fmgr.c:1816">Float8GetDatum</a>(coord);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; out-&gt;nNodes = <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; out-&gt;nodeLabels = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we don't need node labels */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; out-&gt;mapTuplesToNodes = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * in-&gt;nTuples);<br/></li>
<li>&nbsp; &nbsp; out-&gt;leafTupleDatums = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * in-&gt;nTuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: points that have coordinates exactly <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to coord may get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * classified into either node, depending on where they happen to fall in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the sorted list.&nbsp; This is okay as long as the inner_consistent function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * descends into both sides for such cases.&nbsp; This is better than the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * alternative of trying to have an exact boundary, because it keeps the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tree balanced even when we have many instances of the same point value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * So we should never <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> the allTheSame logic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; in-&gt;nTuples; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *p = sorted[i].p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = sorted[i].i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;mapTuplesToNodes[n] = (i &lt; middle) ? <span class="Constant">0</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;leafTupleDatums[n] = PointPGetDatum(p);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L160">&#x200c;</a><span class="linkable">spg_kd_inner_consistent</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; spgInnerConsistentIn *in = (spgInnerConsistentIn *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; spgInnerConsistentOut *out = (spgInnerConsistentOut *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; coord;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bboxes[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(in-&gt;hasPrefix);<br/></li>
<li>&nbsp; &nbsp; coord = DatumGetFloat8(in-&gt;prefixDatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;allTheSame)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;allTheSame should not occur for k-d trees&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(in-&gt;nNodes == <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* &quot;which&quot; is a bitmask of children that satisfy all constraints */<br/></li>
<li></span>&nbsp; &nbsp; which = (<span class="Constant">1</span> &lt;&lt; <span class="Constant">1</span>) | (<span class="Constant">1</span> &lt;&lt; <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; in-&gt;nkeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Point&nbsp; &nbsp; &nbsp;&nbsp; *query = DatumGetPointP(in-&gt;scankeys[i].sk_argument);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *boxQuery;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (in-&gt;scankeys[i].sk_strategy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTLeftStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((in-&gt;level % <span class="Constant">2</span>) != <span class="Constant">0</span> &amp;&amp; FPlt(query-&gt;x, coord))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which &amp;= (<span class="Constant">1</span> &lt;&lt; <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTRightStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((in-&gt;level % <span class="Constant">2</span>) != <span class="Constant">0</span> &amp;&amp; FPgt(query-&gt;x, coord))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which &amp;= (<span class="Constant">1</span> &lt;&lt; <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTSameStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((in-&gt;level % <span class="Constant">2</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FPlt(query-&gt;x, coord))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which &amp;= (<span class="Constant">1</span> &lt;&lt; <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (FPgt(query-&gt;x, coord))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which &amp;= (<span class="Constant">1</span> &lt;&lt; <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FPlt(query-&gt;y, coord))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which &amp;= (<span class="Constant">1</span> &lt;&lt; <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (FPgt(query-&gt;y, coord))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which &amp;= (<span class="Constant">1</span> &lt;&lt; <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTBelowStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTOldBelowStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((in-&gt;level % <span class="Constant">2</span>) == <span class="Constant">0</span> &amp;&amp; FPlt(query-&gt;y, coord))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which &amp;= (<span class="Constant">1</span> &lt;&lt; <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTAboveStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTOldAboveStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((in-&gt;level % <span class="Constant">2</span>) == <span class="Constant">0</span> &amp;&amp; FPgt(query-&gt;y, coord))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which &amp;= (<span class="Constant">1</span> &lt;&lt; <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTContainedByStrategyNumber:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For this operator, the query is a box not a point.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cheat to the extent of assuming that DatumGetPointP won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do anything that would be bad for a pointer-to-box.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boxQuery = DatumGetBoxP(in-&gt;scankeys[i].sk_argument);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((in-&gt;level % <span class="Constant">2</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FPlt(boxQuery-&gt;high.x, coord))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which &amp;= (<span class="Constant">1</span> &lt;&lt; <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (FPgt(boxQuery-&gt;low.x, coord))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which &amp;= (<span class="Constant">1</span> &lt;&lt; <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FPlt(boxQuery-&gt;high.y, coord))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which &amp;= (<span class="Constant">1</span> &lt;&lt; <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (FPgt(boxQuery-&gt;low.y, coord))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; which &amp;= (<span class="Constant">1</span> &lt;&lt; <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized strategy number: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; in-&gt;scankeys[i].sk_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (which == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no need to consider remaining conditions */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We must descend into the children identified by which */<br/></li>
<li></span>&nbsp; &nbsp; out-&gt;nNodes = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fast-path for no matching children */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!which)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; out-&gt;nodeNumbers = (<span class="Type">int</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When ordering scan keys are specified, we've to calculate distance for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them.&nbsp; In order to do that, we need calculate bounding boxes for both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * children nodes.&nbsp; Calculation of those bounding boxes on non-zero level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * require knowledge of bounding box of <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> node.&nbsp; So, we save bounding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * boxes to traversalValues.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;norderbys &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; infArea;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *area;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;distances = (<span class="Type">double</span> **) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">double</span> *) * in-&gt;nNodes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out-&gt;traversalValues = (<span class="Type">void</span> **) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">void</span> *) * in-&gt;nNodes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;level == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; inf = get_float8_infinity();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; infArea.high.x = inf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; infArea.high.y = inf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; infArea.low.x = -inf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; infArea.low.y = -inf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; area = &amp;infArea;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; area = (BOX *) in-&gt;traversalValue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(area);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bboxes[<span class="Constant">0</span>].low = area-&gt;low;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bboxes[<span class="Constant">1</span>].high = area-&gt;high;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;level % <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* split box by x */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bboxes[<span class="Constant">0</span>].high.x = bboxes[<span class="Constant">1</span>].low.x = coord;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bboxes[<span class="Constant">0</span>].high.y = area-&gt;high.y;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bboxes[<span class="Constant">1</span>].low.y = area-&gt;low.y;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* split box by y */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bboxes[<span class="Constant">0</span>].high.y = bboxes[<span class="Constant">1</span>].low.y = coord;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bboxes[<span class="Constant">0</span>].high.x = area-&gt;high.x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bboxes[<span class="Constant">1</span>].low.x = area-&gt;low.x;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= <span class="Constant">2</span>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (which &amp; (<span class="Constant">1</span> &lt;&lt; i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;nodeNumbers[out-&gt;nNodes] = i - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (in-&gt;norderbys &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldCtx = MemoryContextSwitchTo(in-&gt;traversalMemoryContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BOX&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *box = <a href="spgproc.c.html#L82" title="access/spgist/spgproc.c:82">box_copy</a>(&amp;bboxes[i - <span class="Constant">1</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldCtx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;traversalValues[out-&gt;nNodes] = box;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;distances[out-&gt;nNodes] = <a href="spgproc.c.html#L63" title="access/spgist/spgproc.c:63">spg_key_orderbys_distances</a>(BoxPGetDatum(box), <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; in-&gt;orderbys, in-&gt;norderbys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out-&gt;nNodes++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up level increments, too */<br/></li>
<li></span>&nbsp; &nbsp; out-&gt;levelAdds = (<span class="Type">int</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; out-&gt;levelAdds[<span class="Constant">0</span>] = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; out-&gt;levelAdds[<span class="Constant">1</span>] = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * spg_kd_leaf_consistent() is the same as <a href="spgquadtreeproc.c.html#L407" title="access/spgist/spgquadtreeproc.c:407">spg_quad_leaf_consistent</a>(),<br/></li>
<li></span><span class="Comment"> * since we support the same operators and the same leaf data type.<br/></li>
<li></span><span class="Comment"> * So we just borrow that function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
