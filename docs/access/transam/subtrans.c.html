<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/transam/subtrans.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/transam/subtrans.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L72">SubTransCtlData</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L270">BootStrapSUBTRANS</a></li>
<li><a href="#L355">CheckPointSUBTRANS</a></li>
<li><a href="#L379">ExtendSUBTRANS</a></li>
<li><a href="#L201">SUBTRANSShmemBuffers</a></li>
<li><a href="#L220">SUBTRANSShmemInit</a></li>
<li><a href="#L214">SUBTRANSShmemSize</a></li>
<li><a href="#L309">StartupSUBTRANS</a></li>
<li><a href="#L122">SubTransGetParent</a></li>
<li><a href="#L163">SubTransGetTopmostTransaction</a></li>
<li><a href="#L435">SubTransPagePrecedes</a></li>
<li><a href="#L85">SubTransSetParent</a></li>
<li><a href="#L61">TransactionIdToPage</a></li>
<li><a href="#L411">TruncateSUBTRANS</a></li>
<li><a href="#L296">ZeroSUBTRANSPage</a></li>
<li><a href="#L254">check_subtrans_buffers</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L54">SUBTRANS_XACTS_PER_PAGE</a></li>
<li><a href="#L74">SubTransCtl</a></li>
<li><a href="#L66">TransactionIdToEntry</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * subtrans.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PostgreSQL subtransaction-log manager<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The pg_subtrans manager is a pg_xact-like manager that stores the parent<br/></li>
<li></span><span class="Comment"> * transaction Id for each transaction.&nbsp; It is a fundamental part of the<br/></li>
<li></span><span class="Comment"> * nested transactions implementation.&nbsp; A <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> transaction has a parent<br/></li>
<li></span><span class="Comment"> * of InvalidTransactionId, and each subtransaction has its immediate parent.<br/></li>
<li></span><span class="Comment"> * The tree can easily be walked from child to parent, but not in the<br/></li>
<li></span><span class="Comment"> * opposite direction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This code is based on xact.c, but the robustness requirements<br/></li>
<li></span><span class="Comment"> * are completely different from pg_xact, because we only need to remember<br/></li>
<li></span><span class="Comment"> * pg_subtrans information for currently-open transactions.&nbsp; Thus, there is<br/></li>
<li></span><span class="Comment"> * no need to preserve data over a crash and restart.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There are no XLOG interactions since we do not care about preserving<br/></li>
<li></span><span class="Comment"> * data across crashes.&nbsp; During database startup, we simply force the<br/></li>
<li></span><span class="Comment"> * currently-active page of SUBTRANS to zeroes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * src/backend/access/transam/subtrans.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/slru.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/subtrans.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pg_trace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Defines for SubTrans page sizes.&nbsp; A page is the same BLCKSZ as is used<br/></li>
<li></span><span class="Comment"> * everywhere else in Postgres.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: because TransactionIds are 32 bits and wrap around at 0xFFFFFFFF,<br/></li>
<li></span><span class="Comment"> * SubTrans page numbering also wraps around at<br/></li>
<li></span><span class="Comment"> * 0xFFFFFFFF/<a href="#L54" title="access/transam/subtrans.c:54">SUBTRANS_XACTS_PER_PAGE</a>, and segment numbering at<br/></li>
<li></span><span class="Comment"> * 0xFFFFFFFF/<a href="#L54" title="access/transam/subtrans.c:54">SUBTRANS_XACTS_PER_PAGE</a>/SLRU_PAGES_PER_SEGMENT.&nbsp; We need take no<br/></li>
<li></span><span class="Comment"> * explicit notice of that fact in this module, except when comparing segment<br/></li>
<li></span><span class="Comment"> * and page numbers in <a href="#L411" title="access/transam/subtrans.c:411">TruncateSUBTRANS</a> (see <a href="#L435" title="access/transam/subtrans.c:435">SubTransPagePrecedes</a>) and zeroing<br/></li>
<li></span><span class="Comment"> * them in <a href="#L309" title="access/transam/subtrans.c:309">StartupSUBTRANS</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* We need four bytes per xact */<br/></li>
<li><a id="L54">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SUBTRANS_XACTS_PER_PAGE</span> (BLCKSZ / </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(TransactionId))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Although we return an int64 the actual value can't currently exceed<br/></li>
<li></span><span class="Comment"> * 0xFFFFFFFF/<a href="#L54" title="access/transam/subtrans.c:54">SUBTRANS_XACTS_PER_PAGE</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> int64<br/></li>
<li><a id="L61">&#x200c;</a><span class="linkable">TransactionIdToPage</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> xid / (int64) <a href="#L54" title="access/transam/subtrans.c:54">SUBTRANS_XACTS_PER_PAGE</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L66">&#x200c;</a><span class="PreProc">#define <span class="linkable">TransactionIdToEntry</span>(xid) ((xid) % (TransactionId) <a href="#L54" title="access/transam/subtrans.c:54">SUBTRANS_XACTS_PER_PAGE</a>)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Link to shared-memory data structures for SUBTRANS control<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L72">&#x200c;</a></span><span class="Type">static</span> SlruCtlData <span class="linkable">SubTransCtlData</span>;<br/></li>
<li><br/></li>
<li><a id="L74">&#x200c;</a><span class="PreProc">#define <span class="linkable">SubTransCtl</span>&nbsp; (&amp;<a href="#L72" title="access/transam/subtrans.c:72">SubTransCtlData</a>)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L296" title="access/transam/subtrans.c:296">ZeroSUBTRANSPage</a>(int64 pageno);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L435" title="access/transam/subtrans.c:435">SubTransPagePrecedes</a>(int64 page1, int64 page2);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Record the parent of a subtransaction in the subtrans log.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L85">&#x200c;</a></span><span class="linkable">SubTransSetParent</span>(TransactionId xid, TransactionId parent)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno = <a href="clog.c.html#L82" title="access/transam/clog.c:82">TransactionIdToPage</a>(xid);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entryno = <a href="#L66" title="access/transam/subtrans.c:66">TransactionIdToEntry</a>(xid);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li>&nbsp; &nbsp; TransactionId *ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(parent));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="transam.c.html#L314" title="access/transam/transam.c:314">TransactionIdFollows</a>(xid, parent));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lock = SimpleLruGetBankLock(<a href="#L74" title="access/transam/subtrans.c:74">SubTransCtl</a>, pageno);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slotno = <a href="slru.c.html#L488" title="access/transam/slru.c:488">SimpleLruReadPage</a>(<a href="#L74" title="access/transam/subtrans.c:74">SubTransCtl</a>, pageno, <span class="Constant">true</span>, xid);<br/></li>
<li>&nbsp; &nbsp; ptr = (TransactionId *) <a href="#L74" title="access/transam/subtrans.c:74">SubTransCtl</a>-&gt;shared-&gt;page_buffer[slotno];<br/></li>
<li>&nbsp; &nbsp; ptr += entryno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's possible we'll try to set the parent xid multiple times but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shouldn't ever be changing the xid from one valid xid to another valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xid, which would corrupt the data structure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*ptr != parent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(*ptr == InvalidTransactionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ptr = parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L74" title="access/transam/subtrans.c:74">SubTransCtl</a>-&gt;shared-&gt;page_dirty[slotno] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Interrogate the parent of a transaction in the subtrans log.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TransactionId<br/></li>
<li><a id="L122">&#x200c;</a><span class="linkable">SubTransGetParent</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno = <a href="clog.c.html#L82" title="access/transam/clog.c:82">TransactionIdToPage</a>(xid);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entryno = <a href="#L66" title="access/transam/subtrans.c:66">TransactionIdToEntry</a>(xid);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; TransactionId *ptr;<br/></li>
<li>&nbsp; &nbsp; TransactionId parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't ask about stuff that might not be around anymore */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(xid, <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Bootstrap and frozen XIDs have no parent */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsNormal(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* lock is acquired by <a href="slru.c.html#L591" title="access/transam/slru.c:591">SimpleLruReadPage_ReadOnly</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; slotno = <a href="slru.c.html#L591" title="access/transam/slru.c:591">SimpleLruReadPage_ReadOnly</a>(<a href="#L74" title="access/transam/subtrans.c:74">SubTransCtl</a>, pageno, xid);<br/></li>
<li>&nbsp; &nbsp; ptr = (TransactionId *) <a href="#L74" title="access/transam/subtrans.c:74">SubTransCtl</a>-&gt;shared-&gt;page_buffer[slotno];<br/></li>
<li>&nbsp; &nbsp; ptr += entryno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; parent = *ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SimpleLruGetBankLock(<a href="#L74" title="access/transam/subtrans.c:74">SubTransCtl</a>, pageno));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> parent;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L163" title="access/transam/subtrans.c:163">SubTransGetTopmostTransaction</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the topmost transaction of the given transaction id.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because we cannot look back further than <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>, it is possible<br/></li>
<li></span><span class="Comment"> * that this function will lie and return an intermediate subtransaction ID<br/></li>
<li></span><span class="Comment"> * instead of the true topmost parent ID.&nbsp; This is OK, because in practice<br/></li>
<li></span><span class="Comment"> * we only care about detecting whether the topmost parent is still running<br/></li>
<li></span><span class="Comment"> * or is part of a current snapshot's list of still-running transactions.<br/></li>
<li></span><span class="Comment"> * Therefore, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> XID <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a> is as good as <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TransactionId<br/></li>
<li><a id="L163">&#x200c;</a><span class="linkable">SubTransGetTopmostTransaction</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId parentXid = xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; previousXid = xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't ask about stuff that might not be around anymore */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(xid, <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (TransactionIdIsValid(parentXid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; previousXid = parentXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(parentXid, <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parentXid = <a href="#L122" title="access/transam/subtrans.c:122">SubTransGetParent</a>(parentXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * By convention the parent xid gets allocated first, so should always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * precede the child xid. Anything else points to a corrupted data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * structure that could lead to an infinite loop, so exit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(parentXid, previousXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;pg_subtrans contains invalid entry: xid </span><span class="Special">%u</span><span class="Constant"> points to parent xid </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; previousXid, parentXid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(previousXid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> previousXid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Number of shared SUBTRANS buffers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If asked to autotune, use 2MB for every 1GB of shared buffers, up to 8MB.<br/></li>
<li></span><span class="Comment"> * Otherwise just cap the configured amount to be between 16 and the maximum<br/></li>
<li></span><span class="Comment"> * allowed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L201">&#x200c;</a></span><span class="linkable">SUBTRANSShmemBuffers</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* auto-tune based on shared buffers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L167" title="utils/init/globals.c:167">subtransaction_buffers</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="slru.c.html#L217" title="access/transam/slru.c:217">SimpleLruAutotuneBuffers</a>(<span class="Constant">512</span>, <span class="Constant">1024</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(Max(<span class="Constant">16</span>, <a href="../../utils/init/globals.c.html#L167" title="utils/init/globals.c:167">subtransaction_buffers</a>), SLRU_MAX_ALLOWED_BUFFERS);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialization of shared memory for SUBTRANS<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L214">&#x200c;</a><span class="linkable">SUBTRANSShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="slru.c.html#L184" title="access/transam/slru.c:184">SimpleLruShmemSize</a>(<a href="#L201" title="access/transam/subtrans.c:201">SUBTRANSShmemBuffers</a>(), <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L220">&#x200c;</a></span><span class="linkable">SUBTRANSShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If auto-tuning is requested, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> is the time to do it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L167" title="utils/init/globals.c:167">subtransaction_buffers</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[<span class="Constant">32</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buf), <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="#L201" title="access/transam/subtrans.c:201">SUBTRANSShmemBuffers</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../../utils/init/globals.c.html#L167" title="utils/init/globals.c:167">subtransaction_buffers</a>&quot;</span>, buf, PGC_POSTMASTER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_S_DYNAMIC_DEFAULT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We prefer to report this value's source as PGC_S_DYNAMIC_DEFAULT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, if the DBA explicitly set <a href="../../utils/init/globals.c.html#L167" title="utils/init/globals.c:167">subtransaction_buffers</a> = 0 in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the config file, then PGC_S_DYNAMIC_DEFAULT will fail to override<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that and we must force the matter with PGC_S_OVERRIDE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L167" title="utils/init/globals.c:167">subtransaction_buffers</a> == <span class="Constant">0</span>)&nbsp; &nbsp; <span class="Comment">/* failed to apply it? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../../utils/init/globals.c.html#L167" title="utils/init/globals.c:167">subtransaction_buffers</a>&quot;</span>, buf, PGC_POSTMASTER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_S_OVERRIDE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../utils/init/globals.c.html#L167" title="utils/init/globals.c:167">subtransaction_buffers</a> != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L74" title="access/transam/subtrans.c:74">SubTransCtl</a>-&gt;PagePrecedes = <a href="#L435" title="access/transam/subtrans.c:435">SubTransPagePrecedes</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="slru.c.html#L238" title="access/transam/slru.c:238">SimpleLruInit</a>(<a href="#L74" title="access/transam/subtrans.c:74">SubTransCtl</a>, <span class="Constant">&quot;subtransaction&quot;</span>, <a href="#L201" title="access/transam/subtrans.c:201">SUBTRANSShmemBuffers</a>(), <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;pg_subtrans&quot;</span>, LWTRANCHE_SUBTRANS_BUFFER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LWTRANCHE_SUBTRANS_SLRU, SYNC_HANDLER_NONE, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="slru.c.html#L1680" title="access/transam/slru.c:1680">SlruPagePrecedesUnitTests</a>(<a href="#L74" title="access/transam/subtrans.c:74">SubTransCtl</a>, <a href="#L54" title="access/transam/subtrans.c:54">SUBTRANS_XACTS_PER_PAGE</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for <a href="../../utils/init/globals.c.html#L167" title="utils/init/globals.c:167">subtransaction_buffers</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L254">&#x200c;</a></span><span class="linkable">check_subtrans_buffers</span>(<span class="Type">int</span> *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="slru.c.html#L341" title="access/transam/slru.c:341">check_slru_buffers</a>(<span class="Constant">&quot;<a href="../../utils/init/globals.c.html#L167" title="utils/init/globals.c:167">subtransaction_buffers</a>&quot;</span>, <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This func must be called ONCE on system install.&nbsp; It creates<br/></li>
<li></span><span class="Comment"> * the initial SUBTRANS segment.&nbsp; (The SUBTRANS directory is assumed to<br/></li>
<li></span><span class="Comment"> * have been created by the initdb shell script, and <a href="#L220" title="access/transam/subtrans.c:220">SUBTRANSShmemInit</a><br/></li>
<li></span><span class="Comment"> * must have been called already.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: it's not really necessary to create the initial segment <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li></span><span class="Comment"> * since slru.c would create it on first write anyway.&nbsp; But we may as well<br/></li>
<li></span><span class="Comment"> * do it to be sure the directory is set up correctly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L270">&#x200c;</a></span><span class="linkable">BootStrapSUBTRANS</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock = SimpleLruGetBankLock(<a href="#L74" title="access/transam/subtrans.c:74">SubTransCtl</a>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create and zero the first page of the subtrans log */<br/></li>
<li></span>&nbsp; &nbsp; slotno = <a href="#L296" title="access/transam/subtrans.c:296">ZeroSUBTRANSPage</a>(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure it's written out */<br/></li>
<li></span>&nbsp; &nbsp; <a href="slru.c.html#L715" title="access/transam/slru.c:715">SimpleLruWritePage</a>(<a href="#L74" title="access/transam/subtrans.c:74">SubTransCtl</a>, slotno);<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L74" title="access/transam/subtrans.c:74">SubTransCtl</a>-&gt;shared-&gt;page_dirty[slotno]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize (or reinitialize) a page of SUBTRANS to zeroes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The page is not actually written, just set up in shared memory.<br/></li>
<li></span><span class="Comment"> * The slot number of the new page is returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Control lock must be held at entry, and will be held at exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L296">&#x200c;</a></span><span class="linkable">ZeroSUBTRANSPage</span>(int64 pageno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="slru.c.html#L361" title="access/transam/slru.c:361">SimpleLruZeroPage</a>(<a href="#L74" title="access/transam/subtrans.c:74">SubTransCtl</a>, pageno);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This must be called ONCE during postmaster or standalone-backend startup,<br/></li>
<li></span><span class="Comment"> * after <a href="xlog.c.html#L5388" title="access/transam/xlog.c:5388">StartupXLOG</a> has initialized <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * oldestActiveXID is the oldest XID of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> prepared transaction, or nextXid<br/></li>
<li></span><span class="Comment"> * if there are <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L309">&#x200c;</a></span><span class="linkable">StartupSUBTRANS</span>(TransactionId oldestActiveXID)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FullTransactionId nextXid;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; startPage;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; endPage;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *prevlock = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we don't expect pg_subtrans to be valid across crashes, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the currently-active page(s) to zeroes during startup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Whenever we advance into a new page, <a href="#L379" title="access/transam/subtrans.c:379">ExtendSUBTRANS</a> will likewise zero<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the new page without regard to whatever was previously on disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; startPage = <a href="clog.c.html#L82" title="access/transam/clog.c:82">TransactionIdToPage</a>(oldestActiveXID);<br/></li>
<li>&nbsp; &nbsp; nextXid = <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid;<br/></li>
<li>&nbsp; &nbsp; endPage = <a href="clog.c.html#L82" title="access/transam/clog.c:82">TransactionIdToPage</a>(XidFromFullTransactionId(nextXid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock = SimpleLruGetBankLock(<a href="#L74" title="access/transam/subtrans.c:74">SubTransCtl</a>, startPage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prevlock != lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prevlock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(prevlock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevlock = lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L296" title="access/transam/subtrans.c:296">ZeroSUBTRANSPage</a>(startPage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (startPage == endPage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startPage++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must account for wraparound */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (startPage &gt; <a href="clog.c.html#L82" title="access/transam/clog.c:82">TransactionIdToPage</a>(MaxTransactionId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startPage = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform a checkpoint --- either during shutdown, or on-the-fly<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L355">&#x200c;</a></span><span class="linkable">CheckPointSUBTRANS</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write dirty SUBTRANS pages to disk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is not actually necessary from a correctness point of view. We do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it merely to improve the odds that writing of dirty pages is done by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the checkpoint process and not by backends.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TRACE_POSTGRESQL_SUBTRANS_CHECKPOINT_START(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="slru.c.html#L1305" title="access/transam/slru.c:1305">SimpleLruWriteAll</a>(<a href="#L74" title="access/transam/subtrans.c:74">SubTransCtl</a>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_SUBTRANS_CHECKPOINT_DONE(<span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make sure that SUBTRANS has room for a newly-allocated XID.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this is called while holding XidGenLock.&nbsp; We want it to be very fast<br/></li>
<li></span><span class="Comment"> * most of the time; even when it's not so fast, no actual I/O need happen<br/></li>
<li></span><span class="Comment"> * unless we're forced to write out a dirty subtrans page to make room<br/></li>
<li></span><span class="Comment"> * in shared memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L379">&#x200c;</a></span><span class="linkable">ExtendSUBTRANS</span>(TransactionId newestXact)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No work except at first XID of a page.&nbsp; But beware: just after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wraparound, the first XID of page zero is FirstNormalTransactionId.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L66" title="access/transam/subtrans.c:66">TransactionIdToEntry</a>(newestXact) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdEquals(newestXact, FirstNormalTransactionId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pageno = <a href="clog.c.html#L82" title="access/transam/clog.c:82">TransactionIdToPage</a>(newestXact);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lock = SimpleLruGetBankLock(<a href="#L74" title="access/transam/subtrans.c:74">SubTransCtl</a>, pageno);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Zero the page */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L296" title="access/transam/subtrans.c:296">ZeroSUBTRANSPage</a>(pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove all SUBTRANS segments <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the one holding the passed transaction ID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * oldestXact is the oldest <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a> of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> running transaction.&nbsp; This<br/></li>
<li></span><span class="Comment"> * is called only during checkpoint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L411">&#x200c;</a></span><span class="linkable">TruncateSUBTRANS</span>(TransactionId oldestXact)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; cutoffPage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The cutoff point is the start of the segment containing oldestXact. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pass the *page* containing oldestXact to <a href="slru.c.html#L1391" title="access/transam/slru.c:1391">SimpleLruTruncate</a>.&nbsp; We step<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * back one transaction to avoid passing a cutoff page that hasn't been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * created yet in the rare case that oldestXact would be the first item on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a page and oldestXact == <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> XID.&nbsp; In that case, if we didn't subtract<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one, we'd <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> <a href="slru.c.html#L1391" title="access/transam/slru.c:1391">SimpleLruTruncate</a>'s wraparound detection.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TransactionIdRetreat(oldestXact);<br/></li>
<li>&nbsp; &nbsp; cutoffPage = <a href="clog.c.html#L82" title="access/transam/clog.c:82">TransactionIdToPage</a>(oldestXact);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="slru.c.html#L1391" title="access/transam/slru.c:1391">SimpleLruTruncate</a>(<a href="#L74" title="access/transam/subtrans.c:74">SubTransCtl</a>, cutoffPage);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Decide whether a SUBTRANS page number is &quot;older&quot; for truncation purposes.<br/></li>
<li></span><span class="Comment"> * Analogous to <a href="clog.c.html#L1055" title="access/transam/clog.c:1055">CLOGPagePrecedes</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L435">&#x200c;</a></span><span class="linkable">SubTransPagePrecedes</span>(int64 page1, int64 page2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid1;<br/></li>
<li>&nbsp; &nbsp; TransactionId xid2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xid1 = ((TransactionId) page1) * <a href="#L54" title="access/transam/subtrans.c:54">SUBTRANS_XACTS_PER_PAGE</a>;<br/></li>
<li>&nbsp; &nbsp; xid1 += FirstNormalTransactionId + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; xid2 = ((TransactionId) page2) * <a href="#L54" title="access/transam/subtrans.c:54">SUBTRANS_XACTS_PER_PAGE</a>;<br/></li>
<li>&nbsp; &nbsp; xid2 += FirstNormalTransactionId + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid1, xid2) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid1, xid2 + <a href="#L54" title="access/transam/subtrans.c:54">SUBTRANS_XACTS_PER_PAGE</a> - <span class="Constant">1</span>));<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
