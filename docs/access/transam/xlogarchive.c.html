<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/transam/xlogarchive.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/transam/xlogarchive.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L295">ExecuteRecoveryCommand</a></li>
<li><a href="#L358">KeepFileRestoredFromArchive</a></li>
<li><a href="#L54">RestoreArchivedFile</a></li>
<li><a href="#L565">XLogArchiveCheckDone</a></li>
<li><a href="#L712">XLogArchiveCleanup</a></li>
<li><a href="#L510">XLogArchiveForceDone</a></li>
<li><a href="#L619">XLogArchiveIsBusy</a></li>
<li><a href="#L694">XLogArchiveIsReady</a></li>
<li><a href="#L664">XLogArchiveIsReadyOrDone</a></li>
<li><a href="#L444">XLogArchiveNotify</a></li>
<li><a href="#L492">XLogArchiveNotifySeg</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * xlogarchive.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Functions for archiving WAL files and restoring from the archive.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * src/backend/access/transam/xlogarchive.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/wait.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogarchive.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/archive.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/percentrepl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/pgarch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/startup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walsender.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attempt to retrieve the specified file from off-line archival storage.<br/></li>
<li></span><span class="Comment"> * If successful, fill &quot;path&quot; with its complete path (note that this will be<br/></li>
<li></span><span class="Comment"> * a temp file name that doesn't follow the normal naming convention), and<br/></li>
<li></span><span class="Comment"> * return true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If not successful, fill &quot;path&quot; with the name of the normal on-line file<br/></li>
<li></span><span class="Comment"> * (which may or may not actually exist, but we'll try to use it), and return<br/></li>
<li></span><span class="Comment"> * false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For fixed-size files, the caller may pass the expected size as an<br/></li>
<li></span><span class="Comment"> * additional crosscheck on successful recovery.&nbsp; If the file size is not<br/></li>
<li></span><span class="Comment"> * known, set expectedSize = 0.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When 'cleanupEnabled' is false, refrain from deleting <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> old WAL segments<br/></li>
<li></span><span class="Comment"> * in the archive. This is used when fetching the initial checkpoint record,<br/></li>
<li></span><span class="Comment"> * when we are not yet sure how far back we need the WAL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L54">&#x200c;</a></span><span class="linkable">RestoreArchivedFile</span>(<span class="Type">char</span> *path, <span class="Type">const</span> <span class="Type">char</span> *xlogfname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *recovername, <span class="Type">off_t</span> expectedSize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> cleanupEnabled)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; xlogpath[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *xlogRestoreCmd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; lastRestartPointFname[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat stat_buf;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; restartSegNo;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; restartRedoPtr;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; restartTli;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ignore restore_command when not in archive recovery (meaning we are in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * crash recovery).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="xlogrecovery.c.html#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> not_available;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* In standby mode, restore_command might not be supplied */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L82" title="access/transam/xlogrecovery.c:82">recoveryRestoreCommand</a> == <span class="Constant">NULL</span> || strcmp(<a href="xlogrecovery.c.html#L82" title="access/transam/xlogrecovery.c:82">recoveryRestoreCommand</a>, <span class="Constant">&quot;&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> not_available;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When doing archive recovery, we always prefer an archived log file even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if a file of the same name exists in XLOGDIR.&nbsp; The reason is that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * file in XLOGDIR could be an old, un-filled or partly-filled version<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that was copied and restored as part of backing up $PGDATA.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We could try to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> this slightly by checking the local copy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lastchange timestamp against the archived copy, but we have no API to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do this, nor can we guarantee that the lastchange timestamp was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * preserved correctly when we copied to archive. Our aim is robustness,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so we elect not to do this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we cannot obtain the log file from the archive, however, we will try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to use the XLOGDIR file if it exists.&nbsp; This is so that we can make use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of log segments that weren't yet transferred to the archive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Notice that we don't actually overwrite <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> files when we copy back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from archive because the restore_command may inadvertently restore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inappropriate xlogs, or they may be corrupt, so we may wish to fallback<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the segments remaining in current XLOGDIR later. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copy-from-archive filename is always the same, ensuring that we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * run out of disk space on long recoveries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(xlogpath, MAXPGPATH, XLOGDIR <span class="Constant">&quot;/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, recovername);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure there is no existing file named recovername.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stat(xlogpath, &amp;stat_buf) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not stat file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlogpath)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlink(xlogpath) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlogpath)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate the archive file cutoff point for use during log shipping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replication. All files earlier than this point can be deleted from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * archive, though there is no requirement to do so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> is not enabled, initialise this with the filename of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * InvalidXLogRecPtr, which will prevent the deletion of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WAL files<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the archive because of the alphabetic sorting property of WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * filenames.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Once we have successfully located the redo pointer of the checkpoint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from which we start recovery we never request a file prior to the redo<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointer of the last restartpoint. When redo begins we know that we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * successfully located it, so there is no need for additional status<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flags to signify the point when we can begin deleting WAL files from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the archive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cleanupEnabled)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L9383" title="access/transam/xlog.c:9383">GetOldestRestartPoint</a>(&amp;restartRedoPtr, &amp;restartTli);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLByteToSeg(restartRedoPtr, restartSegNo, <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(lastRestartPointFname, restartTli, restartSegNo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we shouldn't need anything earlier than last restart point */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(strcmp(lastRestartPointFname, xlogfname) &lt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(lastRestartPointFname, <span class="Constant">0</span>, <span class="Constant">0</span>, <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build the restore command to execute */<br/></li>
<li></span>&nbsp; &nbsp; xlogRestoreCmd = BuildRestoreCommand(<a href="xlogrecovery.c.html#L82" title="access/transam/xlogrecovery.c:82">recoveryRestoreCommand</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlogpath, xlogfname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lastRestartPointFname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;executing restore command </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlogRestoreCmd)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fflush(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_RESTORE_COMMAND);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../postmaster/startup.c.html#L268" title="postmaster/startup.c:268">PreRestoreCommand</a>() informs the SIGTERM handler for the startup process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that it should <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>() right away.&nbsp; This is done for the duration<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the system() call because there isn't a good way to break out while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it is executing.&nbsp; Since we might call <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>() in a signal handler,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it is best to put <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> additional logic <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> or after the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../postmaster/startup.c.html#L268" title="postmaster/startup.c:268">PreRestoreCommand</a>()/<a href="../../postmaster/startup.c.html#L282" title="postmaster/startup.c:282">PostRestoreCommand</a>() section.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../postmaster/startup.c.html#L268" title="postmaster/startup.c:268">PreRestoreCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy xlog from archival storage to XLOGDIR<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rc = system(xlogRestoreCmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../postmaster/startup.c.html#L282" title="postmaster/startup.c:282">PostRestoreCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(xlogRestoreCmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rc == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * command apparently succeeded, but let's make sure the file is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * really there <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> and has the correct size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stat(xlogpath, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expectedSize &gt; <span class="Constant">0</span> &amp;&amp; stat_buf.st_size != expectedSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elevel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a partial file in standby mode, we assume it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because it's just being copied to the archive, and keep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * trying.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise treat a wrong-sized file as FATAL to ensure the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * DBA would notice it, but is that too strong? We could try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to plow ahead with a local copy of the file ... but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * problem is that there probably isn't one, and we'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incorrectly conclude we've reached the end of WAL and we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * done recovering ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L147" title="access/transam/xlogrecovery.c:147">StandbyMode</a> &amp;&amp; stat_buf.st_size &lt; expectedSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elevel = DEBUG1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elevel = FATAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;archive file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has wrong size: </span><span class="Special">%lld</span><span class="Constant"> instead of </span><span class="Special">%lld</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlogfname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span> <span class="Type">int</span>) stat_buf.st_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span> <span class="Type">int</span>) expectedSize)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;restored log file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> from archive&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlogfname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcpy(path, xlogpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* stat failed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elevel = (errno == <span class="Constant">ENOENT</span>) ? LOG : FATAL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not stat file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, xlogpath),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;restore_command returned a zero exit status, but stat() failed.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember, we rollforward UNTIL the restore fails so failure here is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just part of the process... that makes it difficult to determine<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether the restore failed because there isn't an archive to restore,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or because the administrator has specified the restore program<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * incorrectly.&nbsp; We have to assume the former.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, if the failure was due to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sort of signal, it's best to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * punt and abort recovery.&nbsp; (If we &quot;return false&quot; here, <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> levels will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume that recovery is complete and start up the database!) It's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * essential to abort on child SIGINT and SIGQUIT, because per spec<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * system() ignores SIGINT and SIGQUIT while <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>; if we see one of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those it's a good bet we should have gotten it too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On SIGTERM, assume we have received a fast shutdown request, and exit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cleanly. It's pure chance whether we receive the SIGTERM first, or the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * child process. If we receive it first, the signal handler will call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>, otherwise we do it here. If we or the child process received<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SIGTERM for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other reason than a fast shutdown request, postmaster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will perform an immediate shutdown when it sees us exiting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unexpectedly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We treat hard shell errors such as &quot;command not found&quot; as fatal, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (wait_result_is_signal(rc, <span class="Constant">SIGTERM</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(wait_result_is_any_signal(rc, <span class="Constant">true</span>) ? FATAL : DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not restore file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> from archive: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlogfname, wait_result_to_str(rc))));<br/></li>
<li><br/></li>
<li><span class="Statement">not_available</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if an archived file is not available, there might still be a version of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this file in XLOGDIR, so return that as the filename to open.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In many recovery scenarios we expect this to fail also, but if so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just means we've reached the end of WAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(path, MAXPGPATH, XLOGDIR <span class="Constant">&quot;/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, xlogfname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attempt to execute an external shell command during recovery.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'command' is the shell command to be executed, 'commandName' is a<br/></li>
<li></span><span class="Comment"> * human-readable name describing the command emitted in the logs. If<br/></li>
<li></span><span class="Comment"> * 'failOnSignal' is true and the command is killed by a signal, a FATAL<br/></li>
<li></span><span class="Comment"> * error is thrown. Otherwise a WARNING is emitted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is currently used for recovery_end_command and archive_cleanup_command.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L295">&#x200c;</a></span><span class="linkable">ExecuteRecoveryCommand</span>(<span class="Type">const</span> <span class="Type">char</span> *command, <span class="Type">const</span> <span class="Type">char</span> *commandName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> failOnSignal, uint32 wait_event_info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *xlogRecoveryCmd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; lastRestartPointFname[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; restartSegNo;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; restartRedoPtr;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; restartTli;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(command &amp;&amp; commandName);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate the archive file cutoff point for use during log shipping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replication. All files earlier than this point can be deleted from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * archive, though there is no requirement to do so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xlog.c.html#L9383" title="access/transam/xlog.c:9383">GetOldestRestartPoint</a>(&amp;restartRedoPtr, &amp;restartTli);<br/></li>
<li>&nbsp; &nbsp; XLByteToSeg(restartRedoPtr, restartSegNo, <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; XLogFileName(lastRestartPointFname, restartTli, restartSegNo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * construct the command to be executed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; xlogRecoveryCmd = replace_percent_placeholders(command, commandName, <span class="Constant">&quot;r&quot;</span>, lastRestartPointFname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;executing </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, commandName, command)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * execute the constructed command<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fflush(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(wait_event_info);<br/></li>
<li>&nbsp; &nbsp; rc = system(xlogRecoveryCmd);<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(xlogRecoveryCmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rc != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the failure was due to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sort of signal, it's best to punt and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * abort recovery.&nbsp; See comments in <a href="#L54" title="access/transam/xlogarchive.c:54">RestoreArchivedFile</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport((failOnSignal &amp;&amp; wait_result_is_any_signal(rc, <span class="Constant">true</span>)) ? FATAL : WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; translator: First %s represents a postgresql.conf parameter name like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;recovery_end_command&quot;, the 2nd is the value of that parameter, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; third an already translated error message. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, commandName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; command, wait_result_to_str(rc))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A file was restored from the archive under a temporary filename (path),<br/></li>
<li></span><span class="Comment"> * and <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we want to keep it. Rename it under the permanent filename in<br/></li>
<li></span><span class="Comment"> * pg_wal (xlogfname), replacing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing file with the same name.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L358">&#x200c;</a></span><span class="linkable">KeepFileRestoredFromArchive</span>(<span class="Type">const</span> <span class="Type">char</span> *path, <span class="Type">const</span> <span class="Type">char</span> *xlogfname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; xlogfpath[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; reload = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat statbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(xlogfpath, MAXPGPATH, XLOGDIR <span class="Constant">&quot;/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, xlogfname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(xlogfpath, &amp;statbuf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; oldpath[MAXPGPATH];<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">static</span> <span class="Type">unsigned</span> <span class="Type">int</span> deletedcounter = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On Windows, if another process (e.g a walsender process) holds the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file open in FILE_SHARE_DELETE mode, unlink will succeed, but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file will still show up in directory listing until the last handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is closed, and we cannot rename the new file in its place until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that. To avoid that problem, rename the old file to a temporary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * name first. Use a counter to create a unique filename, because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same file might be restored from the archive multiple times, and a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * walsender could still be holding onto an old deleted version of it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(oldpath, MAXPGPATH, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.deleted</span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlogfpath, deletedcounter++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rename(xlogfpath, oldpath) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not rename file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlogfpath, oldpath)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* same-size buffers, so this never truncates */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; strlcpy(oldpath, xlogfpath, MAXPGPATH);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlink(oldpath) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlogfpath)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reload = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L782" title="storage/file/fd.c:782">durable_rename</a>(path, xlogfpath, ERROR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create .done file forcibly to prevent the restored segment from being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * archived again later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlog.c.html#L119" title="access/transam/xlog.c:119">XLogArchiveMode</a> != ARCHIVE_MODE_ALWAYS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L510" title="access/transam/xlogarchive.c:510">XLogArchiveForceDone</a>(xlogfname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L444" title="access/transam/xlogarchive.c:444">XLogArchiveNotify</a>(xlogfname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the existing file was replaced, since walsenders might have it open,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * request them to reload a currently-open segment. This is only required<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for WAL segments, walsenders don't hold other files open, but there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no harm in doing this too often, and we don't know what kind of a file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're dealing with here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (reload)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/walsender.c.html#L3537" title="replication/walsender.c:3537">WalSndRqstFileReload</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Signal walsender that new WAL has arrived. Again, this isn't necessary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we restored something other than a WAL segment, but it does no harm<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../replication/walsender.c.html#L3666" title="replication/walsender.c:3666">WalSndWakeup</a>(<span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L444" title="access/transam/xlogarchive.c:444">XLogArchiveNotify</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Create an archive notification file<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The name of the notification file is the message that will be picked up<br/></li>
<li></span><span class="Comment"> * by the archiver, e.g. we write 0000000100000001000000C6.ready<br/></li>
<li></span><span class="Comment"> * and the archiver then knows to archive XLOGDIR/0000000100000001000000C6,<br/></li>
<li></span><span class="Comment"> * then when complete, rename it to 0000000100000001000000C6.done<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L444">&#x200c;</a></span><span class="linkable">XLogArchiveNotify</span>(<span class="Type">const</span> <span class="Type">char</span> *xlog)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; archiveStatusPath[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* insert an otherwise empty file called &lt;XLOG&gt;.ready */<br/></li>
<li></span>&nbsp; &nbsp; StatusFilePath(archiveStatusPath, xlog, <span class="Constant">&quot;.ready&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L2583" title="storage/file/fd.c:2583">AllocateFile</a>(archiveStatusPath, <span class="Constant">&quot;w&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create archive status file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; archiveStatusPath)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2781" title="storage/file/fd.c:2781">FreeFile</a>(fd))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write archive status file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; archiveStatusPath)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Timeline history files are given the highest archival priority to <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the chance that a promoted standby will choose a timeline that is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already in use.&nbsp; However, the archiver ordinarily tries to gather<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multiple files to archive from each scan of the archive_status<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * directory, which means that newly created timeline history files could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be left unarchived for a while.&nbsp; To ensure that the archiver picks up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timeline history files as soon as possible, we force the archiver to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan the archive_status directory the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time it looks for a file to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * archive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsTLHistoryFileName(xlog))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/pgarch.c.html#L802" title="postmaster/pgarch.c:802">PgArchForceDirScan</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Notify archiver that it's got something to do */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/pgarch.c.html#L280" title="postmaster/pgarch.c:280">PgArchWakeup</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convenience routine to notify using segment number representation of filename<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L492">&#x200c;</a></span><span class="linkable">XLogArchiveNotifySeg</span>(XLogSegNo segno, TimeLineID tli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; xlog[MAXFNAMELEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(tli != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLogFileName(xlog, tli, segno, <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L444" title="access/transam/xlogarchive.c:444">XLogArchiveNotify</a>(xlog);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L510" title="access/transam/xlogarchive.c:510">XLogArchiveForceDone</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Emit notification forcibly that an XLOG segment file has been successfully<br/></li>
<li></span><span class="Comment"> * archived, by creating &lt;XLOG&gt;.done regardless of whether &lt;XLOG&gt;.ready<br/></li>
<li></span><span class="Comment"> * exists or not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L510">&#x200c;</a></span><span class="linkable">XLogArchiveForceDone</span>(<span class="Type">const</span> <span class="Type">char</span> *xlog)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; archiveReady[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; archiveDone[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat stat_buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exit if already known done */<br/></li>
<li></span>&nbsp; &nbsp; StatusFilePath(archiveDone, xlog, <span class="Constant">&quot;.done&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(archiveDone, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If .ready exists, rename it to .done */<br/></li>
<li></span>&nbsp; &nbsp; StatusFilePath(archiveReady, xlog, <span class="Constant">&quot;.ready&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(archiveReady, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../storage/file/fd.c.html#L782" title="storage/file/fd.c:782">durable_rename</a>(archiveReady, archiveDone, WARNING);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* insert an otherwise empty file called &lt;XLOG&gt;.done */<br/></li>
<li></span>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L2583" title="storage/file/fd.c:2583">AllocateFile</a>(archiveDone, <span class="Constant">&quot;w&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create archive status file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; archiveDone)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2781" title="storage/file/fd.c:2781">FreeFile</a>(fd))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write archive status file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; archiveDone)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L565" title="access/transam/xlogarchive.c:565">XLogArchiveCheckDone</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called when we are ready to delete or recycle an old XLOG segment<br/></li>
<li></span><span class="Comment"> * file or backup history file.&nbsp; If it is okay to delete it then return true.<br/></li>
<li></span><span class="Comment"> * If it is not time to delete it, make sure a .ready file exists, and return<br/></li>
<li></span><span class="Comment"> * false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If &lt;XLOG&gt;.done exists, then return true; else if &lt;XLOG&gt;.ready exists,<br/></li>
<li></span><span class="Comment"> * then return false; else create &lt;XLOG&gt;.ready and return false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The reason we do things this way is so that if the original attempt to<br/></li>
<li></span><span class="Comment"> * create &lt;XLOG&gt;.ready fails, we'll retry during subsequent checkpoints.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L565">&#x200c;</a></span><span class="linkable">XLogArchiveCheckDone</span>(<span class="Type">const</span> <span class="Type">char</span> *xlog)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; archiveStatusPath[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat stat_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The file is always deletable if archive_mode is &quot;off&quot;. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogArchivingActive())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During archive recovery, the file is deletable if archive_mode is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;always&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogArchivingAlways() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L6326" title="access/transam/xlog.c:6326">GetRecoveryState</a>() == RECOVERY_STATE_ARCHIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point of the logic, note that we are either a primary with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * archive_mode set to &quot;on&quot; or &quot;always&quot;, or a standby with archive_mode<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set to &quot;always&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First check for .done --- this means archiver is done with it */<br/></li>
<li></span>&nbsp; &nbsp; StatusFilePath(archiveStatusPath, xlog, <span class="Constant">&quot;.done&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(archiveStatusPath, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for .ready --- this means archiver is still busy with it */<br/></li>
<li></span>&nbsp; &nbsp; StatusFilePath(archiveStatusPath, xlog, <span class="Constant">&quot;.ready&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(archiveStatusPath, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Race condition --- maybe archiver just finished, so recheck */<br/></li>
<li></span>&nbsp; &nbsp; StatusFilePath(archiveStatusPath, xlog, <span class="Constant">&quot;.done&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(archiveStatusPath, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Retry creation of the .ready file */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L444" title="access/transam/xlogarchive.c:444">XLogArchiveNotify</a>(xlog);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L619" title="access/transam/xlogarchive.c:619">XLogArchiveIsBusy</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check to see if an XLOG segment file is still unarchived.<br/></li>
<li></span><span class="Comment"> * This is almost but not quite the inverse of <a href="#L565" title="access/transam/xlogarchive.c:565">XLogArchiveCheckDone</a>: in<br/></li>
<li></span><span class="Comment"> * the first place we aren't chartered to recreate the .ready file, and<br/></li>
<li></span><span class="Comment"> * in the second place we should consider that if the file is already gone<br/></li>
<li></span><span class="Comment"> * then it's not busy.&nbsp; (This check is needed to handle the race condition<br/></li>
<li></span><span class="Comment"> * that a checkpoint already deleted the no-longer-needed file.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L619">&#x200c;</a></span><span class="linkable">XLogArchiveIsBusy</span>(<span class="Type">const</span> <span class="Type">char</span> *xlog)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; archiveStatusPath[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat stat_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First check for .done --- this means archiver is done with it */<br/></li>
<li></span>&nbsp; &nbsp; StatusFilePath(archiveStatusPath, xlog, <span class="Constant">&quot;.done&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(archiveStatusPath, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for .ready --- this means archiver is still busy with it */<br/></li>
<li></span>&nbsp; &nbsp; StatusFilePath(archiveStatusPath, xlog, <span class="Constant">&quot;.ready&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(archiveStatusPath, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Race condition --- maybe archiver just finished, so recheck */<br/></li>
<li></span>&nbsp; &nbsp; StatusFilePath(archiveStatusPath, xlog, <span class="Constant">&quot;.done&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(archiveStatusPath, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check to see if the WAL file has been removed by checkpoint, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implies it has already been archived, and explains why we can't see a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * status file for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(archiveStatusPath, MAXPGPATH, XLOGDIR <span class="Constant">&quot;/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, xlog);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(archiveStatusPath, &amp;stat_buf) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno == <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L664" title="access/transam/xlogarchive.c:664">XLogArchiveIsReadyOrDone</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check to see if an XLOG segment file has a .ready or .done file.<br/></li>
<li></span><span class="Comment"> * This is similar to <a href="#L619" title="access/transam/xlogarchive.c:619">XLogArchiveIsBusy</a>(), but returns true if the file<br/></li>
<li></span><span class="Comment"> * is already archived or is about to be archived.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is currently only used at recovery.&nbsp; During normal operation this<br/></li>
<li></span><span class="Comment"> * would be racy: the file might get removed or marked with .ready as we're<br/></li>
<li></span><span class="Comment"> * checking it, or immediately after we return.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L664">&#x200c;</a></span><span class="linkable">XLogArchiveIsReadyOrDone</span>(<span class="Type">const</span> <span class="Type">char</span> *xlog)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; archiveStatusPath[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat stat_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First check for .done --- this means archiver is done with it */<br/></li>
<li></span>&nbsp; &nbsp; StatusFilePath(archiveStatusPath, xlog, <span class="Constant">&quot;.done&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(archiveStatusPath, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check for .ready --- this means archiver is still busy with it */<br/></li>
<li></span>&nbsp; &nbsp; StatusFilePath(archiveStatusPath, xlog, <span class="Constant">&quot;.ready&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(archiveStatusPath, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Race condition --- maybe archiver just finished, so recheck */<br/></li>
<li></span>&nbsp; &nbsp; StatusFilePath(archiveStatusPath, xlog, <span class="Constant">&quot;.done&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(archiveStatusPath, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L694" title="access/transam/xlogarchive.c:694">XLogArchiveIsReady</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check to see if an XLOG segment file has an archive notification (.ready)<br/></li>
<li></span><span class="Comment"> * file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L694">&#x200c;</a></span><span class="linkable">XLogArchiveIsReady</span>(<span class="Type">const</span> <span class="Type">char</span> *xlog)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; archiveStatusPath[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat stat_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; StatusFilePath(archiveStatusPath, xlog, <span class="Constant">&quot;.ready&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(archiveStatusPath, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L712" title="access/transam/xlogarchive.c:712">XLogArchiveCleanup</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Cleanup archive notification file(s) for a particular xlog segment<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L712">&#x200c;</a></span><span class="linkable">XLogArchiveCleanup</span>(<span class="Type">const</span> <span class="Type">char</span> *xlog)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; archiveStatusPath[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove the .done file */<br/></li>
<li></span>&nbsp; &nbsp; StatusFilePath(archiveStatusPath, xlog, <span class="Constant">&quot;.done&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; unlink(archiveStatusPath);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* should we complain about failure? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove the .ready file if present --- normally it shouldn't be */<br/></li>
<li></span>&nbsp; &nbsp; StatusFilePath(archiveStatusPath, xlog, <span class="Constant">&quot;.ready&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; unlink(archiveStatusPath);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* should we complain about failure? */<br/></li>
<li></span>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
