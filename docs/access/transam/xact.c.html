<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/transam/xact.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/transam/xact.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L97">CheckXidAlive</a></li>
<li><a href="#L257">CurrentTransactionState</a></li>
<li><a href="#L82">DefaultXactDeferrable</a></li>
<li><a href="#L76">DefaultXactIsoLevel</a></li>
<li><a href="#L79">DefaultXactReadOnly</a></li>
<li><a href="#L134">MyXactFlags</a></li>
<li><a href="#L125">ParallelCurrentXids</a></li>
<li><a href="#L324">SubXact_callbacks</a></li>
<li><a href="#L244">TopTransactionStateData</a></li>
<li><a href="#L300">TransactionAbortContext</a></li>
<li><a href="#L83">XactDeferrable</a></li>
<li><a href="#L77">XactIsoLevel</a></li>
<li><a href="#L80">XactReadOnly</a></li>
<li><a href="#L123">XactTopFullTransactionId</a></li>
<li><a href="#L312">Xact_callbacks</a></li>
<li><a href="#L98">bsysscan</a></li>
<li><a href="#L264">currentCommandId</a></li>
<li><a href="#L265">currentCommandIdUsed</a></li>
<li><a href="#L263">currentSubTransactionId</a></li>
<li><a href="#L290">forceSyncCommit</a></li>
<li><a href="#L124">nParallelCurrentXids</a></li>
<li><a href="#L254">nUnreportedXids</a></li>
<li><a href="#L285">prepareGID</a></li>
<li><a href="#L278">stmtStartTimestamp</a></li>
<li><a href="#L85">synchronous_commit</a></li>
<li><a href="#L255">unreportedXids</a></li>
<li><a href="#L277">xactStartTimestamp</a></li>
<li><a href="#L279">xactStopTimestamp</a></li>
<li><a href="#L293">xact_is_sampled</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L224">SerializedTransactionState</a></li>
<li><a href="#L233">SerializedTransactionState</a></li>
<li><a href="#L317">SubXactCallbackItem</a></li>
<li><a href="#L322">SubXactCallbackItem</a></li>
<li><a href="#L155">TBlockState</a></li>
<li><a href="#L182">TBlockState</a></li>
<li><a href="#L139">TransState</a></li>
<li><a href="#L147">TransState</a></li>
<li><a href="#L218">TransactionState</a></li>
<li><a href="#L191">TransactionStateData</a></li>
<li><a href="#L216">TransactionStateData</a></li>
<li><a href="#L305">XactCallbackItem</a></li>
<li><a href="#L310">XactCallbackItem</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L3387">AbortCurrentTransaction</a></li>
<li><a href="#L3405">AbortCurrentTransactionInternal</a></li>
<li><a href="#L4811">AbortOutOfAnyTransaction</a></li>
<li><a href="#L5162">AbortSubTransaction</a></li>
<li><a href="#L2749">AbortTransaction</a></li>
<li><a href="#L632">AssignTransactionId</a></li>
<li><a href="#L1853">AtAbort_Memory</a></li>
<li><a href="#L1885">AtAbort_ResourceOwner</a></li>
<li><a href="#L1558">AtCCI_LocalCache</a></li>
<li><a href="#L1943">AtCleanup_Memory</a></li>
<li><a href="#L1577">AtCommit_Memory</a></li>
<li><a href="#L1164">AtStart_Cache</a></li>
<li><a href="#L1173">AtStart_Memory</a></li>
<li><a href="#L1220">AtStart_ResourceOwner</a></li>
<li><a href="#L1873">AtSubAbort_Memory</a></li>
<li><a href="#L1898">AtSubAbort_ResourceOwner</a></li>
<li><a href="#L1911">AtSubAbort_childXids</a></li>
<li><a href="#L1979">AtSubCleanup_Memory</a></li>
<li><a href="#L1604">AtSubCommit_Memory</a></li>
<li><a href="#L1633">AtSubCommit_childXids</a></li>
<li><a href="#L1248">AtSubStart_Memory</a></li>
<li><a href="#L1272">AtSubStart_ResourceOwner</a></li>
<li><a href="#L4275">BeginImplicitTransactionBlock</a></li>
<li><a href="#L4643">BeginInternalSubTransaction</a></li>
<li><a href="#L3873">BeginTransactionBlock</a></li>
<li><a href="#L5658">BlockStateAsString</a></li>
<li><a href="#L3847">CallSubXactCallbacks</a></li>
<li><a href="#L3787">CallXactCallbacks</a></li>
<li><a href="#L3671">CheckTransactionBlock</a></li>
<li><a href="#L5334">CleanupSubTransaction</a></li>
<li><a href="#L2945">CleanupTransaction</a></li>
<li><a href="#L1097">CommandCounterIncrement</a></li>
<li><a href="#L5048">CommitSubTransaction</a></li>
<li><a href="#L2178">CommitTransaction</a></li>
<li><a href="#L3093">CommitTransactionCommand</a></li>
<li><a href="#L3111">CommitTransactionCommandInternal</a></li>
<li><a href="#L4322">DefineSavepoint</a></li>
<li><a href="#L4300">EndImplicitTransactionBlock</a></li>
<li><a href="#L5587">EndParallelWorkerTransaction</a></li>
<li><a href="#L3993">EndTransactionBlock</a></li>
<li><a href="#L1048">EnterParallelMode</a></li>
<li><a href="#L5463">EstimateTransactionStateSpace</a></li>
<li><a href="#L1061">ExitParallelMode</a></li>
<li><a href="#L1149">ForceSyncCommit</a></li>
<li><a href="#L826">GetCurrentCommandId</a></li>
<li><a href="#L509">GetCurrentFullTransactionId</a></li>
<li><a href="#L527">GetCurrentFullTransactionIdIfAny</a></li>
<li><a href="#L876">GetCurrentStatementStartTimestamp</a></li>
<li><a href="#L788">GetCurrentSubTransactionId</a></li>
<li><a href="#L451">GetCurrentTransactionId</a></li>
<li><a href="#L468">GetCurrentTransactionIdIfAny</a></li>
<li><a href="#L926">GetCurrentTransactionNestLevel</a></li>
<li><a href="#L867">GetCurrentTransactionStartTimestamp</a></li>
<li><a href="#L888">GetCurrentTransactionStopTimestamp</a></li>
<li><a href="#L604">GetStableLatestTransactionId</a></li>
<li><a href="#L480">GetTopFullTransactionId</a></li>
<li><a href="#L496">GetTopFullTransactionIdIfAny</a></li>
<li><a href="#L423">GetTopTransactionId</a></li>
<li><a href="#L438">GetTopTransactionIdIfAny</a></li>
<li><a href="#L404">IsAbortedTransactionBlockState</a></li>
<li><a href="#L1086">IsInParallelMode</a></li>
<li><a href="#L3715">IsInTransactionBlock</a></li>
<li><a href="#L4988">IsSubTransaction</a></li>
<li><a href="#L556">IsSubxactTopXidLogPending</a></li>
<li><a href="#L4915">IsTransactionBlock</a></li>
<li><a href="#L4933">IsTransactionOrTransactionBlock</a></li>
<li><a href="#L384">IsTransactionState</a></li>
<li><a href="#L538">MarkCurrentTransactionIdLoggedIfAny</a></li>
<li><a href="#L588">MarkSubxactTopXidLogged</a></li>
<li><a href="#L5429">PopTransaction</a></li>
<li><a href="#L2460">PrepareTransaction</a></li>
<li><a href="#L3941">PrepareTransactionBlock</a></li>
<li><a href="#L3584">PreventInTransactionBlock</a></li>
<li><a href="#L5367">PushTransaction</a></li>
<li><a href="#L1723">RecordTransactionAbort</a></li>
<li><a href="#L1304">RecordTransactionCommit</a></li>
<li><a href="#L3813">RegisterSubXactCallback</a></li>
<li><a href="#L3753">RegisterXactCallback</a></li>
<li><a href="#L4717">ReleaseCurrentSubTransaction</a></li>
<li><a href="#L4407">ReleaseSavepoint</a></li>
<li><a href="#L3662">RequireTransactionBlock</a></li>
<li><a href="#L3080">RestoreTransactionCharacteristics</a></li>
<li><a href="#L4745">RollbackAndReleaseCurrentSubTransaction</a></li>
<li><a href="#L4516">RollbackToSavepoint</a></li>
<li><a href="#L3072">SaveTransactionCharacteristics</a></li>
<li><a href="#L5491">SerializeTransactionState</a></li>
<li><a href="#L911">SetCurrentStatementStartTimestamp</a></li>
<li><a href="#L856">SetParallelStartTimestamps</a></li>
<li><a href="#L5599">ShowTransactionState</a></li>
<li><a href="#L5611">ShowTransactionStateRec</a></li>
<li><a href="#L5562">StartParallelWorkerTransaction</a></li>
<li><a href="#L5011">StartSubTransaction</a></li>
<li><a href="#L2014">StartTransaction</a></li>
<li><a href="#L2995">StartTransactionCommand</a></li>
<li><a href="#L802">SubTransactionIsActive</a></li>
<li><a href="#L5711">TransStateAsString</a></li>
<li><a href="#L4947">TransactionBlockStatusCode</a></li>
<li><a href="#L938">TransactionIdIsCurrentTransactionId</a></li>
<li><a href="#L1039">TransactionStartedDuringRecovery</a></li>
<li><a href="#L3826">UnregisterSubXactCallback</a></li>
<li><a href="#L3766">UnregisterXactCallback</a></li>
<li><a href="#L4153">UserAbortTransactionBlock</a></li>
<li><a href="#L3656">WarnNoTransactionBlock</a></li>
<li><a href="#L5937">XactLogAbortRecord</a></li>
<li><a href="#L5765">XactLogCommitRecord</a></li>
<li><a href="#L5741">xactGetCommittedChildren</a></li>
<li><a href="#L6314">xact_redo</a></li>
<li><a href="#L6235">xact_redo_abort</a></li>
<li><a href="#L6081">xact_redo_commit</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L236">SerializedTransactionStateHeaderSize</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * xact.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; top level transaction system support routines<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See src/backend/access/transam/README for more information.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/transam/xact.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;time.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/commit_ts.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/multixact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/parallel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/subtrans.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/twophase.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogrecovery.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/index.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_enum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/storage.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/async.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/tablecmds.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/pg_prng.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/spi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/be-fsstubs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pg_trace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logical.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logicallauncher.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logicalworker.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/origin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/snapbuild.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/syncrep.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/condition_variable.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/md.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/sinvaladt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/combocid.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/relmapper.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timeout.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; User-tweakable parameters<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L76">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">DefaultXactIsoLevel</span> = XACT_READ_COMMITTED;<br/></li>
<li><a id="L77">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">XactIsoLevel</span> = XACT_READ_COMMITTED;<br/></li>
<li><br/></li>
<li><a id="L79">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">DefaultXactReadOnly</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L80">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">XactReadOnly</span>;<br/></li>
<li><br/></li>
<li><a id="L82">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">DefaultXactDeferrable</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L83">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">XactDeferrable</span>;<br/></li>
<li><br/></li>
<li><a id="L85">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">synchronous_commit</span> = SYNCHRONOUS_COMMIT_ON;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L97" title="access/transam/xact.c:97">CheckXidAlive</a> is a xid value pointing to a possibly ongoing (sub)<br/></li>
<li></span><span class="Comment"> * transaction.&nbsp; Currently, it is used in logical decoding.&nbsp; It's possible<br/></li>
<li></span><span class="Comment"> * that such transactions can get aborted while the decoding is ongoing in<br/></li>
<li></span><span class="Comment"> * which case we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> decoding that particular transaction.&nbsp; To ensure that we<br/></li>
<li></span><span class="Comment"> * check whether the <a href="#L97" title="access/transam/xact.c:97">CheckXidAlive</a> is aborted after fetching the tuple from<br/></li>
<li></span><span class="Comment"> * system tables.&nbsp; We also ensure that during logical decoding we never<br/></li>
<li></span><span class="Comment"> * directly access the tableam or heap APIs because we are checking for the<br/></li>
<li></span><span class="Comment"> * concurrent aborts only in systable_* APIs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L97">&#x200c;</a></span>TransactionId <span class="linkable">CheckXidAlive</span> = InvalidTransactionId;<br/></li>
<li><a id="L98">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">bsysscan</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When running as a parallel worker, we place only a single<br/></li>
<li></span><span class="Comment"> * <a href="#L191" title="access/transam/xact.c:191">TransactionStateData</a> on the parallel worker's state stack, and the XID<br/></li>
<li></span><span class="Comment"> * reflected there will be that of the *innermost* currently-active<br/></li>
<li></span><span class="Comment"> * subtransaction in the backend that initiated parallelism.&nbsp; However,<br/></li>
<li></span><span class="Comment"> * <a href="#L423" title="access/transam/xact.c:423">GetTopTransactionId</a>() and <a href="#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>()<br/></li>
<li></span><span class="Comment"> * need to return the same answers in the parallel worker as they would have<br/></li>
<li></span><span class="Comment"> * in the user backend, so we need some additional bookkeeping.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L123" title="access/transam/xact.c:123">XactTopFullTransactionId</a> stores the XID of our toplevel transaction, which<br/></li>
<li></span><span class="Comment"> * will be the same as <a href="#L244" title="access/transam/xact.c:244">TopTransactionStateData</a>.fullTransactionId in an<br/></li>
<li></span><span class="Comment"> * ordinary backend; but in a parallel backend, which does not have the entire<br/></li>
<li></span><span class="Comment"> * transaction state, it will instead be copied from the backend that started<br/></li>
<li></span><span class="Comment"> * the parallel operation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L124" title="access/transam/xact.c:124">nParallelCurrentXids</a> will be 0 and <a href="#L125" title="access/transam/xact.c:125">ParallelCurrentXids</a> NULL in an ordinary<br/></li>
<li></span><span class="Comment"> * backend, but in a parallel backend, <a href="#L124" title="access/transam/xact.c:124">nParallelCurrentXids</a> will contain the<br/></li>
<li></span><span class="Comment"> * number of XIDs that need to be considered current, and <a href="#L125" title="access/transam/xact.c:125">ParallelCurrentXids</a><br/></li>
<li></span><span class="Comment"> * will contain the XIDs themselves.&nbsp; This includes all XIDs that were current<br/></li>
<li></span><span class="Comment"> * or sub-committed in the parent at the time the parallel operation began.<br/></li>
<li></span><span class="Comment"> * The XIDs are stored sorted in numerical order (not logical order) to make<br/></li>
<li></span><span class="Comment"> * lookups as fast as possible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L123">&#x200c;</a></span><span class="Type">static</span> FullTransactionId <span class="linkable">XactTopFullTransactionId</span> = {InvalidTransactionId};<br/></li>
<li><a id="L124">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">nParallelCurrentXids</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L125">&#x200c;</a><span class="Type">static</span> TransactionId *<span class="linkable">ParallelCurrentXids</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Miscellaneous flag bits to record events which occur on the top level<br/></li>
<li></span><span class="Comment"> * transaction. These flags are only persisted in <a href="#L134" title="access/transam/xact.c:134">MyXactFlags</a> and are intended<br/></li>
<li></span><span class="Comment"> * so we remember to do certain things later on in the transaction. This is<br/></li>
<li></span><span class="Comment"> * globally accessible, so can be set from anywhere in the code that requires<br/></li>
<li></span><span class="Comment"> * recording flags.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L134">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">MyXactFlags</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; transaction states - transaction state from server perspective<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L139">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">enum</span> <span class="linkable">TransState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TRANS_DEFAULT,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* idle */<br/></li>
<li></span>&nbsp; &nbsp; TRANS_START,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* transaction starting */<br/></li>
<li></span>&nbsp; &nbsp; TRANS_INPROGRESS,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* inside a valid transaction */<br/></li>
<li></span>&nbsp; &nbsp; TRANS_COMMIT,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* commit in progress */<br/></li>
<li></span>&nbsp; &nbsp; TRANS_ABORT,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* abort in progress */<br/></li>
<li></span>&nbsp; &nbsp; TRANS_PREPARE,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* prepare in progress */<br/></li>
<li><a id="L147">&#x200c;</a></span>} <span class="linkable">TransState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; transaction block states - transaction state of client queries<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the subtransaction states are used only for non-topmost<br/></li>
<li></span><span class="Comment"> * transactions; the others appear only in the topmost transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L155">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">enum</span> <span class="linkable">TBlockState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not-in-transaction-block states */<br/></li>
<li></span>&nbsp; &nbsp; TBLOCK_DEFAULT,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* idle */<br/></li>
<li></span>&nbsp; &nbsp; TBLOCK_STARTED,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* running single-query transaction */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transaction block states */<br/></li>
<li></span>&nbsp; &nbsp; TBLOCK_BEGIN,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* starting transaction block */<br/></li>
<li></span>&nbsp; &nbsp; TBLOCK_INPROGRESS,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* live transaction */<br/></li>
<li></span>&nbsp; &nbsp; TBLOCK_IMPLICIT_INPROGRESS, <span class="Comment">/* live transaction after implicit BEGIN */<br/></li>
<li></span>&nbsp; &nbsp; TBLOCK_PARALLEL_INPROGRESS, <span class="Comment">/* live transaction inside parallel worker */<br/></li>
<li></span>&nbsp; &nbsp; TBLOCK_END,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* COMMIT received */<br/></li>
<li></span>&nbsp; &nbsp; TBLOCK_ABORT,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* failed xact, awaiting ROLLBACK */<br/></li>
<li></span>&nbsp; &nbsp; TBLOCK_ABORT_END,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* failed xact, ROLLBACK received */<br/></li>
<li></span>&nbsp; &nbsp; TBLOCK_ABORT_PENDING,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* live xact, ROLLBACK received */<br/></li>
<li></span>&nbsp; &nbsp; TBLOCK_PREPARE,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* live xact, PREPARE received */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* subtransaction states */<br/></li>
<li></span>&nbsp; &nbsp; TBLOCK_SUBBEGIN,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* starting a subtransaction */<br/></li>
<li></span>&nbsp; &nbsp; TBLOCK_SUBINPROGRESS,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* live subtransaction */<br/></li>
<li></span>&nbsp; &nbsp; TBLOCK_SUBRELEASE,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* RELEASE received */<br/></li>
<li></span>&nbsp; &nbsp; TBLOCK_SUBCOMMIT,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* COMMIT received while TBLOCK_SUBINPROGRESS */<br/></li>
<li></span>&nbsp; &nbsp; TBLOCK_SUBABORT,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* failed subxact, awaiting ROLLBACK */<br/></li>
<li></span>&nbsp; &nbsp; TBLOCK_SUBABORT_END,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* failed subxact, ROLLBACK received */<br/></li>
<li></span>&nbsp; &nbsp; TBLOCK_SUBABORT_PENDING,&nbsp; &nbsp; <span class="Comment">/* live subxact, ROLLBACK received */<br/></li>
<li></span>&nbsp; &nbsp; TBLOCK_SUBRESTART,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* live subxact, ROLLBACK TO received */<br/></li>
<li></span>&nbsp; &nbsp; TBLOCK_SUBABORT_RESTART,&nbsp; &nbsp; <span class="Comment">/* failed subxact, ROLLBACK TO received */<br/></li>
<li><a id="L182">&#x200c;</a></span>} <span class="linkable">TBlockState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; transaction state structure<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: parallelModeLevel counts the number of unmatched <a href="#L1048" title="access/transam/xact.c:1048">EnterParallelMode</a><br/></li>
<li></span><span class="Comment"> * calls done at this transaction level.&nbsp; parallelChildXact is true if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> transaction level has nonzero parallelModeLevel.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L191">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">TransactionStateData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FullTransactionId fullTransactionId;&nbsp; &nbsp; <span class="Comment">/* my FullTransactionId */<br/></li>
<li></span>&nbsp; &nbsp; SubTransactionId subTransactionId;&nbsp; &nbsp; <span class="Comment">/* my subxact ID */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* savepoint name, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; savepointLevel; <span class="Comment">/* savepoint level */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L139" title="access/transam/xact.c:139">TransState</a>&nbsp; &nbsp; state;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* low-level state */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L155" title="access/transam/xact.c:155">TBlockState</a> blockState;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* high-level state */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nestingLevel;&nbsp; &nbsp; <span class="Comment">/* transaction nesting depth */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gucNestLevel;&nbsp; &nbsp; <span class="Comment">/* GUC context nesting depth */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext curTransactionContext;&nbsp; &nbsp; <span class="Comment">/* my xact-lifetime context */<br/></li>
<li></span>&nbsp; &nbsp; ResourceOwner curTransactionOwner;&nbsp; &nbsp; <span class="Comment">/* my query resources */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId *childXids;&nbsp; &nbsp; <span class="Comment">/* subcommitted child XIDs, in XID order */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nChildXids;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* # of subcommitted child XIDs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxChildXids;&nbsp; &nbsp; <span class="Comment">/* allocated size of childXids[] */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevUser;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* previous <a href="../../utils/init/miscinit.c.html#L497" title="utils/init/miscinit.c:497">CurrentUserId</a> setting */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevSecContext; <span class="Comment">/* previous <a href="../../utils/init/miscinit.c.html#L503" title="utils/init/miscinit.c:503">SecurityRestrictionContext</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; prevXactReadOnly;&nbsp; &nbsp; <span class="Comment">/* entry-time xact r/o state */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; startedInRecovery;&nbsp; &nbsp; <span class="Comment">/* did we start in recovery? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; didLogXid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* has xid been included in WAL record? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallelModeLevel;&nbsp; &nbsp; <span class="Comment">/* Enter/<a href="#L1061" title="access/transam/xact.c:1061">ExitParallelMode</a> counter */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; parallelChildXact;&nbsp; &nbsp; <span class="Comment">/* is <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parent transaction parallel? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; chain;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* start a new block after this one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; topXidLogged;&nbsp; &nbsp; <span class="Comment">/* for a subxact: is top-level XID logged? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L191" title="access/transam/xact.c:191">TransactionStateData</a> *parent;&nbsp; &nbsp; <span class="Comment">/* back link to parent */<br/></li>
<li><a id="L216">&#x200c;</a></span>} <span class="linkable">TransactionStateData</span>;<br/></li>
<li><br/></li>
<li><a id="L218">&#x200c;</a><span class="Type">typedef</span> <a href="#L191" title="access/transam/xact.c:191">TransactionStateData</a> *<span class="linkable">TransactionState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Serialized representation used to transmit transaction state to parallel<br/></li>
<li></span><span class="Comment"> * workers through shared memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L224">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SerializedTransactionState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xactIsoLevel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; xactDeferrable;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId topFullTransactionId;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId currentFullTransactionId;<br/></li>
<li>&nbsp; &nbsp; CommandId&nbsp; &nbsp; <a href="#L264" title="access/transam/xact.c:264">currentCommandId</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L124" title="access/transam/xact.c:124">nParallelCurrentXids</a>;<br/></li>
<li>&nbsp; &nbsp; TransactionId parallelCurrentXids[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L233">&#x200c;</a>} <span class="linkable">SerializedTransactionState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* The size of <a href="#L224" title="access/transam/xact.c:224">SerializedTransactionState</a>, not including the final array. */<br/></li>
<li><a id="L236">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SerializedTransactionStateHeaderSize</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; offsetof(<a href="#L224" title="access/transam/xact.c:224">SerializedTransactionState</a>, parallelCurrentXids)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a> always points to the current transaction state<br/></li>
<li></span><span class="Comment"> * block.&nbsp; It will point to <a href="#L244" title="access/transam/xact.c:244">TopTransactionStateData</a> when not in a<br/></li>
<li></span><span class="Comment"> * transaction at all, or when in a top-level transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L244">&#x200c;</a></span><span class="Type">static</span> <a href="#L191" title="access/transam/xact.c:191">TransactionStateData</a> <span class="linkable">TopTransactionStateData</span> = {<br/></li>
<li>&nbsp; &nbsp; .state = TRANS_DEFAULT,<br/></li>
<li>&nbsp; &nbsp; .blockState = TBLOCK_DEFAULT,<br/></li>
<li>&nbsp; &nbsp; .topXidLogged = <span class="Constant">false</span>,<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L255" title="access/transam/xact.c:255">unreportedXids</a> holds XIDs of all subtransactions that have not yet been<br/></li>
<li></span><span class="Comment"> * reported in an XLOG_XACT_ASSIGNMENT record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L254">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">nUnreportedXids</span>;<br/></li>
<li><a id="L255">&#x200c;</a><span class="Type">static</span> TransactionId <span class="linkable">unreportedXids</span>[PGPROC_MAX_CACHED_SUBXIDS];<br/></li>
<li><br/></li>
<li><a id="L257">&#x200c;</a><span class="Type">static</span> <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> <span class="linkable">CurrentTransactionState</span> = &amp;<a href="#L244" title="access/transam/xact.c:244">TopTransactionStateData</a>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The subtransaction ID and command ID assignment counters are global<br/></li>
<li></span><span class="Comment"> * to a whole transaction, so we do not keep them in the state stack.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L263">&#x200c;</a></span><span class="Type">static</span> SubTransactionId <span class="linkable">currentSubTransactionId</span>;<br/></li>
<li><a id="L264">&#x200c;</a><span class="Type">static</span> CommandId <span class="linkable">currentCommandId</span>;<br/></li>
<li><a id="L265">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">currentCommandIdUsed</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L277" title="access/transam/xact.c:277">xactStartTimestamp</a> is the value of transaction_timestamp().<br/></li>
<li></span><span class="Comment"> * <a href="#L278" title="access/transam/xact.c:278">stmtStartTimestamp</a> is the value of <a href="../../utils/adt/timestamp.c.html#L1624" title="utils/adt/timestamp.c:1624">statement_timestamp</a>().<br/></li>
<li></span><span class="Comment"> * <a href="#L279" title="access/transam/xact.c:279">xactStopTimestamp</a> is the time at which we log a commit / abort WAL record,<br/></li>
<li></span><span class="Comment"> * or if that was skipped, the time of the first subsequent<br/></li>
<li></span><span class="Comment"> * <a href="#L888" title="access/transam/xact.c:888">GetCurrentTransactionStopTimestamp</a>() call.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These do not change as we enter and exit subtransactions, so we don't<br/></li>
<li></span><span class="Comment"> * keep them inside the <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> stack.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L277">&#x200c;</a></span><span class="Type">static</span> TimestampTz <span class="linkable">xactStartTimestamp</span>;<br/></li>
<li><a id="L278">&#x200c;</a><span class="Type">static</span> TimestampTz <span class="linkable">stmtStartTimestamp</span>;<br/></li>
<li><a id="L279">&#x200c;</a><span class="Type">static</span> TimestampTz <span class="linkable">xactStopTimestamp</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GID to be used for preparing the current transaction.&nbsp; This is also<br/></li>
<li></span><span class="Comment"> * global to a whole transaction, so we don't keep it in the state stack.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L285">&#x200c;</a></span><span class="Type">static</span> <span class="Type">char</span> *<span class="linkable">prepareGID</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Some commands want to force synchronous commit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L290">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">forceSyncCommit</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Flag for logging statements in a transaction. */<br/></li>
<li><a id="L293">&#x200c;</a></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">xact_is_sampled</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Private context for transaction-abort work --- we reserve space for this<br/></li>
<li></span><span class="Comment"> * at startup to ensure that <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a> and <a href="#L5162" title="access/transam/xact.c:5162">AbortSubTransaction</a> can work<br/></li>
<li></span><span class="Comment"> * when we've run out of memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L300">&#x200c;</a></span><span class="Type">static</span> MemoryContext <span class="linkable">TransactionAbortContext</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * List of add-on start- and end-of-xact callbacks<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L305">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">XactCallbackItem</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L305" title="access/transam/xact.c:305">XactCallbackItem</a> *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; XactCallback callback;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *arg;<br/></li>
<li><a id="L310">&#x200c;</a>} <span class="linkable">XactCallbackItem</span>;<br/></li>
<li><br/></li>
<li><a id="L312">&#x200c;</a><span class="Type">static</span> <a href="#L305" title="access/transam/xact.c:305">XactCallbackItem</a> *<span class="linkable">Xact_callbacks</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * List of add-on start- and end-of-subxact callbacks<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L317">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SubXactCallbackItem</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L317" title="access/transam/xact.c:317">SubXactCallbackItem</a> *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; SubXactCallback callback;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *arg;<br/></li>
<li><a id="L322">&#x200c;</a>} <span class="linkable">SubXactCallbackItem</span>;<br/></li>
<li><br/></li>
<li><a id="L324">&#x200c;</a><span class="Type">static</span> <a href="#L317" title="access/transam/xact.c:317">SubXactCallbackItem</a> *<span class="linkable">SubXact_callbacks</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* local function prototypes */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L632" title="access/transam/xact.c:632">AssignTransactionId</a>(<a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1853" title="access/transam/xact.c:1853">AtAbort_Memory</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1943" title="access/transam/xact.c:1943">AtCleanup_Memory</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1885" title="access/transam/xact.c:1885">AtAbort_ResourceOwner</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1558" title="access/transam/xact.c:1558">AtCCI_LocalCache</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1577" title="access/transam/xact.c:1577">AtCommit_Memory</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1164" title="access/transam/xact.c:1164">AtStart_Cache</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1173" title="access/transam/xact.c:1173">AtStart_Memory</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1220" title="access/transam/xact.c:1220">AtStart_ResourceOwner</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3787" title="access/transam/xact.c:3787">CallXactCallbacks</a>(XactEvent event);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3847" title="access/transam/xact.c:3847">CallSubXactCallbacks</a>(SubXactEvent event,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SubTransactionId mySubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SubTransactionId parentSubid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2945" title="access/transam/xact.c:2945">CleanupTransaction</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3671" title="access/transam/xact.c:3671">CheckTransactionBlock</a>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isTopLevel, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> throwError,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *stmtType);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2178" title="access/transam/xact.c:2178">CommitTransaction</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> TransactionId <a href="#L1723" title="access/transam/xact.c:1723">RecordTransactionAbort</a>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isSubXact);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2014" title="access/transam/xact.c:2014">StartTransaction</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3111" title="access/transam/xact.c:3111">CommitTransactionCommandInternal</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3405" title="access/transam/xact.c:3405">AbortCurrentTransactionInternal</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5011" title="access/transam/xact.c:5011">StartSubTransaction</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5048" title="access/transam/xact.c:5048">CommitSubTransaction</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5162" title="access/transam/xact.c:5162">AbortSubTransaction</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5334" title="access/transam/xact.c:5334">CleanupSubTransaction</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5367" title="access/transam/xact.c:5367">PushTransaction</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5429" title="access/transam/xact.c:5429">PopTransaction</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1873" title="access/transam/xact.c:1873">AtSubAbort_Memory</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1979" title="access/transam/xact.c:1979">AtSubCleanup_Memory</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1898" title="access/transam/xact.c:1898">AtSubAbort_ResourceOwner</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1604" title="access/transam/xact.c:1604">AtSubCommit_Memory</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1248" title="access/transam/xact.c:1248">AtSubStart_Memory</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1272" title="access/transam/xact.c:1272">AtSubStart_ResourceOwner</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5599" title="access/transam/xact.c:5599">ShowTransactionState</a>(<span class="Type">const</span> <span class="Type">char</span> *str);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5611" title="access/transam/xact.c:5611">ShowTransactionStateRec</a>(<span class="Type">const</span> <span class="Type">char</span> *str, <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(<a href="#L155" title="access/transam/xact.c:155">TBlockState</a> blockState);<br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<a href="#L5711" title="access/transam/xact.c:5711">TransStateAsString</a>(<a href="#L139" title="access/transam/xact.c:139">TransState</a> state);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; transaction state accessors<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L384" title="access/transam/xact.c:384">IsTransactionState</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This returns true if we are inside a valid transaction; that is,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; it is safe to initiate database access, take heavyweight locks, etc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L384">&#x200c;</a></span><span class="linkable">IsTransactionState</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TRANS_DEFAULT and TRANS_ABORT are obviously unsafe states.&nbsp; However, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also reject the startup/shutdown states TRANS_START, TRANS_COMMIT,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TRANS_PREPARE since it might be too soon or too late within those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transition states to do anything interesting.&nbsp; Hence, the only &quot;valid&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state is TRANS_INPROGRESS.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (s-&gt;state == TRANS_INPROGRESS);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L404" title="access/transam/xact.c:404">IsAbortedTransactionBlockState</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This returns true if we are within an aborted transaction block.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L404">&#x200c;</a></span><span class="linkable">IsAbortedTransactionBlockState</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;blockState == TBLOCK_ABORT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState == TBLOCK_SUBABORT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L423" title="access/transam/xact.c:423">GetTopTransactionId</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This will return the XID of the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> transaction, assigning one if<br/></li>
<li></span><span class="Comment"> * it's not yet set.&nbsp; Be careful to call this only inside a valid xact.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TransactionId<br/></li>
<li><a id="L423">&#x200c;</a><span class="linkable">GetTopTransactionId</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!FullTransactionIdIsValid(<a href="#L123" title="access/transam/xact.c:123">XactTopFullTransactionId</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L632" title="access/transam/xact.c:632">AssignTransactionId</a>(&amp;<a href="#L244" title="access/transam/xact.c:244">TopTransactionStateData</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> XidFromFullTransactionId(<a href="#L123" title="access/transam/xact.c:123">XactTopFullTransactionId</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L438" title="access/transam/xact.c:438">GetTopTransactionIdIfAny</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This will return the XID of the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> transaction, if one is assigned.<br/></li>
<li></span><span class="Comment"> * It will return InvalidTransactionId if we are not currently inside a<br/></li>
<li></span><span class="Comment"> * transaction, or inside a transaction that hasn't yet been assigned an XID.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TransactionId<br/></li>
<li><a id="L438">&#x200c;</a><span class="linkable">GetTopTransactionIdIfAny</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> XidFromFullTransactionId(<a href="#L123" title="access/transam/xact.c:123">XactTopFullTransactionId</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L451" title="access/transam/xact.c:451">GetCurrentTransactionId</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This will return the XID of the current transaction (<a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> or sub<br/></li>
<li></span><span class="Comment"> * transaction), assigning one if it's not yet set.&nbsp; Be careful to call this<br/></li>
<li></span><span class="Comment"> * only inside a valid xact.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TransactionId<br/></li>
<li><a id="L451">&#x200c;</a><span class="linkable">GetCurrentTransactionId</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!FullTransactionIdIsValid(s-&gt;fullTransactionId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L632" title="access/transam/xact.c:632">AssignTransactionId</a>(s);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> XidFromFullTransactionId(s-&gt;fullTransactionId);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L468" title="access/transam/xact.c:468">GetCurrentTransactionIdIfAny</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This will return the XID of the current sub xact, if one is assigned.<br/></li>
<li></span><span class="Comment"> * It will return InvalidTransactionId if we are not currently inside a<br/></li>
<li></span><span class="Comment"> * transaction, or inside a transaction that hasn't been assigned an XID yet.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TransactionId<br/></li>
<li><a id="L468">&#x200c;</a><span class="linkable">GetCurrentTransactionIdIfAny</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> XidFromFullTransactionId(<a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>-&gt;fullTransactionId);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L480" title="access/transam/xact.c:480">GetTopFullTransactionId</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This will return the FullTransactionId of the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> transaction, assigning<br/></li>
<li></span><span class="Comment"> * one if it's not yet set.&nbsp; Be careful to call this only inside a valid xact.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>FullTransactionId<br/></li>
<li><a id="L480">&#x200c;</a><span class="linkable">GetTopFullTransactionId</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!FullTransactionIdIsValid(<a href="#L123" title="access/transam/xact.c:123">XactTopFullTransactionId</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L632" title="access/transam/xact.c:632">AssignTransactionId</a>(&amp;<a href="#L244" title="access/transam/xact.c:244">TopTransactionStateData</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L123" title="access/transam/xact.c:123">XactTopFullTransactionId</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L496" title="access/transam/xact.c:496">GetTopFullTransactionIdIfAny</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This will return the FullTransactionId of the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> transaction, if one is<br/></li>
<li></span><span class="Comment"> * assigned.&nbsp; It will return InvalidFullTransactionId if we are not currently<br/></li>
<li></span><span class="Comment"> * inside a transaction, or inside a transaction that hasn't yet been assigned<br/></li>
<li></span><span class="Comment"> * one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>FullTransactionId<br/></li>
<li><a id="L496">&#x200c;</a><span class="linkable">GetTopFullTransactionIdIfAny</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L123" title="access/transam/xact.c:123">XactTopFullTransactionId</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L509" title="access/transam/xact.c:509">GetCurrentFullTransactionId</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This will return the FullTransactionId of the current transaction (<a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> or<br/></li>
<li></span><span class="Comment"> * sub transaction), assigning one if it's not yet set.&nbsp; Be careful to call<br/></li>
<li></span><span class="Comment"> * this only inside a valid xact.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>FullTransactionId<br/></li>
<li><a id="L509">&#x200c;</a><span class="linkable">GetCurrentFullTransactionId</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!FullTransactionIdIsValid(s-&gt;fullTransactionId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L632" title="access/transam/xact.c:632">AssignTransactionId</a>(s);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> s-&gt;fullTransactionId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L527" title="access/transam/xact.c:527">GetCurrentFullTransactionIdIfAny</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This will return the FullTransactionId of the current sub xact, if one is<br/></li>
<li></span><span class="Comment"> * assigned.&nbsp; It will return InvalidFullTransactionId if we are not currently<br/></li>
<li></span><span class="Comment"> * inside a transaction, or inside a transaction that hasn't been assigned one<br/></li>
<li></span><span class="Comment"> * yet.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>FullTransactionId<br/></li>
<li><a id="L527">&#x200c;</a><span class="linkable">GetCurrentFullTransactionIdIfAny</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>-&gt;fullTransactionId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L538" title="access/transam/xact.c:538">MarkCurrentTransactionIdLoggedIfAny</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Remember that the current xid - if it is assigned - <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> has been wal logged.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L538">&#x200c;</a></span><span class="linkable">MarkCurrentTransactionIdLoggedIfAny</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FullTransactionIdIsValid(<a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>-&gt;fullTransactionId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>-&gt;didLogXid = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L556" title="access/transam/xact.c:556">IsSubxactTopXidLogPending</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used to decide whether we need to WAL log the top-level XID for<br/></li>
<li></span><span class="Comment"> * operation in a subtransaction.&nbsp; We require that for logical decoding, see<br/></li>
<li></span><span class="Comment"> * <a href="../../replication/logical/decode.c.html#L88" title="replication/logical/decode.c:88">LogicalDecodingProcessRecord</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This returns true if <a href="xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> &gt;= logical and we are inside a valid<br/></li>
<li></span><span class="Comment"> * subtransaction, for which the assignment was not yet written to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WAL<br/></li>
<li></span><span class="Comment"> * record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L556">&#x200c;</a></span><span class="linkable">IsSubxactTopXidLogPending</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check whether it is already logged */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>-&gt;topXidLogged)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> has to be logical */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogLogicalInfoActive())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we need to be in a transaction state */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L384" title="access/transam/xact.c:384">IsTransactionState</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* it has to be a subtransaction */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L4988" title="access/transam/xact.c:4988">IsSubTransaction</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the subtransaction has to have a XID assigned */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(<a href="#L468" title="access/transam/xact.c:468">GetCurrentTransactionIdIfAny</a>()))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L588" title="access/transam/xact.c:588">MarkSubxactTopXidLogged</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Remember that the top transaction id for the current subtransaction is WAL<br/></li>
<li></span><span class="Comment"> * logged <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L588">&#x200c;</a></span><span class="linkable">MarkSubxactTopXidLogged</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L556" title="access/transam/xact.c:556">IsSubxactTopXidLogPending</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>-&gt;topXidLogged = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L604" title="access/transam/xact.c:604">GetStableLatestTransactionId</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Get the transaction's XID if it has one, else read the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-to-be-assigned<br/></li>
<li></span><span class="Comment"> * XID.&nbsp; Once we have a value, return that same value for the remainder of the<br/></li>
<li></span><span class="Comment"> * current transaction.&nbsp; This is meant to provide the reference point for the<br/></li>
<li></span><span class="Comment"> * age(xid) function, but might be useful for other maintenance tasks as well.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TransactionId<br/></li>
<li><a id="L604">&#x200c;</a><span class="linkable">GetStableLatestTransactionId</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> LocalTransactionId lxid = InvalidLocalTransactionId;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> TransactionId stablexid = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lxid != <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.lxid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lxid = <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.lxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stablexid = <a href="#L438" title="access/transam/xact.c:438">GetTopTransactionIdIfAny</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(stablexid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stablexid = ReadNextTransactionId();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(stablexid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stablexid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L632" title="access/transam/xact.c:632">AssignTransactionId</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Assigns a new permanent FullTransactionId to the given <a href="#L218" title="access/transam/xact.c:218">TransactionState</a>.<br/></li>
<li></span><span class="Comment"> * We do not assign XIDs to transactions until/unless this is called.<br/></li>
<li></span><span class="Comment"> * Also, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parent TransactionStates that don't yet have XIDs are assigned<br/></li>
<li></span><span class="Comment"> * one; this maintains the invariant that a child transaction has an XID<br/></li>
<li></span><span class="Comment"> * following its parent's.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L632">&#x200c;</a></span><span class="linkable">AssignTransactionId</span>(<a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isSubXact = (s-&gt;parent != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; ResourceOwner currentOwner;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; log_unknown_top = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assert that caller didn't screw up */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!FullTransactionIdIsValid(s-&gt;fullTransactionId));<br/></li>
<li>&nbsp; &nbsp; Assert(s-&gt;state == TRANS_INPROGRESS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Workers synchronize transaction state at the beginning of each parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operation, so we can't account for new XIDs at this point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>() || IsParallelWorker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TRANSACTION_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot assign XIDs during a parallel operation&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure parent(s) have XIDs, so that a child always has an XID later<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than its parent.&nbsp; Mustn't recurse here, or we might get a stack<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overflow if we're at the bottom of a huge stack of subtransactions <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of which have XIDs yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isSubXact &amp;&amp; !FullTransactionIdIsValid(s-&gt;parent-&gt;fullTransactionId))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> p = s-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> *parents;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; parentOffset = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parents = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L218" title="access/transam/xact.c:218">TransactionState</a>) * s-&gt;nestingLevel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (p != <span class="Constant">NULL</span> &amp;&amp; !FullTransactionIdIsValid(p-&gt;fullTransactionId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parents[parentOffset++] = p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p = p-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is technically a recursive call, but the recursion will never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be more than one layer deep.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (parentOffset != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L632" title="access/transam/xact.c:632">AssignTransactionId</a>(parents[--parentOffset]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(parents);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When <a href="xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a>=logical, guarantee that a subtransaction's xid can only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be seen in the WAL stream if its toplevel xid has been logged <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If necessary we log an xact_assignment record with fewer than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PGPROC_MAX_CACHED_SUBXIDS. Note that it is fine if didLogXid isn't set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for a transaction even though it appears in a WAL record, we just might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * superfluously log something. That can happen when an xid is included<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * somewhere inside a wal record, but not in XLogRecord-&gt;xl_xid, like in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xl_standby_locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isSubXact &amp;&amp; XLogLogicalInfoActive() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L244" title="access/transam/xact.c:244">TopTransactionStateData</a>.didLogXid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; log_unknown_top = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate a new FullTransactionId and record its xid in PGPROC and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_subtrans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: we must make the subtrans entry BEFORE the Xid appears anywhere in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared storage other than PGPROC; because if there's no room for it in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PGPROC, the subtrans entry is needed to ensure that other backends see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the Xid as &quot;running&quot;.&nbsp; See <a href="varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s-&gt;fullTransactionId = <a href="varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a>(isSubXact);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isSubXact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L123" title="access/transam/xact.c:123">XactTopFullTransactionId</a> = s-&gt;fullTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isSubXact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="subtrans.c.html#L85" title="access/transam/subtrans.c:85">SubTransSetParent</a>(XidFromFullTransactionId(s-&gt;fullTransactionId),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XidFromFullTransactionId(s-&gt;parent-&gt;fullTransactionId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's a top-level transaction, the predicate locking system needs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be told about it too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isSubXact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L1944" title="storage/lmgr/predicate.c:1944">RegisterPredicateLockingXid</a>(XidFromFullTransactionId(s-&gt;fullTransactionId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Acquire lock on the transaction XID.&nbsp; (We assume this cannot block.) We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have to ensure that the lock is assigned to the transaction's own<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ResourceOwner.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; currentOwner = <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = s-&gt;curTransactionOwner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L626" title="storage/lmgr/lmgr.c:626">XactLockTableInsert</a>(XidFromFullTransactionId(s-&gt;fullTransactionId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = currentOwner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Every PGPROC_MAX_CACHED_SUBXIDS assigned transaction ids within each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * top-level transaction we issue a WAL record for the assignment. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * include the top-level xid and all the subxids that have not yet been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reported using XLOG_XACT_ASSIGNMENT <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is required to limit the amount of shared memory required in a hot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * standby server to keep track of in-progress XIDs. See notes for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/procarray.c.html#L4387" title="storage/ipc/procarray.c:4387">RecordKnownAssignedTransactionIds</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't keep track of the immediate parent of each subxid, only the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * top-level transaction that each subxact belongs to. This is correct in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery only because aborted subtransactions are separately WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * logged.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is correct even for the case where several levels above us didn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have an xid assigned as we recursed up to them beforehand.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isSubXact &amp;&amp; XLogStandbyInfoActive())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L255" title="access/transam/xact.c:255">unreportedXids</a>[<a href="#L254" title="access/transam/xact.c:254">nUnreportedXids</a>] = XidFromFullTransactionId(s-&gt;fullTransactionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L254" title="access/transam/xact.c:254">nUnreportedXids</a>++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ensure this test matches similar one in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="twophase.c.html#L2084" title="access/transam/twophase.c:2084">RecoverPreparedTransactions</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L254" title="access/transam/xact.c:254">nUnreportedXids</a> &gt;= PGPROC_MAX_CACHED_SUBXIDS ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log_unknown_top)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_xact_assignment xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xtop is always set by <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> because we recurse up transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stack to the highest unassigned xid and then come back down<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.xtop = <a href="#L423" title="access/transam/xact.c:423">GetTopTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsValid(xlrec.xtop));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.nsubxacts = <a href="#L254" title="access/transam/xact.c:254">nUnreportedXids</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, MinSizeOfXactAssignment);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) <a href="#L255" title="access/transam/xact.c:255">unreportedXids</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L254" title="access/transam/xact.c:254">nUnreportedXids</a> * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_XACT_ID, XLOG_XACT_ASSIGNMENT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L254" title="access/transam/xact.c:254">nUnreportedXids</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark top, not current xact as having been logged */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L244" title="access/transam/xact.c:244">TopTransactionStateData</a>.didLogXid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L788" title="access/transam/xact.c:788">GetCurrentSubTransactionId</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>SubTransactionId<br/></li>
<li><a id="L788">&#x200c;</a><span class="linkable">GetCurrentSubTransactionId</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> s-&gt;subTransactionId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L802" title="access/transam/xact.c:802">SubTransactionIsActive</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Test if the specified subxact ID is still active.&nbsp; Note caller is<br/></li>
<li></span><span class="Comment"> * responsible for checking whether this ID is relevant to the current xact.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L802">&#x200c;</a></span><span class="linkable">SubTransactionIsActive</span>(SubTransactionId subxid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>; s != <span class="Constant">NULL</span>; s = s-&gt;parent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;state == TRANS_ABORT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;subTransactionId == subxid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L826" title="access/transam/xact.c:826">GetCurrentCommandId</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;used&quot; must be true if the caller intends to use the command ID to mark<br/></li>
<li></span><span class="Comment"> * inserted/updated/deleted tuples.&nbsp; false means the ID is being fetched<br/></li>
<li></span><span class="Comment"> * for read-only purposes (ie, as a snapshot validity cutoff).&nbsp; See<br/></li>
<li></span><span class="Comment"> * <a href="#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>() for discussion.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>CommandId<br/></li>
<li><a id="L826">&#x200c;</a><span class="linkable">GetCurrentCommandId</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> used)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this is global to a transaction, not subtransaction-local */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (used)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Forbid setting <a href="#L265" title="access/transam/xact.c:265">currentCommandIdUsed</a> in a parallel worker, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we have no provision for communicating this back to the leader.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could relax this restriction when <a href="#L265" title="access/transam/xact.c:265">currentCommandIdUsed</a> was already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * true at the start of the parallel operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsParallelWorker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TRANSACTION_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot modify data in a parallel worker&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L265" title="access/transam/xact.c:265">currentCommandIdUsed</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L264" title="access/transam/xact.c:264">currentCommandId</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L856" title="access/transam/xact.c:856">SetParallelStartTimestamps</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In a parallel worker, we should inherit the parent transaction's<br/></li>
<li></span><span class="Comment"> * timestamps rather than setting our own.&nbsp; The parallel worker<br/></li>
<li></span><span class="Comment"> * infrastructure must call this to provide those <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * calling <a href="#L2014" title="access/transam/xact.c:2014">StartTransaction</a>() or <a href="#L911" title="access/transam/xact.c:911">SetCurrentStatementStartTimestamp</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L856">&#x200c;</a></span><span class="linkable">SetParallelStartTimestamps</span>(TimestampTz xact_ts, TimestampTz stmt_ts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(IsParallelWorker());<br/></li>
<li>&nbsp; &nbsp; <a href="#L277" title="access/transam/xact.c:277">xactStartTimestamp</a> = xact_ts;<br/></li>
<li>&nbsp; &nbsp; <a href="#L278" title="access/transam/xact.c:278">stmtStartTimestamp</a> = stmt_ts;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L867" title="access/transam/xact.c:867">GetCurrentTransactionStartTimestamp</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TimestampTz<br/></li>
<li><a id="L867">&#x200c;</a><span class="linkable">GetCurrentTransactionStartTimestamp</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L277" title="access/transam/xact.c:277">xactStartTimestamp</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L876" title="access/transam/xact.c:876">GetCurrentStatementStartTimestamp</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TimestampTz<br/></li>
<li><a id="L876">&#x200c;</a><span class="linkable">GetCurrentStatementStartTimestamp</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L278" title="access/transam/xact.c:278">stmtStartTimestamp</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L888" title="access/transam/xact.c:888">GetCurrentTransactionStopTimestamp</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the transaction stop time hasn't already been set, which can happen if<br/></li>
<li></span><span class="Comment"> * we decided we don't need to log an XLOG record, set <a href="#L279" title="access/transam/xact.c:279">xactStopTimestamp</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TimestampTz<br/></li>
<li><a id="L888">&#x200c;</a><span class="linkable">GetCurrentTransactionStopTimestamp</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a> = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* should only be called after commit / abort processing */<br/></li>
<li></span>&nbsp; &nbsp; Assert(s-&gt;state == TRANS_DEFAULT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;state == TRANS_COMMIT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;state == TRANS_ABORT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;state == TRANS_PREPARE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L279" title="access/transam/xact.c:279">xactStopTimestamp</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L279" title="access/transam/xact.c:279">xactStopTimestamp</a> = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L279" title="access/transam/xact.c:279">xactStopTimestamp</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L911" title="access/transam/xact.c:911">SetCurrentStatementStartTimestamp</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In a parallel worker, this should already have been provided by a call<br/></li>
<li></span><span class="Comment"> * to <a href="#L856" title="access/transam/xact.c:856">SetParallelStartTimestamps</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L911">&#x200c;</a></span><span class="linkable">SetCurrentStatementStartTimestamp</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!IsParallelWorker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L278" title="access/transam/xact.c:278">stmtStartTimestamp</a> = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L278" title="access/transam/xact.c:278">stmtStartTimestamp</a> != <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this will return zero when not inside <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transaction, one when<br/></li>
<li></span><span class="Comment"> * inside a top-level transaction, etc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L926">&#x200c;</a></span><span class="linkable">GetCurrentTransactionNestLevel</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> s-&gt;nestingLevel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L938">&#x200c;</a></span><span class="linkable">TransactionIdIsCurrentTransactionId</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We always say that BootstrapTransactionId is &quot;not my transaction ID&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * even when it is (ie, during bootstrap).&nbsp; Along with the fact that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transam.c always treats BootstrapTransactionId as already committed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this causes the heapam_visibility.c routines to see all tuples as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * committed, which is what we need during bootstrap.&nbsp; (Bootstrap mode<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only inserts tuples, it never updates or deletes them, so all tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can be presumed good immediately.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise, InvalidTransactionId and FrozenTransactionId are certainly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not my transaction ID, so we can just return &quot;false&quot; immediately for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-normal XID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsNormal(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdEquals(xid, <a href="#L438" title="access/transam/xact.c:438">GetTopTransactionIdIfAny</a>()))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In parallel workers, the XIDs we must consider as current are stored in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L125" title="access/transam/xact.c:125">ParallelCurrentXids</a> rather than the transaction-state stack.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the XIDs in this array are sorted numerically rather than according to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactionIdPrecedes order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L124" title="access/transam/xact.c:124">nParallelCurrentXids</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; low = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; high = <a href="#L124" title="access/transam/xact.c:124">nParallelCurrentXids</a> - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (low &lt;= high)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; middle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId probe;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; middle = low + (high - low) / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; probe = <a href="#L125" title="access/transam/xact.c:125">ParallelCurrentXids</a>[middle];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (probe == xid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (probe &lt; xid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = middle + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = middle - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We will return true for the Xid of the current subtransaction, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its subcommitted children, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of its parents, or <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previously subcommitted children.&nbsp; However, a transaction being aborted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is no longer &quot;current&quot;, even though it may still have an entry on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state stack.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>; s != <span class="Constant">NULL</span>; s = s-&gt;parent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;state == TRANS_ABORT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!FullTransactionIdIsValid(s-&gt;fullTransactionId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it can't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> child XIDs either */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdEquals(xid, XidFromFullTransactionId(s-&gt;fullTransactionId)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As the childXids array is ordered, we can use binary search */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; low = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; high = s-&gt;nChildXids - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (low &lt;= high)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; middle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId probe;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; middle = low + (high - low) / <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; probe = s-&gt;childXids[middle];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdEquals(probe, xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(probe, xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = middle + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = middle - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1039" title="access/transam/xact.c:1039">TransactionStartedDuringRecovery</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if the current transaction started while recovery was still<br/></li>
<li></span><span class="Comment"> * in progress. Recovery might have ended since so <a href="xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>() might<br/></li>
<li></span><span class="Comment"> * return false already.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1039">&#x200c;</a></span><span class="linkable">TransactionStartedDuringRecovery</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>-&gt;startedInRecovery;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1048" title="access/transam/xact.c:1048">EnterParallelMode</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1048">&#x200c;</a></span><span class="linkable">EnterParallelMode</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(s-&gt;parallelModeLevel &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ++s-&gt;parallelModeLevel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1061" title="access/transam/xact.c:1061">ExitParallelMode</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1061">&#x200c;</a></span><span class="linkable">ExitParallelMode</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(s-&gt;parallelModeLevel &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(s-&gt;parallelModeLevel &gt; <span class="Constant">1</span> || s-&gt;parallelChildXact ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="parallel.c.html#L1003" title="access/transam/parallel.c:1003">ParallelContextActive</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; --s-&gt;parallelModeLevel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Are we in a parallel operation, as either the leader or a worker?&nbsp; Check<br/></li>
<li></span><span class="Comment"> * this to prohibit operations that change backend-local state expected to<br/></li>
<li></span><span class="Comment"> * match across all workers.&nbsp; Mere caches usually don't require such a<br/></li>
<li></span><span class="Comment"> * restriction.&nbsp; State modified in a strict <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a>/pop fashion, such as the<br/></li>
<li></span><span class="Comment"> * active snapshot stack, is often fine.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We say we are in parallel mode if we are in a subxact of a transaction<br/></li>
<li></span><span class="Comment"> * that's initiated a parallel operation; for most purposes that context<br/></li>
<li></span><span class="Comment"> * has all the same restrictions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1086">&#x200c;</a></span><span class="linkable">IsInParallelMode</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> s-&gt;parallelModeLevel != <span class="Constant">0</span> || s-&gt;parallelChildXact;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1097">&#x200c;</a></span><span class="linkable">CommandCounterIncrement</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the current value of the command counter hasn't been &quot;used&quot; to mark<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples, we need not increment it, since there's no need to distinguish<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a read-only command from others.&nbsp; This helps postpone command counter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overflow, and keeps no-op <a href="#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a> operations cheap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L265" title="access/transam/xact.c:265">currentCommandIdUsed</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Workers synchronize transaction state at the beginning of each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parallel operation, so we can't account for new commands after that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>() || IsParallelWorker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TRANSACTION_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot start commands during a parallel operation&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L264" title="access/transam/xact.c:264">currentCommandId</a> += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L264" title="access/transam/xact.c:264">currentCommandId</a> == InvalidCommandId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L264" title="access/transam/xact.c:264">currentCommandId</a> -= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot have more than 2^32-2 commands in a transaction&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L265" title="access/transam/xact.c:265">currentCommandIdUsed</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Propagate new command ID into static snapshots */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L456" title="utils/time/snapmgr.c:456">SnapshotSetCommandId</a>(<a href="#L264" title="access/transam/xact.c:264">currentCommandId</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> catalog changes done by the just-completed command visible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the local syscache.&nbsp; We obviously don't need to do this after a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * read-only command.&nbsp; (But see hacks in inval.c to make real sure we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't think a command that queued inval messages was read-only.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1558" title="access/transam/xact.c:1558">AtCCI_LocalCache</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1149" title="access/transam/xact.c:1149">ForceSyncCommit</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Interface routine to allow commands to force a synchronous commit of the<br/></li>
<li></span><span class="Comment"> * current top-level transaction.&nbsp; Currently, two-phase commit does not<br/></li>
<li></span><span class="Comment"> * persist and restore this variable.&nbsp; So long as all callers use<br/></li>
<li></span><span class="Comment"> * <a href="#L3584" title="access/transam/xact.c:3584">PreventInTransactionBlock</a>(), that omission has no consequences.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1149">&#x200c;</a></span><span class="linkable">ForceSyncCommit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L290" title="access/transam/xact.c:290">forceSyncCommit</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2014" title="access/transam/xact.c:2014">StartTransaction</a> stuff<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1164" title="access/transam/xact.c:1164">AtStart_Cache</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1164">&#x200c;</a></span><span class="linkable">AtStart_Cache</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L806" title="utils/cache/inval.c:806">AcceptInvalidationMessages</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1173" title="access/transam/xact.c:1173">AtStart_Memory</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1173">&#x200c;</a></span><span class="linkable">AtStart_Memory</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is the first time through, create a private context for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a> to work in.&nbsp; By reserving some space <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * insulate <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a> from out-of-memory scenarios.&nbsp; Like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a>, we set it up with slow growth rate and a nonzero minimum<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * size, so that space will be reserved immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L300" title="access/transam/xact.c:300">TransactionAbortContext</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L300" title="access/transam/xact.c:300">TransactionAbortContext</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L300" title="access/transam/xact.c:300">TransactionAbortContext</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">32</span> * <span class="Constant">1024</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">32</span> * <span class="Constant">1024</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">32</span> * <span class="Constant">1024</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We shouldn't have a transaction context already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a> == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a toplevel context for the transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In a top-level transaction, <a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a> is the same as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a> = <a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;curTransactionContext = <a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make the <a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a> active. */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1220" title="access/transam/xact.c:1220">AtStart_ResourceOwner</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1220">&#x200c;</a></span><span class="linkable">AtStart_ResourceOwner</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We shouldn't have a transaction resource owner already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a> == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a toplevel resource owner for the transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s-&gt;curTransactionOwner = <a href="../../utils/resowner/resowner.c.html#L413" title="utils/resowner/resowner.c:413">ResourceOwnerCreate</a>(<span class="Constant">NULL</span>, <span class="Constant">&quot;TopTransaction&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a> = s-&gt;curTransactionOwner;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L166" title="utils/resowner/resowner.c:166">CurTransactionResourceOwner</a> = s-&gt;curTransactionOwner;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = s-&gt;curTransactionOwner;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5011" title="access/transam/xact.c:5011">StartSubTransaction</a> stuff<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1248" title="access/transam/xact.c:1248">AtSubStart_Memory</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1248">&#x200c;</a></span><span class="linkable">AtSubStart_Memory</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a <a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>, which will be used to hold data that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * survives subtransaction commit but disappears on subtransaction abort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We make it a child of the immediate parent's <a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a> = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; s-&gt;curTransactionContext = <a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make the <a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a> active. */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1272" title="access/transam/xact.c:1272">AtSubStart_ResourceOwner</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1272">&#x200c;</a></span><span class="linkable">AtSubStart_ResourceOwner</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(s-&gt;parent != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a resource owner for the subtransaction.&nbsp; We make it a child of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the immediate parent's resource owner.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s-&gt;curTransactionOwner =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L413" title="utils/resowner/resowner.c:413">ResourceOwnerCreate</a>(s-&gt;parent-&gt;curTransactionOwner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;SubTransaction&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L166" title="utils/resowner/resowner.c:166">CurTransactionResourceOwner</a> = s-&gt;curTransactionOwner;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = s-&gt;curTransactionOwner;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2178" title="access/transam/xact.c:2178">CommitTransaction</a> stuff<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1304" title="access/transam/xact.c:1304">RecordTransactionCommit</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns latest XID among xact and its children, or InvalidTransactionId<br/></li>
<li></span><span class="Comment"> * if the xact has no XID.&nbsp; (We compute that here just because it's easier.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If you change this function, see <a href="twophase.c.html#L2307" title="access/transam/twophase.c:2307">RecordTransactionCommitPrepared</a> also.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TransactionId<br/></li>
<li><a id="L1304">&#x200c;</a><span class="linkable">RecordTransactionCommit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid = <a href="#L438" title="access/transam/xact.c:438">GetTopTransactionIdIfAny</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; markXidCommitted = TransactionIdIsValid(xid);<br/></li>
<li>&nbsp; &nbsp; TransactionId latestXid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrels;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator *rels;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nchildren;<br/></li>
<li>&nbsp; &nbsp; TransactionId *children;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndroppedstats = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; xl_xact_stats_item *droppedstats = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmsgs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; SharedInvalidationMessage *invalMessages = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; RelcacheInitFileInval = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; wrote_xlog;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Log pending invalidations for logical decoding of in-progress<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactions.&nbsp; Normally for DDLs, we log this at each command end,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * however, for certain cases where we directly update the system table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without a transaction block, the invalidations are not logged till this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (XLogLogicalInfoActive())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1604" title="utils/cache/inval.c:1604">LogLogicalInvalidations</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get data needed for commit record */<br/></li>
<li></span>&nbsp; &nbsp; nrels = <a href="../../catalog/storage.c.html#L852" title="catalog/storage.c:852">smgrGetPendingDeletes</a>(<span class="Constant">true</span>, &amp;rels);<br/></li>
<li>&nbsp; &nbsp; nchildren = <a href="#L5741" title="access/transam/xact.c:5741">xactGetCommittedChildren</a>(&amp;children);<br/></li>
<li>&nbsp; &nbsp; ndroppedstats = <a href="../../utils/activity/pgstat_xact.c.html#L270" title="utils/activity/pgstat_xact.c:270">pgstat_get_transactional_drops</a>(<span class="Constant">true</span>, &amp;droppedstats);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (XLogStandbyInfoActive())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nmsgs = <a href="../../utils/cache/inval.c.html#L882" title="utils/cache/inval.c:882">xactGetCommittedInvalidationMessages</a>(&amp;invalMessages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;RelcacheInitFileInval);<br/></li>
<li>&nbsp; &nbsp; wrote_xlog = (<a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a> != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we haven't been assigned an XID yet, we neither can, nor do we want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to write a COMMIT record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!markXidCommitted)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We expect that every <a href="../../catalog/storage.c.html#L206" title="catalog/storage.c:206">RelationDropStorage</a> is followed by a catalog<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * update, and hence XID assignment, so we shouldn't get here with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pending deletes. Same is true for dropping stats.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use a real test not just an Assert to check this, since it's a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fragile.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nrels != <span class="Constant">0</span> || ndroppedstats != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot commit a transaction that deleted files but has no xid&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't have child XIDs either; <a href="#L632" title="access/transam/xact.c:632">AssignTransactionId</a> enforces this */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nchildren == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Transactions without an assigned xid can contain invalidation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * messages (e.g. explicit relcache invalidations or catcache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * invalidations for inplace updates); standbys need to process those.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't emit a commit record without an xid, and we don't want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * force assigning an xid, because that'd be problematic for e.g.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.&nbsp; Hence we emit a bespoke record for the invalidations. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't want to use that in case a commit record is emitted, so they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happen synchronously with commits (besides not wanting to emit more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nmsgs != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/standby.c.html#L1462" title="storage/ipc/standby.c:1462">LogStandbyInvalidations</a>(nmsgs, invalMessages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelcacheInitFileInval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wrote_xlog = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* not strictly necessary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we didn't create XLOG entries, we're done here; otherwise we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> flushing those entries the same as a commit record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would.&nbsp; This will primarily happen for HOT pruning and the like; we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * want these to be flushed to disk in due time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!wrote_xlog)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; replorigin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Are we using the replication origins feature?&nbsp; Or, in other words,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are we replaying remote actions?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; replorigin = (<a href="../../replication/logical/origin.c.html#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a> != InvalidRepOriginId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/logical/origin.c.html#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a> != DoNotReplicateId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mark ourselves as within our &quot;commit critical section&quot;.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * forces <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> concurrent checkpoint to wait until we've updated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_xact.&nbsp; Without this, it is possible for the checkpoint to set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * REDO after the XLOG record but fail to flush the pg_xact update to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * disk, leading to loss of the transaction commit if the system<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * crashes a little later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we could, but don't bother to, set this flag in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1723" title="access/transam/xact.c:1723">RecordTransactionAbort</a>.&nbsp; That's because loss of a transaction abort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is noncritical; the presumption would be that it aborted, anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's safe to change the delayChkptFlags flag of our own backend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * without holding the ProcArrayLock, since we're the only one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * modifying it.&nbsp; This makes checkpoint's determination of which xacts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are delaying the checkpoint a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> fuzzy, but it doesn't matter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert((<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags &amp; DELAY_CHKPT_START) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags |= DELAY_CHKPT_START;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> the commit XLOG record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5765" title="access/transam/xact.c:5765">XactLogCommitRecord</a>(<a href="#L888" title="access/transam/xact.c:888">GetCurrentTransactionStopTimestamp</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nchildren, children, nrels, rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndroppedstats, droppedstats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmsgs, invalMessages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelcacheInitFileInval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L134" title="access/transam/xact.c:134">MyXactFlags</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidTransactionId, <span class="Constant">NULL</span> <span class="Comment">/* plain commit */</span> );<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (replorigin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Move LSNs forward for this replication origin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/logical/origin.c.html#L1219" title="replication/logical/origin.c:1219">replorigin_session_advance</a>(<a href="../../replication/logical/origin.c.html#L156" title="replication/logical/origin.c:156">replorigin_session_origin_lsn</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Record commit timestamp.&nbsp; The value comes from plain commit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * timestamp if there's no replication origin; otherwise, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * timestamp was already set in <a href="../../replication/logical/origin.c.html#L157" title="replication/logical/origin.c:157">replorigin_session_origin_timestamp</a> by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * replication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need to WAL-log anything here, as the commit record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * written above already contains the data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!replorigin || <a href="../../replication/logical/origin.c.html#L157" title="replication/logical/origin.c:157">replorigin_session_origin_timestamp</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/logical/origin.c.html#L157" title="replication/logical/origin.c:157">replorigin_session_origin_timestamp</a> = <a href="#L888" title="access/transam/xact.c:888">GetCurrentTransactionStopTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="commit_ts.c.html#L141" title="access/transam/commit_ts.c:141">TransactionTreeSetCommitTsData</a>(xid, nchildren, children,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../replication/logical/origin.c.html#L157" title="replication/logical/origin.c:157">replorigin_session_origin_timestamp</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../replication/logical/origin.c.html#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if we want to commit asynchronously.&nbsp; We can allow the XLOG flush<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to happen asynchronously if <a href="#L85" title="access/transam/xact.c:85">synchronous_commit</a>=off, or if the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction has not performed <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WAL-logged operation or didn't assign<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an xid.&nbsp; The transaction can end up not writing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WAL, even if it has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an xid, if it only wrote to temporary and/or unlogged tables.&nbsp; It can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end up having written WAL without an xid if it did HOT pruning.&nbsp; In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case of a crash, the loss of such a transaction will be irrelevant;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * temp tables will be lost anyway, unlogged tables will be truncated and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * HOT pruning will be done again later. (Given the foregoing, you might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * think that it would be unnecessary to emit the XLOG record at all in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this case, but we don't currently try to do that.&nbsp; It would certainly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cause problems at least in Hot Standby mode, where the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/procarray.c.html#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> machinery requires tracking every XID assignment.&nbsp; It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might be OK to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it only when <a href="xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> &lt; replica, but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, if we're doing <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-temp rels or committing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * command that wanted to force sync commit, then we must flush XLOG<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediately.&nbsp; (We must not allow asynchronous commit if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-temp tables to be deleted, because we might delete the files <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the COMMIT record is flushed to disk.&nbsp; We do allow asynchronous commit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if all to-be-deleted tables are temporary though, since they are lost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anyway if we crash.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((wrote_xlog &amp;&amp; markXidCommitted &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L85" title="access/transam/xact.c:85">synchronous_commit</a> &gt; SYNCHRONOUS_COMMIT_OFF) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L290" title="access/transam/xact.c:290">forceSyncCommit</a> || nrels &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(<a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now we may update the CLOG, if we wrote a COMMIT record above<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (markXidCommitted)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="transam.c.html#L240" title="access/transam/transam.c:240">TransactionIdCommitTree</a>(xid, nchildren, children);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Asynchronous commit case:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This enables possible committed transaction loss in the case of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * postmaster crash because WAL buffers are left unwritten. Ideally we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could issue the WAL write without the fsync, but some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wal_sync_methods do not allow separate write/fsync.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Report the latest async commit LSN, so that the WAL writer knows to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * flush this commit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L2626" title="access/transam/xlog.c:2626">XLogSetAsyncXactLSN</a>(<a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must not immediately update the CLOG, since we didn't flush the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * XLOG. Instead, we store the LSN up to which the XLOG must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * flushed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the CLOG may be updated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (markXidCommitted)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="transam.c.html#L252" title="access/transam/transam.c:252">TransactionIdAsyncCommitTree</a>(xid, nchildren, children, <a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we entered a commit critical section, leave it <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, and let<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoints proceed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (markXidCommitted)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags &amp;= ~DELAY_CHKPT_START;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute latestXid while we have the child XIDs handy */<br/></li>
<li></span>&nbsp; &nbsp; latestXid = <a href="transam.c.html#L345" title="access/transam/transam.c:345">TransactionIdLatest</a>(xid, nchildren, children);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Wait for synchronous replication, if required. Similar to the decision<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above about using committing asynchronously we only want to wait if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this backend assigned an xid and wrote WAL.&nbsp; No need to wait if an xid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * was assigned due to temporary/unlogged tables or due to HOT pruning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that at this stage we have marked clog, but still show as running<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the procarray and continue to hold locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (wrote_xlog &amp;&amp; markXidCommitted)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/syncrep.c.html#L148" title="replication/syncrep.c:148">SyncRepWaitForLSN</a>(<a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remember end of last commit record */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xlog.c.html#L255" title="access/transam/xlog.c:255">XactLastCommitEnd</a> = <a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset <a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a> until the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> transaction writes something */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a> = <span class="Constant">0</span>;<br/></li>
<li><span class="Statement"><a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a></span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Clean up local data */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rels)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rels);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndroppedstats)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(droppedstats);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> latestXid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1558" title="access/transam/xact.c:1558">AtCCI_LocalCache</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1558">&#x200c;</a></span><span class="linkable">AtCCI_LocalCache</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending relation map changes visible.&nbsp; We must do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processing local sinval messages, so that the map changes will get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reflected into the relcache when relcache invals are processed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/relmapper.c.html#L504" title="utils/cache/relmapper.c:504">AtCCI_RelationMap</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make catalog changes visible to me for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1170" title="utils/cache/inval.c:1170">CommandEndInvalidationMessages</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1577" title="access/transam/xact.c:1577">AtCommit_Memory</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1577">&#x200c;</a></span><span class="linkable">AtCommit_Memory</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we're &quot;out&quot; of a transaction, have the system allocate things<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the top memory context instead of per-transaction contexts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release all transaction-local memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(<a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>-&gt;curTransactionContext = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5048" title="access/transam/xact.c:5048">CommitSubTransaction</a> stuff<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1604" title="access/transam/xact.c:1604">AtSubCommit_Memory</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1604">&#x200c;</a></span><span class="linkable">AtSubCommit_Memory</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(s-&gt;parent != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return to parent transaction level's memory context. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a> = s-&gt;parent-&gt;curTransactionContext;<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ordinarily we cannot throw away the child's <a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since the data it contains will be needed at <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> commit.&nbsp; However, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there isn't actually anything in it, we can throw it away.&nbsp; This avoids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a small memory leak in the common case of &quot;trivial&quot; subxacts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/mmgr/mcxt.c.html#L743" title="utils/mmgr/mcxt.c:743">MemoryContextIsEmpty</a>(s-&gt;curTransactionContext))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(s-&gt;curTransactionContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;curTransactionContext = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1633" title="access/transam/xact.c:1633">AtSubCommit_childXids</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Pass my own XID and my child XIDs up to my parent as committed children.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1633">&#x200c;</a></span><span class="linkable">AtSubCommit_childXids</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_nChildXids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(s-&gt;parent != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The parent childXids array will need to hold my XID and all my<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * childXids, in addition to the XIDs already there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; new_nChildXids = s-&gt;parent-&gt;nChildXids + s-&gt;nChildXids + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate or enlarge the parent array if necessary */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;parent-&gt;maxChildXids &lt; new_nChildXids)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_maxChildXids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId *new_childXids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make it 2x what's needed right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, to avoid having to enlarge it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * repeatedly. But we can't go above MaxAllocSize.&nbsp; (The latter limit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is what ensures that we don't need to worry about integer overflow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here or in the calculation of new_nChildXids.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; new_maxChildXids = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(new_nChildXids * <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) (MaxAllocSize / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_maxChildXids &lt; new_nChildXids)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;maximum number of committed subtransactions (</span><span class="Special">%d</span><span class="Constant">) exceeded&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) (MaxAllocSize / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId)))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We keep the child-XID arrays in <a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>; this avoids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * setting up child-transaction contexts for what might be just a few<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bytes of grandchild XIDs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;parent-&gt;childXids == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_childXids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_maxChildXids * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_childXids = <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(s-&gt;parent-&gt;childXids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_maxChildXids * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;parent-&gt;childXids = new_childXids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;parent-&gt;maxChildXids = new_maxChildXids;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy all my XIDs to parent's array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: We rely on the fact that the XID of a child always follows that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of its parent.&nbsp; By copying the XID of this subtransaction <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XIDs of its children, we ensure that the array stays ordered. Likewise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all XIDs already in the array belong to subtransactions started and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subcommitted <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> us, so their XIDs must precede ours.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s-&gt;parent-&gt;childXids[s-&gt;parent-&gt;nChildXids] = XidFromFullTransactionId(s-&gt;fullTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;nChildXids &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;s-&gt;parent-&gt;childXids[s-&gt;parent-&gt;nChildXids + <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;childXids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;nChildXids * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s-&gt;parent-&gt;nChildXids = new_nChildXids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release child's array to avoid leakage */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;childXids != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(s-&gt;childXids);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We must reset these to avoid double-free if fail later in commit */<br/></li>
<li></span>&nbsp; &nbsp; s-&gt;childXids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;nChildXids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;maxChildXids = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a> stuff<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1723" title="access/transam/xact.c:1723">RecordTransactionAbort</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns latest XID among xact and its children, or InvalidTransactionId<br/></li>
<li></span><span class="Comment"> * if the xact has no XID.&nbsp; (We compute that here just because it's easier.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TransactionId<br/></li>
<li><a id="L1723">&#x200c;</a><span class="linkable">RecordTransactionAbort</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isSubXact)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid = <a href="#L468" title="access/transam/xact.c:468">GetCurrentTransactionIdIfAny</a>();<br/></li>
<li>&nbsp; &nbsp; TransactionId latestXid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrels;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator *rels;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndroppedstats = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; xl_xact_stats_item *droppedstats = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nchildren;<br/></li>
<li>&nbsp; &nbsp; TransactionId *children;<br/></li>
<li>&nbsp; &nbsp; TimestampTz xact_time;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; replorigin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we haven't been assigned an XID, nobody will care whether we aborted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or not.&nbsp; Hence, we're done in that case.&nbsp; It does not matter if we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rels to delete (note that this routine is not responsible for actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deleting 'em).&nbsp; We cannot have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> child XIDs, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset <a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a> until the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> transaction writes something */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isSubXact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have a valid XID, so we should write an ABORT record for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do not flush XLOG to disk here, since the default assumption after a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * crash would be that we aborted, anyway.&nbsp; For the same reason, we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to worry about interlocking against checkpoint start.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that we haven't aborted halfway through <a href="#L1304" title="access/transam/xact.c:1304">RecordTransactionCommit</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;cannot abort transaction </span><span class="Special">%u</span><span class="Constant">, it was already committed&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Are we using the replication origins feature?&nbsp; Or, in other words, are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we replaying remote actions?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; replorigin = (<a href="../../replication/logical/origin.c.html#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a> != InvalidRepOriginId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/logical/origin.c.html#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a> != DoNotReplicateId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch the data we need for the abort record */<br/></li>
<li></span>&nbsp; &nbsp; nrels = <a href="../../catalog/storage.c.html#L852" title="catalog/storage.c:852">smgrGetPendingDeletes</a>(<span class="Constant">false</span>, &amp;rels);<br/></li>
<li>&nbsp; &nbsp; nchildren = <a href="#L5741" title="access/transam/xact.c:5741">xactGetCommittedChildren</a>(&amp;children);<br/></li>
<li>&nbsp; &nbsp; ndroppedstats = <a href="../../utils/activity/pgstat_xact.c.html#L270" title="utils/activity/pgstat_xact.c:270">pgstat_get_transactional_drops</a>(<span class="Constant">false</span>, &amp;droppedstats);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> do we really need a critical section here? */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write the ABORT record */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isSubXact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xact_time = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xact_time = <a href="#L888" title="access/transam/xact.c:888">GetCurrentTransactionStopTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5937" title="access/transam/xact.c:5937">XactLogAbortRecord</a>(xact_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nchildren, children,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nrels, rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ndroppedstats, droppedstats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L134" title="access/transam/xact.c:134">MyXactFlags</a>, InvalidTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (replorigin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Move LSNs forward for this replication origin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/logical/origin.c.html#L1219" title="replication/logical/origin.c:1219">replorigin_session_advance</a>(<a href="../../replication/logical/origin.c.html#L156" title="replication/logical/origin.c:156">replorigin_session_origin_lsn</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report the latest async abort LSN, so that the WAL writer knows to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flush this abort. There's nothing to be gained by delaying this, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WALWriter may as well do this when it can. This is important with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * streaming replication because if we don't flush WAL regularly we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> that large aborts leave us with a long backlog for when commits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * occur after the abort, increasing our window of data loss should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * problems occur at that point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isSubXact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L2626" title="access/transam/xlog.c:2626">XLogSetAsyncXactLSN</a>(<a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark the transaction aborted in clog.&nbsp; This is not absolutely necessary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but we may as well do it while we are here; also, in the subxact case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it is helpful because <a href="../../storage/lmgr/lmgr.c.html#L667" title="storage/lmgr/lmgr.c:667">XactLockTableWait</a> makes use of it to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for already-aborted subtransactions.&nbsp; It is OK to do it without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * having flushed the ABORT record to disk, because in event of a crash<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'd be assumed to have aborted anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="transam.c.html#L270" title="access/transam/transam.c:270">TransactionIdAbortTree</a>(xid, nchildren, children);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute latestXid while we have the child XIDs handy */<br/></li>
<li></span>&nbsp; &nbsp; latestXid = <a href="transam.c.html#L345" title="access/transam/transam.c:345">TransactionIdLatest</a>(xid, nchildren, children);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're aborting a subtransaction, we can immediately remove failed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XIDs from PGPROC's cache of running child XIDs.&nbsp; We do that here for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subxacts, because we already have the child XID array at hand.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> xacts, the equivalent happens just after this function returns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isSubXact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L3975" title="storage/ipc/procarray.c:3975">XidCacheRemoveRunningXids</a>(xid, nchildren, children, latestXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset <a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a> until the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> transaction writes something */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isSubXact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And clean up local data */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rels)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rels);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndroppedstats)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(droppedstats);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> latestXid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1853" title="access/transam/xact.c:1853">AtAbort_Memory</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1853">&#x200c;</a></span><span class="linkable">AtAbort_Memory</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Switch into <a href="#L300" title="access/transam/xact.c:300">TransactionAbortContext</a>, which should have some free space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * even if nothing else does.&nbsp; We'll work in this context until we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * finished cleaning up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is barely possible to get here when we've not been able to create<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L300" title="access/transam/xact.c:300">TransactionAbortContext</a> yet; if so use <a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L300" title="access/transam/xact.c:300">TransactionAbortContext</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(<a href="#L300" title="access/transam/xact.c:300">TransactionAbortContext</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1873" title="access/transam/xact.c:1873">AtSubAbort_Memory</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1873">&#x200c;</a></span><span class="linkable">AtSubAbort_Memory</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L300" title="access/transam/xact.c:300">TransactionAbortContext</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="#L300" title="access/transam/xact.c:300">TransactionAbortContext</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1885" title="access/transam/xact.c:1885">AtAbort_ResourceOwner</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1885">&#x200c;</a></span><span class="linkable">AtAbort_ResourceOwner</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure we have a valid ResourceOwner, if possible (else it will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NULL, which is OK)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = <a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1898" title="access/transam/xact.c:1898">AtSubAbort_ResourceOwner</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1898">&#x200c;</a></span><span class="linkable">AtSubAbort_ResourceOwner</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we have a valid ResourceOwner */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = s-&gt;curTransactionOwner;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1911" title="access/transam/xact.c:1911">AtSubAbort_childXids</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1911">&#x200c;</a></span><span class="linkable">AtSubAbort_childXids</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We keep the child-XID arrays in <a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a> (see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1633" title="access/transam/xact.c:1633">AtSubCommit_childXids</a>).&nbsp; This means we'd better free the array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * explicitly at abort to avoid leakage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;childXids != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(s-&gt;childXids);<br/></li>
<li>&nbsp; &nbsp; s-&gt;childXids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;nChildXids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;maxChildXids = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We could prune the <a href="#L255" title="access/transam/xact.c:255">unreportedXids</a> array here. But we don't bother. That<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would potentially reduce number of XLOG_XACT_ASSIGNMENT <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> but it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would likely introduce more CPU time into the more common paths, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * choose not to do that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2945" title="access/transam/xact.c:2945">CleanupTransaction</a> stuff<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1943" title="access/transam/xact.c:1943">AtCleanup_Memory</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1943">&#x200c;</a></span><span class="linkable">AtCleanup_Memory</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>-&gt;parent == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we're &quot;out&quot; of a transaction, have the system allocate things<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the top memory context instead of per-transaction contexts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clear the special abort context for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L300" title="access/transam/xact.c:300">TransactionAbortContext</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="#L300" title="access/transam/xact.c:300">TransactionAbortContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release all transaction-local memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(<a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>-&gt;curTransactionContext = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5334" title="access/transam/xact.c:5334">CleanupSubTransaction</a> stuff<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1979" title="access/transam/xact.c:1979">AtSubCleanup_Memory</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1979">&#x200c;</a></span><span class="linkable">AtSubCleanup_Memory</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(s-&gt;parent != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we're not in an about-to-be-deleted context */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(s-&gt;parent-&gt;curTransactionContext);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a> = s-&gt;parent-&gt;curTransactionContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clear the special abort context for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L300" title="access/transam/xact.c:300">TransactionAbortContext</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="#L300" title="access/transam/xact.c:300">TransactionAbortContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the subxact local memory contexts. Its <a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a> can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * go too (note this also kills CurTransactionContexts from <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> children<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the subxact).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;curTransactionContext)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(s-&gt;curTransactionContext);<br/></li>
<li>&nbsp; &nbsp; s-&gt;curTransactionContext = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interface routines<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2014" title="access/transam/xact.c:2014">StartTransaction</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2014">&#x200c;</a></span><span class="linkable">StartTransaction</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s;<br/></li>
<li>&nbsp; &nbsp; VirtualTransactionId vxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Let's just make sure the state stack is empty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s = &amp;<a href="#L244" title="access/transam/xact.c:244">TopTransactionStateData</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a> = s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!FullTransactionIdIsValid(<a href="#L123" title="access/transam/xact.c:123">XactTopFullTransactionId</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check the current transaction state */<br/></li>
<li></span>&nbsp; &nbsp; Assert(s-&gt;state == TRANS_DEFAULT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the current transaction state information appropriately during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * start processing.&nbsp; Note that once the transaction status is switched<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this process cannot fail until the user ID and the security context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flags are fetched below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s-&gt;state = TRANS_START;<br/></li>
<li>&nbsp; &nbsp; s-&gt;fullTransactionId = InvalidFullTransactionId;&nbsp; &nbsp; <span class="Comment">/* until assigned */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine if statements are logged in this transaction */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L293" title="access/transam/xact.c:293">xact_is_sampled</a> = <a href="../../utils/misc/guc_tables.c.html#L532" title="utils/misc/guc_tables.c:532">log_xact_sample_rate</a> != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/misc/guc_tables.c.html#L532" title="utils/misc/guc_tables.c:532">log_xact_sample_rate</a> == <span class="Constant">1</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_prng_double(&amp;pg_global_prng_state) &lt;= <a href="../../utils/misc/guc_tables.c.html#L532" title="utils/misc/guc_tables.c:532">log_xact_sample_rate</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> current transaction state fields<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * note: prevXactReadOnly is not used at the outermost level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s-&gt;nestingLevel = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;gucNestLevel = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;childXids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;nChildXids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;maxChildXids = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Once the current user ID and the security context flags are fetched,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * both will be properly reset even if transaction startup fails.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/init/miscinit.c.html#L635" title="utils/init/miscinit.c:635">GetUserIdAndSecContext</a>(&amp;s-&gt;prevUser, &amp;s-&gt;prevSecContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/init/miscinit.c.html#L503" title="utils/init/miscinit.c:503">SecurityRestrictionContext</a> should never be set outside a transaction */<br/></li>
<li></span>&nbsp; &nbsp; Assert(s-&gt;prevSecContext == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure we've reset xact state variables<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If recovery is still in progress, mark this transaction as read-only.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> level defences in <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a> and elsewhere to stop us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from modifying data during recovery, but this gives the normal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indication to the user that the transaction is read-only.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;startedInRecovery = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L80" title="access/transam/xact.c:80">XactReadOnly</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;startedInRecovery = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L80" title="access/transam/xact.c:80">XactReadOnly</a> = <a href="#L79" title="access/transam/xact.c:79">DefaultXactReadOnly</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="access/transam/xact.c:83">XactDeferrable</a> = <a href="#L82" title="access/transam/xact.c:82">DefaultXactDeferrable</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L77" title="access/transam/xact.c:77">XactIsoLevel</a> = <a href="#L76" title="access/transam/xact.c:76">DefaultXactIsoLevel</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L290" title="access/transam/xact.c:290">forceSyncCommit</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L134" title="access/transam/xact.c:134">MyXactFlags</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reinitialize within-transaction counters<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s-&gt;subTransactionId = TopSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L263" title="access/transam/xact.c:263">currentSubTransactionId</a> = TopSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L264" title="access/transam/xact.c:264">currentCommandId</a> = FirstCommandId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L265" title="access/transam/xact.c:265">currentCommandIdUsed</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> reported xid accounting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L254" title="access/transam/xact.c:254">nUnreportedXids</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;didLogXid = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> resource-management stuff first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1173" title="access/transam/xact.c:1173">AtStart_Memory</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L1220" title="access/transam/xact.c:1220">AtStart_ResourceOwner</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assign a new LocalTransactionId, and <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> it with the proc number to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * form a virtual transaction id.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; vxid.procNumber = <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>;<br/></li>
<li>&nbsp; &nbsp; vxid.localTransactionId = <a href="../../storage/ipc/sinvaladt.c.html#L701" title="storage/ipc/sinvaladt.c:701">GetNextLocalTransactionId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lock the virtual transaction id <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we announce it in the proc array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lock.c.html#L4405" title="storage/lmgr/lock.c:4405">VirtualXactLockTableInsert</a>(vxid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advertise it in the proc array.&nbsp; We assume assignment of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * localTransactionId is atomic, and the proc number should be set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.procNumber == vxid.procNumber);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.lxid = vxid.localTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set transaction_timestamp() (a/k/a <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>()).&nbsp; Normally, we want this to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be the same as the first command's <a href="../../utils/adt/timestamp.c.html#L1624" title="utils/adt/timestamp.c:1624">statement_timestamp</a>(), so don't do a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fresh <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>() call (which'd be expensive anyway).&nbsp; But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for transactions started inside procedures (i.e., nonatomic SPI<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contexts), we do need to advance the timestamp.&nbsp; Also, in a parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worker, the timestamp should already have been provided by a call to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L856" title="access/transam/xact.c:856">SetParallelStartTimestamps</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsParallelWorker())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../executor/spi.c.html#L581" title="executor/spi.c:581">SPI_inside_nonatomic_context</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L277" title="access/transam/xact.c:277">xactStartTimestamp</a> = <a href="#L278" title="access/transam/xact.c:278">stmtStartTimestamp</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L277" title="access/transam/xact.c:277">xactStartTimestamp</a> = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L277" title="access/transam/xact.c:277">xactStartTimestamp</a> != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_status.c.html#L682" title="utils/activity/backend_status.c:682">pgstat_report_xact_timestamp</a>(<a href="#L277" title="access/transam/xact.c:277">xactStartTimestamp</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark <a href="#L279" title="access/transam/xact.c:279">xactStopTimestamp</a> as unset. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L279" title="access/transam/xact.c:279">xactStopTimestamp</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> other subsystems for new transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L2217" title="utils/misc/guc.c:2217">AtStart_GUC</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L1164" title="access/transam/xact.c:1164">AtStart_Cache</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../commands/trigger.c.html#L4986" title="commands/trigger.c:4986">AfterTriggerBeginXact</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done with start processing, set current transaction state to &quot;in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * progress&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s-&gt;state = TRANS_INPROGRESS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Schedule transaction timeout */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/lmgr/proc.c.html#L61" title="storage/lmgr/proc.c:61">TransactionTimeout</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/timeout.c.html#L560" title="utils/misc/timeout.c:560">enable_timeout_after</a>(TRANSACTION_TIMEOUT, <a href="../../storage/lmgr/proc.c.html#L61" title="storage/lmgr/proc.c:61">TransactionTimeout</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5599" title="access/transam/xact.c:5599">ShowTransactionState</a>(<span class="Constant">&quot;<a href="#L2014" title="access/transam/xact.c:2014">StartTransaction</a>&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2178" title="access/transam/xact.c:2178">CommitTransaction</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: if you change this routine, better look at <a href="#L2460" title="access/transam/xact.c:2460">PrepareTransaction</a> too!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2178">&#x200c;</a></span><span class="linkable">CommitTransaction</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li>&nbsp; &nbsp; TransactionId latestXid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_parallel_worker;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; is_parallel_worker = (s-&gt;blockState == TBLOCK_PARALLEL_INPROGRESS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Enforce parallel mode restrictions during parallel worker commit. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_parallel_worker)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1048" title="access/transam/xact.c:1048">EnterParallelMode</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5599" title="access/transam/xact.c:5599">ShowTransactionState</a>(<span class="Constant">&quot;<a href="#L2178" title="access/transam/xact.c:2178">CommitTransaction</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check the current transaction state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;state != TRANS_INPROGRESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;<a href="#L2178" title="access/transam/xact.c:2178">CommitTransaction</a> while in </span><span class="Special">%s</span><span class="Constant"> state&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5711" title="access/transam/xact.c:5711">TransStateAsString</a>(s-&gt;state));<br/></li>
<li>&nbsp; &nbsp; Assert(s-&gt;parent == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do pre-commit processing that involves calling user-defined code, such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as triggers.&nbsp; SECURITY_RESTRICTED_OPERATION contexts must not queue an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * action that would run here, because that would bypass the sandbox.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since closing cursors could queue <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> actions, triggers could open<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cursors, etc, we have to keep looping until there's nothing left to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fire all currently pending deferred triggers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/trigger.c.html#L5197" title="commands/trigger.c:5197">AfterTriggerFireDeferred</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Close open portals (converting holdable ones into static portals).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there weren't <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, we are done ... otherwise loop back to check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if they queued deferred triggers.&nbsp; Lather, rinse, <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/mmgr/portalmem.c.html#L677" title="utils/mmgr/portalmem.c:677">PreCommit_Portals</a>(<span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The remaining actions cannot call <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> user-defined code, so it's safe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to start shutting down within-transaction services.&nbsp; But note that most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of this stuff could still throw an error, which would switch us into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the transaction-abort path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L3787" title="access/transam/xact.c:3787">CallXactCallbacks</a>(is_parallel_worker ? XACT_EVENT_PARALLEL_PRE_COMMIT<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : XACT_EVENT_PRE_COMMIT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this xact has started <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unfinished parallel operation, clean up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its workers, warning about leaked resources.&nbsp; (But we don't actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reset parallelModeLevel till entering TRANS_COMMIT, a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> below.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keeps parallel mode restrictions active as long as possible in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel worker.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parallel.c.html#L1254" title="access/transam/parallel.c:1254">AtEOXact_Parallel</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_parallel_worker)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;parallelModeLevel != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;parallelModeLevel is </span><span class="Special">%d</span><span class="Constant"> not 1 at end of parallel worker transaction&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;parallelModeLevel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;parallelModeLevel != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;parallelModeLevel is </span><span class="Special">%d</span><span class="Constant"> not 0 at end of transaction&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;parallelModeLevel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shut down the deferred-<a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> manager */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../commands/trigger.c.html#L5253" title="commands/trigger.c:5253">AfterTriggerEndXact</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Let ON COMMIT management do its thing (must happen after closing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cursors, to avoid dangling-reference problems)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../commands/tablecmds.c.html#L18240" title="commands/tablecmds.c:18240">PreCommit_on_commit_actions</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Synchronize files that are created and not WAL-logged during this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction. This must happen <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/cache/relmapper.c.html#L541" title="utils/cache/relmapper.c:541">AtEOXact_RelationMap</a>(), so that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't see committed-but-broken files after a crash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../catalog/storage.c.html#L700" title="catalog/storage.c:700">smgrDoPendingSyncs</a>(<span class="Constant">true</span>, is_parallel_worker);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* close large objects <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../libpq/be-fsstubs.c.html#L602" title="libpq/be-fsstubs.c:602">AtEOXact_LargeObject</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> notifications sent by NOTIFY commands into the queue.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should be late in the pre-commit sequence to minimize time spent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * holding the notify-insertion lock.&nbsp; However, this could result in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * creating a snapshot, so we must do it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> serializable <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../commands/async.c.html#L861" title="commands/async.c:861">PreCommit_Notify</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark serializable transaction as complete for predicate locking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * purposes.&nbsp; This should be done as late as we can put it and still allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * errors to be raised for failure patterns found at commit.&nbsp; This is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appropriate in a parallel worker however, because we aren't committing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the leader's transaction and its serializable state will live on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!is_parallel_worker)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L4688" title="storage/lmgr/predicate.c:4688">PreCommit_CheckForSerializationFailure</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prevent cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> interrupt while cleaning up */<br/></li>
<li></span>&nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Commit updates to the relation map --- do this as late as possible */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/relmapper.c.html#L541" title="utils/cache/relmapper.c:541">AtEOXact_RelationMap</a>(<span class="Constant">true</span>, is_parallel_worker);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set the current transaction state information appropriately during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit processing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s-&gt;state = TRANS_COMMIT;<br/></li>
<li>&nbsp; &nbsp; s-&gt;parallelModeLevel = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;parallelChildXact = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* should be false already */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Disable transaction timeout */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/lmgr/proc.c.html#L61" title="storage/lmgr/proc.c:61">TransactionTimeout</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/timeout.c.html#L685" title="utils/misc/timeout.c:685">disable_timeout</a>(TRANSACTION_TIMEOUT, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!is_parallel_worker)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to mark our XIDs as committed in pg_xact.&nbsp; This is where we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * durably commit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; latestXid = <a href="#L1304" title="access/transam/xact.c:1304">RecordTransactionCommit</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must not mark our XID committed; the parallel leader is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * responsible for that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; latestXid = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure the leader will know about <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WAL we wrote <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * commits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parallel.c.html#L1539" title="access/transam/parallel.c:1539">ParallelWorkerReportLastRecEnd</a>(<a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_TRANSACTION_COMMIT(<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.lxid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Let others know about no transaction in progress by me. Note that this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must be done _before_ releasing locks we hold and _after_<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1304" title="access/transam/xact.c:1304">RecordTransactionCommit</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L667" title="storage/ipc/procarray.c:667">ProcArrayEndTransaction</a>(<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>, latestXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is all post-commit <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.&nbsp; Note that if an error is raised here,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's too late to abort the transaction.&nbsp; This should be just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * noncritical resource releasing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The ordering of operations is not entirely random.&nbsp; The idea is:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * release resources visible to other backends (eg, files, buffer pins);<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then release locks; then release backend-local resources. We want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * release locks at the point where <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backend <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for us will see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * our transaction as being fully cleaned up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Resources that can be associated with individual queries are handled by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the ResourceOwner mechanism.&nbsp; The other calls here are for backend-wide<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L3787" title="access/transam/xact.c:3787">CallXactCallbacks</a>(is_parallel_worker ? XACT_EVENT_PARALLEL_COMMIT<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : XACT_EVENT_COMMIT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(<a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_BEFORE_LOCKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check we've released all buffer pins */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3502" title="storage/buffer/bufmgr.c:3502">AtEOXact_Buffers</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up the relation cache */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L3194" title="utils/cache/relcache.c:3194">AtEOXact_RelationCache</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make catalog changes visible to all backends.&nbsp; This has to happen after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relcache references are dropped (see comments for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/cache/relcache.c.html#L3194" title="utils/cache/relcache.c:3194">AtEOXact_RelationCache</a>), but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> locks are released (if anyone is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for lock on a relation we've modified, we want them to know<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about the catalog change <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> they start using the relation).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1025" title="utils/cache/inval.c:1025">AtEOXact_Inval</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="multixact.c.html#L1759" title="access/transam/multixact.c:1759">AtEOXact_MultiXact</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(<a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_LOCKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(<a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_AFTER_LOCKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise, dropping of files deleted during the transaction is best done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after releasing relcache and buffer pins.&nbsp; (This is not strictly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessary during commit, since such pins should have been released<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already, but this ordering is definitely critical during abort.)&nbsp; Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this may take many seconds, also delay until after releasing locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Other backends will observe the attendant catalog changes and not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attempt to access affected files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../catalog/storage.c.html#L632" title="catalog/storage.c:632">smgrDoPendingDeletes</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Send out notification signals to other backends (and do other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * post-commit NOTIFY <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>).&nbsp; This must not happen until after our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction is fully done from the viewpoint of other backends.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../commands/async.c.html#L968" title="commands/async.c:968">AtCommit_Notify</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Everything after this should be purely <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>-to-this-backend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L2264" title="utils/misc/guc.c:2264">AtEOXact_GUC</a>(<span class="Constant">true</span>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L428" title="executor/spi.c:428">AtEOXact_SPI</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../catalog/pg_enum.c.html#L726" title="catalog/pg_enum.c:726">AtEOXact_Enum</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../commands/tablecmds.c.html#L18347" title="commands/tablecmds.c:18347">AtEOXact_on_commit_actions</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../catalog/namespace.c.html#L4497" title="catalog/namespace.c:4497">AtEOXact_Namespace</a>(<span class="Constant">true</span>, is_parallel_worker);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/smgr/smgr.c.html#L807" title="storage/smgr/smgr.c:807">AtEOXact_SMgr</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L3165" title="storage/file/fd.c:3165">AtEOXact_Files</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/time/combocid.c.html#L182" title="utils/time/combocid.c:182">AtEOXact_ComboCid</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1869" title="utils/hash/dynahash.c:1869">AtEOXact_HashTables</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_xact.c.html#L40" title="utils/activity/pgstat_xact.c:40">AtEOXact_PgStat</a>(<span class="Constant">true</span>, is_parallel_worker);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L995" title="utils/time/snapmgr.c:995">AtEOXact_Snapshot</a>(<span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../replication/logical/launcher.c.html#L1086" title="replication/logical/launcher.c:1086">AtEOXact_ApplyLauncher</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../replication/logical/worker.c.html#L5003" title="replication/logical/worker.c:5003">AtEOXact_LogicalRepWorkers</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_status.c.html#L682" title="utils/activity/backend_status.c:682">pgstat_report_xact_timestamp</a>(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L854" title="utils/resowner/resowner.c:854">ResourceOwnerDelete</a>(<a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a>);<br/></li>
<li>&nbsp; &nbsp; s-&gt;curTransactionOwner = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L166" title="utils/resowner/resowner.c:166">CurTransactionResourceOwner</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1577" title="access/transam/xact.c:1577">AtCommit_Memory</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s-&gt;fullTransactionId = InvalidFullTransactionId;<br/></li>
<li>&nbsp; &nbsp; s-&gt;subTransactionId = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; s-&gt;nestingLevel = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;gucNestLevel = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;childXids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;nChildXids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;maxChildXids = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L123" title="access/transam/xact.c:123">XactTopFullTransactionId</a> = InvalidFullTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L124" title="access/transam/xact.c:124">nParallelCurrentXids</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done with commit processing, set current transaction state back to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s-&gt;state = TRANS_DEFAULT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2460" title="access/transam/xact.c:2460">PrepareTransaction</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: if you change this routine, better look at <a href="#L2178" title="access/transam/xact.c:2178">CommitTransaction</a> too!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2460">&#x200c;</a></span><span class="linkable">PrepareTransaction</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li>&nbsp; &nbsp; TransactionId xid = <a href="#L451" title="access/transam/xact.c:451">GetCurrentTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; GlobalTransaction gxact;<br/></li>
<li>&nbsp; &nbsp; TimestampTz prepared_at;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5599" title="access/transam/xact.c:5599">ShowTransactionState</a>(<span class="Constant">&quot;<a href="#L2460" title="access/transam/xact.c:2460">PrepareTransaction</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check the current transaction state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;state != TRANS_INPROGRESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;<a href="#L2460" title="access/transam/xact.c:2460">PrepareTransaction</a> while in </span><span class="Special">%s</span><span class="Constant"> state&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5711" title="access/transam/xact.c:5711">TransStateAsString</a>(s-&gt;state));<br/></li>
<li>&nbsp; &nbsp; Assert(s-&gt;parent == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do pre-commit processing that involves calling user-defined code, such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as triggers.&nbsp; Since closing cursors could queue <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> actions,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * triggers could open cursors, etc, we have to keep looping until there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nothing left to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fire all currently pending deferred triggers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/trigger.c.html#L5197" title="commands/trigger.c:5197">AfterTriggerFireDeferred</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Close open portals (converting holdable ones into static portals).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there weren't <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, we are done ... otherwise loop back to check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if they queued deferred triggers.&nbsp; Lather, rinse, <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/mmgr/portalmem.c.html#L677" title="utils/mmgr/portalmem.c:677">PreCommit_Portals</a>(<span class="Constant">true</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3787" title="access/transam/xact.c:3787">CallXactCallbacks</a>(XACT_EVENT_PRE_PREPARE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The remaining actions cannot call <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> user-defined code, so it's safe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to start shutting down within-transaction services.&nbsp; But note that most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of this stuff could still throw an error, which would switch us into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the transaction-abort path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shut down the deferred-<a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> manager */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../commands/trigger.c.html#L5253" title="commands/trigger.c:5253">AfterTriggerEndXact</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Let ON COMMIT management do its thing (must happen after closing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cursors, to avoid dangling-reference problems)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../commands/tablecmds.c.html#L18240" title="commands/tablecmds.c:18240">PreCommit_on_commit_actions</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Synchronize files that are created and not WAL-logged during this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction. This must happen <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="twophase.c.html#L1158" title="access/transam/twophase.c:1158">EndPrepare</a>(), so that we don't see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * committed-but-broken files after a crash and COMMIT PREPARED.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../catalog/storage.c.html#L700" title="catalog/storage.c:700">smgrDoPendingSyncs</a>(<span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* close large objects <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../libpq/be-fsstubs.c.html#L602" title="libpq/be-fsstubs.c:602">AtEOXact_LargeObject</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NOTIFY requires no work at this point */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark serializable transaction as complete for predicate locking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * purposes.&nbsp; This should be done as late as we can put it and still allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * errors to be raised for failure patterns found at commit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L4688" title="storage/lmgr/predicate.c:4688">PreCommit_CheckForSerializationFailure</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't allow PREPARE TRANSACTION if we've accessed a temporary table in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this transaction.&nbsp; Having the prepared xact hold locks on another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backend's temp table seems a bad idea --- for instance it would prevent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the backend from exiting.&nbsp; There are other problems too, such as how to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clean up the source backend's local buffers and ON COMMIT state if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prepared xact includes a DROP of a temp table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Other objects types, like <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, operators or extensions, share the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same restriction as they should not be created, locked or dropped as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this can mess up with this session or even a follow-up session trying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to use the same temporary namespace.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must check this after executing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> ON COMMIT actions, because they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might still access a temp relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> In principle this could be relaxed to allow some useful special<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases, such as a temp table created and dropped all within the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction.&nbsp; That seems to require much more bookkeeping though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((<a href="#L134" title="access/transam/xact.c:134">MyXactFlags</a> &amp; XACT_FLAGS_ACCESSEDTEMPNAMESPACE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot PREPARE a transaction that has operated on temporary objects&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise, don't allow PREPARE after <a href="../../utils/time/snapmgr.c.html#L1272" title="utils/time/snapmgr.c:1272">pg_export_snapshot</a>.&nbsp; This could be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * supported if we added <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> logic to twophase.c, but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't seem worth the trouble.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/time/snapmgr.c.html#L1554" title="utils/time/snapmgr.c:1554">XactHasExportedSnapshots</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot PREPARE a transaction that has exported snapshots&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prevent cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> interrupt while cleaning up */<br/></li>
<li></span>&nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set the current transaction state information appropriately during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prepare processing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s-&gt;state = TRANS_PREPARE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Disable transaction timeout */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/lmgr/proc.c.html#L61" title="storage/lmgr/proc.c:61">TransactionTimeout</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/timeout.c.html#L685" title="utils/misc/timeout.c:685">disable_timeout</a>(TRANSACTION_TIMEOUT, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; prepared_at = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reserve the GID for this transaction. This could fail if the requested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * GID is invalid or already in use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; gxact = <a href="twophase.c.html#L359" title="access/transam/twophase.c:359">MarkAsPreparing</a>(xid, <a href="#L285" title="access/transam/xact.c:285">prepareGID</a>, prepared_at,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(), <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L285" title="access/transam/xact.c:285">prepareGID</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Collect data for the 2PC state file.&nbsp; Note that in general, no actual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state change should happen in the called modules during this step,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since it's still possible to fail <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> commit, and in that case we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * want transaction abort to be able to clean up.&nbsp; (In particular, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * AtPrepare routines may error out if they <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> cases they cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handle.)&nbsp; State <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> should happen in the PostPrepare routines<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * below.&nbsp; However, some modules can go ahead and clear state here because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they wouldn't do anything with it during abort anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: because the 2PC state file <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> will be replayed in the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * order they are made, the order of these calls has to match the order in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which we want things to happen during COMMIT PREPARED or ROLLBACK<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PREPARED; in particular, pay attention to whether things should happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> or after releasing the transaction's locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="twophase.c.html#L1065" title="access/transam/twophase.c:1065">StartPrepare</a>(gxact);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../commands/async.c.html#L836" title="commands/async.c:836">AtPrepare_Notify</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lock.c.html#L3272" title="storage/lmgr/lock.c:3272">AtPrepare_Locks</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L4775" title="storage/lmgr/predicate.c:4775">AtPrepare_PredicateLocks</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_xact.c.html#L189" title="utils/activity/pgstat_xact.c:189">AtPrepare_PgStat</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="multixact.c.html#L1787" title="access/transam/multixact.c:1787">AtPrepare_MultiXact</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/cache/relmapper.c.html#L588" title="utils/cache/relmapper.c:588">AtPrepare_RelationMap</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Here is where we really truly prepare.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to record transaction prepares even if we didn't make <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * updates, because the transaction manager might get confused if we lose<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a global transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="twophase.c.html#L1158" title="access/transam/twophase.c:1158">EndPrepare</a>(gxact);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we clean up backend-<a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> state and release <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> resources.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset <a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a> until the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> transaction writes something */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Transfer our locks to a dummy PGPROC.&nbsp; This has to be done <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/procarray.c.html#L907" title="storage/ipc/procarray.c:907">ProcArrayClearTransaction</a>().&nbsp; Otherwise, a <a href="../../storage/lmgr/lock.c.html#L2872" title="storage/lmgr/lock.c:2872">GetLockConflicts</a>() would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conclude &quot;xact already committed or aborted&quot; for our locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lock.c.html#L3368" title="storage/lmgr/lock.c:3368">PostPrepare_Locks</a>(xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Let others know about no transaction in progress by me.&nbsp; This has to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done *after* the prepared transaction has been marked valid, else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * someone may think it is unlocked and recyclable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L907" title="storage/ipc/procarray.c:907">ProcArrayClearTransaction</a>(<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In normal commit-processing, this is all non-critical post-transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.&nbsp; When the transaction is prepared, however, it's important<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the locks and other per-backend resources are transferred to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prepared transaction's PGPROC entry.&nbsp; Note that if an error is raised<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here, it's too late to abort the transaction. </span><span class="Todo">XXX</span><span class="Comment">: This probably should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be in a critical section, to force a PANIC if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of this fails, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that cure could be worse than the disease.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L3787" title="access/transam/xact.c:3787">CallXactCallbacks</a>(XACT_EVENT_PREPARE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(<a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_BEFORE_LOCKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check we've released all buffer pins */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3502" title="storage/buffer/bufmgr.c:3502">AtEOXact_Buffers</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up the relation cache */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L3194" title="utils/cache/relcache.c:3194">AtEOXact_RelationCache</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* notify doesn't need a postprepare call */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_xact.c.html#L209" title="utils/activity/pgstat_xact.c:209">PostPrepare_PgStat</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L863" title="utils/cache/inval.c:863">PostPrepare_Inval</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../catalog/storage.c.html#L893" title="catalog/storage.c:893">PostPrepare_smgr</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="multixact.c.html#L1801" title="access/transam/multixact.c:1801">PostPrepare_MultiXact</a>(xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L4844" title="storage/lmgr/predicate.c:4844">PostPrepare_PredicateLocks</a>(xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(<a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_LOCKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(<a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_AFTER_LOCKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allow another backend to finish the transaction.&nbsp; After<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="twophase.c.html#L344" title="access/transam/twophase.c:344">PostPrepare_Twophase</a>(), the transaction is completely detached from our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backend.&nbsp; The rest is just non-critical <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> of backend-local state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="twophase.c.html#L344" title="access/transam/twophase.c:344">PostPrepare_Twophase</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* PREPARE acts the same as COMMIT as far as GUC is concerned */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L2264" title="utils/misc/guc.c:2264">AtEOXact_GUC</a>(<span class="Constant">true</span>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L428" title="executor/spi.c:428">AtEOXact_SPI</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../catalog/pg_enum.c.html#L726" title="catalog/pg_enum.c:726">AtEOXact_Enum</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../commands/tablecmds.c.html#L18347" title="commands/tablecmds.c:18347">AtEOXact_on_commit_actions</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../catalog/namespace.c.html#L4497" title="catalog/namespace.c:4497">AtEOXact_Namespace</a>(<span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/smgr/smgr.c.html#L807" title="storage/smgr/smgr.c:807">AtEOXact_SMgr</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L3165" title="storage/file/fd.c:3165">AtEOXact_Files</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/time/combocid.c.html#L182" title="utils/time/combocid.c:182">AtEOXact_ComboCid</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1869" title="utils/hash/dynahash.c:1869">AtEOXact_HashTables</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't call <a href="../../utils/activity/pgstat_xact.c.html#L40" title="utils/activity/pgstat_xact.c:40">AtEOXact_PgStat</a> here; we fixed pgstat state above */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L995" title="utils/time/snapmgr.c:995">AtEOXact_Snapshot</a>(<span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we treat PREPARE as ROLLBACK so far as waking workers goes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../replication/logical/launcher.c.html#L1086" title="replication/logical/launcher.c:1086">AtEOXact_ApplyLauncher</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../replication/logical/worker.c.html#L5003" title="replication/logical/worker.c:5003">AtEOXact_LogicalRepWorkers</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_status.c.html#L682" title="utils/activity/backend_status.c:682">pgstat_report_xact_timestamp</a>(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L854" title="utils/resowner/resowner.c:854">ResourceOwnerDelete</a>(<a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a>);<br/></li>
<li>&nbsp; &nbsp; s-&gt;curTransactionOwner = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L166" title="utils/resowner/resowner.c:166">CurTransactionResourceOwner</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1577" title="access/transam/xact.c:1577">AtCommit_Memory</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s-&gt;fullTransactionId = InvalidFullTransactionId;<br/></li>
<li>&nbsp; &nbsp; s-&gt;subTransactionId = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; s-&gt;nestingLevel = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;gucNestLevel = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;childXids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;nChildXids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;maxChildXids = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L123" title="access/transam/xact.c:123">XactTopFullTransactionId</a> = InvalidFullTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L124" title="access/transam/xact.c:124">nParallelCurrentXids</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done with 1st phase commit processing, set current transaction state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * back to default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s-&gt;state = TRANS_DEFAULT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2749">&#x200c;</a></span><span class="linkable">AbortTransaction</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li>&nbsp; &nbsp; TransactionId latestXid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_parallel_worker;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prevent cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> interrupt while cleaning up */<br/></li>
<li></span>&nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Disable transaction timeout */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/lmgr/proc.c.html#L61" title="storage/lmgr/proc.c:61">TransactionTimeout</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/timeout.c.html#L685" title="utils/misc/timeout.c:685">disable_timeout</a>(TRANSACTION_TIMEOUT, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we have a valid memory context and resource owner */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1853" title="access/transam/xact.c:1853">AtAbort_Memory</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L1885" title="access/transam/xact.c:1885">AtAbort_ResourceOwner</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LW locks we might be holding as quickly as possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Regular locks, however, must be held till we finish aborting.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Releasing LW locks is critical since we might try to grab them again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * while cleaning up!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1878" title="storage/lmgr/lwlock.c:1878">LWLockReleaseAll</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clear wait information and command progress indicator */<br/></li>
<li></span>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L151" title="utils/activity/backend_progress.c:151">pgstat_progress_end_command</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up buffer context locks, too */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5057" title="storage/buffer/bufmgr.c:5057">UnlockBuffers</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset WAL record construction state */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xloginsert.c.html#L222" title="access/transam/xloginsert.c:222">XLogResetInsertion</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cancel condition variable sleep */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also clean up <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> open wait for lock, since the lock manager will choke<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we try to wait for another lock <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L730" title="storage/lmgr/proc.c:730">LockErrorCleanup</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> timeout events are still active, make sure the timeout interrupt<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is scheduled.&nbsp; This covers possible loss of a timeout interrupt due to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * longjmp'ing out of the SIGINT handler (see notes in <a href="../../utils/misc/timeout.c.html#L364" title="utils/misc/timeout.c:364">handle_sig_alarm</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We delay this till after <a href="../../storage/lmgr/proc.c.html#L730" title="storage/lmgr/proc.c:730">LockErrorCleanup</a> so that we don't uselessly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reschedule lock or deadlock check timeouts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/misc/timeout.c.html#L540" title="utils/misc/timeout.c:540">reschedule_timeouts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Re-enable signals, in case we got here by longjmp'ing out of a signal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handler.&nbsp; We do this fairly early in the sequence so that the timeout<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * infrastructure will be functional if needed while aborting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../../libpq/pqsignal.c.html#L22" title="libpq/pqsignal.c:22">UnBlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check the current transaction state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; is_parallel_worker = (s-&gt;blockState == TBLOCK_PARALLEL_INPROGRESS);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;state != TRANS_INPROGRESS &amp;&amp; s-&gt;state != TRANS_PREPARE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;<a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a> while in </span><span class="Special">%s</span><span class="Constant"> state&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5711" title="access/transam/xact.c:5711">TransStateAsString</a>(s-&gt;state));<br/></li>
<li>&nbsp; &nbsp; Assert(s-&gt;parent == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set the current transaction state information appropriately during the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * abort processing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s-&gt;state = TRANS_ABORT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset user ID which might have been changed transiently.&nbsp; We need this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to clean up in case control escaped out of a SECURITY DEFINER function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or other local change of <a href="../../utils/init/miscinit.c.html#L497" title="utils/init/miscinit.c:497">CurrentUserId</a>; therefore, the prior value of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/init/miscinit.c.html#L503" title="utils/init/miscinit.c:503">SecurityRestrictionContext</a> also needs to be restored.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note: it is not necessary to restore session authorization or role<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * settings here because those can only be changed via GUC, and GUC will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * take care of rolling them back if need be.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(s-&gt;prevUser, s-&gt;prevSecContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Forget about <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> active REINDEX. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../catalog/index.c.html#L4149" title="catalog/index.c:4149">ResetReindexState</a>(s-&gt;nestingLevel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset logical streaming state. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../replication/logical/logical.c.html#L1921" title="replication/logical/logical.c:1921">ResetLogicalStreamingState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset snapshot export state. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../replication/logical/snapbuild.c.html#L756" title="replication/logical/snapbuild.c:756">SnapBuildResetExportedSnapshotState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this xact has started <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unfinished parallel operation, clean up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its workers and exit parallel mode.&nbsp; Don't warn about leaked resources.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parallel.c.html#L1254" title="access/transam/parallel.c:1254">AtEOXact_Parallel</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; s-&gt;parallelModeLevel = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;parallelChildXact = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* should be false already */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do abort processing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../commands/trigger.c.html#L5253" title="commands/trigger.c:5253">AfterTriggerEndXact</a>(<span class="Constant">false</span>); <span class="Comment">/* 'false' means it's abort */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/portalmem.c.html#L781" title="utils/mmgr/portalmem.c:781">AtAbort_Portals</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../catalog/storage.c.html#L700" title="catalog/storage.c:700">smgrDoPendingSyncs</a>(<span class="Constant">false</span>, is_parallel_worker);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/be-fsstubs.c.html#L602" title="libpq/be-fsstubs.c:602">AtEOXact_LargeObject</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../commands/async.c.html#L1671" title="commands/async.c:1671">AtAbort_Notify</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/cache/relmapper.c.html#L541" title="utils/cache/relmapper.c:541">AtEOXact_RelationMap</a>(<span class="Constant">false</span>, is_parallel_worker);<br/></li>
<li>&nbsp; &nbsp; <a href="twophase.c.html#L304" title="access/transam/twophase.c:304">AtAbort_Twophase</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advertise the fact that we aborted in pg_xact (assuming that we got as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * far as assigning an XID to advertise).&nbsp; But if we're inside a parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worker, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this; the user backend must be the one to write the abort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!is_parallel_worker)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; latestXid = <a href="#L1723" title="access/transam/xact.c:1723">RecordTransactionAbort</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; latestXid = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since the parallel leader won't get our value of <a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a> in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this case, we nudge WAL-writer ourselves in this case.&nbsp; See related<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comments in <a href="#L1723" title="access/transam/xact.c:1723">RecordTransactionAbort</a> for why this matters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L2626" title="access/transam/xlog.c:2626">XLogSetAsyncXactLSN</a>(<a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_TRANSACTION_ABORT(<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.lxid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Let others know about no transaction in progress by me. Note that this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must be done _before_ releasing locks we hold and _after_<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1723" title="access/transam/xact.c:1723">RecordTransactionAbort</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L667" title="storage/ipc/procarray.c:667">ProcArrayEndTransaction</a>(<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>, latestXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Post-abort <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.&nbsp; See notes in <a href="#L2178" title="access/transam/xact.c:2178">CommitTransaction</a>() concerning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ordering.&nbsp; We can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> all of it if the transaction failed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * creating a resource owner.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_parallel_worker)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3787" title="access/transam/xact.c:3787">CallXactCallbacks</a>(XACT_EVENT_PARALLEL_ABORT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3787" title="access/transam/xact.c:3787">CallXactCallbacks</a>(XACT_EVENT_ABORT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(<a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_BEFORE_LOCKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3502" title="storage/buffer/bufmgr.c:3502">AtEOXact_Buffers</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L3194" title="utils/cache/relcache.c:3194">AtEOXact_RelationCache</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1025" title="utils/cache/inval.c:1025">AtEOXact_Inval</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="multixact.c.html#L1759" title="access/transam/multixact.c:1759">AtEOXact_MultiXact</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(<a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_LOCKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(<a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_AFTER_LOCKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/storage.c.html#L632" title="catalog/storage.c:632">smgrDoPendingDeletes</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L2264" title="utils/misc/guc.c:2264">AtEOXact_GUC</a>(<span class="Constant">false</span>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/spi.c.html#L428" title="executor/spi.c:428">AtEOXact_SPI</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/pg_enum.c.html#L726" title="catalog/pg_enum.c:726">AtEOXact_Enum</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/tablecmds.c.html#L18347" title="commands/tablecmds.c:18347">AtEOXact_on_commit_actions</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/namespace.c.html#L4497" title="catalog/namespace.c:4497">AtEOXact_Namespace</a>(<span class="Constant">false</span>, is_parallel_worker);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/smgr/smgr.c.html#L807" title="storage/smgr/smgr.c:807">AtEOXact_SMgr</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L3165" title="storage/file/fd.c:3165">AtEOXact_Files</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/combocid.c.html#L182" title="utils/time/combocid.c:182">AtEOXact_ComboCid</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1869" title="utils/hash/dynahash.c:1869">AtEOXact_HashTables</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_xact.c.html#L40" title="utils/activity/pgstat_xact.c:40">AtEOXact_PgStat</a>(<span class="Constant">false</span>, is_parallel_worker);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/logical/launcher.c.html#L1086" title="replication/logical/launcher.c:1086">AtEOXact_ApplyLauncher</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/logical/worker.c.html#L5003" title="replication/logical/worker.c:5003">AtEOXact_LogicalRepWorkers</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_status.c.html#L682" title="utils/activity/backend_status.c:682">pgstat_report_xact_timestamp</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * State remains TRANS_ABORT until <a href="#L2945" title="access/transam/xact.c:2945">CleanupTransaction</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2945" title="access/transam/xact.c:2945">CleanupTransaction</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2945">&#x200c;</a></span><span class="linkable">CleanupTransaction</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * State should still be TRANS_ABORT from <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;state != TRANS_ABORT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L2945" title="access/transam/xact.c:2945">CleanupTransaction</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5711" title="access/transam/xact.c:5711">TransStateAsString</a>(s-&gt;state));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do abort <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> processing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/portalmem.c.html#L858" title="utils/mmgr/portalmem.c:858">AtCleanup_Portals</a>();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> safe to release portal memory */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L995" title="utils/time/snapmgr.c:995">AtEOXact_Snapshot</a>(<span class="Constant">false</span>, <span class="Constant">true</span>); <span class="Comment">/* and release the transaction's snapshots */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* and resource owner */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L854" title="utils/resowner/resowner.c:854">ResourceOwnerDelete</a>(<a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a>);<br/></li>
<li>&nbsp; &nbsp; s-&gt;curTransactionOwner = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L166" title="utils/resowner/resowner.c:166">CurTransactionResourceOwner</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1943" title="access/transam/xact.c:1943">AtCleanup_Memory</a>();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and transaction memory */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; s-&gt;fullTransactionId = InvalidFullTransactionId;<br/></li>
<li>&nbsp; &nbsp; s-&gt;subTransactionId = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; s-&gt;nestingLevel = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;gucNestLevel = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;childXids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;nChildXids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;maxChildXids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;parallelModeLevel = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;parallelChildXact = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L123" title="access/transam/xact.c:123">XactTopFullTransactionId</a> = InvalidFullTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L124" title="access/transam/xact.c:124">nParallelCurrentXids</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done with abort processing, set current transaction state back to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s-&gt;state = TRANS_DEFAULT;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2995">&#x200c;</a></span><span class="linkable">StartTransactionCommand</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (s-&gt;blockState)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we aren't in a transaction block, we just do our usual start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_DEFAULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2014" title="access/transam/xact.c:2014">StartTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_STARTED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are somewhere in a transaction block or subtransaction and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about to start a new command.&nbsp; For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we do nothing, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * someday we may do command-local resource initialization. (Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> needed <a href="#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a> was done by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previous <a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_IMPLICIT_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBINPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here we are in a failed transaction block (one of the commands<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caused an abort) so we do nothing but remain in the abort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * state.&nbsp; Eventually we will get a ROLLBACK command which will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * get us out of this state.&nbsp; (It is up to other code to ensure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that no commands other than ROLLBACK will be processed in these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * states.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* These cases are invalid. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_STARTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_BEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PARALLEL_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBBEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRELEASE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBCOMMIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_RESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(s-&gt;blockState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must switch to <a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning. This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already done if we called <a href="#L2014" title="access/transam/xact.c:2014">StartTransaction</a>, otherwise not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Simple system for saving and restoring transaction characteristics<br/></li>
<li></span><span class="Comment"> * (isolation level, read only, deferrable).&nbsp; We need this for transaction<br/></li>
<li></span><span class="Comment"> * chaining, so that we can set the characteristics of the new transaction to<br/></li>
<li></span><span class="Comment"> * be the same as the previous one.&nbsp; (We need something like this because the<br/></li>
<li></span><span class="Comment"> * GUC system resets the characteristics at transaction end, so for example<br/></li>
<li></span><span class="Comment"> * just skipping the reset in <a href="#L2014" title="access/transam/xact.c:2014">StartTransaction</a>() won't work.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3072">&#x200c;</a></span><span class="linkable">SaveTransactionCharacteristics</span>(SavedTransactionCharacteristics *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; s-&gt;save_XactIsoLevel = <a href="#L77" title="access/transam/xact.c:77">XactIsoLevel</a>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;save_XactReadOnly = <a href="#L80" title="access/transam/xact.c:80">XactReadOnly</a>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;save_XactDeferrable = <a href="#L83" title="access/transam/xact.c:83">XactDeferrable</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L3080">&#x200c;</a></span><span class="linkable">RestoreTransactionCharacteristics</span>(<span class="Type">const</span> SavedTransactionCharacteristics *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L77" title="access/transam/xact.c:77">XactIsoLevel</a> = s-&gt;save_XactIsoLevel;<br/></li>
<li>&nbsp; &nbsp; <a href="#L80" title="access/transam/xact.c:80">XactReadOnly</a> = s-&gt;save_XactReadOnly;<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="access/transam/xact.c:83">XactDeferrable</a> = s-&gt;save_XactDeferrable;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a> -- a wrapper function handling the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; loop over subtransactions to avoid a potentially dangerous recursion<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; in <a href="#L3111" title="access/transam/xact.c:3111">CommitTransactionCommandInternal</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3093">&#x200c;</a></span><span class="linkable">CommitTransactionCommand</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Repeatedly call <a href="#L3111" title="access/transam/xact.c:3111">CommitTransactionCommandInternal</a>() until all the work<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (!<a href="#L3111" title="access/transam/xact.c:3111">CommitTransactionCommandInternal</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L3111" title="access/transam/xact.c:3111">CommitTransactionCommandInternal</a> - a function doing an iteration of work<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; regarding handling the commit transaction command.&nbsp; In the case of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; subtransactions more than one iterations could be required.&nbsp; Returns<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; true when no more iterations required, false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3111">&#x200c;</a></span><span class="linkable">CommitTransactionCommandInternal</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li>&nbsp; &nbsp; SavedTransactionCharacteristics savetc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must save in case we need to restore below */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3072" title="access/transam/xact.c:3072">SaveTransactionCharacteristics</a>(&amp;savetc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (s-&gt;blockState)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These shouldn't happen.&nbsp; TBLOCK_DEFAULT means the previous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a> didn't set the STARTED state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * appropriately, while TBLOCK_PARALLEL_INPROGRESS should be ended<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by <a href="#L5587" title="access/transam/xact.c:5587">EndParallelWorkerTransaction</a>(), not this function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_DEFAULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PARALLEL_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(s-&gt;blockState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we aren't in a transaction block, just do our usual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction commit, and return to the idle state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_STARTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2178" title="access/transam/xact.c:2178">CommitTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are completing a &quot;BEGIN TRANSACTION&quot; command, so we change<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the &quot;transaction block in progress&quot; state and return.&nbsp; (We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assume the BEGIN did nothing to the database, so we need no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_BEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_INPROGRESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is the case when we have finished executing a command<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * someplace within a transaction block.&nbsp; We increment the command<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * counter and return.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_IMPLICIT_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBINPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are completing a &quot;COMMIT&quot; command.&nbsp; Do it and return to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * idle state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2178" title="access/transam/xact.c:2178">CommitTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;chain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2014" title="access/transam/xact.c:2014">StartTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_INPROGRESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;chain = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3080" title="access/transam/xact.c:3080">RestoreTransactionCharacteristics</a>(&amp;savetc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here we are in the middle of a transaction block but one of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * commands caused an abort so we do nothing but remain in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * abort state.&nbsp; Eventually we will get a ROLLBACK command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here we were in an aborted transaction block and we just got<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the ROLLBACK command from the user, so clean up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already-aborted transaction and return to the idle state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2945" title="access/transam/xact.c:2945">CleanupTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;chain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2014" title="access/transam/xact.c:2014">StartTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_INPROGRESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;chain = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3080" title="access/transam/xact.c:3080">RestoreTransactionCharacteristics</a>(&amp;savetc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here we were in a perfectly good transaction block but the user<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * told us to ROLLBACK anyway.&nbsp; We have to abort the transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and then clean up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2945" title="access/transam/xact.c:2945">CleanupTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;chain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2014" title="access/transam/xact.c:2014">StartTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_INPROGRESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;chain = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3080" title="access/transam/xact.c:3080">RestoreTransactionCharacteristics</a>(&amp;savetc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are completing a &quot;PREPARE TRANSACTION&quot; command.&nbsp; Do it and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * return to the idle state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2460" title="access/transam/xact.c:2460">PrepareTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The user issued a SAVEPOINT inside a transaction block. Start a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subtransaction.&nbsp; (<a href="#L4322" title="access/transam/xact.c:4322">DefineSavepoint</a> already did <a href="#L5367" title="access/transam/xact.c:5367">PushTransaction</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so as to have someplace to put the SUBBEGIN state.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBBEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5011" title="access/transam/xact.c:5011">StartSubTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_SUBINPROGRESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The user issued a RELEASE command, so we end the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subtransaction and return to the parent transaction. The parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might be ended too, so <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> till we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an INPROGRESS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction or subtransaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRELEASE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5048" title="access/transam/xact.c:5048">CommitSubTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;&nbsp; &nbsp; <span class="Comment">/* changed by pop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (s-&gt;blockState == TBLOCK_SUBRELEASE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(s-&gt;blockState == TBLOCK_INPROGRESS ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;blockState == TBLOCK_SUBINPROGRESS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The user issued a COMMIT, so we end the current subtransaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hierarchy and perform final commit. We do this by rolling up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subtransactions into their parent, which leads to O(N^2)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operations with respect to resource owners - this isn't that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bad until we approach a thousands of savepoints but is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * necessary for correctness should after triggers create new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * resource owners.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBCOMMIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5048" title="access/transam/xact.c:5048">CommitSubTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;&nbsp; &nbsp; <span class="Comment">/* changed by pop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (s-&gt;blockState == TBLOCK_SUBCOMMIT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we had a COMMIT command, finish off the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> xact too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;blockState == TBLOCK_END)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(s-&gt;parent == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2178" title="access/transam/xact.c:2178">CommitTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;chain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2014" title="access/transam/xact.c:2014">StartTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_INPROGRESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;chain = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3080" title="access/transam/xact.c:3080">RestoreTransactionCharacteristics</a>(&amp;savetc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (s-&gt;blockState == TBLOCK_PREPARE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(s-&gt;parent == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2460" title="access/transam/xact.c:2460">PrepareTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(s-&gt;blockState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The current already-failed subtransaction is ending due to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ROLLBACK or ROLLBACK TO command, so pop it and recursively<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * examine the parent (which could be in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of several states).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As we need to examine the parent, return false to request the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller to do the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iteration.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5334" title="access/transam/xact.c:5334">CleanupSubTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As above, but it's not dead yet, so abort first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5162" title="access/transam/xact.c:5162">AbortSubTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5334" title="access/transam/xact.c:5334">CleanupSubTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The current subtransaction is the target of a ROLLBACK TO<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * command.&nbsp; Abort and pop it, then start a new subtransaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with the same name.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; savepointLevel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* save name and keep Cleanup from freeing it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name = s-&gt;name;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;name = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; savepointLevel = s-&gt;savepointLevel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5162" title="access/transam/xact.c:5162">AbortSubTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5334" title="access/transam/xact.c:5334">CleanupSubTransaction</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4322" title="access/transam/xact.c:4322">DefineSavepoint</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;&nbsp; &nbsp; <span class="Comment">/* changed by <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;name = name;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;savepointLevel = savepointLevel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This is the same as TBLOCK_SUBBEGIN case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(s-&gt;blockState == TBLOCK_SUBBEGIN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5011" title="access/transam/xact.c:5011">StartSubTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_SUBINPROGRESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Same as above, but the subtransaction had already failed, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't need <a href="#L5162" title="access/transam/xact.c:5162">AbortSubTransaction</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_RESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; savepointLevel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* save name and keep Cleanup from freeing it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name = s-&gt;name;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;name = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; savepointLevel = s-&gt;savepointLevel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5334" title="access/transam/xact.c:5334">CleanupSubTransaction</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4322" title="access/transam/xact.c:4322">DefineSavepoint</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;&nbsp; &nbsp; <span class="Comment">/* changed by <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;name = name;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;savepointLevel = savepointLevel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This is the same as TBLOCK_SUBBEGIN case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(s-&gt;blockState == TBLOCK_SUBBEGIN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5011" title="access/transam/xact.c:5011">StartSubTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_SUBINPROGRESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done, no more iterations required */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L3387" title="access/transam/xact.c:3387">AbortCurrentTransaction</a> -- a wrapper function handling the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; loop over subtransactions to avoid potentially dangerous recursion in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3405" title="access/transam/xact.c:3405">AbortCurrentTransactionInternal</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3387">&#x200c;</a></span><span class="linkable">AbortCurrentTransaction</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Repeatedly call <a href="#L3405" title="access/transam/xact.c:3405">AbortCurrentTransactionInternal</a>() until all the work is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (!<a href="#L3405" title="access/transam/xact.c:3405">AbortCurrentTransactionInternal</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L3405" title="access/transam/xact.c:3405">AbortCurrentTransactionInternal</a> - a function doing an iteration of work<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; regarding handling the current transaction abort.&nbsp; In the case of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; subtransactions more than one iterations could be required.&nbsp; Returns<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; true when no more iterations required, false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3405">&#x200c;</a></span><span class="linkable">AbortCurrentTransactionInternal</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (s-&gt;blockState)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_DEFAULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;state == TRANS_DEFAULT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we are idle, so nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can get here after an error during transaction start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (state will be TRANS_START).&nbsp; Need to clean up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incompletely started transaction.&nbsp; First, adjust the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * low-level state to suppress warning message from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;state == TRANS_START)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;state = TRANS_INPROGRESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2945" title="access/transam/xact.c:2945">CleanupTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we aren't in a transaction block, we just do the basic abort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &amp; <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> transaction.&nbsp; For this purpose, we treat an implicit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction block as if it were a simple statement.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_STARTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_IMPLICIT_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2945" title="access/transam/xact.c:2945">CleanupTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are in TBLOCK_BEGIN it means something screwed up right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after reading &quot;BEGIN TRANSACTION&quot;.&nbsp; We assume that the user<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will interpret the error as meaning the BEGIN failed to get him<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * into a transaction block, so we should abort and return to idle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_BEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2945" title="access/transam/xact.c:2945">CleanupTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are somewhere in a transaction block and we've gotten a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * failure, so we abort the transaction and set up the persistent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ABORT state.&nbsp; We will stay in ABORT until we get a ROLLBACK.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PARALLEL_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_ABORT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L2945" title="access/transam/xact.c:2945">CleanupTransaction</a> happens when we exit TBLOCK_ABORT_END */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here, we failed while trying to COMMIT.&nbsp; Clean up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction and return to idle state (we do not want to stay in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the transaction).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2945" title="access/transam/xact.c:2945">CleanupTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here, we are already in an aborted transaction state and are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for a ROLLBACK, but for some reason we failed again! So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we just remain in the abort state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are in a failed transaction and we got the ROLLBACK command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have already aborted, we just need to <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> and go to idle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2945" title="access/transam/xact.c:2945">CleanupTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are in a live transaction and we got a ROLLBACK command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Abort, <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>, go to idle state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2945" title="access/transam/xact.c:2945">CleanupTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here, we failed while trying to PREPARE.&nbsp; Clean up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction and return to idle state (we do not want to stay in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the transaction).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2945" title="access/transam/xact.c:2945">CleanupTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We got an error inside a subtransaction.&nbsp; Abort just the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subtransaction, and go to the persistent SUBABORT state until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we get ROLLBACK.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBINPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5162" title="access/transam/xact.c:5162">AbortSubTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_SUBABORT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we failed while trying to create a subtransaction, clean up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the broken subtransaction and abort the parent.&nbsp; The same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * applies if we get a failure while ending a subtransaction.&nbsp; As<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we need to abort the parent, return false to request the caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to do the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iteration.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBBEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRELEASE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBCOMMIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5162" title="access/transam/xact.c:5162">AbortSubTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5334" title="access/transam/xact.c:5334">CleanupSubTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Same as above, except the Abort() was already done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_RESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5334" title="access/transam/xact.c:5334">CleanupSubTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done, no more iterations required */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L3584" title="access/transam/xact.c:3584">PreventInTransactionBlock</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This routine is to be called by statements that must not run inside<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; a transaction block, typically because they have non-rollback-able<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; side effects or do <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> commits.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If this routine completes successfully, then the calling statement is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; guaranteed that if it completes without error, its results will be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; committed immediately.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If we have already started a transaction block, issue an error; also issue<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; an error if we appear to be running inside a user-defined function (which<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; could issue more commands and possibly cause a failure after the statement<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; completes).&nbsp; Subtransactions are verboten too.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We must also set XACT_FLAGS_NEEDIMMEDIATECOMMIT in <a href="#L134" title="access/transam/xact.c:134">MyXactFlags</a>, to ensure<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; that postgres.c follows through by committing after the statement is done.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; isTopLevel: passed down from <a href="../../tcop/utility.c.html#L499" title="tcop/utility.c:499">ProcessUtility</a> to determine whether we are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; inside a function.&nbsp; (We will always fail if this is false, but it's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; convenient to centralize the check here instead of making callers do it.)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; stmtType: statement type name, for error messages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3584">&#x200c;</a></span><span class="linkable">PreventInTransactionBlock</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isTopLevel, <span class="Type">const</span> <span class="Type">char</span> *stmtType)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xact block already started?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4915" title="access/transam/xact.c:4915">IsTransactionBlock</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ACTIVE_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s represents an SQL statement name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> cannot run inside a transaction block&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmtType)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtransaction?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4988" title="access/transam/xact.c:4988">IsSubTransaction</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ACTIVE_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s represents an SQL statement name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> cannot run inside a subtransaction&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmtType)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inside a pipeline that has started an implicit transaction?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L134" title="access/transam/xact.c:134">MyXactFlags</a> &amp; XACT_FLAGS_PIPELINING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ACTIVE_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s represents an SQL statement name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> cannot be executed within a pipeline&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmtType)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inside a function call?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isTopLevel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ACTIVE_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s represents an SQL statement name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> cannot be executed from a function&quot;</span>, stmtType)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we got past <a href="#L4915" title="access/transam/xact.c:4915">IsTransactionBlock</a> test, should be in default state */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>-&gt;blockState != TBLOCK_DEFAULT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>-&gt;blockState != TBLOCK_STARTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;cannot prevent transaction chain&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All okay.&nbsp; Set the flag to make sure the right thing happens later. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L134" title="access/transam/xact.c:134">MyXactFlags</a> |= XACT_FLAGS_NEEDIMMEDIATECOMMIT;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L3656" title="access/transam/xact.c:3656">WarnNoTransactionBlock</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L3662" title="access/transam/xact.c:3662">RequireTransactionBlock</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; These two <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> allow for warnings or errors if a command is executed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; outside of a transaction block.&nbsp; This is useful for commands that have no<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; effects that persist past transaction end (and so calling them outside a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; transaction block is presumably an error).&nbsp; DECLARE CURSOR is an example.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; While top-level transaction control commands (BEGIN/COMMIT/ABORT) and <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; that have no effect issue warnings, all other no-effect commands generate<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; errors.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If we appear to be running inside a user-defined function, we do not<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; issue anything, since the function could issue more commands that make<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; use of the current statement's results.&nbsp; Likewise subtransactions.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Thus these are inverses for <a href="#L3584" title="access/transam/xact.c:3584">PreventInTransactionBlock</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; isTopLevel: passed down from <a href="../../tcop/utility.c.html#L499" title="tcop/utility.c:499">ProcessUtility</a> to determine whether we are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; inside a function.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; stmtType: statement type name, for warning or error messages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3656">&#x200c;</a></span><span class="linkable">WarnNoTransactionBlock</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isTopLevel, <span class="Type">const</span> <span class="Type">char</span> *stmtType)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L3671" title="access/transam/xact.c:3671">CheckTransactionBlock</a>(isTopLevel, <span class="Constant">false</span>, stmtType);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L3662">&#x200c;</a></span><span class="linkable">RequireTransactionBlock</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isTopLevel, <span class="Type">const</span> <span class="Type">char</span> *stmtType)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L3671" title="access/transam/xact.c:3671">CheckTransactionBlock</a>(isTopLevel, <span class="Constant">true</span>, stmtType);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This is the implementation of the above two.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3671">&#x200c;</a></span><span class="linkable">CheckTransactionBlock</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isTopLevel, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> throwError, <span class="Type">const</span> <span class="Type">char</span> *stmtType)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xact block already started?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4915" title="access/transam/xact.c:4915">IsTransactionBlock</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtransaction?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4988" title="access/transam/xact.c:4988">IsSubTransaction</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inside a function call?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isTopLevel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(throwError ? ERROR : WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NO_ACTIVE_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* translator: %s represents an SQL statement name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> can only be used in transaction blocks&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmtType)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L3715" title="access/transam/xact.c:3715">IsInTransactionBlock</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This routine is for statements that need to behave differently inside<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; a transaction block than when running as single commands.&nbsp; ANALYZE is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; currently the only example.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If this routine returns &quot;false&quot;, then the calling statement is allowed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to perform <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> transaction-commit-and-start cycles; there is not a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; risk of messing up <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transaction already in progress.&nbsp; (Note that this<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; is not the identical guarantee provided by <a href="#L3584" title="access/transam/xact.c:3584">PreventInTransactionBlock</a>,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; since we will not force a post-statement commit.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; isTopLevel: passed down from <a href="../../tcop/utility.c.html#L499" title="tcop/utility.c:499">ProcessUtility</a> to determine whether we are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; inside a function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3715">&#x200c;</a></span><span class="linkable">IsInTransactionBlock</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isTopLevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return true on same conditions that would make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L3584" title="access/transam/xact.c:3584">PreventInTransactionBlock</a> error out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4915" title="access/transam/xact.c:4915">IsTransactionBlock</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4988" title="access/transam/xact.c:4988">IsSubTransaction</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L134" title="access/transam/xact.c:134">MyXactFlags</a> &amp; XACT_FLAGS_PIPELINING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isTopLevel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>-&gt;blockState != TBLOCK_DEFAULT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>-&gt;blockState != TBLOCK_STARTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Register or deregister callback <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for start- and end-of-xact<br/></li>
<li></span><span class="Comment"> * operations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are intended for use by dynamically loaded modules.<br/></li>
<li></span><span class="Comment"> * For built-in modules we generally just hardwire the appropriate calls<br/></li>
<li></span><span class="Comment"> * (mainly because it's easier to control the order that way, where needed).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At transaction end, the callback occurs post-commit or post-abort, so the<br/></li>
<li></span><span class="Comment"> * callback <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> can only do noncritical <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3753">&#x200c;</a></span><span class="linkable">RegisterXactCallback</span>(XactCallback callback, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L305" title="access/transam/xact.c:305">XactCallbackItem</a> *item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; item = (<a href="#L305" title="access/transam/xact.c:305">XactCallbackItem</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L305" title="access/transam/xact.c:305">XactCallbackItem</a>));<br/></li>
<li>&nbsp; &nbsp; item-&gt;callback = callback;<br/></li>
<li>&nbsp; &nbsp; item-&gt;arg = arg;<br/></li>
<li>&nbsp; &nbsp; item-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <a href="#L312" title="access/transam/xact.c:312">Xact_callbacks</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L312" title="access/transam/xact.c:312">Xact_callbacks</a> = item;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L3766">&#x200c;</a></span><span class="linkable">UnregisterXactCallback</span>(XactCallback callback, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L305" title="access/transam/xact.c:305">XactCallbackItem</a> *item;<br/></li>
<li>&nbsp; &nbsp; <a href="#L305" title="access/transam/xact.c:305">XactCallbackItem</a> *prev;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; prev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (item = <a href="#L312" title="access/transam/xact.c:312">Xact_callbacks</a>; item; prev = item, item = item-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item-&gt;callback == callback &amp;&amp; item-&gt;arg == arg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prev)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = item-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="access/transam/xact.c:312">Xact_callbacks</a> = item-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3787">&#x200c;</a></span><span class="linkable">CallXactCallbacks</span>(XactEvent event)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L305" title="access/transam/xact.c:305">XactCallbackItem</a> *item;<br/></li>
<li>&nbsp; &nbsp; <a href="#L305" title="access/transam/xact.c:305">XactCallbackItem</a> *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (item = <a href="#L312" title="access/transam/xact.c:312">Xact_callbacks</a>; item; item = <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allow callbacks to unregister themselves when called */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = item-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item-&gt;callback(event, item-&gt;arg);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Register or deregister callback <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for start- and end-of-subxact<br/></li>
<li></span><span class="Comment"> * operations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Pretty much same as above, but for subtransaction events.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At subtransaction end, the callback occurs post-subcommit or post-subabort,<br/></li>
<li></span><span class="Comment"> * so the callback <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> can only do noncritical <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.&nbsp; At<br/></li>
<li></span><span class="Comment"> * subtransaction start, the callback is called when the subtransaction has<br/></li>
<li></span><span class="Comment"> * finished initializing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3813">&#x200c;</a></span><span class="linkable">RegisterSubXactCallback</span>(SubXactCallback callback, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L317" title="access/transam/xact.c:317">SubXactCallbackItem</a> *item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; item = (<a href="#L317" title="access/transam/xact.c:317">SubXactCallbackItem</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L317" title="access/transam/xact.c:317">SubXactCallbackItem</a>));<br/></li>
<li>&nbsp; &nbsp; item-&gt;callback = callback;<br/></li>
<li>&nbsp; &nbsp; item-&gt;arg = arg;<br/></li>
<li>&nbsp; &nbsp; item-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <a href="#L324" title="access/transam/xact.c:324">SubXact_callbacks</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L324" title="access/transam/xact.c:324">SubXact_callbacks</a> = item;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L3826">&#x200c;</a></span><span class="linkable">UnregisterSubXactCallback</span>(SubXactCallback callback, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L317" title="access/transam/xact.c:317">SubXactCallbackItem</a> *item;<br/></li>
<li>&nbsp; &nbsp; <a href="#L317" title="access/transam/xact.c:317">SubXactCallbackItem</a> *prev;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; prev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (item = <a href="#L324" title="access/transam/xact.c:324">SubXact_callbacks</a>; item; prev = item, item = item-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item-&gt;callback == callback &amp;&amp; item-&gt;arg == arg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prev)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = item-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L324" title="access/transam/xact.c:324">SubXact_callbacks</a> = item-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3847">&#x200c;</a></span><span class="linkable">CallSubXactCallbacks</span>(SubXactEvent event,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SubTransactionId mySubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SubTransactionId parentSubid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L317" title="access/transam/xact.c:317">SubXactCallbackItem</a> *item;<br/></li>
<li>&nbsp; &nbsp; <a href="#L317" title="access/transam/xact.c:317">SubXactCallbackItem</a> *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (item = <a href="#L324" title="access/transam/xact.c:324">SubXact_callbacks</a>; item; item = <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allow callbacks to unregister themselves when called */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = item-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item-&gt;callback(event, mySubid, parentSubid, item-&gt;arg);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; transaction block support<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L3873" title="access/transam/xact.c:3873">BeginTransactionBlock</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This executes a BEGIN command.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3873">&#x200c;</a></span><span class="linkable">BeginTransactionBlock</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (s-&gt;blockState)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are not inside a transaction block, so allow one to begin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_STARTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_BEGIN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * BEGIN converts an implicit transaction block to a regular one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Note that we allow this even if we've already done some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * commands, which is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> odd but matches historical practice.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_IMPLICIT_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_BEGIN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Already a transaction block in progress.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PARALLEL_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBINPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ACTIVE_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;there is already a transaction in progress&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* These cases are invalid. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_DEFAULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_BEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBBEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRELEASE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBCOMMIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_RESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L3873" title="access/transam/xact.c:3873">BeginTransactionBlock</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(s-&gt;blockState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L3941" title="access/transam/xact.c:3941">PrepareTransactionBlock</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This executes a PREPARE command.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since PREPARE may actually do a ROLLBACK, the result indicates what<br/></li>
<li></span><span class="Comment"> * happened: true for PREPARE, false for ROLLBACK.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we don't actually do anything here except change blockState.<br/></li>
<li></span><span class="Comment"> * The real work will be done in the upcoming <a href="#L2460" title="access/transam/xact.c:2460">PrepareTransaction</a>().<br/></li>
<li></span><span class="Comment"> * We do it this way because it's not convenient to change memory context,<br/></li>
<li></span><span class="Comment"> * resource owner, etc while executing inside a Portal.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3941">&#x200c;</a></span><span class="linkable">PrepareTransactionBlock</span>(<span class="Type">const</span> <span class="Type">char</span> *gid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up to commit the current transaction */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L3993" title="access/transam/xact.c:3993">EndTransactionBlock</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If successful, change outer tblock state to PREPARE */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (s-&gt;parent != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = s-&gt;parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;blockState == TBLOCK_END)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Save GID where <a href="#L2460" title="access/transam/xact.c:2460">PrepareTransaction</a> can <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L285" title="access/transam/xact.c:285">prepareGID</a> = <a href="../../utils/mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>, gid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_PREPARE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ignore case where we are not in a transaction;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3993" title="access/transam/xact.c:3993">EndTransactionBlock</a> already issued a warning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(s-&gt;blockState == TBLOCK_STARTED ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;blockState == TBLOCK_IMPLICIT_INPROGRESS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> back a PREPARE result tag... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L3993" title="access/transam/xact.c:3993">EndTransactionBlock</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This executes a COMMIT command.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since COMMIT may actually do a ROLLBACK, the result indicates what<br/></li>
<li></span><span class="Comment"> * happened: true for COMMIT, false for ROLLBACK.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we don't actually do anything here except change blockState.<br/></li>
<li></span><span class="Comment"> * The real work will be done in the upcoming <a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>().<br/></li>
<li></span><span class="Comment"> * We do it this way because it's not convenient to change memory context,<br/></li>
<li></span><span class="Comment"> * resource owner, etc while executing inside a Portal.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3993">&#x200c;</a></span><span class="linkable">EndTransactionBlock</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> chain)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (s-&gt;blockState)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are in a transaction block, so tell <a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to COMMIT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_END;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are in an implicit transaction block.&nbsp; If AND CHAIN was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * specified, error.&nbsp; Otherwise commit, but issue a warning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because there was no explicit BEGIN <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_IMPLICIT_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NO_ACTIVE_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s represents an SQL statement name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> can only be used in transaction blocks&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;COMMIT AND CHAIN&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NO_ACTIVE_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;there is no transaction in progress&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_END;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are in a failed transaction block.&nbsp; Tell<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a> it's time to exit the block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_ABORT_END;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are in a live subtransaction block.&nbsp; Set up to subcommit all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * open subtransactions and then commit the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBINPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (s-&gt;parent != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;blockState == TBLOCK_SUBINPROGRESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_SUBCOMMIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L3993" title="access/transam/xact.c:3993">EndTransactionBlock</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(s-&gt;blockState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = s-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;blockState == TBLOCK_INPROGRESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_END;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L3993" title="access/transam/xact.c:3993">EndTransactionBlock</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(s-&gt;blockState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here we are inside an aborted subtransaction.&nbsp; Treat the COMMIT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as ROLLBACK: set up to abort everything and exit the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (s-&gt;parent != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;blockState == TBLOCK_SUBINPROGRESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_SUBABORT_PENDING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (s-&gt;blockState == TBLOCK_SUBABORT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_SUBABORT_END;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L3993" title="access/transam/xact.c:3993">EndTransactionBlock</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(s-&gt;blockState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = s-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;blockState == TBLOCK_INPROGRESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_ABORT_PENDING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (s-&gt;blockState == TBLOCK_ABORT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_ABORT_END;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L3993" title="access/transam/xact.c:3993">EndTransactionBlock</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(s-&gt;blockState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The user issued COMMIT when not inside a transaction.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * COMMIT without CHAIN, issue a WARNING, staying in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TBLOCK_STARTED state.&nbsp; The upcoming call to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>() will then close the transaction and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * put us back into the default state.&nbsp; For COMMIT AND CHAIN,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_STARTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NO_ACTIVE_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s represents an SQL statement name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> can only be used in transaction blocks&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;COMMIT AND CHAIN&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NO_ACTIVE_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;there is no transaction in progress&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The user issued a COMMIT that somehow ran inside a parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worker.&nbsp; We can't cope with that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PARALLEL_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TRANSACTION_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot commit during a parallel operation&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* These cases are invalid. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_DEFAULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_BEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBBEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRELEASE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBCOMMIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_RESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L3993" title="access/transam/xact.c:3993">EndTransactionBlock</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(s-&gt;blockState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(s-&gt;blockState == TBLOCK_STARTED ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;blockState == TBLOCK_END ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;blockState == TBLOCK_ABORT_END ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;blockState == TBLOCK_ABORT_PENDING);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s-&gt;chain = chain;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L4153" title="access/transam/xact.c:4153">UserAbortTransactionBlock</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This executes a ROLLBACK command.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, we don't actually do anything here except change blockState.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4153">&#x200c;</a></span><span class="linkable">UserAbortTransactionBlock</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> chain)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (s-&gt;blockState)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are inside a transaction block and we got a ROLLBACK command<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from the user, so tell <a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a> to abort and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exit the transaction block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_ABORT_PENDING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are inside a failed transaction block and we got a ROLLBACK<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * command from the user.&nbsp; Abort processing is already done, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a> just has to <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> and go back to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * idle state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_ABORT_END;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are inside a subtransaction.&nbsp; Mark everything up to top<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * level as exitable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBINPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (s-&gt;parent != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;blockState == TBLOCK_SUBINPROGRESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_SUBABORT_PENDING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (s-&gt;blockState == TBLOCK_SUBABORT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_SUBABORT_END;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L4153" title="access/transam/xact.c:4153">UserAbortTransactionBlock</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(s-&gt;blockState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = s-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;blockState == TBLOCK_INPROGRESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_ABORT_PENDING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (s-&gt;blockState == TBLOCK_ABORT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_ABORT_END;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L4153" title="access/transam/xact.c:4153">UserAbortTransactionBlock</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(s-&gt;blockState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The user issued ABORT when not inside a transaction.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ROLLBACK without CHAIN, issue a WARNING and go to abort state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The upcoming call to <a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>() will then put<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * us back into the default state.&nbsp; For ROLLBACK AND CHAIN, error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We do the same thing with ABORT inside an implicit transaction,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * although in this case we might be rolling back actual database<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * state changes.&nbsp; (It's debatable whether we should issue a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WARNING in this case, but we have done so historically.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_STARTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_IMPLICIT_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NO_ACTIVE_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s represents an SQL statement name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> can only be used in transaction blocks&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;ROLLBACK AND CHAIN&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NO_ACTIVE_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;there is no transaction in progress&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_ABORT_PENDING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The user issued an ABORT that somehow ran inside a parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worker.&nbsp; We can't cope with that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PARALLEL_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TRANSACTION_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot abort during a parallel operation&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* These cases are invalid. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_DEFAULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_BEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBBEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRELEASE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBCOMMIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_RESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L4153" title="access/transam/xact.c:4153">UserAbortTransactionBlock</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(s-&gt;blockState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(s-&gt;blockState == TBLOCK_ABORT_END ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;blockState == TBLOCK_ABORT_PENDING);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s-&gt;chain = chain;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4275" title="access/transam/xact.c:4275">BeginImplicitTransactionBlock</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Start an implicit transaction block if we're not already in one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike <a href="#L3873" title="access/transam/xact.c:3873">BeginTransactionBlock</a>, this is called directly from the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop<br/></li>
<li></span><span class="Comment"> * in postgres.c, not within a Portal.&nbsp; So we can just change blockState<br/></li>
<li></span><span class="Comment"> * without a lot of ceremony.&nbsp; We do not expect caller to do<br/></li>
<li></span><span class="Comment"> * <a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>/<a href="#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4275">&#x200c;</a></span><span class="linkable">BeginImplicitTransactionBlock</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are in STARTED state (that is, no transaction block is open),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * switch to IMPLICIT_INPROGRESS state, creating an implicit transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For caller convenience, we consider all other transaction states as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * legal here; otherwise the caller would need its own state check, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seems rather pointless.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;blockState == TBLOCK_STARTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_IMPLICIT_INPROGRESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4300" title="access/transam/xact.c:4300">EndImplicitTransactionBlock</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; End an implicit transaction block, if we're in one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Like <a href="#L3993" title="access/transam/xact.c:3993">EndTransactionBlock</a>, we just make <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> needed blockState change here.<br/></li>
<li></span><span class="Comment"> * The real work will be done in the upcoming <a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4300">&#x200c;</a></span><span class="linkable">EndImplicitTransactionBlock</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are in IMPLICIT_INPROGRESS state, switch back to STARTED state,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allowing <a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a> to commit whatever happened during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the implicit transaction block as though it were a single statement.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For caller convenience, we consider all other transaction states as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * legal here; otherwise the caller would need its own state check, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seems rather pointless.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;blockState == TBLOCK_IMPLICIT_INPROGRESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_STARTED;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4322" title="access/transam/xact.c:4322">DefineSavepoint</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This executes a SAVEPOINT command.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4322">&#x200c;</a></span><span class="linkable">DefineSavepoint</span>(<span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Workers synchronize transaction state at the beginning of each parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operation, so we can't account for new subtransactions after that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point.&nbsp; (Note that this check will certainly error out if s-&gt;blockState<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is TBLOCK_PARALLEL_INPROGRESS, so we can treat that as an invalid case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * below.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>() || IsParallelWorker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TRANSACTION_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot define savepoints during a parallel operation&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (s-&gt;blockState)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBINPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Normal subtransaction start */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5367" title="access/transam/xact.c:5367">PushTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;&nbsp; &nbsp; <span class="Comment">/* changed by <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Savepoint names, like the <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> block itself, live<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in <a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;name = <a href="../../utils/mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>, name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We disallow savepoint commands in implicit transaction blocks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There would be no great difficulty in allowing them so far as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this module is concerned, but a savepoint seems inconsistent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with <a href="../../tcop/postgres.c.html#L1013" title="tcop/postgres.c:1013">exec_simple_query</a>'s behavior of abandoning the whole query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * string upon error.&nbsp; Also, the point of an implicit transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * block (as opposed to a regular one) is to automatically close<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after an error, so it's hard to see how a savepoint would fit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * into that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The error messages for this are phrased as if there were no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * active transaction block at all, which is historical but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * perhaps could be improved.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_IMPLICIT_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NO_ACTIVE_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s represents an SQL statement name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> can only be used in transaction blocks&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;SAVEPOINT&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* These cases are invalid. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_DEFAULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_STARTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_BEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PARALLEL_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBBEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRELEASE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBCOMMIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_RESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L4322" title="access/transam/xact.c:4322">DefineSavepoint</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(s-&gt;blockState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4407" title="access/transam/xact.c:4407">ReleaseSavepoint</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This executes a RELEASE command.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, we don't actually do anything here except change blockState.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4407">&#x200c;</a></span><span class="linkable">ReleaseSavepoint</span>(<span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Workers synchronize transaction state at the beginning of each parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operation, so we can't account for transaction state change after that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point.&nbsp; (Note that this check will certainly error out if s-&gt;blockState<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is TBLOCK_PARALLEL_INPROGRESS, so we can treat that as an invalid case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * below.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>() || IsParallelWorker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TRANSACTION_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot release savepoints during a parallel operation&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (s-&gt;blockState)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't release a savepoint if there is no savepoint defined.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_S_E_INVALID_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;savepoint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_IMPLICIT_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See comment about implicit transactions in <a href="#L4322" title="access/transam/xact.c:4322">DefineSavepoint</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NO_ACTIVE_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s represents an SQL statement name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> can only be used in transaction blocks&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;RELEASE SAVEPOINT&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are in a non-aborted subtransaction.&nbsp; This is the only valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBINPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* These cases are invalid. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_DEFAULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_STARTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_BEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PARALLEL_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBBEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRELEASE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBCOMMIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_RESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L4407" title="access/transam/xact.c:4407">ReleaseSavepoint</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(s-&gt;blockState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (target = s; PointerIsValid(target); target = target-&gt;parent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PointerIsValid(target-&gt;name) &amp;&amp; strcmp(target-&gt;name, name) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PointerIsValid(target))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_S_E_INVALID_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;savepoint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* disallow crossing savepoint level boundaries */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (target-&gt;savepointLevel != s-&gt;savepointLevel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_S_E_INVALID_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;savepoint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist within current savepoint level&quot;</span>, name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark &quot;commit pending&quot; all subtransactions up to the target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtransaction.&nbsp; The actual commits will happen when control gets to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; xact = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(xact-&gt;blockState == TBLOCK_SUBINPROGRESS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xact-&gt;blockState = TBLOCK_SUBRELEASE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xact == target)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xact = xact-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(PointerIsValid(xact));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4516" title="access/transam/xact.c:4516">RollbackToSavepoint</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This executes a ROLLBACK TO &lt;savepoint&gt; command.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, we don't actually do anything here except change blockState.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4516">&#x200c;</a></span><span class="linkable">RollbackToSavepoint</span>(<span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Workers synchronize transaction state at the beginning of each parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operation, so we can't account for transaction state change after that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point.&nbsp; (Note that this check will certainly error out if s-&gt;blockState<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is TBLOCK_PARALLEL_INPROGRESS, so we can treat that as an invalid case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * below.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>() || IsParallelWorker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TRANSACTION_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot rollback to savepoints during a parallel operation&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (s-&gt;blockState)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't rollback to a savepoint if there is no savepoint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * defined.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_S_E_INVALID_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;savepoint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_IMPLICIT_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See comment about implicit transactions in <a href="#L4322" title="access/transam/xact.c:4322">DefineSavepoint</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NO_ACTIVE_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s represents an SQL statement name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> can only be used in transaction blocks&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;ROLLBACK TO SAVEPOINT&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is at least one savepoint, so proceed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBINPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* These cases are invalid. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_DEFAULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_STARTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_BEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PARALLEL_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBBEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRELEASE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBCOMMIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_RESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L4516" title="access/transam/xact.c:4516">RollbackToSavepoint</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(s-&gt;blockState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (target = s; PointerIsValid(target); target = target-&gt;parent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PointerIsValid(target-&gt;name) &amp;&amp; strcmp(target-&gt;name, name) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PointerIsValid(target))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_S_E_INVALID_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;savepoint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* disallow crossing savepoint level boundaries */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (target-&gt;savepointLevel != s-&gt;savepointLevel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_S_E_INVALID_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;savepoint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist within current savepoint level&quot;</span>, name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark &quot;abort pending&quot; all subtransactions up to the target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtransaction.&nbsp; The actual aborts will happen when control gets to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; xact = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xact == target)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xact-&gt;blockState == TBLOCK_SUBINPROGRESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xact-&gt;blockState = TBLOCK_SUBABORT_PENDING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (xact-&gt;blockState == TBLOCK_SUBABORT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xact-&gt;blockState = TBLOCK_SUBABORT_END;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L4516" title="access/transam/xact.c:4516">RollbackToSavepoint</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(xact-&gt;blockState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xact = xact-&gt;parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(PointerIsValid(xact));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And mark the target as &quot;restart pending&quot; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (xact-&gt;blockState == TBLOCK_SUBINPROGRESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xact-&gt;blockState = TBLOCK_SUBRESTART;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (xact-&gt;blockState == TBLOCK_SUBABORT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xact-&gt;blockState = TBLOCK_SUBABORT_RESTART;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L4516" title="access/transam/xact.c:4516">RollbackToSavepoint</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(xact-&gt;blockState));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4643" title="access/transam/xact.c:4643">BeginInternalSubTransaction</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is the same as <a href="#L4322" title="access/transam/xact.c:4322">DefineSavepoint</a> except it allows TBLOCK_STARTED,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; TBLOCK_IMPLICIT_INPROGRESS, TBLOCK_PARALLEL_INPROGRESS, TBLOCK_END,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and TBLOCK_PREPARE states, and therefore it can safely be used in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that might be called when not inside a BEGIN block or when<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; running deferred triggers at COMMIT/PREPARE time.&nbsp; Also, it<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; automatically does <a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>/<a href="#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; instead of expecting the caller to do it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4643">&#x200c;</a></span><span class="linkable">BeginInternalSubTransaction</span>(<span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; save_ExitOnAnyError = <a href="../../utils/init/globals.c.html#L120" title="utils/init/globals.c:120">ExitOnAnyError</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Errors within this function are improbable, but if one does happen we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * force a FATAL exit.&nbsp; Callers generally aren't prepared to handle losing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * control, and moreover our transaction state is probably corrupted if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fail partway through; so an ordinary ERROR longjmp isn't okay.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L120" title="utils/init/globals.c:120">ExitOnAnyError</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do not check for parallel mode here.&nbsp; It's permissible to start and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end &quot;<a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>&quot; subtransactions while in parallel mode, so long as no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new XIDs or command IDs are assigned.&nbsp; Enforcement of that occurs in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L632" title="access/transam/xact.c:632">AssignTransactionId</a>() and <a href="#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (s-&gt;blockState)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_STARTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_IMPLICIT_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PARALLEL_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBINPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Normal subtransaction start */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5367" title="access/transam/xact.c:5367">PushTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;&nbsp; &nbsp; <span class="Comment">/* changed by <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Savepoint names, like the <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> block itself, live<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in <a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;name = <a href="../../utils/mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>, name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* These cases are invalid. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_DEFAULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_BEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBBEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRELEASE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBCOMMIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_RESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L4643" title="access/transam/xact.c:4643">BeginInternalSubTransaction</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(s-&gt;blockState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L120" title="utils/init/globals.c:120">ExitOnAnyError</a> = save_ExitOnAnyError;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4717" title="access/transam/xact.c:4717">ReleaseCurrentSubTransaction</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * RELEASE (ie, commit) the innermost subtransaction, regardless of its<br/></li>
<li></span><span class="Comment"> * savepoint name (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).<br/></li>
<li></span><span class="Comment"> * NB: do NOT use <a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>/<a href="#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a> with this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4717">&#x200c;</a></span><span class="linkable">ReleaseCurrentSubTransaction</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do not check for parallel mode here.&nbsp; It's permissible to start and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end &quot;<a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>&quot; subtransactions while in parallel mode, so long as no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new XIDs or command IDs are assigned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;blockState != TBLOCK_SUBINPROGRESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L4717" title="access/transam/xact.c:4717">ReleaseCurrentSubTransaction</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(s-&gt;blockState));<br/></li>
<li>&nbsp; &nbsp; Assert(s-&gt;state == TRANS_INPROGRESS);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L5048" title="access/transam/xact.c:5048">CommitSubTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;&nbsp; &nbsp; <span class="Comment">/* changed by pop */<br/></li>
<li></span>&nbsp; &nbsp; Assert(s-&gt;state == TRANS_INPROGRESS);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4745" title="access/transam/xact.c:4745">RollbackAndReleaseCurrentSubTransaction</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ROLLBACK and RELEASE (ie, abort) the innermost subtransaction, regardless<br/></li>
<li></span><span class="Comment"> * of its savepoint name (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).<br/></li>
<li></span><span class="Comment"> * NB: do NOT use <a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>/<a href="#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a> with this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4745">&#x200c;</a></span><span class="linkable">RollbackAndReleaseCurrentSubTransaction</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do not check for parallel mode here.&nbsp; It's permissible to start and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end &quot;<a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>&quot; subtransactions while in parallel mode, so long as no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new XIDs or command IDs are assigned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (s-&gt;blockState)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be in a subtransaction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBINPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* These cases are invalid. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_DEFAULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_STARTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_BEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_IMPLICIT_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PARALLEL_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBBEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRELEASE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBCOMMIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_RESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L4745" title="access/transam/xact.c:4745">RollbackAndReleaseCurrentSubTransaction</a>: unexpected state </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(s-&gt;blockState));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Abort the current subtransaction, if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;blockState == TBLOCK_SUBINPROGRESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5162" title="access/transam/xact.c:5162">AbortSubTransaction</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And clean it up, too */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5334" title="access/transam/xact.c:5334">CleanupSubTransaction</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;&nbsp; &nbsp; <span class="Comment">/* changed by pop */<br/></li>
<li></span>&nbsp; &nbsp; Assert(s-&gt;blockState == TBLOCK_SUBINPROGRESS ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;blockState == TBLOCK_INPROGRESS ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;blockState == TBLOCK_IMPLICIT_INPROGRESS ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;blockState == TBLOCK_PARALLEL_INPROGRESS ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;blockState == TBLOCK_STARTED);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L4811" title="access/transam/xact.c:4811">AbortOutOfAnyTransaction</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This routine is provided for error recovery purposes.&nbsp; It aborts <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; active transaction or transaction block, leaving the system in a known<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; idle state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4811">&#x200c;</a></span><span class="linkable">AbortOutOfAnyTransaction</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure we're not running in a doomed memory context */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1853" title="access/transam/xact.c:1853">AtAbort_Memory</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get out of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transaction or nested transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (s-&gt;blockState)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_DEFAULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;state == TRANS_DEFAULT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not in a transaction, do nothing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can get here after an error during transaction start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (state will be TRANS_START).&nbsp; Need to clean up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incompletely started transaction.&nbsp; First, adjust the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * low-level state to suppress warning message from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;state == TRANS_START)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;state = TRANS_INPROGRESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2945" title="access/transam/xact.c:2945">CleanupTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_STARTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_BEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_IMPLICIT_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PARALLEL_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In a transaction, so clean up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2945" title="access/transam/xact.c:2945">CleanupTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_END:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a> is already done, still need Cleanup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, if we failed partway through running ROLLBACK,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there will be an active portal running that command, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we need to shut down <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing <a href="#L2945" title="access/transam/xact.c:2945">CleanupTransaction</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/portalmem.c.html#L781" title="utils/mmgr/portalmem.c:781">AtAbort_Portals</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2945" title="access/transam/xact.c:2945">CleanupTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;blockState = TBLOCK_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In a subtransaction, so clean it up and abort parent too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBBEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBINPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRELEASE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBCOMMIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5162" title="access/transam/xact.c:5162">AbortSubTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5334" title="access/transam/xact.c:5334">CleanupSubTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;&nbsp; &nbsp; <span class="Comment">/* changed by pop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_RESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As above, but <a href="#L5162" title="access/transam/xact.c:5162">AbortSubTransaction</a> already done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;curTransactionOwner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As in TBLOCK_ABORT, might have a live portal to zap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/portalmem.c.html#L979" title="utils/mmgr/portalmem.c:979">AtSubAbort_Portals</a>(s-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;parent-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;curTransactionOwner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;parent-&gt;curTransactionOwner);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5334" title="access/transam/xact.c:5334">CleanupSubTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;&nbsp; &nbsp; <span class="Comment">/* changed by pop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (s-&gt;blockState != TBLOCK_DEFAULT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should be out of all subxacts <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(s-&gt;parent == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we didn't actually have anything to do, revert to <a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1943" title="access/transam/xact.c:1943">AtCleanup_Memory</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4915" title="access/transam/xact.c:4915">IsTransactionBlock</a> --- are we within a transaction block?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4915">&#x200c;</a></span><span class="linkable">IsTransactionBlock</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;blockState == TBLOCK_DEFAULT || s-&gt;blockState == TBLOCK_STARTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4933" title="access/transam/xact.c:4933">IsTransactionOrTransactionBlock</a> --- are we within either a transaction<br/></li>
<li></span><span class="Comment"> * or a transaction block?&nbsp; &nbsp; (The backend is only really &quot;idle&quot; when this<br/></li>
<li></span><span class="Comment"> * returns false.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should match up with <a href="#L4915" title="access/transam/xact.c:4915">IsTransactionBlock</a> and <a href="#L384" title="access/transam/xact.c:384">IsTransactionState</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4933">&#x200c;</a></span><span class="linkable">IsTransactionOrTransactionBlock</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;blockState == TBLOCK_DEFAULT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4947" title="access/transam/xact.c:4947">TransactionBlockStatusCode</a> - return status code to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> in <a href="../../tcop/dest.c.html#L256" title="tcop/dest.c:256">ReadyForQuery</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char<br/></li>
<li><a id="L4947">&#x200c;</a></span><span class="linkable">TransactionBlockStatusCode</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (s-&gt;blockState)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_DEFAULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_STARTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">'I'</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* idle --- not in transaction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_BEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBBEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_IMPLICIT_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PARALLEL_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBINPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRELEASE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBCOMMIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">'T'</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in transaction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_RESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">'E'</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in failed transaction */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* should never get here */<br/></li>
<li></span>&nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;invalid transaction block state: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(s-&gt;blockState));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4988" title="access/transam/xact.c:4988">IsSubTransaction</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4988">&#x200c;</a></span><span class="linkable">IsSubTransaction</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;nestingLevel &gt;= <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5011" title="access/transam/xact.c:5011">StartSubTransaction</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If you're wondering why this is separate from <a href="#L5367" title="access/transam/xact.c:5367">PushTransaction</a>: it's because<br/></li>
<li></span><span class="Comment"> * we can't conveniently do this stuff right inside <a href="#L4322" title="access/transam/xact.c:4322">DefineSavepoint</a>.&nbsp; The<br/></li>
<li></span><span class="Comment"> * SAVEPOINT utility command will be executed inside a Portal, and if we<br/></li>
<li></span><span class="Comment"> * muck with <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> or <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> then exit from<br/></li>
<li></span><span class="Comment"> * the Portal will undo those settings.&nbsp; So we make <a href="#L4322" title="access/transam/xact.c:4322">DefineSavepoint</a> just<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> a dummy transaction block, and when control returns to the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment"> * idle loop, <a href="#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a> will be called, and we'll come here<br/></li>
<li></span><span class="Comment"> * to finish starting the subtransaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5011">&#x200c;</a></span><span class="linkable">StartSubTransaction</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;state != TRANS_DEFAULT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;<a href="#L5011" title="access/transam/xact.c:5011">StartSubTransaction</a> while in </span><span class="Special">%s</span><span class="Constant"> state&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5711" title="access/transam/xact.c:5711">TransStateAsString</a>(s-&gt;state));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s-&gt;state = TRANS_START;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize subsystems for new subtransaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> resource-management stuff first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1248" title="access/transam/xact.c:1248">AtSubStart_Memory</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L1272" title="access/transam/xact.c:1272">AtSubStart_ResourceOwner</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../commands/trigger.c.html#L5301" title="commands/trigger.c:5301">AfterTriggerBeginSubXact</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s-&gt;state = TRANS_INPROGRESS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call start-of-subxact callbacks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3847" title="access/transam/xact.c:3847">CallSubXactCallbacks</a>(SUBXACT_EVENT_START_SUB, s-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;parent-&gt;subTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5599" title="access/transam/xact.c:5599">ShowTransactionState</a>(<span class="Constant">&quot;<a href="#L5011" title="access/transam/xact.c:5011">StartSubTransaction</a>&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5048" title="access/transam/xact.c:5048">CommitSubTransaction</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The caller has to make sure to always reassign <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; if it has a local pointer to it after calling this function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5048">&#x200c;</a></span><span class="linkable">CommitSubTransaction</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5599" title="access/transam/xact.c:5599">ShowTransactionState</a>(<span class="Constant">&quot;<a href="#L5048" title="access/transam/xact.c:5048">CommitSubTransaction</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;state != TRANS_INPROGRESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;<a href="#L5048" title="access/transam/xact.c:5048">CommitSubTransaction</a> while in </span><span class="Special">%s</span><span class="Constant"> state&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5711" title="access/transam/xact.c:5711">TransStateAsString</a>(s-&gt;state));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pre-commit processing goes here */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L3847" title="access/transam/xact.c:3847">CallSubXactCallbacks</a>(SUBXACT_EVENT_PRE_COMMIT_SUB, s-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;parent-&gt;subTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this subxact has started <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unfinished parallel operation, clean up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its workers and exit parallel mode.&nbsp; Warn about leaked resources.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parallel.c.html#L1233" title="access/transam/parallel.c:1233">AtEOSubXact_Parallel</a>(<span class="Constant">true</span>, s-&gt;subTransactionId);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;parallelModeLevel != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;parallelModeLevel is </span><span class="Special">%d</span><span class="Constant"> not 0 at end of subtransaction&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;parallelModeLevel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;parallelModeLevel = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do the actual &quot;commit&quot;, such as it is */<br/></li>
<li></span>&nbsp; &nbsp; s-&gt;state = TRANS_COMMIT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must CCI to ensure commands of subtransaction are seen as done */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prior to 8.4 we marked subcommit in clog at this point.&nbsp; We <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * perform that step, if required, as part of the atomic update of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whole transaction tree at top level commit or abort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Post-commit <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (FullTransactionIdIsValid(s-&gt;fullTransactionId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1633" title="access/transam/xact.c:1633">AtSubCommit_childXids</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../commands/trigger.c.html#L5349" title="commands/trigger.c:5349">AfterTriggerEndSubXact</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/portalmem.c.html#L943" title="utils/mmgr/portalmem.c:943">AtSubCommit_Portals</a>(s-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;parent-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;parent-&gt;nestingLevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;parent-&gt;curTransactionOwner);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/be-fsstubs.c.html#L648" title="libpq/be-fsstubs.c:648">AtEOSubXact_LargeObject</a>(<span class="Constant">true</span>, s-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;parent-&gt;subTransactionId);<br/></li>
<li>&nbsp; &nbsp; <a href="../../commands/async.c.html#L1691" title="commands/async.c:1691">AtSubCommit_Notify</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3847" title="access/transam/xact.c:3847">CallSubXactCallbacks</a>(SUBXACT_EVENT_COMMIT_SUB, s-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;parent-&gt;subTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(s-&gt;curTransactionOwner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_BEFORE_LOCKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L3346" title="utils/cache/relcache.c:3346">AtEOSubXact_RelationCache</a>(<span class="Constant">true</span>, s-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;parent-&gt;subTransactionId);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1082" title="utils/cache/inval.c:1082">AtEOSubXact_Inval</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../catalog/storage.c.html#L914" title="catalog/storage.c:914">AtSubCommit_smgr</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The only lock we actually release here is the subtransaction XID lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = s-&gt;curTransactionOwner;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (FullTransactionIdIsValid(s-&gt;fullTransactionId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L643" title="storage/lmgr/lmgr.c:643">XactLockTableDelete</a>(XidFromFullTransactionId(s-&gt;fullTransactionId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Other locks should get transferred to their parent resource owner.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(s-&gt;curTransactionOwner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_LOCKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(s-&gt;curTransactionOwner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_AFTER_LOCKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L2264" title="utils/misc/guc.c:2264">AtEOXact_GUC</a>(<span class="Constant">true</span>, s-&gt;gucNestLevel);<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/spi.c.html#L482" title="executor/spi.c:482">AtEOSubXact_SPI</a>(<span class="Constant">true</span>, s-&gt;subTransactionId);<br/></li>
<li>&nbsp; &nbsp; <a href="../../commands/tablecmds.c.html#L18379" title="commands/tablecmds.c:18379">AtEOSubXact_on_commit_actions</a>(<span class="Constant">true</span>, s-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;parent-&gt;subTransactionId);<br/></li>
<li>&nbsp; &nbsp; <a href="../../catalog/namespace.c.html#L4543" title="catalog/namespace.c:4543">AtEOSubXact_Namespace</a>(<span class="Constant">true</span>, s-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;parent-&gt;subTransactionId);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L3132" title="storage/file/fd.c:3132">AtEOSubXact_Files</a>(<span class="Constant">true</span>, s-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;parent-&gt;subTransactionId);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1895" title="utils/hash/dynahash.c:1895">AtEOSubXact_HashTables</a>(<span class="Constant">true</span>, s-&gt;nestingLevel);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_xact.c.html#L112" title="utils/activity/pgstat_xact.c:112">AtEOSubXact_PgStat</a>(<span class="Constant">true</span>, s-&gt;nestingLevel);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L938" title="utils/time/snapmgr.c:938">AtSubCommit_Snapshot</a>(s-&gt;nestingLevel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to restore the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> transaction's read-only state, in case the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> is read-write while the child is read-only; GUC will incorrectly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * think it should leave the child state in place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L80" title="access/transam/xact.c:80">XactReadOnly</a> = s-&gt;prevXactReadOnly;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = s-&gt;parent-&gt;curTransactionOwner;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L166" title="utils/resowner/resowner.c:166">CurTransactionResourceOwner</a> = s-&gt;parent-&gt;curTransactionOwner;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L854" title="utils/resowner/resowner.c:854">ResourceOwnerDelete</a>(s-&gt;curTransactionOwner);<br/></li>
<li>&nbsp; &nbsp; s-&gt;curTransactionOwner = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1604" title="access/transam/xact.c:1604">AtSubCommit_Memory</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s-&gt;state = TRANS_DEFAULT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5429" title="access/transam/xact.c:5429">PopTransaction</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5162" title="access/transam/xact.c:5162">AbortSubTransaction</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5162">&#x200c;</a></span><span class="linkable">AbortSubTransaction</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prevent cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> interrupt while cleaning up */<br/></li>
<li></span>&nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we have a valid memory context and resource owner */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1873" title="access/transam/xact.c:1873">AtSubAbort_Memory</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L1898" title="access/transam/xact.c:1898">AtSubAbort_ResourceOwner</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LW locks we might be holding as quickly as possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Regular locks, however, must be held till we finish aborting.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Releasing LW locks is critical since we might try to grab them again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * while cleaning up!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">FIXME</span><span class="Comment"> This may be incorrect --- Are there some locks we should keep?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Buffer locks, for example?&nbsp; I don't think so but I'm not sure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1878" title="storage/lmgr/lwlock.c:1878">LWLockReleaseAll</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L151" title="utils/activity/backend_progress.c:151">pgstat_progress_end_command</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5057" title="storage/buffer/bufmgr.c:5057">UnlockBuffers</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset WAL record construction state */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xloginsert.c.html#L222" title="access/transam/xloginsert.c:222">XLogResetInsertion</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cancel condition variable sleep */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also clean up <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> open wait for lock, since the lock manager will choke<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we try to wait for another lock <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L730" title="storage/lmgr/proc.c:730">LockErrorCleanup</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> timeout events are still active, make sure the timeout interrupt<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is scheduled.&nbsp; This covers possible loss of a timeout interrupt due to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * longjmp'ing out of the SIGINT handler (see notes in <a href="../../utils/misc/timeout.c.html#L364" title="utils/misc/timeout.c:364">handle_sig_alarm</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We delay this till after <a href="../../storage/lmgr/proc.c.html#L730" title="storage/lmgr/proc.c:730">LockErrorCleanup</a> so that we don't uselessly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reschedule lock or deadlock check timeouts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/misc/timeout.c.html#L540" title="utils/misc/timeout.c:540">reschedule_timeouts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Re-enable signals, in case we got here by longjmp'ing out of a signal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handler.&nbsp; We do this fairly early in the sequence so that the timeout<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * infrastructure will be functional if needed while aborting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../../libpq/pqsignal.c.html#L22" title="libpq/pqsignal.c:22">UnBlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check the current transaction state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5599" title="access/transam/xact.c:5599">ShowTransactionState</a>(<span class="Constant">&quot;<a href="#L5162" title="access/transam/xact.c:5162">AbortSubTransaction</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;state != TRANS_INPROGRESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;<a href="#L5162" title="access/transam/xact.c:5162">AbortSubTransaction</a> while in </span><span class="Special">%s</span><span class="Constant"> state&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5711" title="access/transam/xact.c:5711">TransStateAsString</a>(s-&gt;state));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s-&gt;state = TRANS_ABORT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset user ID which might have been changed transiently.&nbsp; (See notes in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2749" title="access/transam/xact.c:2749">AbortTransaction</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(s-&gt;prevUser, s-&gt;prevSecContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Forget about <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> active REINDEX. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../catalog/index.c.html#L4149" title="catalog/index.c:4149">ResetReindexState</a>(s-&gt;nestingLevel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset logical streaming state. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../replication/logical/logical.c.html#L1921" title="replication/logical/logical.c:1921">ResetLogicalStreamingState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No need for <a href="../../replication/logical/snapbuild.c.html#L756" title="replication/logical/snapbuild.c:756">SnapBuildResetExportedSnapshotState</a>() here, snapshot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exports are not supported in subtransactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this subxact has started <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unfinished parallel operation, clean up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its workers and exit parallel mode.&nbsp; Don't warn about leaked resources.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parallel.c.html#L1233" title="access/transam/parallel.c:1233">AtEOSubXact_Parallel</a>(<span class="Constant">false</span>, s-&gt;subTransactionId);<br/></li>
<li>&nbsp; &nbsp; s-&gt;parallelModeLevel = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> all this stuff if the subxact failed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> creating a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ResourceOwner...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;curTransactionOwner)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/trigger.c.html#L5349" title="commands/trigger.c:5349">AfterTriggerEndSubXact</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/portalmem.c.html#L979" title="utils/mmgr/portalmem.c:979">AtSubAbort_Portals</a>(s-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;parent-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;curTransactionOwner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;parent-&gt;curTransactionOwner);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/be-fsstubs.c.html#L648" title="libpq/be-fsstubs.c:648">AtEOSubXact_LargeObject</a>(<span class="Constant">false</span>, s-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;parent-&gt;subTransactionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/async.c.html#L1761" title="commands/async.c:1761">AtSubAbort_Notify</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advertise the fact that we aborted in pg_xact. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1723" title="access/transam/xact.c:1723">RecordTransactionAbort</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Post-abort <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FullTransactionIdIsValid(s-&gt;fullTransactionId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1911" title="access/transam/xact.c:1911">AtSubAbort_childXids</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3847" title="access/transam/xact.c:3847">CallSubXactCallbacks</a>(SUBXACT_EVENT_ABORT_SUB, s-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;parent-&gt;subTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(s-&gt;curTransactionOwner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_BEFORE_LOCKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L3346" title="utils/cache/relcache.c:3346">AtEOSubXact_RelationCache</a>(<span class="Constant">false</span>, s-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;parent-&gt;subTransactionId);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/cache/inval.c.html#L1082" title="utils/cache/inval.c:1082">AtEOSubXact_Inval</a> sometimes needs to temporarily bump the refcount<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on the relcache entries that it processes.&nbsp; We cannot use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subtransaction's resource owner anymore, because we've already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * started releasing it.&nbsp; But we can use the parent resource owner.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = s-&gt;parent-&gt;curTransactionOwner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1082" title="utils/cache/inval.c:1082">AtEOSubXact_Inval</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = s-&gt;curTransactionOwner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(s-&gt;curTransactionOwner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_LOCKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L648" title="utils/resowner/resowner.c:648">ResourceOwnerRelease</a>(s-&gt;curTransactionOwner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RESOURCE_RELEASE_AFTER_LOCKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/storage.c.html#L934" title="catalog/storage.c:934">AtSubAbort_smgr</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L2264" title="utils/misc/guc.c:2264">AtEOXact_GUC</a>(<span class="Constant">false</span>, s-&gt;gucNestLevel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/spi.c.html#L482" title="executor/spi.c:482">AtEOSubXact_SPI</a>(<span class="Constant">false</span>, s-&gt;subTransactionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/tablecmds.c.html#L18379" title="commands/tablecmds.c:18379">AtEOSubXact_on_commit_actions</a>(<span class="Constant">false</span>, s-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;parent-&gt;subTransactionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/namespace.c.html#L4543" title="catalog/namespace.c:4543">AtEOSubXact_Namespace</a>(<span class="Constant">false</span>, s-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;parent-&gt;subTransactionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L3132" title="storage/file/fd.c:3132">AtEOSubXact_Files</a>(<span class="Constant">false</span>, s-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;parent-&gt;subTransactionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1895" title="utils/hash/dynahash.c:1895">AtEOSubXact_HashTables</a>(<span class="Constant">false</span>, s-&gt;nestingLevel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_xact.c.html#L112" title="utils/activity/pgstat_xact.c:112">AtEOSubXact_PgStat</a>(<span class="Constant">false</span>, s-&gt;nestingLevel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L959" title="utils/time/snapmgr.c:959">AtSubAbort_Snapshot</a>(s-&gt;nestingLevel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Restore the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> transaction's read-only state, too.&nbsp; This should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * redundant with GUC's <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> but we may as well do it for consistency<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with the commit case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L80" title="access/transam/xact.c:80">XactReadOnly</a> = s-&gt;prevXactReadOnly;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5334" title="access/transam/xact.c:5334">CleanupSubTransaction</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The caller has to make sure to always reassign <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; if it has a local pointer to it after calling this function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5334">&#x200c;</a></span><span class="linkable">CleanupSubTransaction</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5599" title="access/transam/xact.c:5599">ShowTransactionState</a>(<span class="Constant">&quot;<a href="#L5334" title="access/transam/xact.c:5334">CleanupSubTransaction</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;state != TRANS_ABORT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;<a href="#L5334" title="access/transam/xact.c:5334">CleanupSubTransaction</a> while in </span><span class="Special">%s</span><span class="Constant"> state&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5711" title="access/transam/xact.c:5711">TransStateAsString</a>(s-&gt;state));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/portalmem.c.html#L1092" title="utils/mmgr/portalmem.c:1092">AtSubCleanup_Portals</a>(s-&gt;subTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = s-&gt;parent-&gt;curTransactionOwner;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L166" title="utils/resowner/resowner.c:166">CurTransactionResourceOwner</a> = s-&gt;parent-&gt;curTransactionOwner;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;curTransactionOwner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L854" title="utils/resowner/resowner.c:854">ResourceOwnerDelete</a>(s-&gt;curTransactionOwner);<br/></li>
<li>&nbsp; &nbsp; s-&gt;curTransactionOwner = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1979" title="access/transam/xact.c:1979">AtSubCleanup_Memory</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s-&gt;state = TRANS_DEFAULT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5429" title="access/transam/xact.c:5429">PopTransaction</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5367" title="access/transam/xact.c:5367">PushTransaction</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create transaction state stack entry for a subtransaction<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The caller has to make sure to always reassign <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; if it has a local pointer to it after calling this function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5367">&#x200c;</a></span><span class="linkable">PushTransaction</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> p = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We keep subtransaction state nodes in <a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s = (<a href="#L218" title="access/transam/xact.c:218">TransactionState</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L191" title="access/transam/xact.c:191">TransactionStateData</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assign a subtransaction ID, watching out for counter wraparound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L263" title="access/transam/xact.c:263">currentSubTransactionId</a> += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L263" title="access/transam/xact.c:263">currentSubTransactionId</a> == InvalidSubTransactionId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L263" title="access/transam/xact.c:263">currentSubTransactionId</a> -= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot have more than 2^32-1 subtransactions in a transaction&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> stack a minimally valid subtransaction without fear of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * failure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; s-&gt;fullTransactionId = InvalidFullTransactionId;&nbsp; &nbsp; <span class="Comment">/* until assigned */<br/></li>
<li></span>&nbsp; &nbsp; s-&gt;subTransactionId = <a href="#L263" title="access/transam/xact.c:263">currentSubTransactionId</a>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;parent = p;<br/></li>
<li>&nbsp; &nbsp; s-&gt;nestingLevel = p-&gt;nestingLevel + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;gucNestLevel = <a href="../../utils/misc/guc.c.html#L2237" title="utils/misc/guc.c:2237">NewGUCNestLevel</a>();<br/></li>
<li>&nbsp; &nbsp; s-&gt;savepointLevel = p-&gt;savepointLevel;<br/></li>
<li>&nbsp; &nbsp; s-&gt;state = TRANS_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; s-&gt;blockState = TBLOCK_SUBBEGIN;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/miscinit.c.html#L635" title="utils/init/miscinit.c:635">GetUserIdAndSecContext</a>(&amp;s-&gt;prevUser, &amp;s-&gt;prevSecContext);<br/></li>
<li>&nbsp; &nbsp; s-&gt;prevXactReadOnly = <a href="#L80" title="access/transam/xact.c:80">XactReadOnly</a>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;startedInRecovery = p-&gt;startedInRecovery;<br/></li>
<li>&nbsp; &nbsp; s-&gt;parallelModeLevel = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; s-&gt;parallelChildXact = (p-&gt;parallelModeLevel != <span class="Constant">0</span> || p-&gt;parallelChildXact);<br/></li>
<li>&nbsp; &nbsp; s-&gt;topXidLogged = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a> = s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L5162" title="access/transam/xact.c:5162">AbortSubTransaction</a> and <a href="#L5334" title="access/transam/xact.c:5334">CleanupSubTransaction</a> have to be able to cope<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with the subtransaction from here on out; in particular they should not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume that it necessarily has a transaction context, resource owner,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or XID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5429" title="access/transam/xact.c:5429">PopTransaction</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Pop back to parent transaction state<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The caller has to make sure to always reassign <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; if it has a local pointer to it after calling this function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5429">&#x200c;</a></span><span class="linkable">PopTransaction</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;state != TRANS_DEFAULT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;<a href="#L5429" title="access/transam/xact.c:5429">PopTransaction</a> while in </span><span class="Special">%s</span><span class="Constant"> state&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5711" title="access/transam/xact.c:5711">TransStateAsString</a>(s-&gt;state));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;parent == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;<a href="#L5429" title="access/transam/xact.c:5429">PopTransaction</a> with no parent&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a> = s-&gt;parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Let's just make sure <a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a> is good */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a> = s-&gt;parent-&gt;curTransactionContext;<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L155" title="utils/mmgr/mcxt.c:155">CurTransactionContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ditto for ResourceOwner links */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L166" title="utils/resowner/resowner.c:166">CurTransactionResourceOwner</a> = s-&gt;parent-&gt;curTransactionOwner;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = s-&gt;parent-&gt;curTransactionOwner;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Free the old child structure */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(s-&gt;name);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(s);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5463" title="access/transam/xact.c:5463">EstimateTransactionStateSpace</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Estimate the amount of space that will be needed by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5491" title="access/transam/xact.c:5491">SerializeTransactionState</a>.&nbsp; It would be OK to overestimate slightly,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; but it's simple for us to work out the precise value, so we do.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L5463">&#x200c;</a><span class="linkable">EstimateTransactionStateSpace</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nxids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size = <a href="#L236" title="access/transam/xact.c:236">SerializedTransactionStateHeaderSize</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>; s != <span class="Constant">NULL</span>; s = s-&gt;parent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FullTransactionIdIsValid(s-&gt;fullTransactionId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nxids = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(nxids, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nxids = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(nxids, s-&gt;nChildXids);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId), nxids));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5491" title="access/transam/xact.c:5491">SerializeTransactionState</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Write out relevant details of our transaction state that will be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; needed by a parallel worker.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We need to save and restore <a href="#L83" title="access/transam/xact.c:83">XactDeferrable</a>, <a href="#L77" title="access/transam/xact.c:77">XactIsoLevel</a>, and the XIDs<br/></li>
<li></span><span class="Comment"> * associated with this transaction.&nbsp; These are serialized into a<br/></li>
<li></span><span class="Comment"> * caller-supplied buffer big enough to hold the number of bytes reported by<br/></li>
<li></span><span class="Comment"> * <a href="#L5463" title="access/transam/xact.c:5463">EstimateTransactionStateSpace</a>().&nbsp; We emit the XIDs in sorted order for the<br/></li>
<li></span><span class="Comment"> * convenience of the receiving process.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5491">&#x200c;</a></span><span class="linkable">SerializeTransactionState</span>(Size maxsize, <span class="Type">char</span> *start_address)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nxids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; TransactionId *workspace;<br/></li>
<li>&nbsp; &nbsp; <a href="#L224" title="access/transam/xact.c:224">SerializedTransactionState</a> *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (<a href="#L224" title="access/transam/xact.c:224">SerializedTransactionState</a> *) start_address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;xactIsoLevel = <a href="#L77" title="access/transam/xact.c:77">XactIsoLevel</a>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;xactDeferrable = <a href="#L83" title="access/transam/xact.c:83">XactDeferrable</a>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;topFullTransactionId = <a href="#L123" title="access/transam/xact.c:123">XactTopFullTransactionId</a>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;currentFullTransactionId =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>-&gt;fullTransactionId;<br/></li>
<li>&nbsp; &nbsp; result-&gt;<a href="#L264" title="access/transam/xact.c:264">currentCommandId</a> = <a href="#L264" title="access/transam/xact.c:264">currentCommandId</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're running in a parallel worker and launching a parallel worker<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of our own, we can just pass along the information that was passed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L124" title="access/transam/xact.c:124">nParallelCurrentXids</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;<a href="#L124" title="access/transam/xact.c:124">nParallelCurrentXids</a> = <a href="#L124" title="access/transam/xact.c:124">nParallelCurrentXids</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;result-&gt;parallelCurrentXids[<span class="Constant">0</span>], <a href="#L125" title="access/transam/xact.c:125">ParallelCurrentXids</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L124" title="access/transam/xact.c:124">nParallelCurrentXids</a> * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, we need to generate a sorted list of XIDs that our workers should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * view as current.&nbsp; First, figure out how many there are.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>; s != <span class="Constant">NULL</span>; s = s-&gt;parent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FullTransactionIdIsValid(s-&gt;fullTransactionId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nxids = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(nxids, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nxids = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(nxids, s-&gt;nChildXids);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L236" title="access/transam/xact.c:236">SerializedTransactionStateHeaderSize</a> + nxids * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &lt;= maxsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy them to our scratch space. */<br/></li>
<li></span>&nbsp; &nbsp; workspace = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nxids * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>; s != <span class="Constant">NULL</span>; s = s-&gt;parent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FullTransactionIdIsValid(s-&gt;fullTransactionId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workspace[i++] = XidFromFullTransactionId(s-&gt;fullTransactionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;nChildXids &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;workspace[i], s-&gt;childXids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; s-&gt;nChildXids * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i += s-&gt;nChildXids;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(i == nxids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort them. */<br/></li>
<li></span>&nbsp; &nbsp; qsort(workspace, nxids, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId), <a href="../../utils/adt/xid.c.html#L139" title="utils/adt/xid.c:139">xidComparator</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy data into output area. */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;<a href="#L124" title="access/transam/xact.c:124">nParallelCurrentXids</a> = nxids;<br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;result-&gt;parallelCurrentXids[<span class="Constant">0</span>], workspace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nxids * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5562" title="access/transam/xact.c:5562">StartParallelWorkerTransaction</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Start a parallel worker transaction, restoring the relevant<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; transaction state serialized by <a href="#L5491" title="access/transam/xact.c:5491">SerializeTransactionState</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5562">&#x200c;</a></span><span class="linkable">StartParallelWorkerTransaction</span>(<span class="Type">char</span> *tstatespace)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L224" title="access/transam/xact.c:224">SerializedTransactionState</a> *tstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>-&gt;blockState == TBLOCK_DEFAULT);<br/></li>
<li>&nbsp; &nbsp; <a href="#L2014" title="access/transam/xact.c:2014">StartTransaction</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tstate = (<a href="#L224" title="access/transam/xact.c:224">SerializedTransactionState</a> *) tstatespace;<br/></li>
<li>&nbsp; &nbsp; <a href="#L77" title="access/transam/xact.c:77">XactIsoLevel</a> = tstate-&gt;xactIsoLevel;<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="access/transam/xact.c:83">XactDeferrable</a> = tstate-&gt;xactDeferrable;<br/></li>
<li>&nbsp; &nbsp; <a href="#L123" title="access/transam/xact.c:123">XactTopFullTransactionId</a> = tstate-&gt;topFullTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>-&gt;fullTransactionId =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tstate-&gt;currentFullTransactionId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L264" title="access/transam/xact.c:264">currentCommandId</a> = tstate-&gt;<a href="#L264" title="access/transam/xact.c:264">currentCommandId</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L124" title="access/transam/xact.c:124">nParallelCurrentXids</a> = tstate-&gt;<a href="#L124" title="access/transam/xact.c:124">nParallelCurrentXids</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L125" title="access/transam/xact.c:125">ParallelCurrentXids</a> = &amp;tstate-&gt;parallelCurrentXids[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>-&gt;blockState = TBLOCK_PARALLEL_INPROGRESS;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5587" title="access/transam/xact.c:5587">EndParallelWorkerTransaction</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; End a parallel worker transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5587">&#x200c;</a></span><span class="linkable">EndParallelWorkerTransaction</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>-&gt;blockState == TBLOCK_PARALLEL_INPROGRESS);<br/></li>
<li>&nbsp; &nbsp; <a href="#L2178" title="access/transam/xact.c:2178">CommitTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>-&gt;blockState = TBLOCK_DEFAULT;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5599" title="access/transam/xact.c:5599">ShowTransactionState</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Debug support<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5599">&#x200c;</a></span><span class="linkable">ShowTransactionState</span>(<span class="Type">const</span> <span class="Type">char</span> *str)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> work if message will definitely not be printed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/error/elog.c.html#L276" title="utils/error/elog.c:276">message_level_is_interesting</a>(DEBUG5))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5611" title="access/transam/xact.c:5611">ShowTransactionStateRec</a>(str, <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5611" title="access/transam/xact.c:5611">ShowTransactionStateRec</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Recursive subroutine for <a href="#L5599" title="access/transam/xact.c:5599">ShowTransactionState</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5611">&#x200c;</a></span><span class="linkable">ShowTransactionStateRec</span>(<span class="Type">const</span> <span class="Type">char</span> *str, <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;parent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since this function recurses, it could be driven to stack overflow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is just a debugging aid, so we can leave out some details<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * instead of erroring out with <a href="../../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../tcop/postgres.c.html#L3545" title="tcop/postgres.c:3545">stack_is_too_deep</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG5,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">): parent omitted to avoid stack overflow&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; str, s-&gt;nestingLevel)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5611" title="access/transam/xact.c:5611">ShowTransactionStateRec</a>(str, s-&gt;parent);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;nChildXids &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;, children: </span><span class="Special">%u</span><span class="Constant">&quot;</span>, s-&gt;childXids[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; s-&gt;nChildXids; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot; </span><span class="Special">%u</span><span class="Constant">&quot;</span>, s-&gt;childXids[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG5,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">) name: </span><span class="Special">%s</span><span class="Constant">; blockState: </span><span class="Special">%s</span><span class="Constant">; state: </span><span class="Special">%s</span><span class="Constant">, xid/subid/cid: </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u%s%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; str, s-&gt;nestingLevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerIsValid(s-&gt;name) ? s-&gt;name : <span class="Constant">&quot;unnamed&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a>(s-&gt;blockState),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L5711" title="access/transam/xact.c:5711">TransStateAsString</a>(s-&gt;state),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) XidFromFullTransactionId(s-&gt;fullTransactionId),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) s-&gt;subTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) <a href="#L264" title="access/transam/xact.c:264">currentCommandId</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L265" title="access/transam/xact.c:265">currentCommandIdUsed</a> ? <span class="Constant">&quot; (used)&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buf.data)));<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5658" title="access/transam/xact.c:5658">BlockStateAsString</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Debug support<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L5658">&#x200c;</a><span class="linkable">BlockStateAsString</span>(<a href="#L155" title="access/transam/xact.c:155">TBlockState</a> blockState)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (blockState)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_DEFAULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;DEFAULT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_STARTED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;STARTED&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_BEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;BEGIN&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;INPROGRESS&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_IMPLICIT_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;IMPLICIT_INPROGRESS&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PARALLEL_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;PARALLEL_INPROGRESS&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;<a href="../../regex/regcomp.c.html#L336" title="regex/regcomp.c:336">END</a>&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ABORT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ABORT_END&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_ABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ABORT_PENDING&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;PREPARE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBBEGIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SUBBEGIN&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBINPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SUBINPROGRESS&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRELEASE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SUBRELEASE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBCOMMIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SUBCOMMIT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SUBABORT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SUBABORT_END&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_PENDING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SUBABORT_PENDING&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBRESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SUBRESTART&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TBLOCK_SUBABORT_RESTART:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;SUBABORT_RESTART&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;UNRECOGNIZED&quot;</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5711" title="access/transam/xact.c:5711">TransStateAsString</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Debug support<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L5711">&#x200c;</a><span class="linkable">TransStateAsString</span>(<a href="#L139" title="access/transam/xact.c:139">TransState</a> state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (state)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_DEFAULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;DEFAULT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_START:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;START&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_INPROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;INPROGRESS&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_COMMIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;COMMIT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_ABORT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;ABORT&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TRANS_PREPARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;PREPARE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;UNRECOGNIZED&quot;</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5741" title="access/transam/xact.c:5741">xactGetCommittedChildren</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Gets the list of committed children of the current transaction.&nbsp; The return<br/></li>
<li></span><span class="Comment"> * value is the number of child transactions.&nbsp; *ptr is set to point to an<br/></li>
<li></span><span class="Comment"> * array of TransactionIds.&nbsp; The array is allocated in <a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>;<br/></li>
<li></span><span class="Comment"> * the caller should *not* <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>() it (this is a change from pre-8.4 code!).<br/></li>
<li></span><span class="Comment"> * If there are no subxacts, *ptr is set to NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L5741">&#x200c;</a></span><span class="linkable">xactGetCommittedChildren</span>(TransactionId **ptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L218" title="access/transam/xact.c:218">TransactionState</a> s = <a href="#L257" title="access/transam/xact.c:257">CurrentTransactionState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;nChildXids == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ptr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *ptr = s-&gt;childXids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> s-&gt;nChildXids;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; XLOG support routines<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Log the commit record for a plain or twophase transaction commit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A 2pc commit will be emitted when twophase_xid is valid, a plain one<br/></li>
<li></span><span class="Comment"> * otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L5765">&#x200c;</a><span class="linkable">XactLogCommitRecord</span>(TimestampTz commit_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nsubxacts, TransactionId *subxacts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nrels, RelFileLocator *rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> ndroppedstats, xl_xact_stats_item *droppedstats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nmsgs, SharedInvalidationMessage *msgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> relcacheInval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> xactflags, TransactionId twophase_xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *twophase_gid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xl_xact_commit xlrec;<br/></li>
<li>&nbsp; &nbsp; xl_xact_xinfo xl_xinfo;<br/></li>
<li>&nbsp; &nbsp; xl_xact_dbinfo xl_dbinfo;<br/></li>
<li>&nbsp; &nbsp; xl_xact_subxacts xl_subxacts;<br/></li>
<li>&nbsp; &nbsp; xl_xact_relfilelocators xl_relfilelocators;<br/></li>
<li>&nbsp; &nbsp; xl_xact_stats_items xl_dropped_stats;<br/></li>
<li>&nbsp; &nbsp; xl_xact_invals xl_invals;<br/></li>
<li>&nbsp; &nbsp; xl_xact_twophase xl_twophase;<br/></li>
<li>&nbsp; &nbsp; xl_xact_origin xl_origin;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../utils/init/globals.c.html#L43" title="utils/init/globals.c:43">CritSectionCount</a> &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xl_xinfo.xinfo = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* decide between a plain and 2pc commit */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(twophase_xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info = XLOG_XACT_COMMIT;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; info = XLOG_XACT_COMMIT_PREPARED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First figure out and collect all the information needed */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; xlrec.xact_time = commit_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relcacheInval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xinfo.xinfo |= XACT_COMPLETION_UPDATE_RELCACHE_FILE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L290" title="access/transam/xact.c:290">forceSyncCommit</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xinfo.xinfo |= XACT_COMPLETION_FORCE_SYNC_COMMIT;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((xactflags &amp; XACT_FLAGS_ACQUIREDACCESSEXCLUSIVELOCK))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xinfo.xinfo |= XACT_XINFO_HAS_AE_LOCKS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if the caller would like to ask standbys for immediate feedback<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * once this commit is applied.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="access/transam/xact.c:85">synchronous_commit</a> &gt;= SYNCHRONOUS_COMMIT_REMOTE_APPLY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xinfo.xinfo |= XACT_COMPLETION_APPLY_FEEDBACK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Relcache invalidations requires information about the current database<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and so does logical decoding.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nmsgs &gt; <span class="Constant">0</span> || XLogLogicalInfoActive())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xinfo.xinfo |= XACT_XINFO_HAS_DBINFO;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_dbinfo.dbId = <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_dbinfo.tsId = <a href="../../utils/init/globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nsubxacts &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xinfo.xinfo |= XACT_XINFO_HAS_SUBXACTS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_subxacts.nsubxacts = nsubxacts;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nrels &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xinfo.xinfo |= XACT_XINFO_HAS_RELFILELOCATORS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_relfilelocators.nrels = nrels;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info |= XLR_SPECIAL_REL_UPDATE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndroppedstats &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xinfo.xinfo |= XACT_XINFO_HAS_DROPPED_STATS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_dropped_stats.nitems = ndroppedstats;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nmsgs &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xinfo.xinfo |= XACT_XINFO_HAS_INVALS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_invals.nmsgs = nmsgs;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(twophase_xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xinfo.xinfo |= XACT_XINFO_HAS_TWOPHASE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_twophase.xid = twophase_xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(twophase_gid != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogLogicalInfoActive())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_xinfo.xinfo |= XACT_XINFO_HAS_GID;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> transaction origin information */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../replication/logical/origin.c.html#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a> != InvalidRepOriginId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xinfo.xinfo |= XACT_XINFO_HAS_ORIGIN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_origin.origin_lsn = <a href="../../replication/logical/origin.c.html#L156" title="replication/logical/origin.c:156">replorigin_session_origin_lsn</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_origin.origin_timestamp = <a href="../../replication/logical/origin.c.html#L157" title="replication/logical/origin.c:157">replorigin_session_origin_timestamp</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xl_xinfo.xinfo != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info |= XLOG_XACT_HAS_INFO;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Then include all the collected data into the commit record. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xlrec), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_xact_commit));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xl_xinfo.xinfo != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xl_xinfo.xinfo), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_xinfo.xinfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xl_xinfo.xinfo &amp; XACT_XINFO_HAS_DBINFO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xl_dbinfo), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_dbinfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xl_xinfo.xinfo &amp; XACT_XINFO_HAS_SUBXACTS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xl_subxacts),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MinSizeOfXactSubxacts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) subxacts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nsubxacts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xl_xinfo.xinfo &amp; XACT_XINFO_HAS_RELFILELOCATORS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xl_relfilelocators),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MinSizeOfXactRelfileLocators);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nrels * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xl_xinfo.xinfo &amp; XACT_XINFO_HAS_DROPPED_STATS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xl_dropped_stats),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MinSizeOfXactStatsItems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) droppedstats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ndroppedstats * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_xact_stats_item));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xl_xinfo.xinfo &amp; XACT_XINFO_HAS_INVALS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xl_invals), MinSizeOfXactInvals);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) msgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nmsgs * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xl_xinfo.xinfo &amp; XACT_XINFO_HAS_TWOPHASE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xl_twophase), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_xact_twophase));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xl_xinfo.xinfo &amp; XACT_XINFO_HAS_GID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>(unconstify(<span class="Type">char</span> *, twophase_gid), strlen(twophase_gid) + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xl_xinfo.xinfo &amp; XACT_XINFO_HAS_ORIGIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xl_origin), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_xact_origin));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we allow filtering by xacts */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xloginsert.c.html#L456" title="access/transam/xloginsert.c:456">XLogSetRecordFlags</a>(XLOG_INCLUDE_ORIGIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_XACT_ID, info);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Log the commit record for a plain or twophase transaction abort.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A 2pc abort will be emitted when twophase_xid is valid, a plain one<br/></li>
<li></span><span class="Comment"> * otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L5937">&#x200c;</a><span class="linkable">XactLogAbortRecord</span>(TimestampTz abort_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nsubxacts, TransactionId *subxacts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nrels, RelFileLocator *rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> ndroppedstats, xl_xact_stats_item *droppedstats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> xactflags, TransactionId twophase_xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *twophase_gid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xl_xact_abort xlrec;<br/></li>
<li>&nbsp; &nbsp; xl_xact_xinfo xl_xinfo;<br/></li>
<li>&nbsp; &nbsp; xl_xact_subxacts xl_subxacts;<br/></li>
<li>&nbsp; &nbsp; xl_xact_relfilelocators xl_relfilelocators;<br/></li>
<li>&nbsp; &nbsp; xl_xact_stats_items xl_dropped_stats;<br/></li>
<li>&nbsp; &nbsp; xl_xact_twophase xl_twophase;<br/></li>
<li>&nbsp; &nbsp; xl_xact_dbinfo xl_dbinfo;<br/></li>
<li>&nbsp; &nbsp; xl_xact_origin xl_origin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../utils/init/globals.c.html#L43" title="utils/init/globals.c:43">CritSectionCount</a> &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xl_xinfo.xinfo = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* decide between a plain and 2pc abort */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(twophase_xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info = XLOG_XACT_ABORT;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; info = XLOG_XACT_ABORT_PREPARED;<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First figure out and collect all the information needed */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; xlrec.xact_time = abort_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((xactflags &amp; XACT_FLAGS_ACQUIREDACCESSEXCLUSIVELOCK))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xinfo.xinfo |= XACT_XINFO_HAS_AE_LOCKS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nsubxacts &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xinfo.xinfo |= XACT_XINFO_HAS_SUBXACTS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_subxacts.nsubxacts = nsubxacts;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nrels &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xinfo.xinfo |= XACT_XINFO_HAS_RELFILELOCATORS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_relfilelocators.nrels = nrels;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info |= XLR_SPECIAL_REL_UPDATE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndroppedstats &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xinfo.xinfo |= XACT_XINFO_HAS_DROPPED_STATS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_dropped_stats.nitems = ndroppedstats;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(twophase_xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xinfo.xinfo |= XACT_XINFO_HAS_TWOPHASE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_twophase.xid = twophase_xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(twophase_gid != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogLogicalInfoActive())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_xinfo.xinfo |= XACT_XINFO_HAS_GID;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(twophase_xid) &amp;&amp; XLogLogicalInfoActive())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xinfo.xinfo |= XACT_XINFO_HAS_DBINFO;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_dbinfo.dbId = <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_dbinfo.tsId = <a href="../../utils/init/globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Dump transaction origin information. We need this during recovery to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update the replication origin progress.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../replication/logical/origin.c.html#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a> != InvalidRepOriginId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xinfo.xinfo |= XACT_XINFO_HAS_ORIGIN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_origin.origin_lsn = <a href="../../replication/logical/origin.c.html#L156" title="replication/logical/origin.c:156">replorigin_session_origin_lsn</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_origin.origin_timestamp = <a href="../../replication/logical/origin.c.html#L157" title="replication/logical/origin.c:157">replorigin_session_origin_timestamp</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xl_xinfo.xinfo != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info |= XLOG_XACT_HAS_INFO;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Then include all the collected data into the abort record. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xlrec), MinSizeOfXactAbort);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xl_xinfo.xinfo != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xl_xinfo), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_xinfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xl_xinfo.xinfo &amp; XACT_XINFO_HAS_DBINFO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xl_dbinfo), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_dbinfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xl_xinfo.xinfo &amp; XACT_XINFO_HAS_SUBXACTS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xl_subxacts),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MinSizeOfXactSubxacts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) subxacts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nsubxacts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xl_xinfo.xinfo &amp; XACT_XINFO_HAS_RELFILELOCATORS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xl_relfilelocators),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MinSizeOfXactRelfileLocators);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nrels * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xl_xinfo.xinfo &amp; XACT_XINFO_HAS_DROPPED_STATS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xl_dropped_stats),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MinSizeOfXactStatsItems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) droppedstats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ndroppedstats * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_xact_stats_item));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xl_xinfo.xinfo &amp; XACT_XINFO_HAS_TWOPHASE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xl_twophase), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_xact_twophase));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xl_xinfo.xinfo &amp; XACT_XINFO_HAS_GID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>(unconstify(<span class="Type">char</span> *, twophase_gid), strlen(twophase_gid) + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xl_xinfo.xinfo &amp; XACT_XINFO_HAS_ORIGIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xl_origin), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_xact_origin));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Include the replication origin */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xloginsert.c.html#L456" title="access/transam/xloginsert.c:456">XLogSetRecordFlags</a>(XLOG_INCLUDE_ORIGIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_XACT_ID, info);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Before 9.0 this was a fairly short function, but <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> it performs many<br/></li>
<li></span><span class="Comment"> * actions for which the order of execution is critical.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6081">&#x200c;</a></span><span class="linkable">xact_redo_commit</span>(xl_xact_parsed_commit *parsed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RepOriginId origin_id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId max_xid;<br/></li>
<li>&nbsp; &nbsp; TimestampTz commit_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; max_xid = <a href="transam.c.html#L345" title="access/transam/transam.c:345">TransactionIdLatest</a>(xid, parsed-&gt;nsubxacts, parsed-&gt;subxacts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure nextXid is beyond <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> XID mentioned in the record. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="varsup.c.html#L304" title="access/transam/varsup.c:304">AdvanceNextFullTransactionIdPastXid</a>(max_xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(((parsed-&gt;xinfo &amp; XACT_XINFO_HAS_ORIGIN) == <span class="Constant">0</span>) ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (origin_id == InvalidRepOriginId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parsed-&gt;xinfo &amp; XACT_XINFO_HAS_ORIGIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; commit_time = parsed-&gt;origin_timestamp;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; commit_time = parsed-&gt;xact_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set the transaction commit timestamp and metadata */<br/></li>
<li></span>&nbsp; &nbsp; <a href="commit_ts.c.html#L141" title="access/transam/commit_ts.c:141">TransactionTreeSetCommitTsData</a>(xid, parsed-&gt;nsubxacts, parsed-&gt;subxacts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; commit_time, origin_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> == STANDBY_DISABLED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mark the transaction committed in pg_xact.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="transam.c.html#L240" title="access/transam/transam.c:240">TransactionIdCommitTree</a>(xid, parsed-&gt;nsubxacts, parsed-&gt;subxacts);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a transaction completion record arrives that has as-yet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unobserved subtransactions then this will not have been fully<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * handled by the call to <a href="../../storage/ipc/procarray.c.html#L4387" title="storage/ipc/procarray.c:4387">RecordKnownAssignedTransactionIds</a>() in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> recovery loop in xlog.c. So we need to do bookkeeping again to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cover that case. This is confusing and it is easy to think this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * call is irrelevant, which has happened three times in development<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already. Leave it in.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L4387" title="storage/ipc/procarray.c:4387">RecordKnownAssignedTransactionIds</a>(max_xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mark the transaction committed in pg_xact. We use async commit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * protocol during recovery to provide information on database<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consistency for when users try to set hint bits. It is important<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we do not set hint bits until the <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> is past<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this commit record. This ensures that if we crash we don't see hint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bits set on changes made by transactions that haven't yet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recovered. It's unlikely but it's good to be safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="transam.c.html#L252" title="access/transam/transam.c:252">TransactionIdAsyncCommitTree</a>(xid, parsed-&gt;nsubxacts, parsed-&gt;subxacts, lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must mark clog <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we update the ProcArray.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L4456" title="storage/ipc/procarray.c:4456">ExpireTreeKnownAssignedTransactionIds</a>(xid, parsed-&gt;nsubxacts, parsed-&gt;subxacts, max_xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Send <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cache invalidations attached to the commit. We must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * maintain the same order of invalidation then release locks as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * occurs in <a href="#L2178" title="access/transam/xact.c:2178">CommitTransaction</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L961" title="utils/cache/inval.c:961">ProcessCommittedInvalidationMessages</a>(parsed-&gt;msgs, parsed-&gt;nmsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XactCompletionRelcacheInitFileInval(parsed-&gt;xinfo),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parsed-&gt;dbId, parsed-&gt;tsId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Release locks, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. We do this for both two phase and normal one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * phase transactions. In effect we are ignoring the prepare phase and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just going straight to lock release.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsed-&gt;xinfo &amp; XACT_XINFO_HAS_AE_LOCKS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/standby.c.html#L1091" title="storage/ipc/standby.c:1091">StandbyReleaseLockTree</a>(xid, parsed-&gt;nsubxacts, parsed-&gt;subxacts);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parsed-&gt;xinfo &amp; XACT_XINFO_HAS_ORIGIN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recover apply progress */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/logical/origin.c.html#L888" title="replication/logical/origin.c:888">replorigin_advance</a>(origin_id, parsed-&gt;origin_lsn, lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span> <span class="Comment">/* backward */</span> , <span class="Constant">false</span> <span class="Comment">/* WAL */</span> );<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure files supposed to be dropped are dropped */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parsed-&gt;nrels &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First update minimum recovery point to cover this WAL record. Once<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a relation is deleted, there's no going back. The buffer manager<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enforces the WAL-first rule for normal updates to relation files,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so that the minimum recovery point is always updated <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * corresponding change in the data file is flushed to disk, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to do the same here since we're bypassing the buffer manager.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Doing this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> deleting the files means that if a deletion fails<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for some reason, you cannot start up the system even after restart,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * until you fix the underlying situation so that the deletion will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * succeed. Alternatively, we could update the minimum recovery point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after deletion, but that would leave a small window where the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL-first rule would be violated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure files supposed to be dropped are dropped */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/smgr/md.c.html#L1446" title="storage/smgr/md.c:1446">DropRelationFiles</a>(parsed-&gt;xlocators, parsed-&gt;nrels, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parsed-&gt;nstats &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see equivalent call for relations above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_xact.c.html#L312" title="utils/activity/pgstat_xact.c:312">pgstat_execute_transactional_drops</a>(parsed-&gt;nstats, parsed-&gt;stats, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We issue an <a href="xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>() for the same reason we emit <a href="#L1149" title="access/transam/xact.c:1149">ForceSyncCommit</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in normal operation. For example, in CREATE DATABASE, we copy all files<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the template database, and then commit the transaction. If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * crash after all the files have been copied but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the commit, you<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have files in the data directory without an entry in pg_database. To<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * minimize the window for that, we use <a href="#L1149" title="access/transam/xact.c:1149">ForceSyncCommit</a>() to rush the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit record to disk as quick as possible. We have the same window<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during recovery, and forcing an <a href="xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>() (which updates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> during recovery) helps to reduce that problem window,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> user that requested <a href="#L1149" title="access/transam/xact.c:1149">ForceSyncCommit</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (XactCompletionForceSyncCommit(parsed-&gt;xinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If asked by the primary (because someone is <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for a synchronous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit = remote_apply), we will need to ask walreceiver to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a reply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (XactCompletionApplyFeedback(parsed-&gt;xinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogrecovery.c.html#L4487" title="access/transam/xlogrecovery.c:4487">XLogRequestWalReceiverReply</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Be careful with the order of execution, as with <a href="#L6081" title="access/transam/xact.c:6081">xact_redo_commit</a>().<br/></li>
<li></span><span class="Comment"> * The two <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are similar but differ in key places.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note also that an abort can be for a subtransaction and its children,<br/></li>
<li></span><span class="Comment"> * not just for a top level abort. That means we have to consider<br/></li>
<li></span><span class="Comment"> * topxid != xid, whereas in commit we would <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> topxid == xid always<br/></li>
<li></span><span class="Comment"> * because subtransaction commit is never WAL logged.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6235">&#x200c;</a></span><span class="linkable">xact_redo_abort</span>(xl_xact_parsed_abort *parsed, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr lsn, RepOriginId origin_id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId max_xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure nextXid is beyond <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> XID mentioned in the record. */<br/></li>
<li></span>&nbsp; &nbsp; max_xid = <a href="transam.c.html#L345" title="access/transam/transam.c:345">TransactionIdLatest</a>(xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsed-&gt;nsubxacts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parsed-&gt;subxacts);<br/></li>
<li>&nbsp; &nbsp; <a href="varsup.c.html#L304" title="access/transam/varsup.c:304">AdvanceNextFullTransactionIdPastXid</a>(max_xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> == STANDBY_DISABLED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark the transaction aborted in pg_xact, no need for async stuff */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="transam.c.html#L270" title="access/transam/transam.c:270">TransactionIdAbortTree</a>(xid, parsed-&gt;nsubxacts, parsed-&gt;subxacts);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a transaction completion record arrives that has as-yet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unobserved subtransactions then this will not have been fully<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * handled by the call to <a href="../../storage/ipc/procarray.c.html#L4387" title="storage/ipc/procarray.c:4387">RecordKnownAssignedTransactionIds</a>() in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> recovery loop in xlog.c. So we need to do bookkeeping again to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cover that case. This is confusing and it is easy to think this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * call is irrelevant, which has happened three times in development<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already. Leave it in.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L4387" title="storage/ipc/procarray.c:4387">RecordKnownAssignedTransactionIds</a>(max_xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark the transaction aborted in pg_xact, no need for async stuff */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="transam.c.html#L270" title="access/transam/transam.c:270">TransactionIdAbortTree</a>(xid, parsed-&gt;nsubxacts, parsed-&gt;subxacts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must update the ProcArray after we have marked clog.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L4456" title="storage/ipc/procarray.c:4456">ExpireTreeKnownAssignedTransactionIds</a>(xid, parsed-&gt;nsubxacts, parsed-&gt;subxacts, max_xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There are no invalidation messages to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> or undo.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Release locks, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. There are no invalidations to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parsed-&gt;xinfo &amp; XACT_XINFO_HAS_AE_LOCKS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/standby.c.html#L1091" title="storage/ipc/standby.c:1091">StandbyReleaseLockTree</a>(xid, parsed-&gt;nsubxacts, parsed-&gt;subxacts);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parsed-&gt;xinfo &amp; XACT_XINFO_HAS_ORIGIN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recover apply progress */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/logical/origin.c.html#L888" title="replication/logical/origin.c:888">replorigin_advance</a>(origin_id, parsed-&gt;origin_lsn, lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span> <span class="Comment">/* backward */</span> , <span class="Constant">false</span> <span class="Comment">/* WAL */</span> );<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure files supposed to be dropped are dropped */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parsed-&gt;nrels &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See comments about update of minimum recovery point on truncation,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in <a href="#L6081" title="access/transam/xact.c:6081">xact_redo_commit</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/smgr/md.c.html#L1446" title="storage/smgr/md.c:1446">DropRelationFiles</a>(parsed-&gt;xlocators, parsed-&gt;nrels, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parsed-&gt;nstats &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see equivalent call for relations above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_xact.c.html#L312" title="utils/activity/pgstat_xact.c:312">pgstat_execute_transactional_drops</a>(parsed-&gt;nstats, parsed-&gt;stats, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L6314">&#x200c;</a></span><span class="linkable">xact_redo</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(record) &amp; XLOG_XACT_OPMASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Backup blocks are not used in xact <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!XLogRecHasAnyBlockRefs(record));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (info == XLOG_XACT_COMMIT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xact_commit *xlrec = (xl_xact_commit *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xact_parsed_commit parsed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../rmgrdesc/xactdesc.c.html#L35" title="access/rmgrdesc/xactdesc.c:35">ParseCommitRecord</a>(XLogRecGetInfo(record), xlrec, &amp;parsed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6081" title="access/transam/xact.c:6081">xact_redo_commit</a>(&amp;parsed, XLogRecGetXid(record),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; record-&gt;EndRecPtr, XLogRecGetOrigin(record));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_XACT_COMMIT_PREPARED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xact_commit *xlrec = (xl_xact_commit *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xact_parsed_commit parsed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../rmgrdesc/xactdesc.c.html#L35" title="access/rmgrdesc/xactdesc.c:35">ParseCommitRecord</a>(XLogRecGetInfo(record), xlrec, &amp;parsed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6081" title="access/transam/xact.c:6081">xact_redo_commit</a>(&amp;parsed, parsed.twophase_xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; record-&gt;EndRecPtr, XLogRecGetOrigin(record));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> <a href="twophase.c.html#L188" title="access/transam/twophase.c:188">TwoPhaseState</a> gxact entry and/or 2PC file. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(TwoPhaseStateLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="twophase.c.html#L2582" title="access/transam/twophase.c:2582">PrepareRedoRemove</a>(parsed.twophase_xid, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_XACT_ABORT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xact_abort *xlrec = (xl_xact_abort *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xact_parsed_abort parsed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../rmgrdesc/xactdesc.c.html#L141" title="access/rmgrdesc/xactdesc.c:141">ParseAbortRecord</a>(XLogRecGetInfo(record), xlrec, &amp;parsed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6235" title="access/transam/xact.c:6235">xact_redo_abort</a>(&amp;parsed, XLogRecGetXid(record),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record-&gt;EndRecPtr, XLogRecGetOrigin(record));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_XACT_ABORT_PREPARED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xact_abort *xlrec = (xl_xact_abort *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xact_parsed_abort parsed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../rmgrdesc/xactdesc.c.html#L141" title="access/rmgrdesc/xactdesc.c:141">ParseAbortRecord</a>(XLogRecGetInfo(record), xlrec, &amp;parsed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6235" title="access/transam/xact.c:6235">xact_redo_abort</a>(&amp;parsed, parsed.twophase_xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record-&gt;EndRecPtr, XLogRecGetOrigin(record));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> <a href="twophase.c.html#L188" title="access/transam/twophase.c:188">TwoPhaseState</a> gxact entry and/or 2PC file. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(TwoPhaseStateLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="twophase.c.html#L2582" title="access/transam/twophase.c:2582">PrepareRedoRemove</a>(parsed.twophase_xid, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_XACT_PREPARE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Store xid and start/end pointers of the WAL record in <a href="twophase.c.html#L188" title="access/transam/twophase.c:188">TwoPhaseState</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * gxact entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(TwoPhaseStateLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="twophase.c.html#L2480" title="access/transam/twophase.c:2480">PrepareRedoAdd</a>(XLogRecGetData(record),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; record-&gt;ReadRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; record-&gt;EndRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecGetOrigin(record));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_XACT_ASSIGNMENT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xact_assignment *xlrec = (xl_xact_assignment *) XLogRecGetData(record);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> &gt;= STANDBY_INITIALIZED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L1306" title="storage/ipc/procarray.c:1306">ProcArrayApplyXidAssignment</a>(xlrec-&gt;xtop,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec-&gt;nsubxacts, xlrec-&gt;xsub);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_XACT_INVALIDATIONS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> we do ignore this for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, what matters are invalidations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * written into the commit record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;<a href="#L6314" title="access/transam/xact.c:6314">xact_redo</a>: unknown op code </span><span class="Special">%u</span><span class="Constant">&quot;</span>, info);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
