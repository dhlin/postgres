<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/transam/clog.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/transam/clog.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L108">XactCtlData</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L833">BootStrapCLOG</a></li>
<li><a href="#L1055">CLOGPagePrecedes</a></li>
<li><a href="#L768">CLOGShmemBuffers</a></li>
<li><a href="#L787">CLOGShmemInit</a></li>
<li><a href="#L781">CLOGShmemSize</a></li>
<li><a href="#L937">CheckPointCLOG</a></li>
<li><a href="#L959">ExtendCLOG</a></li>
<li><a href="#L877">StartupCLOG</a></li>
<li><a href="#L441">TransactionGroupUpdateXidStatus</a></li>
<li><a href="#L735">TransactionIdGetStatus</a></li>
<li><a href="#L293">TransactionIdSetPageStatus</a></li>
<li><a href="#L364">TransactionIdSetPageStatusInternal</a></li>
<li><a href="#L661">TransactionIdSetStatusBit</a></li>
<li><a href="#L183">TransactionIdSetTreeStatus</a></li>
<li><a href="#L82">TransactionIdToPage</a></li>
<li><a href="#L892">TrimCLOG</a></li>
<li><a href="#L1000">TruncateCLOG</a></li>
<li><a href="#L1088">WriteTruncateXlogRec</a></li>
<li><a href="#L1074">WriteZeroPageXlogRec</a></li>
<li><a href="#L860">ZeroCLOGPage</a></li>
<li><a href="#L821">check_transaction_buffers</a></li>
<li><a href="#L1107">clog_redo</a></li>
<li><a href="#L1149">clogsyncfiletag</a></li>
<li><a href="#L257">set_status_by_pages</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L62">CLOG_BITS_PER_XACT</a></li>
<li><a href="#L93">CLOG_LSNS_PER_PAGE</a></li>
<li><a href="#L72">CLOG_MAX_ALLOWED_BUFFERS</a></li>
<li><a href="#L63">CLOG_XACTS_PER_BYTE</a></li>
<li><a href="#L92">CLOG_XACTS_PER_LSN_GROUP</a></li>
<li><a href="#L64">CLOG_XACTS_PER_PAGE</a></li>
<li><a href="#L65">CLOG_XACT_BITMASK</a></li>
<li><a href="#L95">GetLSNIndex</a></li>
<li><a href="#L103">THRESHOLD_SUBTRANS_CLOG_OPT</a></li>
<li><a href="#L89">TransactionIdToBIndex</a></li>
<li><a href="#L88">TransactionIdToByte</a></li>
<li><a href="#L87">TransactionIdToPgIndex</a></li>
<li><a href="#L110">XactCtl</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * clog.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PostgreSQL transaction-commit-log manager<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module stores two bits per transaction regarding its commit/abort<br/></li>
<li></span><span class="Comment"> * status; the status for four transactions fit in a byte.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This would be a pretty simple abstraction on top of slru.c, except that<br/></li>
<li></span><span class="Comment"> * for performance reasons we allow multiple transactions that are<br/></li>
<li></span><span class="Comment"> * committing concurrently to form a queue, so that a single process can<br/></li>
<li></span><span class="Comment"> * update the status for all of them within a single lock acquisition run.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * XLOG interactions: this module generates an XLOG record whenever a new<br/></li>
<li></span><span class="Comment"> * CLOG page is initialized to zeroes.&nbsp; Other writes of CLOG come from<br/></li>
<li></span><span class="Comment"> * recording of transaction commit or abort in xact.c, which generates its<br/></li>
<li></span><span class="Comment"> * own XLOG <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> for these events and will re-perform the status update<br/></li>
<li></span><span class="Comment"> * on redo; so we need make no additional XLOG entry here.&nbsp; For synchronous<br/></li>
<li></span><span class="Comment"> * transaction commits, the XLOG is guaranteed flushed through the XLOG commit<br/></li>
<li></span><span class="Comment"> * record <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we are called to log a commit, so the WAL rule &quot;write xlog<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> data&quot; is satisfied automatically.&nbsp; However, for async commits we<br/></li>
<li></span><span class="Comment"> * must track the latest LSN affecting each CLOG page, so that we can flush<br/></li>
<li></span><span class="Comment"> * XLOG that far and satisfy the WAL rule.&nbsp; We don't have to worry about this<br/></li>
<li></span><span class="Comment"> * for aborts (whether sync or async), since the post-crash assumption would<br/></li>
<li></span><span class="Comment"> * be that such transactions failed anyway.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * src/backend/access/transam/clog.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/clog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/slru.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pg_trace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/sync.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Defines for CLOG page sizes.&nbsp; A page is the same BLCKSZ as is used<br/></li>
<li></span><span class="Comment"> * everywhere else in Postgres.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: because TransactionIds are 32 bits and wrap around at 0xFFFFFFFF,<br/></li>
<li></span><span class="Comment"> * CLOG page numbering also wraps around at 0xFFFFFFFF/<a href="#L64" title="access/transam/clog.c:64">CLOG_XACTS_PER_PAGE</a>,<br/></li>
<li></span><span class="Comment"> * and CLOG segment numbering at<br/></li>
<li></span><span class="Comment"> * 0xFFFFFFFF/<a href="#L64" title="access/transam/clog.c:64">CLOG_XACTS_PER_PAGE</a>/SLRU_PAGES_PER_SEGMENT.&nbsp; We need take no<br/></li>
<li></span><span class="Comment"> * explicit notice of that fact in this module, except when comparing segment<br/></li>
<li></span><span class="Comment"> * and page numbers in <a href="#L1000" title="access/transam/clog.c:1000">TruncateCLOG</a> (see <a href="#L1055" title="access/transam/clog.c:1055">CLOGPagePrecedes</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* We need two bits per xact, so four xacts fit in a byte */<br/></li>
<li><a id="L62">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CLOG_BITS_PER_XACT</span>&nbsp; &nbsp; </span><span class="Constant">2<br/></li>
<li><a id="L63">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CLOG_XACTS_PER_BYTE</span> </span><span class="Constant">4<br/></li>
<li><a id="L64">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CLOG_XACTS_PER_PAGE</span> (BLCKSZ * <a href="#L63" title="access/transam/clog.c:63">CLOG_XACTS_PER_BYTE</a>)<br/></li>
<li><a id="L65">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CLOG_XACT_BITMASK</span>&nbsp; &nbsp; ((</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; <a href="#L62" title="access/transam/clog.c:62">CLOG_BITS_PER_XACT</a>) - </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Because space used in CLOG by each transaction is so small, we place a<br/></li>
<li></span><span class="Comment"> * smaller limit on the number of CLOG buffers than SLRU allows.&nbsp; No other<br/></li>
<li></span><span class="Comment"> * SLRU needs this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L72">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CLOG_MAX_ALLOWED_BUFFERS</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(SLRU_MAX_ALLOWED_BUFFERS, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; (((MaxTransactionId / </span><span class="Constant">2</span><span class="PreProc">) + (<a href="#L64" title="access/transam/clog.c:64">CLOG_XACTS_PER_PAGE</a> - </span><span class="Constant">1</span><span class="PreProc">)) / <a href="#L64" title="access/transam/clog.c:64">CLOG_XACTS_PER_PAGE</a>))<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Although we return an int64 the actual value can't currently exceed<br/></li>
<li></span><span class="Comment"> * 0xFFFFFFFF/<a href="#L64" title="access/transam/clog.c:64">CLOG_XACTS_PER_PAGE</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> int64<br/></li>
<li><a id="L82">&#x200c;</a><span class="linkable">TransactionIdToPage</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> xid / (int64) <a href="#L64" title="access/transam/clog.c:64">CLOG_XACTS_PER_PAGE</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L87">&#x200c;</a><span class="PreProc">#define <span class="linkable">TransactionIdToPgIndex</span>(xid) ((xid) % (TransactionId) <a href="#L64" title="access/transam/clog.c:64">CLOG_XACTS_PER_PAGE</a>)<br/></li>
<li><a id="L88">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TransactionIdToByte</span>(xid)&nbsp; &nbsp; (<a href="#L87" title="access/transam/clog.c:87">TransactionIdToPgIndex</a>(xid) / <a href="#L63" title="access/transam/clog.c:63">CLOG_XACTS_PER_BYTE</a>)<br/></li>
<li><a id="L89">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TransactionIdToBIndex</span>(xid)&nbsp; &nbsp; ((xid) % (TransactionId) <a href="#L63" title="access/transam/clog.c:63">CLOG_XACTS_PER_BYTE</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* We store the latest async LSN for each group of transactions */<br/></li>
<li><a id="L92">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CLOG_XACTS_PER_LSN_GROUP</span>&nbsp; &nbsp; </span><span class="Constant">32</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* keep this a power of 2 */<br/></li>
<li><a id="L93">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">CLOG_LSNS_PER_PAGE</span>&nbsp; &nbsp; (<a href="#L64" title="access/transam/clog.c:64">CLOG_XACTS_PER_PAGE</a> / <a href="#L92" title="access/transam/clog.c:92">CLOG_XACTS_PER_LSN_GROUP</a>)<br/></li>
<li></span><br/></li>
<li><a id="L95">&#x200c;</a><span class="PreProc">#define <span class="linkable">GetLSNIndex</span>(slotno, xid)&nbsp; &nbsp; ((slotno) * <a href="#L93" title="access/transam/clog.c:93">CLOG_LSNS_PER_PAGE</a> + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((xid) % (TransactionId) <a href="#L64" title="access/transam/clog.c:64">CLOG_XACTS_PER_PAGE</a>) / <a href="#L92" title="access/transam/clog.c:92">CLOG_XACTS_PER_LSN_GROUP</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The number of subtransactions below which we consider to apply clog group<br/></li>
<li></span><span class="Comment"> * update optimization.&nbsp; Testing reveals that the number higher than this can<br/></li>
<li></span><span class="Comment"> * hurt performance.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L103">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">THRESHOLD_SUBTRANS_CLOG_OPT</span>&nbsp; &nbsp; </span><span class="Constant">5<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Link to shared-memory data structures for CLOG control<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L108">&#x200c;</a></span><span class="Type">static</span> SlruCtlData <span class="linkable">XactCtlData</span>;<br/></li>
<li><br/></li>
<li><a id="L110">&#x200c;</a><span class="PreProc">#define <span class="linkable">XactCtl</span> (&amp;<a href="#L108" title="access/transam/clog.c:108">XactCtlData</a>)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L860" title="access/transam/clog.c:860">ZeroCLOGPage</a>(int64 pageno, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> writeXlog);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1055" title="access/transam/clog.c:1055">CLOGPagePrecedes</a>(int64 page1, int64 page2);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="commit_ts.c.html#L989" title="access/transam/commit_ts.c:989">WriteZeroPageXlogRec</a>(int64 pageno);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="commit_ts.c.html#L1000" title="access/transam/commit_ts.c:1000">WriteTruncateXlogRec</a>(int64 pageno, TransactionId oldestXact,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid oldestXactDb);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L293" title="access/transam/clog.c:293">TransactionIdSetPageStatus</a>(TransactionId xid, <span class="Type">int</span> nsubxids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId *subxids, XidStatus status,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr lsn, int64 pageno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> all_xact_same_page);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L661" title="access/transam/clog.c:661">TransactionIdSetStatusBit</a>(TransactionId xid, XidStatus status,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr lsn, <span class="Type">int</span> slotno);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L257" title="access/transam/clog.c:257">set_status_by_pages</a>(<span class="Type">int</span> nsubxids, TransactionId *subxids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XidStatus status, XLogRecPtr lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L441" title="access/transam/clog.c:441">TransactionGroupUpdateXidStatus</a>(TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XidStatus status, XLogRecPtr lsn, int64 pageno);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L364" title="access/transam/clog.c:364">TransactionIdSetPageStatusInternal</a>(TransactionId xid, <span class="Type">int</span> nsubxids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId *subxids, XidStatus status,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr lsn, int64 pageno);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L183" title="access/transam/clog.c:183">TransactionIdSetTreeStatus</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Record the final state of transaction entries in the commit log for<br/></li>
<li></span><span class="Comment"> * a transaction and its subtransaction tree. Take care to ensure this is<br/></li>
<li></span><span class="Comment"> * efficient, and as atomic as possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * xid is a single xid to set status for. This will typically be<br/></li>
<li></span><span class="Comment"> * the top level transactionid for a top level commit or abort. It can<br/></li>
<li></span><span class="Comment"> * also be a subtransaction when we record transaction aborts.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * subxids is an array of xids of length nsubxids, representing subtransactions<br/></li>
<li></span><span class="Comment"> * in the tree of xid. In various cases nsubxids may be zero.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * lsn must be the WAL location of the commit record when recording an async<br/></li>
<li></span><span class="Comment"> * commit.&nbsp; For a synchronous commit it can be InvalidXLogRecPtr, since the<br/></li>
<li></span><span class="Comment"> * caller guarantees the commit record is already flushed in that case.&nbsp; It<br/></li>
<li></span><span class="Comment"> * should be InvalidXLogRecPtr for abort cases, too.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the commit case, atomicity is limited by whether all the subxids are in<br/></li>
<li></span><span class="Comment"> * the same CLOG page as xid.&nbsp; If they all are, then the lock will be grabbed<br/></li>
<li></span><span class="Comment"> * only once, and the status will be set to committed directly.&nbsp; Otherwise<br/></li>
<li></span><span class="Comment"> * we must<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; 1. set sub-committed all subxids that are not on the same page as the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> xid<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; 2. atomically set committed the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> xid and the subxids on the same page<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; 3. go over the first bunch again and set them committed<br/></li>
<li></span><span class="Comment"> * Note that as far as concurrent checkers are concerned, <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> transaction<br/></li>
<li></span><span class="Comment"> * commit as a whole is still atomic.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Example:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; TransactionId t commits and has subxids t1, t2, t3, t4<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; t is on page p1, t1 is also on p1, t2 and t3 are on p2, t4 is on p3<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 1. update pages2-3:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page2: set t2,t3 as sub-committed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page3: set t4 as sub-committed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 2. update page1:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page1: set t,t1 as committed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 3. update pages2-3:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page2: set t2,t3 as committed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page3: set t4 as committed<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this is a low-level routine and is NOT the preferred entry point<br/></li>
<li></span><span class="Comment"> * for most uses; <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in transam.c are the intended callers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> Think about issuing POSIX_FADV_WILLNEED on pages that we will need,<br/></li>
<li></span><span class="Comment"> * but aren't yet in cache, as well as hinting pages not to fall out of<br/></li>
<li></span><span class="Comment"> * cache yet.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L183">&#x200c;</a></span><span class="linkable">TransactionIdSetTreeStatus</span>(TransactionId xid, <span class="Type">int</span> nsubxids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId *subxids, XidStatus status, XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno = <a href="#L82" title="access/transam/clog.c:82">TransactionIdToPage</a>(xid);&nbsp; &nbsp; <span class="Comment">/* get page of parent */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(status == TRANSACTION_STATUS_COMMITTED ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; status == TRANSACTION_STATUS_ABORTED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See how many subxids, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, are on the same page as the parent, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nsubxids; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L82" title="access/transam/clog.c:82">TransactionIdToPage</a>(subxids[i]) != pageno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do all items fit on a single page?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (i == nsubxids)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set the parent and all subtransactions in a single call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L293" title="access/transam/clog.c:293">TransactionIdSetPageStatus</a>(xid, nsubxids, subxids, status, lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pageno, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nsubxids_on_first_page = i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is a commit then we care about doing this correctly (i.e.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * using the subcommitted intermediate status).&nbsp; By here, we know<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're updating more than one page of clog, so we must mark entries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that are *not* on the first page so that they show as subcommitted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we then return to update the status to fully committed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To avoid touching the first page twice, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> marking subcommitted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the subxids on that first page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (status == TRANSACTION_STATUS_COMMITTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L257" title="access/transam/clog.c:257">set_status_by_pages</a>(nsubxids - nsubxids_on_first_page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subxids + nsubxids_on_first_page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRANSACTION_STATUS_SUB_COMMITTED, lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now set the parent and subtransactions on same page as the parent,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pageno = <a href="#L82" title="access/transam/clog.c:82">TransactionIdToPage</a>(xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L293" title="access/transam/clog.c:293">TransactionIdSetPageStatus</a>(xid, nsubxids_on_first_page, subxids, status,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lsn, pageno, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now work through the rest of the subxids one clog page at a time,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * starting from the second page onwards, like we did above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L257" title="access/transam/clog.c:257">set_status_by_pages</a>(nsubxids - nsubxids_on_first_page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subxids + nsubxids_on_first_page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status, lsn);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper for <a href="#L183" title="access/transam/clog.c:183">TransactionIdSetTreeStatus</a>: set the status for a bunch of<br/></li>
<li></span><span class="Comment"> * transactions, chunking in the separate CLOG pages involved. We never<br/></li>
<li></span><span class="Comment"> * pass the whole transaction tree to this function, only subtransactions<br/></li>
<li></span><span class="Comment"> * that are on different pages to the top level transaction id.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L257">&#x200c;</a></span><span class="linkable">set_status_by_pages</span>(<span class="Type">int</span> nsubxids, TransactionId *subxids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XidStatus status, XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno = <a href="#L82" title="access/transam/clog.c:82">TransactionIdToPage</a>(subxids[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(nsubxids &gt; <span class="Constant">0</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else the pageno fetch above is unsafe */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (i &lt; nsubxids)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_on_page = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; nextpageno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextpageno = <a href="#L82" title="access/transam/clog.c:82">TransactionIdToPage</a>(subxids[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nextpageno != pageno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_on_page++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (i &lt; nsubxids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L293" title="access/transam/clog.c:293">TransactionIdSetPageStatus</a>(InvalidTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; num_on_page, subxids + offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; status, lsn, pageno, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageno = nextpageno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Record the final state of transaction entries in the commit log for all<br/></li>
<li></span><span class="Comment"> * entries on a single page.&nbsp; Atomic only on this page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L293">&#x200c;</a></span><span class="linkable">TransactionIdSetPageStatus</span>(TransactionId xid, <span class="Type">int</span> nsubxids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId *subxids, XidStatus status,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr lsn, int64 pageno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> all_xact_same_page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't use group update when PGPROC overflows. */<br/></li>
<li></span>&nbsp; &nbsp; StaticAssertDecl(<a href="#L103" title="access/transam/clog.c:103">THRESHOLD_SUBTRANS_CLOG_OPT</a> &lt;= PGPROC_MAX_CACHED_SUBXIDS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;group clog threshold less than PGPROC cached subxids&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the SLRU bank lock for the page we are going to access. */<br/></li>
<li></span>&nbsp; &nbsp; lock = SimpleLruGetBankLock(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When there is contention on the SLRU bank lock we need, we try to group<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multiple updates; a single leader process will perform transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * status updates for multiple backends so that the number of times the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bank lock needs to be acquired is reduced.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For this optimization to be safe, the XID and subxids in <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a> must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same as the ones for which we're setting the status.&nbsp; Check that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this is the case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For this optimization to be efficient, we shouldn't have too many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sub-XIDs and all of the XIDs for which we're adjusting clog should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the same page.&nbsp; Check those conditions, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (all_xact_same_page &amp;&amp; xid == <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nsubxids &lt;= <a href="#L103" title="access/transam/clog.c:103">THRESHOLD_SUBTRANS_CLOG_OPT</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nsubxids == <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxidStatus.count &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (nsubxids == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; memcmp(subxids, <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxids.xids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nsubxids * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId)) == <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we can immediately acquire the lock, we update the status of our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * own XID and release the lock.&nbsp; If not, try use group XID update. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that doesn't work out, fall back to <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the lock to perform<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an update for this transaction only.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/lmgr/lwlock.c.html#L1341" title="storage/lmgr/lwlock.c:1341">LWLockConditionalAcquire</a>(lock, LW_EXCLUSIVE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Got the lock without <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>!&nbsp; Do the update. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L364" title="access/transam/clog.c:364">TransactionIdSetPageStatusInternal</a>(xid, nsubxids, subxids, status,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lsn, pageno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L441" title="access/transam/clog.c:441">TransactionGroupUpdateXidStatus</a>(xid, status, lsn, pageno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Group update mechanism has done the work. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fall through only if update isn't done yet. */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Group update not applicable, or couldn't <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> this page number. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L364" title="access/transam/clog.c:364">TransactionIdSetPageStatusInternal</a>(xid, nsubxids, subxids, status,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lsn, pageno);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Record the final state of transaction entry in the commit log<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> locking here; caller must handle that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L364">&#x200c;</a></span><span class="linkable">TransactionIdSetPageStatusInternal</span>(TransactionId xid, <span class="Type">int</span> nsubxids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId *subxids, XidStatus status,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr lsn, int64 pageno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(status == TRANSACTION_STATUS_COMMITTED ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; status == TRANSACTION_STATUS_ABORTED ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (status == TRANSACTION_STATUS_SUB_COMMITTED &amp;&amp; !TransactionIdIsValid(xid)));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(SimpleLruGetBankLock(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, pageno),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LW_EXCLUSIVE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're doing an async commit (ie, lsn is valid), then we must wait<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> active write on the page slot to complete.&nbsp; Otherwise our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update could reach disk in that write, which will not do since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mustn't let it reach disk until we've done the appropriate WAL flush.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * But when lsn is invalid, it's OK to scribble on a page while it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * write-busy, since we don't care if the update reaches disk sooner than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we think.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; slotno = <a href="slru.c.html#L488" title="access/transam/slru.c:488">SimpleLruReadPage</a>(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, pageno, XLogRecPtrIsInvalid(lsn), xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> transaction id, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we update more than one xid on this page while it is being written<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out, we might <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> that some of the bits go to disk and others don't.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are updating commits on the page with the top-level xid that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could break atomicity, so we subcommit the subxids first <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we mark<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the top-level commit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Subtransactions first, if needed ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (status == TRANSACTION_STATUS_COMMITTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nsubxids; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>-&gt;shared-&gt;page_number[slotno] == <a href="#L82" title="access/transam/clog.c:82">TransactionIdToPage</a>(subxids[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L661" title="access/transam/clog.c:661">TransactionIdSetStatusBit</a>(subxids[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRANSACTION_STATUS_SUB_COMMITTED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lsn, slotno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... then the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> transaction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L661" title="access/transam/clog.c:661">TransactionIdSetStatusBit</a>(xid, status, lsn, slotno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set the subtransactions */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nsubxids; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>-&gt;shared-&gt;page_number[slotno] == <a href="#L82" title="access/transam/clog.c:82">TransactionIdToPage</a>(subxids[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L661" title="access/transam/clog.c:661">TransactionIdSetStatusBit</a>(subxids[i], status, lsn, slotno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L110" title="access/transam/clog.c:110">XactCtl</a>-&gt;shared-&gt;page_dirty[slotno] = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine for <a href="#L293" title="access/transam/clog.c:293">TransactionIdSetPageStatus</a>, q.v.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When we cannot immediately acquire the SLRU bank lock in exclusive mode at<br/></li>
<li></span><span class="Comment"> * commit time, add ourselves to a list of processes that need their XIDs<br/></li>
<li></span><span class="Comment"> * status update.&nbsp; The first process to add itself to the list will acquire<br/></li>
<li></span><span class="Comment"> * the lock in exclusive mode and set transaction status as required on behalf<br/></li>
<li></span><span class="Comment"> * of all group members.&nbsp; This avoids a great deal of contention when many<br/></li>
<li></span><span class="Comment"> * processes are trying to commit at once, since the lock need not be<br/></li>
<li></span><span class="Comment"> * repeatedly handed off from one committing process to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true when transaction status has been updated in clog; returns<br/></li>
<li></span><span class="Comment"> * false if we decided against applying the optimization because the page<br/></li>
<li></span><span class="Comment"> * number we need to update differs from those processes already <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L441">&#x200c;</a></span><span class="linkable">TransactionGroupUpdateXidStatus</span>(TransactionId xid, XidStatus status,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr lsn, int64 pageno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> PROC_HDR *procglobal = <a href="../../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>;<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nextidx;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; wakeidx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevpageno;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *prevlock = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We should definitely have an XID whose status needs to be updated. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare to add ourselves to the list of processes needing a group XID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * status update.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; proc-&gt;clogGroupMember = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;clogGroupMemberXid = xid;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;clogGroupMemberXidStatus = status;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;clogGroupMemberPage = pageno;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;clogGroupMemberLsn = lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We put ourselves in the queue by writing <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;clogGroupFirst.&nbsp; However, if there's already a process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * listed there, we <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> our pageno with that of that process; if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * differs, we cannot participate in the group, so we return for caller to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update pg_xact in the normal way.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're not the first process in the list, we must follow the leader.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do this by storing the data we want updated in our PGPROC entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where the leader can <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it, then going to sleep.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If no process is already in the list, we're the leader; our first step<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is to lock the SLRU bank to which our page belongs, then we close out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the group by resetting the list pointer from <a href="../../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;clogGroupFirst<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (this lets other processes set up other groups later); finally we do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the SLRU updates, release the SLRU bank lock, and wake up the sleeping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If another group starts to update a page in a different SLRU bank, they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can proceed concurrently, since the bank lock they're going to use is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different from ours.&nbsp; If another group starts to update a page in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same bank as ours, they wait until we release the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nextidx = pg_atomic_read_u32(&amp;procglobal-&gt;clogGroupFirst);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add the proc to list, if the clog page where we need to update the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current transaction status is same as group leader's clog page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is a race condition here, which is that after doing the below<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check and <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> adding this proc's clog update to a group, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * group leader might have already finished the group update for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page and becomes group leader of another group, updating a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * different page.&nbsp; This will lead to a situation where a single group<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can have different clog page updates.&nbsp; This isn't likely and will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still work, just less efficiently -- we handle this case by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * switching to a different bank lock in the loop below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nextidx != INVALID_PROC_NUMBER &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetPGProcByNumber(nextidx)-&gt;clogGroupMemberPage != proc-&gt;clogGroupMemberPage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ensure that this proc is not a member of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> clog group that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * needs an XID status update.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;clogGroupMember = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_write_u32(&amp;proc-&gt;clogGroupNext, INVALID_PROC_NUMBER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_write_u32(&amp;proc-&gt;clogGroupNext, nextidx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_atomic_compare_exchange_u32(&amp;procglobal-&gt;clogGroupFirst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;nextidx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (uint32) <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the list was not empty, the leader will update the status of our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XID. It is impossible to have followers without a leader because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first process that has added itself to the list will always have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nextidx as INVALID_PROC_NUMBER.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nextidx != INVALID_PROC_NUMBER)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extraWaits = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sleep until the leader updates our XID status. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_XACT_GROUP_UPDATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* acts as a read barrier */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/posix_sema.c.html#L320" title="port/posix_sema.c:320">PGSemaphoreLock</a>(proc-&gt;sem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!proc-&gt;clogGroupMember)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extraWaits++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(pg_atomic_read_u32(&amp;proc-&gt;clogGroupNext) == INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fix semaphore count for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> absorbed wakeups */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (extraWaits-- &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/posix_sema.c.html#L340" title="port/posix_sema.c:340">PGSemaphoreUnlock</a>(proc-&gt;sem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * By here, we know we're the leader process.&nbsp; Acquire the SLRU bank lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that corresponds to the page we originally wanted to modify.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; prevpageno = proc-&gt;clogGroupMemberPage;<br/></li>
<li>&nbsp; &nbsp; prevlock = SimpleLruGetBankLock(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, prevpageno);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(prevlock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we've got the lock, clear the list of processes <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * group XID status update, saving a pointer to the head of the list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Trying to pop elements one at a time could lead to an ABA problem.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> processes trying to do this would create a separate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * group.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nextidx = pg_atomic_exchange_u32(&amp;procglobal-&gt;clogGroupFirst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remember head of list so we can perform wakeups after dropping lock. */<br/></li>
<li></span>&nbsp; &nbsp; wakeidx = nextidx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Walk the list and update the status of all XIDs. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (nextidx != INVALID_PROC_NUMBER)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *nextproc = &amp;<a href="../../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;<a href="../../storage/ipc/procarray.c.html#L271" title="storage/ipc/procarray.c:271">allProcs</a>[nextidx];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thispageno = nextproc-&gt;clogGroupMemberPage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the page to update belongs to a different bank than the previous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one, exchange bank lock to the new one.&nbsp; This should be quite rare,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as described above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (We could try to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> this by waking up the processes for which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we have already updated the status while we exchange the lock, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the code doesn't do that at present.&nbsp; I think it'd require<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * additional bookkeeping, making the common path slower in order to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * improve an infrequent case.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (thispageno != prevpageno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock = SimpleLruGetBankLock(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, thispageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prevlock != lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(prevlock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevlock = lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevpageno = thispageno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Transactions with more than <a href="#L103" title="access/transam/clog.c:103">THRESHOLD_SUBTRANS_CLOG_OPT</a> sub-XIDs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should not use group XID status update mechanism.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nextproc-&gt;subxidStatus.count &lt;= <a href="#L103" title="access/transam/clog.c:103">THRESHOLD_SUBTRANS_CLOG_OPT</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L364" title="access/transam/clog.c:364">TransactionIdSetPageStatusInternal</a>(nextproc-&gt;clogGroupMemberXid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nextproc-&gt;subxidStatus.count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nextproc-&gt;subxids.xids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nextproc-&gt;clogGroupMemberXidStatus,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nextproc-&gt;clogGroupMemberLsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nextproc-&gt;clogGroupMemberPage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Move to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> proc in list. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nextidx = pg_atomic_read_u32(&amp;nextproc-&gt;clogGroupNext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're done with the lock <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (prevlock != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(prevlock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we've released the lock, go back and wake everybody up.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't do this under the lock so as to keep lock hold times to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * minimum.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Perhaps we could do this in two passes, the first setting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clogGroupNext to invalid while saving the semaphores to an array, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a single write barrier, then another pass unlocking the semaphores.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (wakeidx != INVALID_PROC_NUMBER)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *wakeproc = &amp;<a href="../../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;<a href="../../storage/ipc/procarray.c.html#L271" title="storage/ipc/procarray.c:271">allProcs</a>[wakeidx];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wakeidx = pg_atomic_read_u32(&amp;wakeproc-&gt;clogGroupNext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_write_u32(&amp;wakeproc-&gt;clogGroupNext, INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ensure all previous writes are visible <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> follower continues. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_write_barrier();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wakeproc-&gt;clogGroupMember = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wakeproc != <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/posix_sema.c.html#L340" title="port/posix_sema.c:340">PGSemaphoreUnlock</a>(wakeproc-&gt;sem);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sets the commit status of a single transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must hold the corresponding SLRU bank lock, will be held at exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L661">&#x200c;</a></span><span class="linkable">TransactionIdSetStatusBit</span>(TransactionId xid, XidStatus status, XLogRecPtr lsn, <span class="Type">int</span> slotno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byteno = <a href="#L88" title="access/transam/clog.c:88">TransactionIdToByte</a>(xid);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bshift = <a href="#L89" title="access/transam/clog.c:89">TransactionIdToBIndex</a>(xid) * <a href="#L62" title="access/transam/clog.c:62">CLOG_BITS_PER_XACT</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *byteptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; byteval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; curval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>-&gt;shared-&gt;page_number[slotno] == <a href="#L82" title="access/transam/clog.c:82">TransactionIdToPage</a>(xid));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(SimpleLruGetBankLock(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L110" title="access/transam/clog.c:110">XactCtl</a>-&gt;shared-&gt;page_number[slotno]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LW_EXCLUSIVE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; byteptr = <a href="#L110" title="access/transam/clog.c:110">XactCtl</a>-&gt;shared-&gt;page_buffer[slotno] + byteno;<br/></li>
<li>&nbsp; &nbsp; curval = (*byteptr &gt;&gt; bshift) &amp; <a href="#L65" title="access/transam/clog.c:65">CLOG_XACT_BITMASK</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When replaying transactions during recovery we still need to perform<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the two phases of subcommit and then commit. However, some transactions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are already correctly marked, so we just treat those as a no-op which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allows us to keep the following Assert as restrictive as possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a> &amp;&amp; status == TRANSACTION_STATUS_SUB_COMMITTED &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; curval == TRANSACTION_STATUS_COMMITTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Current state change should be from 0 or subcommitted to target state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or we should already be there when replaying changes during recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(curval == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (curval == TRANSACTION_STATUS_SUB_COMMITTED &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status != TRANSACTION_STATUS_IN_PROGRESS) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curval == status);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* note this assumes exclusive access to the clog page */<br/></li>
<li></span>&nbsp; &nbsp; byteval = *byteptr;<br/></li>
<li>&nbsp; &nbsp; byteval &amp;= ~(((<span class="Constant">1</span> &lt;&lt; <a href="#L62" title="access/transam/clog.c:62">CLOG_BITS_PER_XACT</a>) - <span class="Constant">1</span>) &lt;&lt; bshift);<br/></li>
<li>&nbsp; &nbsp; byteval |= (status &lt;&lt; bshift);<br/></li>
<li>&nbsp; &nbsp; *byteptr = byteval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update the group LSN if the transaction completion LSN is higher.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: lsn will be invalid when supplied during <a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a> processing,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so we don't need to do anything special to avoid LSN updates during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery. After recovery completes the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> clog change will set the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LSN correctly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(lsn))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lsnindex = <a href="#L95" title="access/transam/clog.c:95">GetLSNIndex</a>(slotno, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>-&gt;shared-&gt;group_lsn[lsnindex] &lt; lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L110" title="access/transam/clog.c:110">XactCtl</a>-&gt;shared-&gt;group_lsn[lsnindex] = lsn;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Interrogate the state of a transaction in the commit log.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Aside from the actual commit status, this function returns (into *lsn)<br/></li>
<li></span><span class="Comment"> * an LSN that is late enough to be able to guarantee that if we flush up to<br/></li>
<li></span><span class="Comment"> * that LSN then we will have flushed the transaction's commit record to disk.<br/></li>
<li></span><span class="Comment"> * The result is not necessarily the exact LSN of the transaction's commit<br/></li>
<li></span><span class="Comment"> * record!&nbsp; &nbsp; For example, for long-past transactions (those whose clog pages<br/></li>
<li></span><span class="Comment"> * already migrated to disk), we'll return InvalidXLogRecPtr.&nbsp; Also, because<br/></li>
<li></span><span class="Comment"> * we group transactions on the same clog page to conserve storage, we might<br/></li>
<li></span><span class="Comment"> * return the LSN of a later transaction that falls into the same group.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this is a low-level routine and is NOT the preferred entry point<br/></li>
<li></span><span class="Comment"> * for most uses; <a href="transam.c.html#L52" title="access/transam/transam.c:52">TransactionLogFetch</a>() in transam.c is the intended caller.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XidStatus<br/></li>
<li><a id="L735">&#x200c;</a><span class="linkable">TransactionIdGetStatus</span>(TransactionId xid, XLogRecPtr *lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno = <a href="#L82" title="access/transam/clog.c:82">TransactionIdToPage</a>(xid);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byteno = <a href="#L88" title="access/transam/clog.c:88">TransactionIdToByte</a>(xid);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bshift = <a href="#L89" title="access/transam/clog.c:89">TransactionIdToBIndex</a>(xid) * <a href="#L62" title="access/transam/clog.c:62">CLOG_BITS_PER_XACT</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lsnindex;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *byteptr;<br/></li>
<li>&nbsp; &nbsp; XidStatus&nbsp; &nbsp; status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* lock is acquired by <a href="slru.c.html#L591" title="access/transam/slru.c:591">SimpleLruReadPage_ReadOnly</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; slotno = <a href="slru.c.html#L591" title="access/transam/slru.c:591">SimpleLruReadPage_ReadOnly</a>(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, pageno, xid);<br/></li>
<li>&nbsp; &nbsp; byteptr = <a href="#L110" title="access/transam/clog.c:110">XactCtl</a>-&gt;shared-&gt;page_buffer[slotno] + byteno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; status = (*byteptr &gt;&gt; bshift) &amp; <a href="#L65" title="access/transam/clog.c:65">CLOG_XACT_BITMASK</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lsnindex = <a href="#L95" title="access/transam/clog.c:95">GetLSNIndex</a>(slotno, xid);<br/></li>
<li>&nbsp; &nbsp; *lsn = <a href="#L110" title="access/transam/clog.c:110">XactCtl</a>-&gt;shared-&gt;group_lsn[lsnindex];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SimpleLruGetBankLock(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, pageno));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> status;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Number of shared CLOG buffers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If asked to autotune, use 2MB for every 1GB of shared buffers, up to 8MB.<br/></li>
<li></span><span class="Comment"> * Otherwise just cap the configured amount to be between 16 and the maximum<br/></li>
<li></span><span class="Comment"> * allowed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L768">&#x200c;</a></span><span class="linkable">CLOGShmemBuffers</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* auto-tune based on shared buffers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L168" title="utils/init/globals.c:168">transaction_buffers</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="slru.c.html#L217" title="access/transam/slru.c:217">SimpleLruAutotuneBuffers</a>(<span class="Constant">512</span>, <span class="Constant">1024</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(Max(<span class="Constant">16</span>, <a href="../../utils/init/globals.c.html#L168" title="utils/init/globals.c:168">transaction_buffers</a>), <a href="#L72" title="access/transam/clog.c:72">CLOG_MAX_ALLOWED_BUFFERS</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialization of shared memory for CLOG<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L781">&#x200c;</a><span class="linkable">CLOGShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="slru.c.html#L184" title="access/transam/slru.c:184">SimpleLruShmemSize</a>(<a href="#L768" title="access/transam/clog.c:768">CLOGShmemBuffers</a>(), <a href="#L93" title="access/transam/clog.c:93">CLOG_LSNS_PER_PAGE</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L787">&#x200c;</a></span><span class="linkable">CLOGShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If auto-tuning is requested, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> is the time to do it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L168" title="utils/init/globals.c:168">transaction_buffers</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[<span class="Constant">32</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buf), <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="#L768" title="access/transam/clog.c:768">CLOGShmemBuffers</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../../utils/init/globals.c.html#L168" title="utils/init/globals.c:168">transaction_buffers</a>&quot;</span>, buf, PGC_POSTMASTER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_S_DYNAMIC_DEFAULT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We prefer to report this value's source as PGC_S_DYNAMIC_DEFAULT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, if the DBA explicitly set <a href="../../utils/init/globals.c.html#L168" title="utils/init/globals.c:168">transaction_buffers</a> = 0 in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * config file, then PGC_S_DYNAMIC_DEFAULT will fail to override that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and we must force the matter with PGC_S_OVERRIDE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L168" title="utils/init/globals.c:168">transaction_buffers</a> == <span class="Constant">0</span>)&nbsp; &nbsp; <span class="Comment">/* failed to apply it? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../../utils/init/globals.c.html#L168" title="utils/init/globals.c:168">transaction_buffers</a>&quot;</span>, buf, PGC_POSTMASTER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_S_OVERRIDE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../utils/init/globals.c.html#L168" title="utils/init/globals.c:168">transaction_buffers</a> != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L110" title="access/transam/clog.c:110">XactCtl</a>-&gt;PagePrecedes = <a href="#L1055" title="access/transam/clog.c:1055">CLOGPagePrecedes</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="slru.c.html#L238" title="access/transam/slru.c:238">SimpleLruInit</a>(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, <span class="Constant">&quot;transaction&quot;</span>, <a href="#L768" title="access/transam/clog.c:768">CLOGShmemBuffers</a>(), <a href="#L93" title="access/transam/clog.c:93">CLOG_LSNS_PER_PAGE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;pg_xact&quot;</span>, LWTRANCHE_XACT_BUFFER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LWTRANCHE_XACT_SLRU, SYNC_HANDLER_CLOG, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="slru.c.html#L1680" title="access/transam/slru.c:1680">SlruPagePrecedesUnitTests</a>(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, <a href="#L64" title="access/transam/clog.c:64">CLOG_XACTS_PER_PAGE</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for <a href="../../utils/init/globals.c.html#L168" title="utils/init/globals.c:168">transaction_buffers</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L821">&#x200c;</a></span><span class="linkable">check_transaction_buffers</span>(<span class="Type">int</span> *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="slru.c.html#L341" title="access/transam/slru.c:341">check_slru_buffers</a>(<span class="Constant">&quot;<a href="../../utils/init/globals.c.html#L168" title="utils/init/globals.c:168">transaction_buffers</a>&quot;</span>, <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This func must be called ONCE on system install.&nbsp; It creates<br/></li>
<li></span><span class="Comment"> * the initial CLOG segment.&nbsp; (The CLOG directory is assumed to<br/></li>
<li></span><span class="Comment"> * have been created by initdb, and <a href="#L787" title="access/transam/clog.c:787">CLOGShmemInit</a> must have been<br/></li>
<li></span><span class="Comment"> * called already.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L833">&#x200c;</a></span><span class="linkable">BootStrapCLOG</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock = SimpleLruGetBankLock(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create and zero the first page of the commit log */<br/></li>
<li></span>&nbsp; &nbsp; slotno = <a href="#L860" title="access/transam/clog.c:860">ZeroCLOGPage</a>(<span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure it's written out */<br/></li>
<li></span>&nbsp; &nbsp; <a href="slru.c.html#L715" title="access/transam/slru.c:715">SimpleLruWritePage</a>(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, slotno);<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>-&gt;shared-&gt;page_dirty[slotno]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize (or reinitialize) a page of CLOG to zeroes.<br/></li>
<li></span><span class="Comment"> * If writeXlog is true, also emit an XLOG record saying we did this.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The page is not actually written, just set up in shared memory.<br/></li>
<li></span><span class="Comment"> * The slot number of the new page is returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Control lock must be held at entry, and will be held at exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L860">&#x200c;</a></span><span class="linkable">ZeroCLOGPage</span>(int64 pageno, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> writeXlog)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slotno = <a href="slru.c.html#L361" title="access/transam/slru.c:361">SimpleLruZeroPage</a>(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (writeXlog)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="commit_ts.c.html#L989" title="access/transam/commit_ts.c:989">WriteZeroPageXlogRec</a>(pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> slotno;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This must be called ONCE during postmaster or standalone-backend startup,<br/></li>
<li></span><span class="Comment"> * after <a href="xlog.c.html#L5388" title="access/transam/xlog.c:5388">StartupXLOG</a> has initialized <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L877">&#x200c;</a></span><span class="linkable">StartupCLOG</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid = XidFromFullTransactionId(<a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno = <a href="#L82" title="access/transam/clog.c:82">TransactionIdToPage</a>(xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize our idea of the latest page number.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>-&gt;shared-&gt;latest_page_number, pageno);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This must be called ONCE at the end of startup/recovery.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L892">&#x200c;</a></span><span class="linkable">TrimCLOG</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid = XidFromFullTransactionId(<a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno = <a href="#L82" title="access/transam/clog.c:82">TransactionIdToPage</a>(xid);<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock = SimpleLruGetBankLock(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Zero out the remainder of the current clog page.&nbsp; Under normal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * circumstances it should be zeroes already, but it seems at least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * theoretically possible that XLOG replay will have settled on a nextXID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value that is less than the last XID actually used and marked by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previous database lifecycle (since subtransaction commit writes clog<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but makes no WAL entry).&nbsp; Let's just be safe. (We need not worry about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages beyond the current one, since those will be zeroed when first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used.&nbsp; For the same reason, there is no need to do anything when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nextXid is exactly at a page boundary; and it's likely that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;current&quot; page doesn't exist yet in that case.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L87" title="access/transam/clog.c:87">TransactionIdToPgIndex</a>(xid) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; byteno = <a href="#L88" title="access/transam/clog.c:88">TransactionIdToByte</a>(xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bshift = <a href="#L89" title="access/transam/clog.c:89">TransactionIdToBIndex</a>(xid) * <a href="#L62" title="access/transam/clog.c:62">CLOG_BITS_PER_XACT</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *byteptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slotno = <a href="slru.c.html#L488" title="access/transam/slru.c:488">SimpleLruReadPage</a>(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, pageno, <span class="Constant">false</span>, xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; byteptr = <a href="#L110" title="access/transam/clog.c:110">XactCtl</a>-&gt;shared-&gt;page_buffer[slotno] + byteno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Zero so-far-unused positions in the current byte */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *byteptr &amp;= (<span class="Constant">1</span> &lt;&lt; bshift) - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Zero the rest of the page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(byteptr + <span class="Constant">1</span>, <span class="Constant">0</span>, BLCKSZ - byteno - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L110" title="access/transam/clog.c:110">XactCtl</a>-&gt;shared-&gt;page_dirty[slotno] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform a checkpoint --- either during shutdown, or on-the-fly<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L937">&#x200c;</a></span><span class="linkable">CheckPointCLOG</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write dirty CLOG pages to disk.&nbsp; This may result in sync requests<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * queued for later handling by <a href="../../storage/sync/sync.c.html#L286" title="storage/sync/sync.c:286">ProcessSyncRequests</a>(), as part of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TRACE_POSTGRESQL_CLOG_CHECKPOINT_START(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="slru.c.html#L1305" title="access/transam/slru.c:1305">SimpleLruWriteAll</a>(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_CLOG_CHECKPOINT_DONE(<span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make sure that CLOG has room for a newly-allocated XID.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this is called while holding XidGenLock.&nbsp; We want it to be very fast<br/></li>
<li></span><span class="Comment"> * most of the time; even when it's not so fast, no actual I/O need happen<br/></li>
<li></span><span class="Comment"> * unless we're forced to write out a dirty clog or xlog page to make room<br/></li>
<li></span><span class="Comment"> * in shared memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L959">&#x200c;</a></span><span class="linkable">ExtendCLOG</span>(TransactionId newestXact)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No work except at first XID of a page.&nbsp; But beware: just after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wraparound, the first XID of page zero is FirstNormalTransactionId.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L87" title="access/transam/clog.c:87">TransactionIdToPgIndex</a>(newestXact) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdEquals(newestXact, FirstNormalTransactionId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pageno = <a href="#L82" title="access/transam/clog.c:82">TransactionIdToPage</a>(newestXact);<br/></li>
<li>&nbsp; &nbsp; lock = SimpleLruGetBankLock(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Zero the page and make an XLOG entry about it */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L860" title="access/transam/clog.c:860">ZeroCLOGPage</a>(pageno, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove all CLOG segments <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the one holding the passed transaction ID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Before removing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> CLOG data, we must flush XLOG to disk, to ensure<br/></li>
<li></span><span class="Comment"> * that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> recently-emitted FREEZE_PAGE <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> have reached disk; otherwise<br/></li>
<li></span><span class="Comment"> * a crash and restart might leave us with some unfrozen tuples referencing<br/></li>
<li></span><span class="Comment"> * removed CLOG data.&nbsp; We choose to emit a special TRUNCATE XLOG record too.<br/></li>
<li></span><span class="Comment"> * Replaying the deletion from XLOG is not critical, since the files could<br/></li>
<li></span><span class="Comment"> * just as well be removed later, but doing so prevents a long-running hot<br/></li>
<li></span><span class="Comment"> * standby server from acquiring an unreasonably bloated CLOG directory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since CLOG segments hold a large number of transactions, the opportunity to<br/></li>
<li></span><span class="Comment"> * actually remove a segment is fairly rare, and so it seems best not to do<br/></li>
<li></span><span class="Comment"> * the XLOG flush unless we have confirmed that there is a removable segment.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1000">&#x200c;</a></span><span class="linkable">TruncateCLOG</span>(TransactionId oldestXact, Oid oldestxid_datoid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; cutoffPage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The cutoff point is the start of the segment containing oldestXact. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pass the *page* containing oldestXact to <a href="slru.c.html#L1391" title="access/transam/slru.c:1391">SimpleLruTruncate</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cutoffPage = <a href="#L82" title="access/transam/clog.c:82">TransactionIdToPage</a>(oldestXact);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check to see if there's <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> files that could be removed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="slru.c.html#L1774" title="access/transam/slru.c:1774">SlruScanDirectory</a>(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, <a href="slru.c.html#L1695" title="access/transam/slru.c:1695">SlruScanDirCbReportPresence</a>, &amp;cutoffPage))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to remove */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advance oldestClogXid <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> truncating clog, so concurrent xact status<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lookups can ensure they don't attempt to access truncated-away clog.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's only necessary to do this if we will actually truncate away clog<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="varsup.c.html#L355" title="access/transam/varsup.c:355">AdvanceOldestClogXid</a>(oldestXact);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write XLOG record and flush XLOG to disk. We record the oldest xid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're keeping information about here so we can ensure that it's always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ahead of clog truncation in case we crash, and so a standby finds out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the new valid xid <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="commit_ts.c.html#L1000" title="access/transam/commit_ts.c:1000">WriteTruncateXlogRec</a>(cutoffPage, oldestXact, oldestxid_datoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we can remove the old CLOG segment(s) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="slru.c.html#L1391" title="access/transam/slru.c:1391">SimpleLruTruncate</a>(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, cutoffPage);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Decide whether a CLOG page number is &quot;older&quot; for truncation purposes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We need to use comparison of TransactionIds here in order to do the right<br/></li>
<li></span><span class="Comment"> * thing with wraparound XID arithmetic.&nbsp; However, <a href="transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>()<br/></li>
<li></span><span class="Comment"> * would get weird about permanent xact IDs.&nbsp; So, offset both such that xid1,<br/></li>
<li></span><span class="Comment"> * xid2, and xid2 + <a href="#L64" title="access/transam/clog.c:64">CLOG_XACTS_PER_PAGE</a> - 1 are all normal XIDs; this offset<br/></li>
<li></span><span class="Comment"> * is relevant to page 0 and to the page preceding page 0.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The page containing oldestXact-2^31 is the important edge case.&nbsp; The<br/></li>
<li></span><span class="Comment"> * portion of that page equaling or following oldestXact-2^31 is expendable,<br/></li>
<li></span><span class="Comment"> * but the portion preceding oldestXact-2^31 is not.&nbsp; When oldestXact-2^31 is<br/></li>
<li></span><span class="Comment"> * the first XID of a page and segment, the entire page and segment is<br/></li>
<li></span><span class="Comment"> * expendable, and we could truncate the segment.&nbsp; Recognizing that case would<br/></li>
<li></span><span class="Comment"> * require making oldestXact, not just the page containing oldestXact,<br/></li>
<li></span><span class="Comment"> * available to this callback.&nbsp; The benefit would be rare and small, so we<br/></li>
<li></span><span class="Comment"> * don't <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> that edge case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1055">&#x200c;</a></span><span class="linkable">CLOGPagePrecedes</span>(int64 page1, int64 page2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid1;<br/></li>
<li>&nbsp; &nbsp; TransactionId xid2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xid1 = ((TransactionId) page1) * <a href="#L64" title="access/transam/clog.c:64">CLOG_XACTS_PER_PAGE</a>;<br/></li>
<li>&nbsp; &nbsp; xid1 += FirstNormalTransactionId + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; xid2 = ((TransactionId) page2) * <a href="#L64" title="access/transam/clog.c:64">CLOG_XACTS_PER_PAGE</a>;<br/></li>
<li>&nbsp; &nbsp; xid2 += FirstNormalTransactionId + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid1, xid2) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid1, xid2 + <a href="#L64" title="access/transam/clog.c:64">CLOG_XACTS_PER_PAGE</a> - <span class="Constant">1</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write a ZEROPAGE xlog record<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1074">&#x200c;</a></span><span class="linkable">WriteZeroPageXlogRec</span>(int64 pageno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;pageno), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pageno));<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_CLOG_ID, CLOG_ZEROPAGE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write a TRUNCATE xlog record<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We must flush the xlog record to disk <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning --- see notes<br/></li>
<li></span><span class="Comment"> * in <a href="#L1000" title="access/transam/clog.c:1000">TruncateCLOG</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1088">&#x200c;</a></span><span class="linkable">WriteTruncateXlogRec</span>(int64 pageno, TransactionId oldestXact, Oid oldestXactDb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; xl_clog_truncate xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec.pageno = pageno;<br/></li>
<li>&nbsp; &nbsp; xlrec.oldestXact = oldestXact;<br/></li>
<li>&nbsp; &nbsp; xlrec.oldestXactDb = oldestXactDb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xlrec), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_clog_truncate));<br/></li>
<li>&nbsp; &nbsp; recptr = <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_CLOG_ID, CLOG_TRUNCATE);<br/></li>
<li>&nbsp; &nbsp; <a href="xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(recptr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * CLOG resource manager's routines<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1107">&#x200c;</a></span><span class="linkable">clog_redo</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(record) &amp; ~XLR_INFO_MASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Backup blocks are not used in clog <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!XLogRecHasAnyBlockRefs(record));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (info == CLOG_ZEROPAGE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;pageno, XLogRecGetData(record), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pageno));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock = SimpleLruGetBankLock(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, pageno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slotno = <a href="#L860" title="access/transam/clog.c:860">ZeroCLOGPage</a>(pageno, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slru.c.html#L715" title="access/transam/slru.c:715">SimpleLruWritePage</a>(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, slotno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>-&gt;shared-&gt;page_dirty[slotno]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == CLOG_TRUNCATE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_clog_truncate xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;xlrec, XLogRecGetData(record), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_clog_truncate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="varsup.c.html#L355" title="access/transam/varsup.c:355">AdvanceOldestClogXid</a>(xlrec.oldestXact);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slru.c.html#L1391" title="access/transam/slru.c:1391">SimpleLruTruncate</a>(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, xlrec.pageno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;<a href="#L1107" title="access/transam/clog.c:1107">clog_redo</a>: unknown op code </span><span class="Special">%u</span><span class="Constant">&quot;</span>, info);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Entrypoint for sync.c to sync clog files.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1149">&#x200c;</a></span><span class="linkable">clogsyncfiletag</span>(<span class="Type">const</span> FileTag *ftag, <span class="Type">char</span> *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="slru.c.html#L1814" title="access/transam/slru.c:1814">SlruSyncFileTag</a>(<a href="#L110" title="access/transam/clog.c:110">XactCtl</a>, ftag, path);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
