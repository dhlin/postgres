<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/transam/xloginsert.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/transam/xloginsert.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L132">begininsert_called</a></li>
<li><a href="#L103">curinsert_flags</a></li>
<li><a href="#L113">hdr_rdt</a></li>
<li><a href="#L114">hdr_scratch</a></li>
<li><a href="#L98">mainrdata_head</a></li>
<li><a href="#L99">mainrdata_last</a></li>
<li><a href="#L100">mainrdata_len</a></li>
<li><a href="#L130">max_rdatas</a></li>
<li><a href="#L91">max_registered_block_id</a></li>
<li><a href="#L90">max_registered_buffers</a></li>
<li><a href="#L129">num_rdatas</a></li>
<li><a href="#L128">rdatas</a></li>
<li><a href="#L89">registered_buffers</a></li>
<li><a href="#L135">xloginsert_cxt</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L87">registered_buffer</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1348">InitXLogInsert</a></li>
<li><a href="#L149">XLogBeginInsert</a></li>
<li><a href="#L1027">XLogCheckBufferNeedsBackup</a></li>
<li><a href="#L944">XLogCompressBackupBlock</a></li>
<li><a href="#L175">XLogEnsureRecordSpace</a></li>
<li><a href="#L474">XLogInsert</a></li>
<li><a href="#L548">XLogRecordAssemble</a></li>
<li><a href="#L309">XLogRegisterBlock</a></li>
<li><a href="#L405">XLogRegisterBufData</a></li>
<li><a href="#L242">XLogRegisterBuffer</a></li>
<li><a href="#L364">XLogRegisterData</a></li>
<li><a href="#L222">XLogResetInsertion</a></li>
<li><a href="#L1065">XLogSaveBufferForHint</a></li>
<li><a href="#L456">XLogSetRecordFlags</a></li>
<li><a href="#L1143">log_newpage</a></li>
<li><a href="#L1237">log_newpage_buffer</a></li>
<li><a href="#L1270">log_newpage_range</a></li>
<li><a href="#L1175">log_newpages</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L62">COMPRESS_BUFSIZE</a></li>
<li><a href="#L119">HEADER_SCRATCH_SIZE</a></li>
<li><a href="#L48">LZ4_MAX_BLCKSZ</a></li>
<li><a href="#L50">LZ4_MAX_BLCKSZ</a></li>
<li><a href="#L59">PGLZ_MAX_BLCKSZ</a></li>
<li><a href="#L117">SizeOfXLogTransactionId</a></li>
<li><a href="#L116">SizeOfXlogOrigin</a></li>
<li><a href="#L54">ZSTD_MAX_BLCKSZ</a></li>
<li><a href="#L56">ZSTD_MAX_BLCKSZ</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * xloginsert.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Functions for constructing WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Constructing a WAL record begins with a call to <a href="#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>,<br/></li>
<li></span><span class="Comment"> * followed by a number of XLogRegister* calls. The registered data is<br/></li>
<li></span><span class="Comment"> * collected in private working memory, and finally assembled into a chain<br/></li>
<li></span><span class="Comment"> * of XLogRecData structs by a call to <a href="#L548" title="access/transam/xloginsert.c:548">XLogRecordAssemble</a>(). See<br/></li>
<li></span><span class="Comment"> * access/transam/README for details.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * src/backend/access/transam/xloginsert.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_LZ4<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;lz4.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_ZSTD<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;zstd.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_control.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/pg_lzcompress.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pg_trace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/origin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Guess the maximum buffer size required to store a compressed version of<br/></li>
<li></span><span class="Comment"> * backup block image.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef USE_LZ4<br/></li>
<li><a id="L48">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; <span class="linkable">LZ4_MAX_BLCKSZ</span>&nbsp; &nbsp; &nbsp; &nbsp; LZ4_COMPRESSBOUND(BLCKSZ)<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L50">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LZ4_MAX_BLCKSZ</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_ZSTD<br/></li>
<li><a id="L54">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ZSTD_MAX_BLCKSZ</span>&nbsp; &nbsp; &nbsp; &nbsp; ZSTD_COMPRESSBOUND(BLCKSZ)<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L56">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ZSTD_MAX_BLCKSZ</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L59">&#x200c;</a><span class="PreProc">#define <span class="linkable">PGLZ_MAX_BLCKSZ</span>&nbsp; &nbsp; &nbsp; &nbsp; PGLZ_MAX_OUTPUT(BLCKSZ)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Buffer size required to store a compressed version of backup block image */<br/></li>
<li><a id="L62">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">COMPRESS_BUFSIZE</span>&nbsp; &nbsp; Max(Max(<a href="#L59" title="access/transam/xloginsert.c:59">PGLZ_MAX_BLCKSZ</a>, <a href="#L48" title="access/transam/xloginsert.c:48">LZ4_MAX_BLCKSZ</a>), <a href="#L54" title="access/transam/xloginsert.c:54">ZSTD_MAX_BLCKSZ</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * For each block reference registered with <a href="#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>, we fill in<br/></li>
<li></span><span class="Comment"> * a <a href="#L87" title="access/transam/xloginsert.c:87">registered_buffer</a> struct.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; in_use;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* is this slot in use? */<br/></li>
<li></span>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* REGBUF_* flags */<br/></li>
<li></span>&nbsp; &nbsp; RelFileLocator rlocator;&nbsp; &nbsp; <span class="Comment">/* identifies the relation and block */<br/></li>
<li></span>&nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forkno;<br/></li>
<li>&nbsp; &nbsp; BlockNumber block;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* page content */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; rdata_len;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* total length of data in rdata chain */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecData *rdata_head;&nbsp; &nbsp; <span class="Comment">/* head of the chain of data registered with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this block */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecData *rdata_tail;&nbsp; &nbsp; <span class="Comment">/* last entry in the chain, or &amp;rdata_head if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * empty */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; XLogRecData bkp_rdatas[<span class="Constant">2</span>];&nbsp; &nbsp; <span class="Comment">/* temporary <a href="#L128" title="access/transam/xloginsert.c:128">rdatas</a> used to hold references to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backup block data in <a href="#L548" title="access/transam/xloginsert.c:548">XLogRecordAssemble</a>() */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* buffer to store a compressed version of backup block image */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; compressed_page[<a href="#L62" title="access/transam/xloginsert.c:62">COMPRESS_BUFSIZE</a>];<br/></li>
<li><a id="L87">&#x200c;</a>} <span class="linkable">registered_buffer</span>;<br/></li>
<li><br/></li>
<li><a id="L89">&#x200c;</a><span class="Type">static</span> <a href="#L87" title="access/transam/xloginsert.c:87">registered_buffer</a> *<span class="linkable">registered_buffers</span>;<br/></li>
<li><a id="L90">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">max_registered_buffers</span>; <span class="Comment">/* allocated size */<br/></li>
<li><a id="L91">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">max_registered_block_id</span> = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* highest block_id + 1 currently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * registered */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A chain of XLogRecDatas to hold the &quot;<a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> data&quot; of a WAL record, registered<br/></li>
<li></span><span class="Comment"> * with <a href="#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>(...).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L98">&#x200c;</a></span><span class="Type">static</span> XLogRecData *<span class="linkable">mainrdata_head</span>;<br/></li>
<li><a id="L99">&#x200c;</a><span class="Type">static</span> XLogRecData *<span class="linkable">mainrdata_last</span> = (XLogRecData *) &amp;<a href="#L98" title="access/transam/xloginsert.c:98">mainrdata_head</a>;<br/></li>
<li><a id="L100">&#x200c;</a><span class="Type">static</span> uint64 <span class="linkable">mainrdata_len</span>;&nbsp; &nbsp; <span class="Comment">/* total # of bytes in chain */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* flags for the in-progress insertion */<br/></li>
<li><a id="L103">&#x200c;</a></span><span class="Type">static</span> uint8 <span class="linkable">curinsert_flags</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These are used to hold the record header while constructing a record.<br/></li>
<li></span><span class="Comment"> * '<a href="#L114" title="access/transam/xloginsert.c:114">hdr_scratch</a>' is not a plain variable, but is <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d at initialization,<br/></li>
<li></span><span class="Comment"> * because we want it to be MAXALIGNed and padding bytes zeroed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For simplicity, it's allocated large enough to hold the headers for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * WAL record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L113">&#x200c;</a></span><span class="Type">static</span> XLogRecData <span class="linkable">hdr_rdt</span>;<br/></li>
<li><a id="L114">&#x200c;</a><span class="Type">static</span> <span class="Type">char</span> *<span class="linkable">hdr_scratch</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><a id="L116">&#x200c;</a><span class="PreProc">#define <span class="linkable">SizeOfXlogOrigin</span>&nbsp; &nbsp; (</span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(RepOriginId) + </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(</span><span class="Type">char</span><span class="PreProc">))<br/></li>
<li><a id="L117">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SizeOfXLogTransactionId</span>&nbsp; &nbsp; (</span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(TransactionId) + </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(</span><span class="Type">char</span><span class="PreProc">))<br/></li>
<li></span><br/></li>
<li><a id="L119">&#x200c;</a><span class="PreProc">#define <span class="linkable">HEADER_SCRATCH_SIZE</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (SizeOfXLogRecord + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; MaxSizeOfXLogRecordBlockHeader * (XLR_MAX_BLOCK_ID + </span><span class="Constant">1</span><span class="PreProc">) + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; SizeOfXLogRecordDataHeaderLong + <a href="#L116" title="access/transam/xloginsert.c:116">SizeOfXlogOrigin</a> + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; <a href="#L117" title="access/transam/xloginsert.c:117">SizeOfXLogTransactionId</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * An array of XLogRecData structs, to hold registered data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L128">&#x200c;</a></span><span class="Type">static</span> XLogRecData *<span class="linkable">rdatas</span>;<br/></li>
<li><a id="L129">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">num_rdatas</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* entries currently used */<br/></li>
<li><a id="L130">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">max_rdatas</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocated size */<br/></li>
<li></span><br/></li>
<li><a id="L132">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">begininsert_called</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Memory context to hold the registered buffer and data references. */<br/></li>
<li><a id="L135">&#x200c;</a></span><span class="Type">static</span> MemoryContext <span class="linkable">xloginsert_cxt</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> XLogRecData *<a href="#L548" title="access/transam/xloginsert.c:548">XLogRecordAssemble</a>(RmgrId rmid, uint8 info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr <a href="xlog.c.html#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="xlog.c.html#L286" title="access/transam/xlog.c:286">doPageWrites</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr *fpw_lsn, <span class="Type">int</span> *num_fpi,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *topxid_included);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L944" title="access/transam/xloginsert.c:944">XLogCompressBackupBlock</a>(<span class="Type">char</span> *page, uint16 hole_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16 hole_length, <span class="Type">char</span> *dest, uint16 *dlen);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Begin constructing a WAL record. This must be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment"> * XLogRegister* <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> and <a href="#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L149">&#x200c;</a></span><span class="linkable">XLogBeginInsert</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L91" title="access/transam/xloginsert.c:91">max_registered_block_id</a> == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L99" title="access/transam/xloginsert.c:99">mainrdata_last</a> == (XLogRecData *) &amp;<a href="#L98" title="access/transam/xloginsert.c:98">mainrdata_head</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L100" title="access/transam/xloginsert.c:100">mainrdata_len</a> == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cross-check on whether we should be here or not */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="xlog.c.html#L6345" title="access/transam/xlog.c:6345">XLogInsertAllowed</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot make new WAL entries during recovery&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L132" title="access/transam/xloginsert.c:132">begininsert_called</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a> was already called&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L132" title="access/transam/xloginsert.c:132">begininsert_called</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Ensure that there are enough buffer and data slots in the working area,<br/></li>
<li></span><span class="Comment"> * for subsequent <a href="#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>, <a href="#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a> and <a href="#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a><br/></li>
<li></span><span class="Comment"> * calls.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There is always space for a small number of buffers and data chunks, enough<br/></li>
<li></span><span class="Comment"> * for most record types. This function is for the exceptional cases that need<br/></li>
<li></span><span class="Comment"> * more.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L175">&#x200c;</a></span><span class="linkable">XLogEnsureRecordSpace</span>(<span class="Type">int</span> max_block_id, <span class="Type">int</span> ndatas)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbuffers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This must be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> entering a critical section, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocating memory inside a critical section can fail. <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>() will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check the same, but better to check it here too so that we fail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consistently even if the arrays happen to be large enough already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../utils/init/globals.c.html#L43" title="utils/init/globals.c:43">CritSectionCount</a> == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the minimum <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> can't be decreased */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (max_block_id &lt; XLR_NORMAL_MAX_BLOCK_ID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; max_block_id = XLR_NORMAL_MAX_BLOCK_ID;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndatas &lt; XLR_NORMAL_RDATAS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndatas = XLR_NORMAL_RDATAS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (max_block_id &gt; XLR_MAX_BLOCK_ID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;maximum number of WAL record block references exceeded&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; nbuffers = max_block_id + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nbuffers &gt; <a href="#L90" title="access/transam/xloginsert.c:90">max_registered_buffers</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L89" title="access/transam/xloginsert.c:89">registered_buffers</a> = (<a href="#L87" title="access/transam/xloginsert.c:87">registered_buffer</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(<a href="#L89" title="access/transam/xloginsert.c:89">registered_buffers</a>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L87" title="access/transam/xloginsert.c:87">registered_buffer</a>) * nbuffers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At least the padding bytes in the structs must be zeroed, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they are included in WAL data, but <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it all for tidiness.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(&amp;<a href="#L89" title="access/transam/xloginsert.c:89">registered_buffers</a>[<a href="#L90" title="access/transam/xloginsert.c:90">max_registered_buffers</a>], <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (nbuffers - <a href="#L90" title="access/transam/xloginsert.c:90">max_registered_buffers</a>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L87" title="access/transam/xloginsert.c:87">registered_buffer</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L90" title="access/transam/xloginsert.c:90">max_registered_buffers</a> = nbuffers;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndatas &gt; <a href="#L130" title="access/transam/xloginsert.c:130">max_rdatas</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L128" title="access/transam/xloginsert.c:128">rdatas</a> = (XLogRecData *) <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(<a href="#L128" title="access/transam/xloginsert.c:128">rdatas</a>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(XLogRecData) * ndatas);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L130" title="access/transam/xloginsert.c:130">max_rdatas</a> = ndatas;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reset WAL record construction buffers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L222">&#x200c;</a></span><span class="linkable">XLogResetInsertion</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L91" title="access/transam/xloginsert.c:91">max_registered_block_id</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L89" title="access/transam/xloginsert.c:89">registered_buffers</a>[i].in_use = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L129" title="access/transam/xloginsert.c:129">num_rdatas</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L91" title="access/transam/xloginsert.c:91">max_registered_block_id</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="access/transam/xloginsert.c:100">mainrdata_len</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L99" title="access/transam/xloginsert.c:99">mainrdata_last</a> = (XLogRecData *) &amp;<a href="#L98" title="access/transam/xloginsert.c:98">mainrdata_head</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L103" title="access/transam/xloginsert.c:103">curinsert_flags</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L132" title="access/transam/xloginsert.c:132">begininsert_called</a> = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Register a reference to a buffer with the WAL record being constructed.<br/></li>
<li></span><span class="Comment"> * This must be called for every page that the WAL-logged operation modifies.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L242">&#x200c;</a></span><span class="linkable">XLogRegisterBuffer</span>(uint8 block_id, Buffer buffer, uint8 flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L87" title="access/transam/xloginsert.c:87">registered_buffer</a> *regbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NO_IMAGE doesn't make sense with FORCE_IMAGE */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!((flags &amp; REGBUF_FORCE_IMAGE) &amp;&amp; (flags &amp; (REGBUF_NO_IMAGE))));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L132" title="access/transam/xloginsert.c:132">begininsert_called</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ordinarily, buffer should be exclusive-locked and marked dirty <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we get here, otherwise we could end up violating one of the rules in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * access/transam/README.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some callers intentionally register a clean page and never update that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page's LSN; in that case they can pass the flag REGBUF_NO_CHANGE to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bypass these checks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(flags &amp; REGBUF_NO_CHANGE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../storage/buffer/bufmgr.c.html#L2413" title="storage/buffer/bufmgr.c:2413">BufferIsExclusiveLocked</a>(buffer) &amp;&amp; <a href="../../storage/buffer/bufmgr.c.html#L2442" title="storage/buffer/bufmgr.c:2442">BufferIsDirty</a>(buffer));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (block_id &gt;= <a href="#L91" title="access/transam/xloginsert.c:91">max_registered_block_id</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block_id &gt;= <a href="#L90" title="access/transam/xloginsert.c:90">max_registered_buffers</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too many registered buffers&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L91" title="access/transam/xloginsert.c:91">max_registered_block_id</a> = block_id + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; regbuf = &amp;<a href="#L89" title="access/transam/xloginsert.c:89">registered_buffers</a>[block_id];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3688" title="storage/buffer/bufmgr.c:3688">BufferGetTag</a>(buffer, &amp;regbuf-&gt;rlocator, &amp;regbuf-&gt;forkno, &amp;regbuf-&gt;block);<br/></li>
<li>&nbsp; &nbsp; regbuf-&gt;page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; regbuf-&gt;flags = flags;<br/></li>
<li>&nbsp; &nbsp; regbuf-&gt;rdata_tail = (XLogRecData *) &amp;regbuf-&gt;rdata_head;<br/></li>
<li>&nbsp; &nbsp; regbuf-&gt;rdata_len = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that this page hasn't already been registered with some other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * block_id.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L91" title="access/transam/xloginsert.c:91">max_registered_block_id</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="access/transam/xloginsert.c:87">registered_buffer</a> *regbuf_old = &amp;<a href="#L89" title="access/transam/xloginsert.c:89">registered_buffers</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == block_id || !regbuf_old-&gt;in_use)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!RelFileLocatorEquals(regbuf_old-&gt;rlocator, regbuf-&gt;rlocator) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; regbuf_old-&gt;forkno != regbuf-&gt;forkno ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; regbuf_old-&gt;block != regbuf-&gt;block);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; regbuf-&gt;in_use = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Like <a href="#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>, but for registering a block that's not in the<br/></li>
<li></span><span class="Comment"> * shared buffer pool (i.e. when you don't have a Buffer for it).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L309">&#x200c;</a></span><span class="linkable">XLogRegisterBlock</span>(uint8 block_id, RelFileLocator *rlocator, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blknum, Page page, uint8 flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L87" title="access/transam/xloginsert.c:87">registered_buffer</a> *regbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L132" title="access/transam/xloginsert.c:132">begininsert_called</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (block_id &gt;= <a href="#L91" title="access/transam/xloginsert.c:91">max_registered_block_id</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L91" title="access/transam/xloginsert.c:91">max_registered_block_id</a> = block_id + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (block_id &gt;= <a href="#L90" title="access/transam/xloginsert.c:90">max_registered_buffers</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too many registered buffers&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; regbuf = &amp;<a href="#L89" title="access/transam/xloginsert.c:89">registered_buffers</a>[block_id];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; regbuf-&gt;rlocator = *rlocator;<br/></li>
<li>&nbsp; &nbsp; regbuf-&gt;forkno = forknum;<br/></li>
<li>&nbsp; &nbsp; regbuf-&gt;block = blknum;<br/></li>
<li>&nbsp; &nbsp; regbuf-&gt;page = page;<br/></li>
<li>&nbsp; &nbsp; regbuf-&gt;flags = flags;<br/></li>
<li>&nbsp; &nbsp; regbuf-&gt;rdata_tail = (XLogRecData *) &amp;regbuf-&gt;rdata_head;<br/></li>
<li>&nbsp; &nbsp; regbuf-&gt;rdata_len = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that this page hasn't already been registered with some other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * block_id.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L91" title="access/transam/xloginsert.c:91">max_registered_block_id</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="access/transam/xloginsert.c:87">registered_buffer</a> *regbuf_old = &amp;<a href="#L89" title="access/transam/xloginsert.c:89">registered_buffers</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == block_id || !regbuf_old-&gt;in_use)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!RelFileLocatorEquals(regbuf_old-&gt;rlocator, regbuf-&gt;rlocator) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; regbuf_old-&gt;forkno != regbuf-&gt;forkno ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; regbuf_old-&gt;block != regbuf-&gt;block);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; regbuf-&gt;in_use = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add data to the WAL record that's being constructed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The data is appended to the &quot;<a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> chunk&quot;, available at replay with<br/></li>
<li></span><span class="Comment"> * XLogRecGetData().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L364">&#x200c;</a></span><span class="linkable">XLogRegisterData</span>(<span class="Type">char</span> *data, uint32 len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecData *rdata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L132" title="access/transam/xloginsert.c:132">begininsert_called</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L129" title="access/transam/xloginsert.c:129">num_rdatas</a> &gt;= <a href="#L130" title="access/transam/xloginsert.c:130">max_rdatas</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;too much WAL data&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant"> out of </span><span class="Special">%d</span><span class="Constant"> data segments are already in use.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="access/transam/xloginsert.c:129">num_rdatas</a>, <a href="#L130" title="access/transam/xloginsert.c:130">max_rdatas</a>)));<br/></li>
<li>&nbsp; &nbsp; rdata = &amp;<a href="#L128" title="access/transam/xloginsert.c:128">rdatas</a>[<a href="#L129" title="access/transam/xloginsert.c:129">num_rdatas</a>++];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rdata-&gt;data = data;<br/></li>
<li>&nbsp; &nbsp; rdata-&gt;len = len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we use the <a href="#L99" title="access/transam/xloginsert.c:99">mainrdata_last</a> pointer to track the end of the chain, so no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to clear '<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>' here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L99" title="access/transam/xloginsert.c:99">mainrdata_last</a>-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = rdata;<br/></li>
<li>&nbsp; &nbsp; <a href="#L99" title="access/transam/xloginsert.c:99">mainrdata_last</a> = rdata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="access/transam/xloginsert.c:100">mainrdata_len</a> += len;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add buffer-specific data to the WAL record that's being constructed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Block_id must reference a block previously registered with<br/></li>
<li></span><span class="Comment"> * <a href="#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(). If this is called more than once for the same<br/></li>
<li></span><span class="Comment"> * block_id, the data is appended.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The maximum amount of data that can be registered per block is 65535<br/></li>
<li></span><span class="Comment"> * bytes. That should be plenty; if you need more than BLCKSZ bytes to<br/></li>
<li></span><span class="Comment"> * reconstruct the changes to the page, you might as well just log a full<br/></li>
<li></span><span class="Comment"> * copy of it. (the &quot;<a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> data&quot; that's not associated with a block is not<br/></li>
<li></span><span class="Comment"> * limited)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L405">&#x200c;</a></span><span class="linkable">XLogRegisterBufData</span>(uint8 block_id, <span class="Type">char</span> *data, uint32 len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L87" title="access/transam/xloginsert.c:87">registered_buffer</a> *regbuf;<br/></li>
<li>&nbsp; &nbsp; XLogRecData *rdata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L132" title="access/transam/xloginsert.c:132">begininsert_called</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the registered buffer struct */<br/></li>
<li></span>&nbsp; &nbsp; regbuf = &amp;<a href="#L89" title="access/transam/xloginsert.c:89">registered_buffers</a>[block_id];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!regbuf-&gt;in_use)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no block with id </span><span class="Special">%d</span><span class="Constant"> registered with WAL insertion&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; block_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check against <a href="#L130" title="access/transam/xloginsert.c:130">max_rdatas</a> and ensure we do not register more data per<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer than can be handled by the physical data format; i.e. that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regbuf-&gt;rdata_len does not grow beyond what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLogRecordBlockHeader-&gt;data_length can hold.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L129" title="access/transam/xloginsert.c:129">num_rdatas</a> &gt;= <a href="#L130" title="access/transam/xloginsert.c:130">max_rdatas</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;too much WAL data&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant"> out of </span><span class="Special">%d</span><span class="Constant"> data segments are already in use.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="access/transam/xloginsert.c:129">num_rdatas</a>, <a href="#L130" title="access/transam/xloginsert.c:130">max_rdatas</a>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (regbuf-&gt;rdata_len + len &gt; <span class="Constant">UINT16_MAX</span> || len &gt; <span class="Constant">UINT16_MAX</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;too much WAL data&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;Registering more than maximum </span><span class="Special">%u</span><span class="Constant"> bytes allowed to block </span><span class="Special">%u</span><span class="Constant">: current </span><span class="Special">%u</span><span class="Constant"> bytes, adding </span><span class="Special">%u</span><span class="Constant"> bytes.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">UINT16_MAX</span>, block_id, regbuf-&gt;rdata_len, len)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rdata = &amp;<a href="#L128" title="access/transam/xloginsert.c:128">rdatas</a>[<a href="#L129" title="access/transam/xloginsert.c:129">num_rdatas</a>++];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rdata-&gt;data = data;<br/></li>
<li>&nbsp; &nbsp; rdata-&gt;len = len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; regbuf-&gt;rdata_tail-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = rdata;<br/></li>
<li>&nbsp; &nbsp; regbuf-&gt;rdata_tail = rdata;<br/></li>
<li>&nbsp; &nbsp; regbuf-&gt;rdata_len += len;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set insert status flags for the upcoming WAL record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The flags that can be used here are:<br/></li>
<li></span><span class="Comment"> * - XLOG_INCLUDE_ORIGIN, to determine if the replication origin should be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; included in the record.<br/></li>
<li></span><span class="Comment"> * - XLOG_MARK_UNIMPORTANT, to signal that the record is not important for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; durability, which allows to avoid triggering WAL archiving and other<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; background activity.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L456">&#x200c;</a></span><span class="linkable">XLogSetRecordFlags</span>(uint8 flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L132" title="access/transam/xloginsert.c:132">begininsert_called</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L103" title="access/transam/xloginsert.c:103">curinsert_flags</a> |= flags;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> an XLOG record having the specified RMID and info bytes, with the<br/></li>
<li></span><span class="Comment"> * body of the record being the data and buffer references registered earlier<br/></li>
<li></span><span class="Comment"> * with XLogRegister* calls.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns XLOG pointer to end of record (beginning of <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> record).<br/></li>
<li></span><span class="Comment"> * This can be used as LSN for data pages affected by the logged action.<br/></li>
<li></span><span class="Comment"> * (LSN is the XLOG point up to which the XLOG must be flushed to disk<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the data page can be written out.&nbsp; This implements the basic<br/></li>
<li></span><span class="Comment"> * WAL rule &quot;write the log <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the data&quot;.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L474">&#x200c;</a><span class="linkable">XLogInsert</span>(RmgrId rmid, uint8 info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; EndPos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>() must have been called. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L132" title="access/transam/xloginsert.c:132">begininsert_called</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a> was not called&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The caller can set rmgr bits, XLR_SPECIAL_REL_UPDATE and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLR_CHECK_CONSISTENCY; the rest are reserved for use by me.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((info &amp; ~(XLR_RMGR_INFO_MASK |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLR_SPECIAL_REL_UPDATE |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLR_CHECK_CONSISTENCY)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;invalid xlog info mask </span><span class="Special">%02X</span><span class="Constant">&quot;</span>, info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_WAL_INSERT(rmid, info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In bootstrap mode, we don't actually log anything but XLOG resources;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return a phony record pointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode() &amp;&amp; rmid != RM_XLOG_ID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L222" title="access/transam/xloginsert.c:222">XLogResetInsertion</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EndPos = SizeOfXLogLongPHD; <span class="Comment">/* start of 1st chkpt record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> EndPos;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; <a href="xlog.c.html#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L286" title="access/transam/xlog.c:286">doPageWrites</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; topxid_included = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; fpw_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecData *rdt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_fpi = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> needed to decide whether to do full-page writes. Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't yet have an insertion lock, these could change under us,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but <a href="xlog.c.html#L743" title="access/transam/xlog.c:743">XLogInsertRecord</a> will recheck them once it has a lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L6423" title="access/transam/xlog.c:6423">GetFullPageWriteInfo</a>(&amp;<a href="xlog.c.html#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>, &amp;<a href="xlog.c.html#L286" title="access/transam/xlog.c:286">doPageWrites</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rdt = <a href="#L548" title="access/transam/xloginsert.c:548">XLogRecordAssemble</a>(rmid, info, <a href="xlog.c.html#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>, <a href="xlog.c.html#L286" title="access/transam/xlog.c:286">doPageWrites</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;fpw_lsn, &amp;num_fpi, &amp;topxid_included);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EndPos = <a href="xlog.c.html#L743" title="access/transam/xlog.c:743">XLogInsertRecord</a>(rdt, fpw_lsn, <a href="#L103" title="access/transam/xloginsert.c:103">curinsert_flags</a>, num_fpi,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; topxid_included);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (EndPos == InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L222" title="access/transam/xloginsert.c:222">XLogResetInsertion</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> EndPos;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Assemble a WAL record from the registered data and buffers into an<br/></li>
<li></span><span class="Comment"> * XLogRecData chain, ready for insertion with <a href="xlog.c.html#L743" title="access/transam/xlog.c:743">XLogInsertRecord</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The record header fields are filled in, except for the xl_prev field. The<br/></li>
<li></span><span class="Comment"> * calculated CRC does not include the record header yet.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> registered buffers, and a full-page image was not taken<br/></li>
<li></span><span class="Comment"> * of all of them, *fpw_lsn is set to the lowest LSN among such pages. This<br/></li>
<li></span><span class="Comment"> * signals that the assembled record is only good for insertion on the<br/></li>
<li></span><span class="Comment"> * assumption that the <a href="xlog.c.html#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> and <a href="xlog.c.html#L286" title="access/transam/xlog.c:286">doPageWrites</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> were up-to-date.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *topxid_included is set if the topmost transaction ID is logged with the<br/></li>
<li></span><span class="Comment"> * current subtransaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> XLogRecData *<br/></li>
<li><a id="L548">&#x200c;</a><span class="linkable">XLogRecordAssemble</span>(RmgrId rmid, uint8 info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr <a href="xlog.c.html#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="xlog.c.html#L286" title="access/transam/xlog.c:286">doPageWrites</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr *fpw_lsn, <span class="Type">int</span> *num_fpi, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *topxid_included)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecData *rdt;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; total_len = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block_id;<br/></li>
<li>&nbsp; &nbsp; pg_crc32c&nbsp; &nbsp; rdata_crc;<br/></li>
<li>&nbsp; &nbsp; <a href="#L87" title="access/transam/xloginsert.c:87">registered_buffer</a> *prev_regbuf = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; XLogRecData *rdt_datas_last;<br/></li>
<li>&nbsp; &nbsp; XLogRecord *rechdr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *scratch = <a href="#L114" title="access/transam/xloginsert.c:114">hdr_scratch</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: this function can be called multiple times for the same record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All the modifications we do to the rdata chains below must handle that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The record begins with the fixed-size header */<br/></li>
<li></span>&nbsp; &nbsp; rechdr = (XLogRecord *) scratch;<br/></li>
<li>&nbsp; &nbsp; scratch += SizeOfXLogRecord;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L113" title="access/transam/xloginsert.c:113">hdr_rdt</a>.<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; rdt_datas_last = &amp;<a href="#L113" title="access/transam/xloginsert.c:113">hdr_rdt</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L113" title="access/transam/xloginsert.c:113">hdr_rdt</a>.data = <a href="#L114" title="access/transam/xloginsert.c:114">hdr_scratch</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Enforce consistency checks for this record if user is looking for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> at the beginning of this routine to give the possibility<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for callers of <a href="#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>() to pass XLR_CHECK_CONSISTENCY directly for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlog.c.html#L126" title="access/transam/xlog.c:126">wal_consistency_checking</a>[rmid])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info |= XLR_CHECK_CONSISTENCY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make an rdata chain containing all the data portions of all block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * references. This includes the data for full-page images. Also append<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the headers for the block references in the scratch buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *fpw_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (block_id = <span class="Constant">0</span>; block_id &lt; <a href="#L91" title="access/transam/xloginsert.c:91">max_registered_block_id</a>; block_id++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="access/transam/xloginsert.c:87">registered_buffer</a> *regbuf = &amp;<a href="#L89" title="access/transam/xloginsert.c:89">registered_buffers</a>[block_id];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needs_backup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needs_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecordBlockHeader bkpb;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecordBlockImageHeader bimg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecordBlockCompressHeader cbimg = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; samerel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_compressed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; include_image;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!regbuf-&gt;in_use)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Determine if this block needs to be backed up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (regbuf-&gt;flags &amp; REGBUF_FORCE_IMAGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needs_backup = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (regbuf-&gt;flags &amp; REGBUF_NO_IMAGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needs_backup = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="xlog.c.html#L286" title="access/transam/xlog.c:286">doPageWrites</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needs_backup = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We assume page LSN is first data on *every* page that can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * passed to <a href="#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>, whether it has the standard page layout<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; page_lsn = PageGetLSN(regbuf-&gt;page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needs_backup = (page_lsn &lt;= <a href="xlog.c.html#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!needs_backup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*fpw_lsn == InvalidXLogRecPtr || page_lsn &lt; *fpw_lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *fpw_lsn = page_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Determine if the buffer data needs to included */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (regbuf-&gt;rdata_len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needs_data = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((regbuf-&gt;flags &amp; REGBUF_KEEP_DATA) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needs_data = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needs_data = !needs_backup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bkpb.id = block_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bkpb.fork_flags = regbuf-&gt;forkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bkpb.data_length = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((regbuf-&gt;flags &amp; REGBUF_WILL_INIT) == REGBUF_WILL_INIT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bkpb.fork_flags |= BKPBLOCK_WILL_INIT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If needs_backup is true or WAL checking is enabled for current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * resource manager, log a full-page write for the current block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; include_image = needs_backup || (info &amp; XLR_CHECK_CONSISTENCY) != <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (include_image)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = regbuf-&gt;page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; compressed_len = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The page needs to be backed up, so calculate its hole length<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and offset.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (regbuf-&gt;flags &amp; REGBUF_STANDARD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assume we can omit data between pd_lower and pd_upper */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = ((PageHeader) page)-&gt;pd_lower;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = ((PageHeader) page)-&gt;pd_upper;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> &gt;= SizeOfPageHeaderData &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> &gt; <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> &lt;= BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bimg.hole_offset = <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cbimg.hole_length = <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> - <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No &quot;hole&quot; to remove */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bimg.hole_offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cbimg.hole_length = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not a standard page header, don't try to eliminate &quot;hole&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bimg.hole_offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cbimg.hole_length = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to compress a block image if <a href="xlog.c.html#L124" title="access/transam/xlog.c:124">wal_compression</a> is enabled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlog.c.html#L124" title="access/transam/xlog.c:124">wal_compression</a> != WAL_COMPRESSION_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_compressed =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L944" title="access/transam/xloginsert.c:944">XLogCompressBackupBlock</a>(page, bimg.hole_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cbimg.hole_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; regbuf-&gt;compressed_page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;compressed_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fill in the remaining fields in the XLogRecordBlockHeader<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * struct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bkpb.fork_flags |= BKPBLOCK_HAS_IMAGE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report a full page image constructed for the WAL record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *num_fpi += <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Construct XLogRecData entries for the page content.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdt_datas_last-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = &amp;regbuf-&gt;bkp_rdatas[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdt_datas_last = rdt_datas_last-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bimg.bimg_info = (cbimg.hole_length == <span class="Constant">0</span>) ? <span class="Constant">0</span> : BKPIMAGE_HAS_HOLE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If WAL consistency checking is enabled for the resource manager<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of this WAL record, a full-page image is included in the record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the block modified. During redo, the full-page is replayed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only if BKPIMAGE_APPLY is set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needs_backup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bimg.bimg_info |= BKPIMAGE_APPLY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_compressed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The current compression is stored in the WAL record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bimg.length = compressed_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set the compression method used for this block */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> ((WalCompression) <a href="xlog.c.html#L124" title="access/transam/xlog.c:124">wal_compression</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAL_COMPRESSION_PGLZ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bimg.bimg_info |= BKPIMAGE_COMPRESS_PGLZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAL_COMPRESSION_LZ4:<br/></li>
<li><span class="PreProc">#ifdef USE_LZ4<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bimg.bimg_info |= BKPIMAGE_COMPRESS_LZ4;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;LZ4 is not supported by this build&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAL_COMPRESSION_ZSTD:<br/></li>
<li><span class="PreProc">#ifdef USE_ZSTD<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bimg.bimg_info |= BKPIMAGE_COMPRESS_ZSTD;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;zstd is not supported by this build&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAL_COMPRESSION_NONE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);&nbsp; &nbsp; <span class="Comment">/* cannot happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no default case, so that compiler will warn */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdt_datas_last-&gt;data = regbuf-&gt;compressed_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdt_datas_last-&gt;len = compressed_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bimg.length = BLCKSZ - cbimg.hole_length;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cbimg.hole_length == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdt_datas_last-&gt;data = page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdt_datas_last-&gt;len = BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the hole */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdt_datas_last-&gt;data = page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdt_datas_last-&gt;len = bimg.hole_offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdt_datas_last-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = &amp;regbuf-&gt;bkp_rdatas[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdt_datas_last = rdt_datas_last-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdt_datas_last-&gt;data =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page + (bimg.hole_offset + cbimg.hole_length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdt_datas_last-&gt;len =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BLCKSZ - (bimg.hole_offset + cbimg.hole_length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_len += bimg.length;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needs_data)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When copying to XLogRecordBlockHeader, the length is narrowed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to an uint16.&nbsp; Double-check that it is still correct.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(regbuf-&gt;rdata_len &lt;= <span class="Constant">UINT16_MAX</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Link the caller-supplied rdata chain for this buffer to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overall list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bkpb.fork_flags |= BKPBLOCK_HAS_DATA;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bkpb.data_length = (uint16) regbuf-&gt;rdata_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_len += regbuf-&gt;rdata_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdt_datas_last-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = regbuf-&gt;rdata_head;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdt_datas_last = regbuf-&gt;rdata_tail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prev_regbuf &amp;&amp; RelFileLocatorEquals(regbuf-&gt;rlocator, prev_regbuf-&gt;rlocator))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; samerel = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bkpb.fork_flags |= BKPBLOCK_SAME_REL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; samerel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prev_regbuf = regbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ok, copy the header to the scratch buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(scratch, &amp;bkpb, SizeOfXLogRecordBlockHeader);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scratch += SizeOfXLogRecordBlockHeader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (include_image)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(scratch, &amp;bimg, SizeOfXLogRecordBlockImageHeader);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scratch += SizeOfXLogRecordBlockImageHeader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cbimg.hole_length != <span class="Constant">0</span> &amp;&amp; is_compressed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(scratch, &amp;cbimg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SizeOfXLogRecordBlockCompressHeader);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scratch += SizeOfXLogRecordBlockCompressHeader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!samerel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(scratch, &amp;regbuf-&gt;rlocator, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scratch += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(scratch, &amp;regbuf-&gt;block, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BlockNumber));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scratch += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BlockNumber);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* followed by the record's origin, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((<a href="#L103" title="access/transam/xloginsert.c:103">curinsert_flags</a> &amp; XLOG_INCLUDE_ORIGIN) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/logical/origin.c.html#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a> != InvalidRepOriginId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *(scratch++) = (<span class="Type">char</span>) XLR_BLOCK_ID_ORIGIN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(scratch, &amp;<a href="../../replication/logical/origin.c.html#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../../replication/logical/origin.c.html#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scratch += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../../replication/logical/origin.c.html#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* followed by toplevel XID, if not already included in previous record */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xact.c.html#L556" title="access/transam/xact.c:556">IsSubxactTopXidLogPending</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid = <a href="xact.c.html#L438" title="access/transam/xact.c:438">GetTopTransactionIdIfAny</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set the flag that the top xid is included in the WAL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *topxid_included = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *(scratch++) = (<span class="Type">char</span>) XLR_BLOCK_ID_TOPLEVEL_XID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(scratch, &amp;xid, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scratch += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* followed by <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> data, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L100" title="access/transam/xloginsert.c:100">mainrdata_len</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L100" title="access/transam/xloginsert.c:100">mainrdata_len</a> &gt; <span class="Constant">255</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; mainrdata_len_4b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L100" title="access/transam/xloginsert.c:100">mainrdata_len</a> &gt; PG_UINT32_MAX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;too much WAL data&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;Main data length is </span><span class="Special">%llu</span><span class="Constant"> bytes for a maximum of </span><span class="Special">%u</span><span class="Constant"> bytes.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">long</span>) <a href="#L100" title="access/transam/xloginsert.c:100">mainrdata_len</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_UINT32_MAX)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mainrdata_len_4b = (uint32) <a href="#L100" title="access/transam/xloginsert.c:100">mainrdata_len</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(scratch++) = (<span class="Type">char</span>) XLR_BLOCK_ID_DATA_LONG;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(scratch, &amp;mainrdata_len_4b, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scratch += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(scratch++) = (<span class="Type">char</span>) XLR_BLOCK_ID_DATA_SHORT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *(scratch++) = (uint8) <a href="#L100" title="access/transam/xloginsert.c:100">mainrdata_len</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rdt_datas_last-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <a href="#L98" title="access/transam/xloginsert.c:98">mainrdata_head</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rdt_datas_last = <a href="#L99" title="access/transam/xloginsert.c:99">mainrdata_last</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; total_len += <a href="#L100" title="access/transam/xloginsert.c:100">mainrdata_len</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; rdt_datas_last-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L113" title="access/transam/xloginsert.c:113">hdr_rdt</a>.len = (scratch - <a href="#L114" title="access/transam/xloginsert.c:114">hdr_scratch</a>);<br/></li>
<li>&nbsp; &nbsp; total_len += <a href="#L113" title="access/transam/xloginsert.c:113">hdr_rdt</a>.len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate CRC of the data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that the record header isn't added into the CRC initially since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't know the prev-link yet.&nbsp; Thus, the CRC will represent the CRC of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the whole record in the order: rdata, then backup blocks, then record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * header.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; INIT_CRC32C(rdata_crc);<br/></li>
<li>&nbsp; &nbsp; COMP_CRC32C(rdata_crc, <a href="#L114" title="access/transam/xloginsert.c:114">hdr_scratch</a> + SizeOfXLogRecord, <a href="#L113" title="access/transam/xloginsert.c:113">hdr_rdt</a>.len - SizeOfXLogRecord);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (rdt = <a href="#L113" title="access/transam/xloginsert.c:113">hdr_rdt</a>.<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>; rdt != <span class="Constant">NULL</span>; rdt = rdt-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; COMP_CRC32C(rdata_crc, rdt-&gt;data, rdt-&gt;len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure that the XLogRecord is not too large.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLogReader machinery is only able to handle <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> up to a certain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * size (ignoring machine resource limitations), so make sure that we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not emit <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> larger than the sizes advertised to be supported.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (total_len &gt; XLogRecordMaxSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;oversized WAL record&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;WAL record would be </span><span class="Special">%llu</span><span class="Constant"> bytes (of maximum </span><span class="Special">%u</span><span class="Constant"> bytes); rmid </span><span class="Special">%u</span><span class="Constant"> flags </span><span class="Special">%u</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">long</span>) total_len, XLogRecordMaxSize, rmid, info)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill in the fields in the record header. Prev-link is filled in later,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * once we know where in the WAL the record will be inserted. The CRC does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not include the record header yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rechdr-&gt;xl_xid = <a href="xact.c.html#L468" title="access/transam/xact.c:468">GetCurrentTransactionIdIfAny</a>();<br/></li>
<li>&nbsp; &nbsp; rechdr-&gt;xl_tot_len = (uint32) total_len;<br/></li>
<li>&nbsp; &nbsp; rechdr-&gt;xl_info = info;<br/></li>
<li>&nbsp; &nbsp; rechdr-&gt;xl_rmid = rmid;<br/></li>
<li>&nbsp; &nbsp; rechdr-&gt;xl_prev = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; rechdr-&gt;xl_crc = rdata_crc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;<a href="#L113" title="access/transam/xloginsert.c:113">hdr_rdt</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a compressed version of a backup block image.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false if compression fails (i.e., compressed result is actually<br/></li>
<li></span><span class="Comment"> * bigger than original). Otherwise, returns true and sets 'dlen' to<br/></li>
<li></span><span class="Comment"> * the length of compressed block image.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L944">&#x200c;</a></span><span class="linkable">XLogCompressBackupBlock</span>(<span class="Type">char</span> *page, uint16 hole_offset, uint16 hole_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> *dest, uint16 *dlen)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; orig_len = BLCKSZ - hole_length;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; len = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; extra_bytes = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *source;<br/></li>
<li>&nbsp; &nbsp; PGAlignedBlock tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hole_length != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the hole */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; source = tmp.data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(source, page, hole_offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(source + hole_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; page + (hole_offset + hole_length),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BLCKSZ - (hole_length + hole_offset));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Extra data needs to be stored in WAL record for the compressed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * version of block image if the hole exists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; extra_bytes = SizeOfXLogRecordBlockCompressHeader;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; source = page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> ((WalCompression) <a href="xlog.c.html#L124" title="access/transam/xlog.c:124">wal_compression</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAL_COMPRESSION_PGLZ:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = pglz_compress(source, orig_len, dest, PGLZ_strategy_default);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAL_COMPRESSION_LZ4:<br/></li>
<li><span class="PreProc">#ifdef USE_LZ4<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = LZ4_compress_default(source, dest, orig_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L62" title="access/transam/xloginsert.c:62">COMPRESS_BUFSIZE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* failure */<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;LZ4 is not supported by this build&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAL_COMPRESSION_ZSTD:<br/></li>
<li><span class="PreProc">#ifdef USE_ZSTD<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = ZSTD_compress(dest, <a href="#L62" title="access/transam/xloginsert.c:62">COMPRESS_BUFSIZE</a>, source, orig_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ZSTD_CLEVEL_DEFAULT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ZSTD_isError(len))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* failure */<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;zstd is not supported by this build&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAL_COMPRESSION_NONE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cannot happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no default case, so that compiler will warn */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We recheck the actual size even if compression reports success and see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the number of bytes saved by compression is larger than the length<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of extra data needed for the compressed version of block image.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len + extra_bytes &lt; orig_len)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *dlen = (uint16) len;&nbsp; &nbsp; <span class="Comment">/* successful compression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine whether the buffer referenced has to be backed up.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since we don't yet have the insert lock, <a href="xlog.c.html#L122" title="access/transam/xlog.c:122">fullPageWrites</a> and runningBackups<br/></li>
<li></span><span class="Comment"> * (which forces full-page writes) could change later, so the result should<br/></li>
<li></span><span class="Comment"> * be used for optimization purposes only.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1027">&#x200c;</a></span><span class="linkable">XLogCheckBufferNeedsBackup</span>(Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; <a href="xlog.c.html#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L286" title="access/transam/xlog.c:286">doPageWrites</a>;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="xlog.c.html#L6423" title="access/transam/xlog.c:6423">GetFullPageWriteInfo</a>(&amp;<a href="xlog.c.html#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>, &amp;<a href="xlog.c.html#L286" title="access/transam/xlog.c:286">doPageWrites</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlog.c.html#L286" title="access/transam/xlog.c:286">doPageWrites</a> &amp;&amp; PageGetLSN(page) &lt;= <a href="xlog.c.html#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* buffer requires backup */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* buffer does not need to be backed up */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write a backup block if needed when we are setting a hint. Note that<br/></li>
<li></span><span class="Comment"> * this may be called for a variety of page types, not just heaps.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callable while holding just share lock on the buffer content.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can't use the plain backup block mechanism since that relies on the<br/></li>
<li></span><span class="Comment"> * Buffer being exclusively locked. Since some modifications (setting LSN, hint<br/></li>
<li></span><span class="Comment"> * bits) are allowed in a sharelocked buffer that can lead to wal checksum<br/></li>
<li></span><span class="Comment"> * failures. So instead we copy the page and insert the copied data as normal<br/></li>
<li></span><span class="Comment"> * record data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We only need to do something if page has not yet been full page written in<br/></li>
<li></span><span class="Comment"> * this checkpoint round. The LSN of the inserted wal record is returned if we<br/></li>
<li></span><span class="Comment"> * had to write, InvalidXLogRecPtr otherwise.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is possible that multiple concurrent backends could attempt to write WAL<br/></li>
<li></span><span class="Comment"> * <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>. In that case, multiple copies of the same block would be recorded<br/></li>
<li></span><span class="Comment"> * in separate WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> by different backends, though that is still OK from<br/></li>
<li></span><span class="Comment"> * a correctness perspective.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L1065">&#x200c;</a><span class="linkable">XLogSaveBufferForHint</span>(Buffer buffer, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> buffer_std)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; <a href="xlog.c.html#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure no checkpoint can change our view of <a href="xlog.c.html#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert((<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags &amp; DELAY_CHKPT_START) != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update <a href="xlog.c.html#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> so that we can make the right decision<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xlog.c.html#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> = <a href="xlog.c.html#L6393" title="access/transam/xlog.c:6393">GetRedoRecPtr</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We assume page LSN is first data on *every* page that can be passed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>, whether it has the standard page layout or not. Since we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only holding a share-lock on the page, we must take the buffer header<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock when we look at the LSN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lsn = <a href="../../storage/buffer/bufmgr.c.html#L3928" title="storage/buffer/bufmgr.c:3928">BufferGetLSNAtomic</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lsn &lt;= <a href="xlog.c.html#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGAlignedBlock copied_buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *origdata = (<span class="Type">char</span> *) BufferGetBlock(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy buffer so we don't have to worry about concurrent hint <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lsn updates. We assume pd_lower/<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> cannot be changed without an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exclusive lock, so the contents bkp are not racy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buffer_std)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assume we can omit data between pd_lower and pd_upper */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> = ((PageHeader) page)-&gt;pd_lower;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> = ((PageHeader) page)-&gt;pd_upper;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(copied_buffer.data, origdata, <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(copied_buffer.data + <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, origdata + <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>, BLCKSZ - <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(copied_buffer.data, origdata, BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buffer_std)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= REGBUF_STANDARD;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3688" title="storage/buffer/bufmgr.c:3688">BufferGetTag</a>(buffer, &amp;rlocator, &amp;forkno, &amp;blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L309" title="access/transam/xloginsert.c:309">XLogRegisterBlock</a>(<span class="Constant">0</span>, &amp;rlocator, forkno, blkno, copied_buffer.data, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_XLOG_ID, XLOG_FPI_FOR_HINT);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> recptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write a WAL record containing a full image of a page. Caller is responsible<br/></li>
<li></span><span class="Comment"> * for writing the page to disk after calling this routine.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: If you're using this function, you should be building pages in private<br/></li>
<li></span><span class="Comment"> * memory and writing them directly to smgr.&nbsp; If you're using buffers, call<br/></li>
<li></span><span class="Comment"> * <a href="#L1237" title="access/transam/xloginsert.c:1237">log_newpage_buffer</a> instead.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the page follows the standard page layout, with a PageHeader and unused<br/></li>
<li></span><span class="Comment"> * space between pd_lower and pd_upper, set 'page_std' to true. That allows<br/></li>
<li></span><span class="Comment"> * the unused space to be left out from the WAL record, making it smaller.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L1143">&#x200c;</a><span class="linkable">log_newpage</span>(RelFileLocator *rlocator, ForkNumber forknum, BlockNumber blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page page, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> page_std)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; flags = REGBUF_FORCE_IMAGE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (page_std)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags |= REGBUF_STANDARD;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L309" title="access/transam/xloginsert.c:309">XLogRegisterBlock</a>(<span class="Constant">0</span>, rlocator, forknum, blkno, page, flags);<br/></li>
<li>&nbsp; &nbsp; recptr = <a href="#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_XLOG_ID, XLOG_FPI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The page may be uninitialized. If so, we can't set the LSN because that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would corrupt the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!PageIsNew(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> recptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Like <a href="#L1143" title="access/transam/xloginsert.c:1143">log_newpage</a>(), but allows logging multiple pages in one operation.<br/></li>
<li></span><span class="Comment"> * It is more efficient than calling <a href="#L1143" title="access/transam/xloginsert.c:1143">log_newpage</a>() for each page separately,<br/></li>
<li></span><span class="Comment"> * because we can write multiple pages in a single WAL record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1175">&#x200c;</a></span><span class="linkable">log_newpages</span>(RelFileLocator *rlocator, ForkNumber forknum, <span class="Type">int</span> num_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber *blknos, Page *pages, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> page_std)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; flags = REGBUF_FORCE_IMAGE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (page_std)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags |= REGBUF_STANDARD;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Iterate over all the pages. They are collected into batches of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLR_MAX_BLOCK_ID pages, and a single WAL-record is written for each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * batch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L175" title="access/transam/xloginsert.c:175">XLogEnsureRecordSpace</a>(XLR_MAX_BLOCK_ID - <span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (i &lt; num_pages)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; batch_start = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbatch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbatch = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (nbatch &lt; XLR_MAX_BLOCK_ID &amp;&amp; i &lt; num_pages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L309" title="access/transam/xloginsert.c:309">XLogRegisterBlock</a>(nbatch, rlocator, forknum, blknos[i], pages[i], flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbatch++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_XLOG_ID, XLOG_FPI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = batch_start; j &lt; i; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The page may be uninitialized. If so, we can't set the LSN<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because that would corrupt the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!PageIsNew(pages[j]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(pages[j], recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write a WAL record containing a full image of a page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller should <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the buffer and mark it dirty <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling this<br/></li>
<li></span><span class="Comment"> * function.&nbsp; This function will set the page LSN.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the page follows the standard page layout, with a PageHeader and unused<br/></li>
<li></span><span class="Comment"> * space between pd_lower and pd_upper, set 'page_std' to true. That allows<br/></li>
<li></span><span class="Comment"> * the unused space to be left out from the WAL record, making it smaller.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L1237">&#x200c;</a><span class="linkable">log_newpage_buffer</span>(Buffer buffer, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> page_std)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li>&nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forknum;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shared buffers should be modified in a critical section. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../utils/init/globals.c.html#L43" title="utils/init/globals.c:43">CritSectionCount</a> &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3688" title="storage/buffer/bufmgr.c:3688">BufferGetTag</a>(buffer, &amp;rlocator, &amp;forknum, &amp;blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1143" title="access/transam/xloginsert.c:1143">log_newpage</a>(&amp;rlocator, forknum, blkno, page, page_std);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * WAL-log a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of blocks in a relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An image of all pages with block numbers 'startblk' &lt;= X &lt; 'endblk' is<br/></li>
<li></span><span class="Comment"> * written to the WAL. If the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is large, this is done in multiple WAL<br/></li>
<li></span><span class="Comment"> * <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If all page follows the standard page layout, with a PageHeader and unused<br/></li>
<li></span><span class="Comment"> * space between pd_lower and pd_upper, set 'page_std' to true. That allows<br/></li>
<li></span><span class="Comment"> * the unused space to be left out from the WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, making them smaller.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: This function acquires exclusive-locks on the pages. Typically, this<br/></li>
<li></span><span class="Comment"> * is used on a newly-built relation, and the caller is holding a<br/></li>
<li></span><span class="Comment"> * AccessExclusiveLock on it, so no other backend can be accessing it at the<br/></li>
<li></span><span class="Comment"> * same time. If that's not the case, you must ensure that this does not<br/></li>
<li></span><span class="Comment"> * cause a deadlock through some other means.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1270">&#x200c;</a></span><span class="linkable">log_newpage_range</span>(Relation rel, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber startblk, BlockNumber endblk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> page_std)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; flags = REGBUF_FORCE_IMAGE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (page_std)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags |= REGBUF_STANDARD;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Iterate over all the pages in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. They are collected into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * batches of XLR_MAX_BLOCK_ID pages, and a single WAL-record is written<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for each batch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L175" title="access/transam/xloginsert.c:175">XLogEnsureRecordSpace</a>(XLR_MAX_BLOCK_ID - <span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; blkno = startblk;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (blkno &lt; endblk)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; bufpack[XLR_MAX_BLOCK_ID];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbufs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Collect a batch of blocks. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nbufs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (nbufs &lt; XLR_MAX_BLOCK_ID &amp;&amp; blkno &lt; endblk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(rel, forknum, blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RBM_NORMAL, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Completely empty pages are not WAL-logged. Writing a WAL record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would change the LSN, and we don't want that. We want the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to stay empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!PageIsNew(BufferGetPage(buf)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufpack[nbufs++] = buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nothing more to do if all remaining blocks were empty. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nbufs == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Write WAL record for this batch. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nbufs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(bufpack[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(i, bufpack[i], flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_XLOG_ID, XLOG_FPI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nbufs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(BufferGetPage(bufpack[i]), recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(bufpack[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate working buffers needed for WAL record construction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1348">&#x200c;</a></span><span class="linkable">InitXLogInsert</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> assembled can be decoded.&nbsp; This is capped based<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on what XLogReader would require at its maximum bound.&nbsp; The XLOG_BLCKSZ<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * addend covers the larger <a href="xlogreader.c.html#L190" title="access/transam/xlogreader.c:190">allocate_recordbuf</a>() demand.&nbsp; This code path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is called once per backend, more than enough for this check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; max_required =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogreader.c.html#L1629" title="access/transam/xlogreader.c:1629">DecodeXLogRecordRequiredSpace</a>(XLogRecordMaxSize + XLOG_BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(AllocSizeIsValid(max_required));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the working areas */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L135" title="access/transam/xloginsert.c:135">xloginsert_cxt</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L135" title="access/transam/xloginsert.c:135">xloginsert_cxt</a> = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;WAL record construction&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L89" title="access/transam/xloginsert.c:89">registered_buffers</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L89" title="access/transam/xloginsert.c:89">registered_buffers</a> = (<a href="#L87" title="access/transam/xloginsert.c:87">registered_buffer</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="#L135" title="access/transam/xloginsert.c:135">xloginsert_cxt</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L87" title="access/transam/xloginsert.c:87">registered_buffer</a>) * (XLR_NORMAL_MAX_BLOCK_ID + <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L90" title="access/transam/xloginsert.c:90">max_registered_buffers</a> = XLR_NORMAL_MAX_BLOCK_ID + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L128" title="access/transam/xloginsert.c:128">rdatas</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L128" title="access/transam/xloginsert.c:128">rdatas</a> = <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="#L135" title="access/transam/xloginsert.c:135">xloginsert_cxt</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(XLogRecData) * XLR_NORMAL_RDATAS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L130" title="access/transam/xloginsert.c:130">max_rdatas</a> = XLR_NORMAL_RDATAS;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate a buffer to hold the header information for a WAL record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L114" title="access/transam/xloginsert.c:114">hdr_scratch</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L114" title="access/transam/xloginsert.c:114">hdr_scratch</a> = <a href="../../utils/mmgr/mcxt.c.html#L1214" title="utils/mmgr/mcxt.c:1214">MemoryContextAllocZero</a>(<a href="#L135" title="access/transam/xloginsert.c:135">xloginsert_cxt</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L119" title="access/transam/xloginsert.c:119">HEADER_SCRATCH_SIZE</a>);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
