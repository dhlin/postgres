<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/transam/parallel.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/transam/parallel.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L118">InitializingParallelWorker</a></li>
<li><a href="#L137">InternalParallelWorkers</a></li>
<li><a href="#L121">MyFixedParallelState</a></li>
<li><a href="#L127">ParallelLeaderPid</a></li>
<li><a href="#L115">ParallelMessagePending</a></li>
<li><a href="#L112">ParallelWorkerNumber</a></li>
<li><a href="#L124">pcxt_list</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L81">FixedParallelState</a></li>
<li><a href="#L104">FixedParallelState</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1233">AtEOSubXact_Parallel</a></li>
<li><a href="#L1254">AtEOXact_Parallel</a></li>
<li><a href="#L167">CreateParallelContext</a></li>
<li><a href="#L929">DestroyParallelContext</a></li>
<li><a href="#L1116">HandleParallelMessage</a></li>
<li><a href="#L1016">HandleParallelMessageInterrupt</a></li>
<li><a href="#L1027">HandleParallelMessages</a></li>
<li><a href="#L205">InitializeParallelDSM</a></li>
<li><a href="#L552">LaunchParallelWorkers</a></li>
<li><a href="#L1595">LookupParallelWorkerFunction</a></li>
<li><a href="#L1003">ParallelContextActive</a></li>
<li><a href="#L1271">ParallelWorkerMain</a></li>
<li><a href="#L1539">ParallelWorkerReportLastRecEnd</a></li>
<li><a href="#L1567">ParallelWorkerShutdown</a></li>
<li><a href="#L488">ReinitializeParallelDSM</a></li>
<li><a href="#L538">ReinitializeParallelWorkers</a></li>
<li><a href="#L672">WaitForParallelWorkersToAttach</a></li>
<li><a href="#L889">WaitForParallelWorkersToExit</a></li>
<li><a href="#L775">WaitForParallelWorkersToFinish</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L54">PARALLEL_ERROR_QUEUE_SIZE</a></li>
<li><a href="#L70">PARALLEL_KEY_ACTIVE_SNAPSHOT</a></li>
<li><a href="#L78">PARALLEL_KEY_CLIENTCONNINFO</a></li>
<li><a href="#L68">PARALLEL_KEY_COMBO_CID</a></li>
<li><a href="#L72">PARALLEL_KEY_ENTRYPOINT</a></li>
<li><a href="#L65">PARALLEL_KEY_ERROR_QUEUE</a></li>
<li><a href="#L64">PARALLEL_KEY_FIXED</a></li>
<li><a href="#L67">PARALLEL_KEY_GUC</a></li>
<li><a href="#L66">PARALLEL_KEY_LIBRARY</a></li>
<li><a href="#L74">PARALLEL_KEY_PENDING_SYNCS</a></li>
<li><a href="#L75">PARALLEL_KEY_REINDEX_STATE</a></li>
<li><a href="#L76">PARALLEL_KEY_RELMAPPER_STATE</a></li>
<li><a href="#L73">PARALLEL_KEY_SESSION_DSM</a></li>
<li><a href="#L69">PARALLEL_KEY_TRANSACTION_SNAPSHOT</a></li>
<li><a href="#L71">PARALLEL_KEY_TRANSACTION_STATE</a></li>
<li><a href="#L77">PARALLEL_KEY_UNCOMMITTEDENUMS</a></li>
<li><a href="#L57">PARALLEL_MAGIC</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * parallel.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Infrastructure for launching parallel workers<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/transam/parallel.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/brin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/nbtree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/parallel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/session.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/index.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_enum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/storage.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/async.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/execParallel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/libpq.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqmq.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/spin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/combocid.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/relmapper.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We don't want to waste a lot of memory on an error queue which, most of<br/></li>
<li></span><span class="Comment"> * the time, will process only a handful of small messages.&nbsp; However, it is<br/></li>
<li></span><span class="Comment"> * desirable to make it large enough that a typical ErrorResponse can be sent<br/></li>
<li></span><span class="Comment"> * without blocking.&nbsp; That way, a worker that errors out can write the whole<br/></li>
<li></span><span class="Comment"> * message into the queue and terminate without <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the user backend.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L54">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_ERROR_QUEUE_SIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">16384<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Magic number for parallel context TOC. */<br/></li>
<li><a id="L57">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_MAGIC</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x50477c7c<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Magic numbers for per-context parallel state sharing.&nbsp; Higher-level code<br/></li>
<li></span><span class="Comment"> * should use smaller <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, leaving these very large ones for use by this<br/></li>
<li></span><span class="Comment"> * module.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L64">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_FIXED</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xFFFFFFFFFFFF0001</span><span class="PreProc">)<br/></li>
<li><a id="L65">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_ERROR_QUEUE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xFFFFFFFFFFFF0002</span><span class="PreProc">)<br/></li>
<li><a id="L66">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_LIBRARY</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xFFFFFFFFFFFF0003</span><span class="PreProc">)<br/></li>
<li><a id="L67">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_GUC</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xFFFFFFFFFFFF0004</span><span class="PreProc">)<br/></li>
<li><a id="L68">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_COMBO_CID</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xFFFFFFFFFFFF0005</span><span class="PreProc">)<br/></li>
<li><a id="L69">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_TRANSACTION_SNAPSHOT</span>&nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xFFFFFFFFFFFF0006</span><span class="PreProc">)<br/></li>
<li><a id="L70">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_ACTIVE_SNAPSHOT</span>&nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xFFFFFFFFFFFF0007</span><span class="PreProc">)<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_TRANSACTION_STATE</span>&nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xFFFFFFFFFFFF0008</span><span class="PreProc">)<br/></li>
<li><a id="L72">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_ENTRYPOINT</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xFFFFFFFFFFFF0009</span><span class="PreProc">)<br/></li>
<li><a id="L73">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_SESSION_DSM</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xFFFFFFFFFFFF000A</span><span class="PreProc">)<br/></li>
<li><a id="L74">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_PENDING_SYNCS</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xFFFFFFFFFFFF000B</span><span class="PreProc">)<br/></li>
<li><a id="L75">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_REINDEX_STATE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xFFFFFFFFFFFF000C</span><span class="PreProc">)<br/></li>
<li><a id="L76">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_RELMAPPER_STATE</span>&nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xFFFFFFFFFFFF000D</span><span class="PreProc">)<br/></li>
<li><a id="L77">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_UNCOMMITTEDENUMS</span>&nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xFFFFFFFFFFFF000E</span><span class="PreProc">)<br/></li>
<li><a id="L78">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_CLIENTCONNINFO</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xFFFFFFFFFFFF000F</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Fixed-size parallel state. */<br/></li>
<li><a id="L81">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">FixedParallelState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fixed-size state that workers must restore. */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; database_id;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; authenticated_user_id;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_user_id;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outer_user_id;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp_namespace_id;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp_toast_namespace_id;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sec_context;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_superuser;<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *parallel_leader_pgproc;<br/></li>
<li>&nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; parallel_leader_pid;<br/></li>
<li>&nbsp; &nbsp; ProcNumber&nbsp; &nbsp; parallel_leader_proc_number;<br/></li>
<li>&nbsp; &nbsp; TimestampTz xact_ts;<br/></li>
<li>&nbsp; &nbsp; TimestampTz stmt_ts;<br/></li>
<li>&nbsp; &nbsp; SerializableXactHandle serializable_xact_handle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mutex protects remaining fields. */<br/></li>
<li></span>&nbsp; &nbsp; slock_t&nbsp; &nbsp; &nbsp; &nbsp; mutex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Maximum <a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a> of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> worker. */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; last_xlog_end;<br/></li>
<li><a id="L104">&#x200c;</a>} <span class="linkable">FixedParallelState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Our parallel worker number.&nbsp; We <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> this to -1, meaning that we are<br/></li>
<li></span><span class="Comment"> * not a parallel worker.&nbsp; In parallel workers, it will be set to a value &gt;= 0<br/></li>
<li></span><span class="Comment"> * and &lt; the number of workers <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> user code is invoked; each parallel<br/></li>
<li></span><span class="Comment"> * worker will get a different parallel worker number.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L112">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">ParallelWorkerNumber</span> = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Is there a parallel message pending which we need to receive? */<br/></li>
<li><a id="L115">&#x200c;</a></span><span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">ParallelMessagePending</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Are we initializing a parallel worker? */<br/></li>
<li><a id="L118">&#x200c;</a></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">InitializingParallelWorker</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Pointer to our fixed parallel state. */<br/></li>
<li><a id="L121">&#x200c;</a></span><span class="Type">static</span> <a href="#L81" title="access/transam/parallel.c:81">FixedParallelState</a> *<span class="linkable">MyFixedParallelState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* List of active parallel contexts. */<br/></li>
<li><a id="L124">&#x200c;</a></span><span class="Type">static</span> dlist_head <span class="linkable">pcxt_list</span> = DLIST_STATIC_INIT(<span class="linkable">pcxt_list</span>);<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="../../postmaster/postmaster.c.html#L177" title="postmaster/postmaster.c:177">Backend</a>-local copy of data from <a href="#L81" title="access/transam/parallel.c:81">FixedParallelState</a>. */<br/></li>
<li><a id="L127">&#x200c;</a></span><span class="Type">static</span> pid_t <span class="linkable">ParallelLeaderPid</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * List of <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> parallel worker entry points.&nbsp; We need this for<br/></li>
<li></span><span class="Comment"> * reasons explained in <a href="#L1595" title="access/transam/parallel.c:1595">LookupParallelWorkerFunction</a>(), below.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *fn_name;<br/></li>
<li>&nbsp; &nbsp; parallel_worker_main_type fn_addr;<br/></li>
<li><a id="L137">&#x200c;</a>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">InternalParallelWorkers</span>[] =<br/></li>
<li><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="../../executor/execParallel.c.html#L1400" title="executor/execParallel.c:1400">ParallelQueryMain</a>&quot;</span>, <a href="../../executor/execParallel.c.html#L1400" title="executor/execParallel.c:1400">ParallelQueryMain</a><br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="../nbtree/nbtsort.c.html#L1740" title="access/nbtree/nbtsort.c:1740">_bt_parallel_build_main</a>&quot;</span>, <a href="../nbtree/nbtsort.c.html#L1740" title="access/nbtree/nbtsort.c:1740">_bt_parallel_build_main</a><br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="../brin/brin.c.html#L2851" title="access/brin/brin.c:2851">_brin_parallel_build_main</a>&quot;</span>, <a href="../brin/brin.c.html#L2851" title="access/brin/brin.c:2851">_brin_parallel_build_main</a><br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="../../commands/vacuumparallel.c.html#L988" title="commands/vacuumparallel.c:988">parallel_vacuum_main</a>&quot;</span>, <a href="../../commands/vacuumparallel.c.html#L988" title="commands/vacuumparallel.c:988">parallel_vacuum_main</a><br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Private <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>. */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1116" title="access/transam/parallel.c:1116">HandleParallelMessage</a>(ParallelContext *pcxt, <span class="Type">int</span> i, StringInfo msg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L889" title="access/transam/parallel.c:889">WaitForParallelWorkersToExit</a>(ParallelContext *pcxt);<br/></li>
<li><span class="Type">static</span> parallel_worker_main_type <a href="#L1595" title="access/transam/parallel.c:1595">LookupParallelWorkerFunction</a>(<span class="Type">const</span> <span class="Type">char</span> *libraryname, <span class="Type">const</span> <span class="Type">char</span> *funcname);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1567" title="access/transam/parallel.c:1567">ParallelWorkerShutdown</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Establish a new parallel context.&nbsp; This should be done after entering<br/></li>
<li></span><span class="Comment"> * parallel mode, and (unless there is an error) the context should be<br/></li>
<li></span><span class="Comment"> * destroyed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> exiting the current subtransaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ParallelContext *<br/></li>
<li><a id="L167">&#x200c;</a><span class="linkable">CreateParallelContext</span>(<span class="Type">const</span> <span class="Type">char</span> *library_name, <span class="Type">const</span> <span class="Type">char</span> *function_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nworkers)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; ParallelContext *pcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It is unsafe to create a parallel context if not in parallel mode. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Number of workers should be non-negative. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(nworkers &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We might be running in a short-lived memory context. */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize a new ParallelContext. */<br/></li>
<li></span>&nbsp; &nbsp; pcxt = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ParallelContext));<br/></li>
<li>&nbsp; &nbsp; pcxt-&gt;subid = <a href="xact.c.html#L788" title="access/transam/xact.c:788">GetCurrentSubTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; pcxt-&gt;nworkers = nworkers;<br/></li>
<li>&nbsp; &nbsp; pcxt-&gt;nworkers_to_launch = nworkers;<br/></li>
<li>&nbsp; &nbsp; pcxt-&gt;library_name = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(library_name);<br/></li>
<li>&nbsp; &nbsp; pcxt-&gt;function_name = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(function_name);<br/></li>
<li>&nbsp; &nbsp; pcxt-&gt;<a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; shm_toc_initialize_estimator(&amp;pcxt-&gt;estimator);<br/></li>
<li>&nbsp; &nbsp; dlist_push_head(&amp;<a href="#L124" title="access/transam/parallel.c:124">pcxt_list</a>, &amp;pcxt-&gt;node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore previous memory context. */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pcxt;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Establish the dynamic shared memory segment for a parallel context and<br/></li>
<li></span><span class="Comment"> * copy state and other bookkeeping information that will be needed by<br/></li>
<li></span><span class="Comment"> * parallel workers into it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L205">&#x200c;</a></span><span class="linkable">InitializeParallelDSM</span>(ParallelContext *pcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; library_len = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; guc_len = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; combocidlen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; tsnaplen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; asnaplen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; tstatelen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; pendingsyncslen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; reindexlen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; relmapperlen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; uncommittedenumslen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; clientconninfolen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; segsize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <a href="#L81" title="access/transam/parallel.c:81">FixedParallelState</a> *fps;<br/></li>
<li>&nbsp; &nbsp; dsm_handle&nbsp; &nbsp; session_dsm_handle = DSM_HANDLE_INVALID;<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; transaction_snapshot = <a href="../../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; active_snapshot = <a href="../../utils/time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We might be running in a very short-lived memory context. */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allow space to store the fixed-size parallel state. */<br/></li>
<li></span>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L81" title="access/transam/parallel.c:81">FixedParallelState</a>));<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normally, the user will have requested at least one worker process, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if by chance they have not, we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> a bunch of things here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;nworkers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get (or create) the per-session DSM segment's handle. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; session_dsm_handle = <a href="../common/session.c.html#L70" title="access/common/session.c:70">GetSessionDsmHandle</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we weren't able to create a per-session DSM segment, then we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * continue but we can't safely launch <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> workers because their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * record typmods would be incompatible so they couldn't exchange<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (session_dsm_handle == DSM_HANDLE_INVALID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;nworkers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;nworkers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Estimate space for various kinds of state sharing. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; library_len = <a href="../../utils/fmgr/dfmgr.c.html#L637" title="utils/fmgr/dfmgr.c:637">EstimateLibraryStateSpace</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, library_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; guc_len = <a href="../../utils/misc/guc.c.html#L5907" title="utils/misc/guc.c:5907">EstimateGUCStateSpace</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, guc_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; combocidlen = <a href="../../utils/time/combocid.c.html#L297" title="utils/time/combocid.c:297">EstimateComboCIDStateSpace</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, combocidlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsolationUsesXactSnapshot())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tsnaplen = <a href="../../utils/time/snapmgr.c.html#L1692" title="utils/time/snapmgr.c:1692">EstimateSnapshotSpace</a>(transaction_snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, tsnaplen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; asnaplen = <a href="../../utils/time/snapmgr.c.html#L1692" title="utils/time/snapmgr.c:1692">EstimateSnapshotSpace</a>(active_snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, asnaplen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tstatelen = <a href="xact.c.html#L5463" title="access/transam/xact.c:5463">EstimateTransactionStateSpace</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, tstatelen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dsm_handle));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pendingsyncslen = <a href="../../catalog/storage.c.html#L546" title="catalog/storage.c:546">EstimatePendingSyncsSpace</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, pendingsyncslen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reindexlen = <a href="../../catalog/index.c.html#L4178" title="catalog/index.c:4178">EstimateReindexStateSpace</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, reindexlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relmapperlen = <a href="../../utils/cache/relmapper.c.html#L713" title="utils/cache/relmapper.c:713">EstimateRelationMapSpace</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, relmapperlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uncommittedenumslen = <a href="../../catalog/pg_enum.c.html#L813" title="catalog/pg_enum.c:813">EstimateUncommittedEnumsSpace</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, uncommittedenumslen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; clientconninfolen = <a href="../../utils/init/miscinit.c.html#L1027" title="utils/init/miscinit.c:1027">EstimateClientConnectionInfoSpace</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, clientconninfolen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If you add more chunks here, you probably need to add keys. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">12</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Estimate space need for error queues. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; StaticAssertStmt(BUFFERALIGN(<a href="#L54" title="access/transam/parallel.c:54">PARALLEL_ERROR_QUEUE_SIZE</a>) ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L54" title="access/transam/parallel.c:54">PARALLEL_ERROR_QUEUE_SIZE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;parallel error queue size not buffer-aligned&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<a href="#L54" title="access/transam/parallel.c:54">PARALLEL_ERROR_QUEUE_SIZE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;nworkers));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Estimate how much we'll need for the entrypoint info. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, strlen(pcxt-&gt;library_name) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strlen(pcxt-&gt;function_name) + <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create DSM and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> with new table of contents.&nbsp; But if the user<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * didn't request <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> workers, then don't bother creating a dynamic shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory segment; instead, just use backend-private memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, if we can't create a dynamic shared memory segment because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * maximum number of segments have already been created, then fall back to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backend-private memory, and plan not to use <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> workers.&nbsp; We hope this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * won't happen very often, but it's better to abandon the use of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallelism than to fail outright.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; segsize = <a href="../../storage/ipc/shm_toc.c.html#L263" title="storage/ipc/shm_toc.c:263">shm_toc_estimate</a>(&amp;pcxt-&gt;estimator);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;nworkers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;seg = <a href="../../storage/ipc/dsm.c.html#L516" title="storage/ipc/dsm.c:516">dsm_create</a>(segsize, DSM_CREATE_NULL_IF_MAXSEGMENTS);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;seg != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;toc = <a href="../../storage/ipc/shm_toc.c.html#L40" title="storage/ipc/shm_toc.c:40">shm_toc_create</a>(<a href="#L57" title="access/transam/parallel.c:57">PARALLEL_MAGIC</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/ipc/dsm.c.html#L1095" title="storage/ipc/dsm.c:1095">dsm_segment_address</a>(pcxt-&gt;seg),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; segsize);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;nworkers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;private_memory = <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, segsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;toc = <a href="../../storage/ipc/shm_toc.c.html#L40" title="storage/ipc/shm_toc.c:40">shm_toc_create</a>(<a href="#L57" title="access/transam/parallel.c:57">PARALLEL_MAGIC</a>, pcxt-&gt;private_memory,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; segsize);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize fixed-size state in shared memory. */<br/></li>
<li></span>&nbsp; &nbsp; fps = (<a href="#L81" title="access/transam/parallel.c:81">FixedParallelState</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L81" title="access/transam/parallel.c:81">FixedParallelState</a>));<br/></li>
<li>&nbsp; &nbsp; fps-&gt;database_id = <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li>&nbsp; &nbsp; fps-&gt;authenticated_user_id = <a href="../../utils/init/miscinit.c.html#L583" title="utils/init/miscinit.c:583">GetAuthenticatedUserId</a>();<br/></li>
<li>&nbsp; &nbsp; fps-&gt;outer_user_id = <a href="../../utils/init/miscinit.c.html#L924" title="utils/init/miscinit.c:924">GetCurrentRoleId</a>();<br/></li>
<li>&nbsp; &nbsp; fps-&gt;is_superuser = <a href="../../utils/misc/guc_tables.c.html#L521" title="utils/misc/guc_tables.c:521">current_role_is_superuser</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/miscinit.c.html#L635" title="utils/init/miscinit.c:635">GetUserIdAndSecContext</a>(&amp;fps-&gt;current_user_id, &amp;fps-&gt;sec_context);<br/></li>
<li>&nbsp; &nbsp; <a href="../../catalog/namespace.c.html#L3790" title="catalog/namespace.c:3790">GetTempNamespaceState</a>(&amp;fps-&gt;temp_namespace_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;fps-&gt;temp_toast_namespace_id);<br/></li>
<li>&nbsp; &nbsp; fps-&gt;parallel_leader_pgproc = <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>;<br/></li>
<li>&nbsp; &nbsp; fps-&gt;parallel_leader_pid = <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li>&nbsp; &nbsp; fps-&gt;parallel_leader_proc_number = <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>;<br/></li>
<li>&nbsp; &nbsp; fps-&gt;xact_ts = <a href="xact.c.html#L867" title="access/transam/xact.c:867">GetCurrentTransactionStartTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; fps-&gt;stmt_ts = <a href="xact.c.html#L876" title="access/transam/xact.c:876">GetCurrentStatementStartTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; fps-&gt;serializable_xact_handle = <a href="../../storage/lmgr/predicate.c.html#L5031" title="storage/lmgr/predicate.c:5031">ShareSerializableXact</a>();<br/></li>
<li>&nbsp; &nbsp; SpinLockInit(&amp;fps-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; fps-&gt;last_xlog_end = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L64" title="access/transam/parallel.c:64">PARALLEL_KEY_FIXED</a>, fps);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the rest of this if we're not budgeting for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> workers. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;nworkers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *libraryspace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *gucspace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *combocidspace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tsnapspace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *asnapspace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tstatespace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pendingsyncsspace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *reindexspace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *relmapperspace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *error_queue_space;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *session_dsm_handle_space;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *entrypointstate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *uncommittedenumsspace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *clientconninfospace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; lnamelen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Serialize shared libraries we have loaded. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; libraryspace = <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, library_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/dfmgr.c.html#L654" title="utils/fmgr/dfmgr.c:654">SerializeLibraryState</a>(library_len, libraryspace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L66" title="access/transam/parallel.c:66">PARALLEL_KEY_LIBRARY</a>, libraryspace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Serialize GUC settings. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; gucspace = <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, guc_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L6060" title="utils/misc/guc.c:6060">SerializeGUCState</a>(guc_len, gucspace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L67" title="access/transam/parallel.c:67">PARALLEL_KEY_GUC</a>, gucspace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Serialize combo CID state. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; combocidspace = <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, combocidlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/combocid.c.html#L316" title="utils/time/combocid.c:316">SerializeComboCIDState</a>(combocidlen, combocidspace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L68" title="access/transam/parallel.c:68">PARALLEL_KEY_COMBO_CID</a>, combocidspace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Serialize the transaction snapshot if the transaction isolation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * level uses a transaction snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsolationUsesXactSnapshot())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tsnapspace = <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, tsnaplen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L1716" title="utils/time/snapmgr.c:1716">SerializeSnapshot</a>(transaction_snapshot, tsnapspace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L69" title="access/transam/parallel.c:69">PARALLEL_KEY_TRANSACTION_SNAPSHOT</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tsnapspace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Serialize the active snapshot. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; asnapspace = <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, asnaplen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L1716" title="utils/time/snapmgr.c:1716">SerializeSnapshot</a>(active_snapshot, asnapspace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L70" title="access/transam/parallel.c:70">PARALLEL_KEY_ACTIVE_SNAPSHOT</a>, asnapspace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Provide the handle for per-session segment. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; session_dsm_handle_space = <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dsm_handle));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *(dsm_handle *) session_dsm_handle_space = session_dsm_handle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L73" title="access/transam/parallel.c:73">PARALLEL_KEY_SESSION_DSM</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; session_dsm_handle_space);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Serialize transaction state. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tstatespace = <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, tstatelen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xact.c.html#L5491" title="access/transam/xact.c:5491">SerializeTransactionState</a>(tstatelen, tstatespace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L71" title="access/transam/parallel.c:71">PARALLEL_KEY_TRANSACTION_STATE</a>, tstatespace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Serialize pending syncs. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pendingsyncsspace = <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, pendingsyncslen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/storage.c.html#L559" title="catalog/storage.c:559">SerializePendingSyncs</a>(pendingsyncslen, pendingsyncsspace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L74" title="access/transam/parallel.c:74">PARALLEL_KEY_PENDING_SYNCS</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pendingsyncsspace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Serialize reindex state. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; reindexspace = <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, reindexlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/index.c.html#L4189" title="catalog/index.c:4189">SerializeReindexState</a>(reindexlen, reindexspace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L75" title="access/transam/parallel.c:75">PARALLEL_KEY_REINDEX_STATE</a>, reindexspace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Serialize relmapper state. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relmapperspace = <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, relmapperlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/relmapper.c.html#L724" title="utils/cache/relmapper.c:724">SerializeRelationMap</a>(relmapperlen, relmapperspace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L76" title="access/transam/parallel.c:76">PARALLEL_KEY_RELMAPPER_STATE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relmapperspace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Serialize uncommitted enum state. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; uncommittedenumsspace = <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uncommittedenumslen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/pg_enum.c.html#L827" title="catalog/pg_enum.c:827">SerializeUncommittedEnums</a>(uncommittedenumsspace, uncommittedenumslen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L77" title="access/transam/parallel.c:77">PARALLEL_KEY_UNCOMMITTEDENUMS</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uncommittedenumsspace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Serialize our ClientConnectionInfo. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; clientconninfospace = <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, clientconninfolen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/miscinit.c.html#L1043" title="utils/init/miscinit.c:1043">SerializeClientConnectionInfo</a>(clientconninfolen, clientconninfospace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L78" title="access/transam/parallel.c:78">PARALLEL_KEY_CLIENTCONNINFO</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; clientconninfospace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allocate space for worker information. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;worker = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ParallelWorkerInfo) * pcxt-&gt;nworkers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Establish error queues in dynamic shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These queues should be used only for transmitting ErrorResponse,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NoticeResponse, and NotifyResponse protocol messages.&nbsp; Tuple data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should be transmitted via separate (possibly larger?) queues.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; error_queue_space =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<a href="#L54" title="access/transam/parallel.c:54">PARALLEL_ERROR_QUEUE_SIZE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;nworkers));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; pcxt-&gt;nworkers; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>&nbsp; &nbsp; &nbsp;&nbsp; *mq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start = error_queue_space + i * <a href="#L54" title="access/transam/parallel.c:54">PARALLEL_ERROR_QUEUE_SIZE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mq = <a href="../../storage/ipc/shm_mq.c.html#L177" title="storage/ipc/shm_mq.c:177">shm_mq_create</a>(start, <a href="#L54" title="access/transam/parallel.c:54">PARALLEL_ERROR_QUEUE_SIZE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L206" title="storage/ipc/shm_mq.c:206">shm_mq_set_receiver</a>(mq, <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;worker[i].error_mqh = <a href="../../storage/ipc/shm_mq.c.html#L290" title="storage/ipc/shm_mq.c:290">shm_mq_attach</a>(mq, pcxt-&gt;seg, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L65" title="access/transam/parallel.c:65">PARALLEL_KEY_ERROR_QUEUE</a>, error_queue_space);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Serialize entrypoint information.&nbsp; It's unsafe to pass function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointers across processes, as the function pointer may be different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in each process in EXEC_BACKEND builds, so we always pass library<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and function name.&nbsp; (We use library name &quot;postgres&quot; for <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the core backend.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lnamelen = strlen(pcxt-&gt;library_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entrypointstate = <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, lnamelen +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strlen(pcxt-&gt;function_name) + <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcpy(entrypointstate, pcxt-&gt;library_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcpy(entrypointstate + lnamelen + <span class="Constant">1</span>, pcxt-&gt;function_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L72" title="access/transam/parallel.c:72">PARALLEL_KEY_ENTRYPOINT</a>, entrypointstate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore previous memory context. */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reinitialize the dynamic shared memory segment for a parallel context such<br/></li>
<li></span><span class="Comment"> * that we could launch workers for it again.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L488">&#x200c;</a></span><span class="linkable">ReinitializeParallelDSM</span>(ParallelContext *pcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L81" title="access/transam/parallel.c:81">FixedParallelState</a> *fps;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Wait for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> old workers to exit. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;nworkers_launched &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L775" title="access/transam/parallel.c:775">WaitForParallelWorkersToFinish</a>(pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L889" title="access/transam/parallel.c:889">WaitForParallelWorkersToExit</a>(pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;nworkers_launched = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;known_attached_workers)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pcxt-&gt;known_attached_workers);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;known_attached_workers = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;nknown_attached_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset a few bits of fixed parallel state to a clean state. */<br/></li>
<li></span>&nbsp; &nbsp; fps = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(pcxt-&gt;toc, <a href="#L64" title="access/transam/parallel.c:64">PARALLEL_KEY_FIXED</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; fps-&gt;last_xlog_end = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recreate error queues (if they exist). */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;nworkers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *error_queue_space;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; error_queue_space =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(pcxt-&gt;toc, <a href="#L65" title="access/transam/parallel.c:65">PARALLEL_KEY_ERROR_QUEUE</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; pcxt-&gt;nworkers; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>&nbsp; &nbsp; &nbsp;&nbsp; *mq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start = error_queue_space + i * <a href="#L54" title="access/transam/parallel.c:54">PARALLEL_ERROR_QUEUE_SIZE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mq = <a href="../../storage/ipc/shm_mq.c.html#L177" title="storage/ipc/shm_mq.c:177">shm_mq_create</a>(start, <a href="#L54" title="access/transam/parallel.c:54">PARALLEL_ERROR_QUEUE_SIZE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L206" title="storage/ipc/shm_mq.c:206">shm_mq_set_receiver</a>(mq, <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;worker[i].error_mqh = <a href="../../storage/ipc/shm_mq.c.html#L290" title="storage/ipc/shm_mq.c:290">shm_mq_attach</a>(mq, pcxt-&gt;seg, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reinitialize parallel workers for a parallel context such that we could<br/></li>
<li></span><span class="Comment"> * launch a different number of workers.&nbsp; This is required for cases where<br/></li>
<li></span><span class="Comment"> * we need to reuse the same DSM segment, but the number of workers can<br/></li>
<li></span><span class="Comment"> * vary from run-to-run.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L538">&#x200c;</a></span><span class="linkable">ReinitializeParallelWorkers</span>(ParallelContext *pcxt, <span class="Type">int</span> nworkers_to_launch)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The number of workers that need to be launched must be less than the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of workers with which the parallel context is initialized.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(pcxt-&gt;nworkers &gt;= nworkers_to_launch);<br/></li>
<li>&nbsp; &nbsp; pcxt-&gt;nworkers_to_launch = nworkers_to_launch;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Launch parallel workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L552">&#x200c;</a></span><span class="linkable">LaunchParallelWorkers</span>(ParallelContext *pcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; BackgroundWorker worker;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; any_registrations_failed = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Skip this if we have no workers. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;nworkers == <span class="Constant">0</span> || pcxt-&gt;nworkers_to_launch == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need to be a lock group leader. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L1893" title="storage/lmgr/proc.c:1893">BecomeLockGroupLeader</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we do have workers, we'd better have a DSM segment. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(pcxt-&gt;seg != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We might be running in a short-lived memory context. */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Configure a worker. */<br/></li>
<li></span>&nbsp; &nbsp; memset(&amp;worker, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(worker));<br/></li>
<li>&nbsp; &nbsp; snprintf(worker.bgw_name, BGW_MAXLEN, <span class="Constant">&quot;parallel worker for PID </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li>&nbsp; &nbsp; snprintf(worker.bgw_type, BGW_MAXLEN, <span class="Constant">&quot;parallel worker&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; worker.bgw_flags =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BGWORKER_SHMEM_ACCESS | BGWORKER_BACKEND_DATABASE_CONNECTION<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; | BGWORKER_CLASS_PARALLEL;<br/></li>
<li>&nbsp; &nbsp; worker.bgw_start_time = BgWorkerStart_ConsistentState;<br/></li>
<li>&nbsp; &nbsp; worker.bgw_restart_time = BGW_NEVER_RESTART;<br/></li>
<li>&nbsp; &nbsp; sprintf(worker.bgw_library_name, <span class="Constant">&quot;postgres&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; sprintf(worker.bgw_function_name, <span class="Constant">&quot;<a href="#L1271" title="access/transam/parallel.c:1271">ParallelWorkerMain</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; worker.bgw_main_arg = UInt32GetDatum(<a href="../../storage/ipc/dsm.c.html#L1123" title="storage/ipc/dsm.c:1123">dsm_segment_handle</a>(pcxt-&gt;seg));<br/></li>
<li>&nbsp; &nbsp; worker.bgw_notify_pid = <a href="../../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start workers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The caller must be able to tolerate ending up with fewer workers than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expected, so there is no need to throw an error here if registration<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fails.&nbsp; It wouldn't <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> much anyway, because registering the worker in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no way guarantees that it will start up and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> successfully.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; pcxt-&gt;nworkers_to_launch; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(worker.bgw_extra, &amp;i, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!any_registrations_failed &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/bgworker.c.html#L970" title="postmaster/bgworker.c:970">RegisterDynamicBackgroundWorker</a>(&amp;worker,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;pcxt-&gt;worker[i].bgwhandle))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L319" title="storage/ipc/shm_mq.c:319">shm_mq_set_handle</a>(pcxt-&gt;worker[i].error_mqh,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;worker[i].bgwhandle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;nworkers_launched++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we weren't able to register the worker, then we've bumped up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * against the <a href="../../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a> limit, and future<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * registrations will probably fail too, so arrange to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * But we still have to execute this code for the remaining slots<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to make sure that we forget about the error queues we budgeted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for those workers.&nbsp; Otherwise, we'll wait for them to start,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but they never will.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; any_registrations_failed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;worker[i].bgwhandle = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L843" title="storage/ipc/shm_mq.c:843">shm_mq_detach</a>(pcxt-&gt;worker[i].error_mqh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;worker[i].error_mqh = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that nworkers_launched has taken its final value, we can <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * known_attached_workers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;nworkers_launched &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;known_attached_workers =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * pcxt-&gt;nworkers_launched);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;nknown_attached_workers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore previous memory context. */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait for all workers to attach to their error queues, and throw an error if<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> worker fails to do this.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callers can assume that if this function returns successfully, then the<br/></li>
<li></span><span class="Comment"> * number of workers given by pcxt-&gt;nworkers_launched have initialized and<br/></li>
<li></span><span class="Comment"> * attached to their error queues.&nbsp; Whether or not these workers are guaranteed<br/></li>
<li></span><span class="Comment"> * to still be running depends on what code the caller asked them to run;<br/></li>
<li></span><span class="Comment"> * this function does not guarantee that they have not exited.&nbsp; However, it<br/></li>
<li></span><span class="Comment"> * does guarantee that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> workers which exited must have done so cleanly and<br/></li>
<li></span><span class="Comment"> * after successfully performing the work with which they were tasked.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If this function is not called, then some of the workers that were launched<br/></li>
<li></span><span class="Comment"> * may not have been started due to a fork() failure, or may have exited during<br/></li>
<li></span><span class="Comment"> * early startup prior to attaching to the error queue, so nworkers_launched<br/></li>
<li></span><span class="Comment"> * cannot be viewed as completely reliable.&nbsp; It will never be less than the<br/></li>
<li></span><span class="Comment"> * number of workers which actually started, but it might be more.&nbsp; Any workers<br/></li>
<li></span><span class="Comment"> * that failed to start will still be discovered by<br/></li>
<li></span><span class="Comment"> * <a href="#L775" title="access/transam/parallel.c:775">WaitForParallelWorkersToFinish</a> and an error will be thrown at that time,<br/></li>
<li></span><span class="Comment"> * provided that function is eventually reached.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In general, the leader process should do as much work as possible <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * calling this function.&nbsp; fork() failures and other early-startup failures<br/></li>
<li></span><span class="Comment"> * are very uncommon, and having the leader sit idle when it could be doing<br/></li>
<li></span><span class="Comment"> * useful work is undesirable.&nbsp; However, if the leader needs to wait for<br/></li>
<li></span><span class="Comment"> * all of its workers or for a specific worker, it may want to call this<br/></li>
<li></span><span class="Comment"> * function <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing so.&nbsp; If not, it must make some other provision for<br/></li>
<li></span><span class="Comment"> * the failure-to-start case, lest it wait forever.&nbsp; On the other hand, a<br/></li>
<li></span><span class="Comment"> * leader which never waits for a worker that might not be started yet, or<br/></li>
<li></span><span class="Comment"> * at least never does so prior to <a href="#L775" title="access/transam/parallel.c:775">WaitForParallelWorkersToFinish</a>(), need not<br/></li>
<li></span><span class="Comment"> * call this function at all.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L672">&#x200c;</a></span><span class="linkable">WaitForParallelWorkersToAttach</span>(ParallelContext *pcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Skip this if we have no launched workers. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;nworkers_launched == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This will process <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parallel messages that are pending and it may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * also throw an error propagated from a worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; pcxt-&gt;nworkers_launched; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BgwHandleStatus status;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>&nbsp; &nbsp; &nbsp;&nbsp; *mq;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;known_attached_workers[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If error_mqh is NULL, then the worker has already exited<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cleanly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;worker[i].error_mqh == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;known_attached_workers[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++pcxt-&gt;nknown_attached_workers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="../../postmaster/bgworker.c.html#L1082" title="postmaster/bgworker.c:1082">GetBackgroundWorkerPid</a>(pcxt-&gt;worker[i].bgwhandle, &amp;pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (status == BGWH_STARTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Has the worker attached to the error queue? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mq = <a href="../../storage/ipc/shm_mq.c.html#L905" title="storage/ipc/shm_mq.c:905">shm_mq_get_queue</a>(pcxt-&gt;worker[i].error_mqh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/ipc/shm_mq.c.html#L257" title="storage/ipc/shm_mq.c:257">shm_mq_get_sender</a>(mq) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Yes, so it is known to be attached. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;known_attached_workers[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++pcxt-&gt;nknown_attached_workers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (status == BGWH_STOPPED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the worker stopped without attaching to the error queue,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * throw an error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mq = <a href="../../storage/ipc/shm_mq.c.html#L905" title="storage/ipc/shm_mq.c:905">shm_mq_get_queue</a>(pcxt-&gt;worker[i].error_mqh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/ipc/shm_mq.c.html#L257" title="storage/ipc/shm_mq.c:257">shm_mq_get_sender</a>(mq) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;parallel worker failed to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a>&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;More details may be available in the server log.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;known_attached_workers[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++pcxt-&gt;nknown_attached_workers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Worker not yet started, so we must wait.&nbsp; The postmaster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will notify us if the worker's state changes.&nbsp; Our latch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might also get set for some other reason, but if so we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just end up <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the same worker again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1</span>, WAIT_EVENT_BGWORKER_STARTUP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &amp; WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If all workers are known to have started, we're done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;nknown_attached_workers &gt;= pcxt-&gt;nworkers_launched)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(pcxt-&gt;nknown_attached_workers == pcxt-&gt;nworkers_launched);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait for all workers to finish computing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Even if the parallel operation seems to have completed successfully, it's<br/></li>
<li></span><span class="Comment"> * important to call this function afterwards.&nbsp; We must not <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> errors<br/></li>
<li></span><span class="Comment"> * the workers may have thrown during the parallel operation, or <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> that they<br/></li>
<li></span><span class="Comment"> * may yet throw while shutting down.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also, we want to update our notion of <a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a> based on worker<br/></li>
<li></span><span class="Comment"> * feedback.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L775">&#x200c;</a></span><span class="linkable">WaitForParallelWorkersToFinish</span>(ParallelContext *pcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; anyone_alive = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nfinished = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This will process <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parallel messages that are pending, which may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * change the outcome of the loop that follows.&nbsp; It may also throw an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error propagated from a worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; pcxt-&gt;nworkers_launched; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If error_mqh is NULL, then the worker has already exited<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cleanly.&nbsp; If we have received a message through error_mqh from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the worker, we know it started up cleanly, and therefore we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * certain to be notified when it exits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;worker[i].error_mqh == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++nfinished;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pcxt-&gt;known_attached_workers[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; anyone_alive = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!anyone_alive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If all workers are known to have finished, we're done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nfinished &gt;= pcxt-&gt;nworkers_launched)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nfinished == pcxt-&gt;nworkers_launched);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We didn't detect <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> living workers, but not all workers are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * known to have exited cleanly.&nbsp; Either not all workers have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * launched yet, or maybe some of them failed to start or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * terminated abnormally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; pcxt-&gt;nworkers_launched; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>&nbsp; &nbsp; &nbsp;&nbsp; *mq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the worker is BGWH_NOT_YET_STARTED or BGWH_STARTED, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should just keep <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>.&nbsp; If it is BGWH_STOPPED, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * further investigation is needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;worker[i].error_mqh == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;worker[i].bgwhandle == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/bgworker.c.html#L1082" title="postmaster/bgworker.c:1082">GetBackgroundWorkerPid</a>(pcxt-&gt;worker[i].bgwhandle,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;pid) != BGWH_STOPPED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check whether the worker ended up stopped without ever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attaching to the error queue.&nbsp; If so, the postmaster was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unable to fork the worker or it exited without initializing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * properly.&nbsp; We must throw an error, since the caller may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have been expecting the worker to do some work <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exiting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mq = <a href="../../storage/ipc/shm_mq.c.html#L905" title="storage/ipc/shm_mq.c:905">shm_mq_get_queue</a>(pcxt-&gt;worker[i].error_mqh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/ipc/shm_mq.c.html#L257" title="storage/ipc/shm_mq.c:257">shm_mq_get_sender</a>(mq) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;parallel worker failed to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a>&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;More details may be available in the server log.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The worker is stopped, but is attached to the error queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unless there's a bug somewhere, this will only happen when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the worker writes messages and terminates after the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CHECK_FOR_INTERRUPTS() near the top of this function and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the call to <a href="../../postmaster/bgworker.c.html#L1082" title="postmaster/bgworker.c:1082">GetBackgroundWorkerPid</a>().&nbsp; In that case,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or latch should have been set as well and the right things<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will happen on the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> pass through the loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>, WL_LATCH_SET | WL_EXIT_ON_PM_DEATH, -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_PARALLEL_FINISH);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;toc != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L81" title="access/transam/parallel.c:81">FixedParallelState</a> *fps;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fps = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(pcxt-&gt;toc, <a href="#L64" title="access/transam/parallel.c:64">PARALLEL_KEY_FIXED</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fps-&gt;last_xlog_end &gt; <a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a> = fps-&gt;last_xlog_end;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait for all workers to exit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function ensures that workers have been completely shutdown.&nbsp; The<br/></li>
<li></span><span class="Comment"> * difference between <a href="#L775" title="access/transam/parallel.c:775">WaitForParallelWorkersToFinish</a> and this function is<br/></li>
<li></span><span class="Comment"> * that the former just ensures that last message sent by a worker backend is<br/></li>
<li></span><span class="Comment"> * received by the leader backend whereas this ensures the complete shutdown.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L889">&#x200c;</a></span><span class="linkable">WaitForParallelWorkersToExit</span>(ParallelContext *pcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Wait until the workers actually <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; pcxt-&gt;nworkers_launched; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BgwHandleStatus status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;worker == <span class="Constant">NULL</span> || pcxt-&gt;worker[i].bgwhandle == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; status = <a href="../../postmaster/bgworker.c.html#L1182" title="postmaster/bgworker.c:1182">WaitForBackgroundWorkerShutdown</a>(pcxt-&gt;worker[i].bgwhandle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the postmaster kicked the bucket, we have no chance of cleaning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up safely -- we won't be able to tell when our workers are actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dead.&nbsp; This doesn't necessitate a PANIC since they will all abort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * eventually, but we can't safely continue this session.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (status == BGWH_POSTMASTER_DIED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ADMIN_SHUTDOWN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;postmaster exited during a parallel transaction&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release memory. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pcxt-&gt;worker[i].bgwhandle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;worker[i].bgwhandle = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Destroy a parallel context.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If expecting a clean exit, you should use <a href="#L775" title="access/transam/parallel.c:775">WaitForParallelWorkersToFinish</a>()<br/></li>
<li></span><span class="Comment"> * first, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling this function.&nbsp; When this function is invoked, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * remaining workers are forcibly killed; the dynamic shared memory segment<br/></li>
<li></span><span class="Comment"> * is unmapped; and we then wait (uninterruptibly) for the workers to exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L929">&#x200c;</a></span><span class="linkable">DestroyParallelContext</span>(ParallelContext *pcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Be careful about order of operations here!&nbsp; We remove the parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context from the list <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we do anything else; otherwise, if an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error occurs during a subsequent step, we might try to nuke it again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from <a href="#L1254" title="access/transam/parallel.c:1254">AtEOXact_Parallel</a> or <a href="#L1233" title="access/transam/parallel.c:1233">AtEOSubXact_Parallel</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dlist_delete(&amp;pcxt-&gt;node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Kill each worker in turn, and forget their error queues. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;worker != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; pcxt-&gt;nworkers_launched; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;worker[i].error_mqh != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/bgworker.c.html#L1221" title="postmaster/bgworker.c:1221">TerminateBackgroundWorker</a>(pcxt-&gt;worker[i].bgwhandle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L843" title="storage/ipc/shm_mq.c:843">shm_mq_detach</a>(pcxt-&gt;worker[i].error_mqh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;worker[i].error_mqh = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have allocated a shared memory segment, detach it.&nbsp; This will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implicitly detach the error queues, and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other shared memory queues,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stored there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;seg != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L803" title="storage/ipc/dsm.c:803">dsm_detach</a>(pcxt-&gt;seg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;seg = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this parallel context is actually in backend-private memory rather<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than shared memory, free that memory instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;private_memory != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pcxt-&gt;private_memory);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;private_memory = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't finish transaction commit or abort until all of the workers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have exited.&nbsp; This means, in particular, that we can't respond to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interrupts at this stage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; <a href="#L889" title="access/transam/parallel.c:889">WaitForParallelWorkersToExit</a>(pcxt);<br/></li>
<li>&nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Free the worker array itself. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;worker != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pcxt-&gt;worker);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;worker = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Free memory. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pcxt-&gt;library_name);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pcxt-&gt;function_name);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Are there <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parallel contexts currently active?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1003">&#x200c;</a></span><span class="linkable">ParallelContextActive</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> !dlist_is_empty(&amp;<a href="#L124" title="access/transam/parallel.c:124">pcxt_list</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle receipt of an interrupt indicating a parallel worker message.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is called within a signal handler!&nbsp; All we can do is set<br/></li>
<li></span><span class="Comment"> * a flag that will cause the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> CHECK_FOR_INTERRUPTS() to invoke<br/></li>
<li></span><span class="Comment"> * <a href="#L1027" title="access/transam/parallel.c:1027">HandleParallelMessages</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1016">&#x200c;</a></span><span class="linkable">HandleParallelMessageInterrupt</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L115" title="access/transam/parallel.c:115">ParallelMessagePending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> queued protocol messages received from parallel workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1027">&#x200c;</a></span><span class="linkable">HandleParallelMessages</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> MemoryContext hpm_context = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is invoked from <a href="../../tcop/postgres.c.html#L3244" title="tcop/postgres.c:3244">ProcessInterrupts</a>(), and since some of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> it calls contain CHECK_FOR_INTERRUPTS(), there is a potential<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for recursive calls if more signals are received while this runs.&nbsp; It's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unclear that recursive entry would be safe, and it doesn't seem useful<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * even if it is safe, so let's block interrupts until done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Moreover, <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> might be pointing almost anywhere.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't want to risk leaking data into long-lived contexts, so let's do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * our work here in a private context that we can reset on each use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hpm_context == <span class="Constant">NULL</span>)&nbsp; &nbsp; <span class="Comment">/* first time through? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hpm_context = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L1027" title="access/transam/parallel.c:1027">HandleParallelMessages</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(hpm_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(hpm_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK to process messages.&nbsp; Reset the flag saying there are more to do. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L115" title="access/transam/parallel.c:115">ParallelMessagePending</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L124" title="access/transam/parallel.c:124">pcxt_list</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ParallelContext *pcxt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pcxt = dlist_container(ParallelContext, node, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;worker == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; pcxt-&gt;nworkers_launched; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Read as many messages as we can from each worker, but stop when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either (1) the worker's error queue goes away, which can happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we receive a Terminate message from the worker; or (2) no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more messages can be read from the worker without blocking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (pcxt-&gt;worker[i].error_mqh != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shm_mq_result res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="../../storage/ipc/shm_mq.c.html#L572" title="storage/ipc/shm_mq.c:572">shm_mq_receive</a>(pcxt-&gt;worker[i].error_mqh, &amp;nbytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;data, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res == SHM_MQ_WOULD_BLOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (res == SHM_MQ_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfoData msg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;msg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(&amp;msg, data, nbytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1116" title="access/transam/parallel.c:1116">HandleParallelMessage</a>(pcxt, i, &amp;msg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(msg.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;lost connection to parallel worker&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Might as well clear the context on our way out */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(hpm_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle a single protocol message received from a single parallel worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1116">&#x200c;</a></span><span class="linkable">HandleParallelMessage</span>(ParallelContext *pcxt, <span class="Type">int</span> i, StringInfo msg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; msgtype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;known_attached_workers != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !pcxt-&gt;known_attached_workers[i])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;known_attached_workers[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;nknown_attached_workers++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; msgtype = <a href="../../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(msg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (msgtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_ErrorResponse:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_NoticeResponse:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ErrorData&nbsp; &nbsp; edata;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ErrorContextCallback *save_error_context_stack;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parse ErrorResponse or NoticeResponse. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqmq.c.html#L216" title="libpq/pqmq.c:216">pq_parse_errornotice</a>(msg, &amp;edata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Death of a worker isn't enough justification for suicide. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; edata.elevel = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(edata.elevel, ERROR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If desired, add a context line to show that this is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * message propagated from a parallel worker.&nbsp; Otherwise, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can sometimes be confusing to understand what actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happened.&nbsp; (We don't do this in DEBUG_PARALLEL_REGRESS mode<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because it causes test-result instability depending on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether a parallel worker is actually used or not.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/plan/planner.c.html#L67" title="optimizer/plan/planner.c:67">debug_parallel_query</a> != DEBUG_PARALLEL_REGRESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (edata.context)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; edata.context = psprintf(<span class="Constant">&quot;</span><span class="Special">%s\n%s</span><span class="Constant">&quot;</span>, edata.context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;parallel worker&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; edata.context = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;parallel worker&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Context beyond that should use the error context callbacks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that were in effect when the ParallelContext was created,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not the current ones.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_error_context_stack = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = pcxt-&gt;<a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Rethrow error or <a href="../../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> notice. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1861" title="utils/error/elog.c:1861">ThrowErrorData</a>(&amp;edata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not an error, so restore previous context stack. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = save_error_context_stack;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_NotificationResponse:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Propagate NotifyResponse. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *channel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *payload;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(msg, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; channel = <a href="../../libpq/pqformat.c.html#L608" title="libpq/pqformat.c:608">pq_getmsgrawstring</a>(msg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; payload = <a href="../../libpq/pqformat.c.html#L608" title="libpq/pqformat.c:608">pq_getmsgrawstring</a>(msg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L296" title="libpq/pqformat.c:296">pq_endmessage</a>(msg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/async.c.html#L2224" title="commands/async.c:2224">NotifyMyFrontEnd</a>(channel, payload, pid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'P'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parallel progress reporting */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only incremental progress reporting is currently supported.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, it's possible to add more fields to the message to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allow for handling of other backend progress APIs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = <a href="../../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(msg, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; incr = <a href="../../libpq/pqformat.c.html#L453" title="libpq/pqformat.c:453">pq_getmsgint64</a>(msg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../libpq/pqformat.c.html#L635" title="libpq/pqformat.c:635">pq_getmsgend</a>(msg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L70" title="utils/activity/backend_progress.c:70">pgstat_progress_incr_param</a>(index, incr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Terminate:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L843" title="storage/ipc/shm_mq.c:843">shm_mq_detach</a>(pcxt-&gt;worker[i].error_mqh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;worker[i].error_mqh = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized message type received from parallel worker: </span><span class="Special">%c</span><span class="Constant"> (message length </span><span class="Special">%d</span><span class="Constant"> bytes)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; msgtype, msg-&gt;len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * End-of-subtransaction <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> for parallel contexts.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Here we remove only parallel contexts initiated within the current<br/></li>
<li></span><span class="Comment"> * subtransaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1233">&#x200c;</a></span><span class="linkable">AtEOSubXact_Parallel</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit, SubTransactionId mySubId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (!dlist_is_empty(&amp;<a href="#L124" title="access/transam/parallel.c:124">pcxt_list</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ParallelContext *pcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pcxt = dlist_head_element(ParallelContext, node, &amp;<a href="#L124" title="access/transam/parallel.c:124">pcxt_list</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;subid != mySubId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;leaked parallel context&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L929" title="access/transam/parallel.c:929">DestroyParallelContext</a>(pcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * End-of-transaction <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> for parallel contexts.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We nuke all remaining parallel contexts.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1254">&#x200c;</a></span><span class="linkable">AtEOXact_Parallel</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (!dlist_is_empty(&amp;<a href="#L124" title="access/transam/parallel.c:124">pcxt_list</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ParallelContext *pcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pcxt = dlist_head_element(ParallelContext, node, &amp;<a href="#L124" title="access/transam/parallel.c:124">pcxt_list</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;leaked parallel context&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L929" title="access/transam/parallel.c:929">DestroyParallelContext</a>(pcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Main entrypoint for parallel workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1271">&#x200c;</a></span><span class="linkable">ParallelWorkerMain</span>(Datum main_arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L26" title="storage/ipc/shm_toc.c:26">shm_toc</a>&nbsp; &nbsp; *toc;<br/></li>
<li>&nbsp; &nbsp; <a href="#L81" title="access/transam/parallel.c:81">FixedParallelState</a> *fps;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *error_queue_space;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a>&nbsp; &nbsp; &nbsp;&nbsp; *mq;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L137" title="storage/ipc/shm_mq.c:137">shm_mq_handle</a> *mqh;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *libraryspace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *entrypointstate;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *library_name;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *function_name;<br/></li>
<li>&nbsp; &nbsp; parallel_worker_main_type entrypt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *gucspace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *combocidspace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tsnapspace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *asnapspace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tstatespace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pendingsyncsspace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *reindexspace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *relmapperspace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *uncommittedenumsspace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *clientconninfospace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *session_dsm_handle_space;<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; tsnapshot;<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; asnapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set flag to indicate that we're initializing a parallel worker. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L118" title="access/transam/parallel.c:118">InitializingParallelWorker</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Establish signal handlers. */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGTERM</span>, <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../postmaster/postmaster.c.html#L4229" title="postmaster/postmaster.c:4229">BackgroundWorkerUnblockSignals</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine and set our parallel worker number. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a> == -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;<a href="#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a>, <a href="../../postmaster/postmaster.c.html#L185" title="postmaster/postmaster.c:185">MyBgworkerEntry</a>-&gt;bgw_extra, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up a memory context to work in, just for cleanliness. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Parallel worker&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Attach to the dynamic shared memory segment for the parallel query, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> its table of contents.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: at this point, we have not created <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> ResourceOwner in this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process.&nbsp; This will result in our DSM mapping surviving until process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exit, which is fine.&nbsp; If there were a ResourceOwner, it would acquire<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ownership of the mapping, but we have no need for that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; seg = <a href="../../storage/ipc/dsm.c.html#L665" title="storage/ipc/dsm.c:665">dsm_attach</a>(DatumGetUInt32(main_arg));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (seg == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not map dynamic shared memory segment&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; toc = <a href="../../storage/ipc/shm_toc.c.html#L64" title="storage/ipc/shm_toc.c:64">shm_toc_attach</a>(<a href="#L57" title="access/transam/parallel.c:57">PARALLEL_MAGIC</a>, <a href="../../storage/ipc/dsm.c.html#L1095" title="storage/ipc/dsm.c:1095">dsm_segment_address</a>(seg));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (toc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid magic number in dynamic shared memory segment&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up fixed parallel state. */<br/></li>
<li></span>&nbsp; &nbsp; fps = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L64" title="access/transam/parallel.c:64">PARALLEL_KEY_FIXED</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L121" title="access/transam/parallel.c:121">MyFixedParallelState</a> = fps;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Arrange to signal the leader if we exit. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L127" title="access/transam/parallel.c:127">ParallelLeaderPid</a> = fps-&gt;parallel_leader_pid;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L89" title="utils/init/globals.c:89">ParallelLeaderProcNumber</a> = fps-&gt;parallel_leader_proc_number;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>(<a href="#L1567" title="access/transam/parallel.c:1567">ParallelWorkerShutdown</a>, PointerGetDatum(seg));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we can <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> and attach to the error queue provided for us.&nbsp; That's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * good, because until we do that, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> errors that happen here will not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reported back to the process that requested that this worker be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * launched.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; error_queue_space = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L65" title="access/transam/parallel.c:65">PARALLEL_KEY_ERROR_QUEUE</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; mq = (<a href="../../storage/ipc/shm_mq.c.html#L71" title="storage/ipc/shm_mq.c:71">shm_mq</a> *) (error_queue_space +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a> * <a href="#L54" title="access/transam/parallel.c:54">PARALLEL_ERROR_QUEUE_SIZE</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_mq.c.html#L224" title="storage/ipc/shm_mq.c:224">shm_mq_set_sender</a>(mq, <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>);<br/></li>
<li>&nbsp; &nbsp; mqh = <a href="../../storage/ipc/shm_mq.c.html#L290" title="storage/ipc/shm_mq.c:290">shm_mq_attach</a>(mq, seg, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqmq.c.html#L53" title="libpq/pqmq.c:53">pq_redirect_to_shm_mq</a>(seg, mqh);<br/></li>
<li>&nbsp; &nbsp; <a href="../../libpq/pqmq.c.html#L78" title="libpq/pqmq.c:78">pq_set_parallel_leader</a>(fps-&gt;parallel_leader_pid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fps-&gt;parallel_leader_proc_number);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Hooray! Primary initialization is complete.&nbsp; Now, we need to set up our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backend-local state to match the original backend.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Join locking group.&nbsp; We must do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> anything that could try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * acquire a heavyweight lock, because <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> heavyweight locks acquired to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this point could block either directly against the parallel group<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leader or against some process which in turn waits for a lock that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conflicts with the parallel group leader, causing an undetected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deadlock.&nbsp; (If we can't join the lock group, the leader has gone away,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so just exit quietly.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/lmgr/proc.c.html#L1923" title="storage/lmgr/proc.c:1923">BecomeLockGroupMember</a>(fps-&gt;parallel_leader_pgproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fps-&gt;parallel_leader_pid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Restore transaction and statement start-time timestamps.&nbsp; This must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happen <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> anything that would start a transaction, else asserts in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xact.c will fire.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xact.c.html#L856" title="access/transam/xact.c:856">SetParallelStartTimestamps</a>(fps-&gt;xact_ts, fps-&gt;stmt_ts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Identify the entry point to be called.&nbsp; In theory this could result in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loading an additional library, though most likely the entry point is in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the core backend or in a library we just loaded.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; entrypointstate = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L72" title="access/transam/parallel.c:72">PARALLEL_KEY_ENTRYPOINT</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; library_name = entrypointstate;<br/></li>
<li>&nbsp; &nbsp; function_name = entrypointstate + strlen(library_name) + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entrypt = <a href="#L1595" title="access/transam/parallel.c:1595">LookupParallelWorkerFunction</a>(library_name, function_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore database connection. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../postmaster/postmaster.c.html#L4189" title="postmaster/postmaster.c:4189">BackgroundWorkerInitializeConnectionByOid</a>(fps-&gt;database_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fps-&gt;authenticated_user_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the client encoding to the database encoding, since that is what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the leader will expect.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mb/mbutils.c.html#L208" title="utils/mb/mbutils.c:208">SetClientEncoding</a>(<a href="../../utils/mb/mbutils.c.html#L1261" title="utils/mb/mbutils.c:1261">GetDatabaseEncoding</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Load libraries that were loaded by original backend.&nbsp; We want to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> restoring GUCs, because the libraries might define custom<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * variables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; libraryspace = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L66" title="access/transam/parallel.c:66">PARALLEL_KEY_LIBRARY</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/fmgr/dfmgr.c.html#L676" title="utils/fmgr/dfmgr.c:676">RestoreLibraryState</a>(libraryspace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore GUC <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> from launching backend. */<br/></li>
<li></span>&nbsp; &nbsp; gucspace = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L67" title="access/transam/parallel.c:67">PARALLEL_KEY_GUC</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L6152" title="utils/misc/guc.c:6152">RestoreGUCState</a>(gucspace);<br/></li>
<li>&nbsp; &nbsp; <a href="xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Crank up a transaction state appropriate to a parallel worker. */<br/></li>
<li></span>&nbsp; &nbsp; tstatespace = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L71" title="access/transam/parallel.c:71">PARALLEL_KEY_TRANSACTION_STATE</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="xact.c.html#L5562" title="access/transam/xact.c:5562">StartParallelWorkerTransaction</a>(tstatespace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore combo CID state. */<br/></li>
<li></span>&nbsp; &nbsp; combocidspace = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L68" title="access/transam/parallel.c:68">PARALLEL_KEY_COMBO_CID</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/time/combocid.c.html#L342" title="utils/time/combocid.c:342">RestoreComboCIDState</a>(combocidspace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Attach to the per-session DSM segment and contained objects. */<br/></li>
<li></span>&nbsp; &nbsp; session_dsm_handle_space =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L73" title="access/transam/parallel.c:73">PARALLEL_KEY_SESSION_DSM</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../common/session.c.html#L155" title="access/common/session.c:155">AttachSession</a>(*(dsm_handle *) session_dsm_handle_space);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the transaction isolation level is REPEATABLE READ or SERIALIZABLE,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the leader has serialized the transaction snapshot and we must restore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it. At <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> isolation levels, there is no transaction-lifetime<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot, but we need <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a> to get set to a value which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * less than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the xmin of every snapshot that will be used by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this worker. The easiest way to accomplish that is to install the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * active snapshot as the transaction snapshot. Code running in this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel worker might take new snapshots via <a href="../../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or <a href="../../utils/time/snapmgr.c.html#L291" title="utils/time/snapmgr.c:291">GetLatestSnapshot</a>(), but it shouldn't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> way of acquiring a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot older than the active snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; asnapspace = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L70" title="access/transam/parallel.c:70">PARALLEL_KEY_ACTIVE_SNAPSHOT</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; tsnapspace = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L69" title="access/transam/parallel.c:69">PARALLEL_KEY_TRANSACTION_SNAPSHOT</a>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; asnapshot = <a href="../../utils/time/snapmgr.c.html#L1775" title="utils/time/snapmgr.c:1775">RestoreSnapshot</a>(asnapspace);<br/></li>
<li>&nbsp; &nbsp; tsnapshot = tsnapspace ? <a href="../../utils/time/snapmgr.c.html#L1775" title="utils/time/snapmgr.c:1775">RestoreSnapshot</a>(tsnapspace) : asnapshot;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L1840" title="utils/time/snapmgr.c:1840">RestoreTransactionSnapshot</a>(tsnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; fps-&gt;parallel_leader_pgproc);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a>(asnapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We've changed which tuples we can see, and must therefore invalidate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * system caches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L792" title="utils/cache/inval.c:792">InvalidateSystemCaches</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Restore current role id.&nbsp; Skip verifying whether session user is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allowed to become this role and blindly restore the leader's state for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current role.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/init/miscinit.c.html#L945" title="utils/init/miscinit.c:945">SetCurrentRoleId</a>(fps-&gt;outer_user_id, fps-&gt;is_superuser);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore user ID and security context. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(fps-&gt;current_user_id, fps-&gt;sec_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore temp-namespace state to ensure search path matches leader's. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../catalog/namespace.c.html#L3806" title="catalog/namespace.c:3806">SetTempNamespaceState</a>(fps-&gt;temp_namespace_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fps-&gt;temp_toast_namespace_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore pending syncs. */<br/></li>
<li></span>&nbsp; &nbsp; pendingsyncsspace = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L74" title="access/transam/parallel.c:74">PARALLEL_KEY_PENDING_SYNCS</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../catalog/storage.c.html#L610" title="catalog/storage.c:610">RestorePendingSyncs</a>(pendingsyncsspace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore reindex state. */<br/></li>
<li></span>&nbsp; &nbsp; reindexspace = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L75" title="access/transam/parallel.c:75">PARALLEL_KEY_REINDEX_STATE</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../catalog/index.c.html#L4207" title="catalog/index.c:4207">RestoreReindexState</a>(reindexspace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore relmapper state. */<br/></li>
<li></span>&nbsp; &nbsp; relmapperspace = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L76" title="access/transam/parallel.c:76">PARALLEL_KEY_RELMAPPER_STATE</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/cache/relmapper.c.html#L741" title="utils/cache/relmapper.c:741">RestoreRelationMap</a>(relmapperspace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore uncommitted enums. */<br/></li>
<li></span>&nbsp; &nbsp; uncommittedenumsspace = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L77" title="access/transam/parallel.c:77">PARALLEL_KEY_UNCOMMITTEDENUMS</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../catalog/pg_enum.c.html#L873" title="catalog/pg_enum.c:873">RestoreUncommittedEnums</a>(uncommittedenumsspace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore the ClientConnectionInfo. */<br/></li>
<li></span>&nbsp; &nbsp; clientconninfospace = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L78" title="access/transam/parallel.c:78">PARALLEL_KEY_CLIENTCONNINFO</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/init/miscinit.c.html#L1075" title="utils/init/miscinit.c:1075">RestoreClientConnectionInfo</a>(clientconninfospace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize <a href="../../utils/init/miscinit.c.html#L498" title="utils/init/miscinit.c:498">SystemUser</a> <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that <a href="../../utils/init/miscinit.c.html#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a> is restored. Also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensure that auth_method is actually valid, aka authn_id is not NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/miscinit.c.html#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.authn_id)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/miscinit.c.html#L867" title="utils/init/miscinit.c:867">InitializeSystemUser</a>(<a href="../../utils/init/miscinit.c.html#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.authn_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../libpq/hba.c.html#L3061" title="libpq/hba.c:3061">hba_authname</a>(<a href="../../utils/init/miscinit.c.html#L1010" title="utils/init/miscinit.c:1010">MyClientConnectionInfo</a>.auth_method));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Attach to the leader's serializable transaction, if SERIALIZABLE. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L5040" title="storage/lmgr/predicate.c:5040">AttachSerializableXact</a>(fps-&gt;serializable_xact_handle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We've initialized all of our state <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>; nothing should change<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hereafter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L118" title="access/transam/parallel.c:118">InitializingParallelWorker</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="xact.c.html#L1048" title="access/transam/xact.c:1048">EnterParallelMode</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Time to do the real work: invoke the caller-supplied code.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; entrypt(seg, toc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must exit parallel mode to pop active snapshot. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xact.c.html#L1061" title="access/transam/xact.c:1061">ExitParallelMode</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must pop active snapshot so snapmgr.c doesn't complain. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shut down the parallel-worker transaction. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xact.c.html#L5587" title="access/transam/xact.c:5587">EndParallelWorkerTransaction</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Detach from the per-session DSM segment. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../common/session.c.html#L201" title="access/common/session.c:201">DetachSession</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report success. */<br/></li>
<li></span>&nbsp; &nbsp; pq_putmessage(PqMsg_Terminate, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update shared memory with the ending location of the last WAL record we<br/></li>
<li></span><span class="Comment"> * wrote, if it's greater than the value already stored there.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1539">&#x200c;</a></span><span class="linkable">ParallelWorkerReportLastRecEnd</span>(XLogRecPtr last_xlog_end)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L81" title="access/transam/parallel.c:81">FixedParallelState</a> *fps = <a href="#L121" title="access/transam/parallel.c:121">MyFixedParallelState</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(fps != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;fps-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fps-&gt;last_xlog_end &lt; last_xlog_end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fps-&gt;last_xlog_end = last_xlog_end;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;fps-&gt;mutex);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make sure the leader tries to read from our error queue one more time.<br/></li>
<li></span><span class="Comment"> * This guards against the case where we exit uncleanly without sending an<br/></li>
<li></span><span class="Comment"> * ErrorResponse to the leader, for example because some code calls <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a><br/></li>
<li></span><span class="Comment"> * directly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also explicitly detach from dsm segment so that subsystems using<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/ipc/dsm.c.html#L1132" title="storage/ipc/dsm.c:1132">on_dsm_detach</a>() have a chance to <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> stats <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the stats subsystem is<br/></li>
<li></span><span class="Comment"> * shut down as part of a <a href="../../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>() hook.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * One might think this could instead be solved by carefully ordering the<br/></li>
<li></span><span class="Comment"> * attaching to dsm segments, so that the pgstats segments get detached from<br/></li>
<li></span><span class="Comment"> * later than the parallel query one. That turns out to not work because the<br/></li>
<li></span><span class="Comment"> * stats <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> might need to grow which can cause new segments to be allocated,<br/></li>
<li></span><span class="Comment"> * which then will be detached from earlier.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1567">&#x200c;</a></span><span class="linkable">ParallelWorkerShutdown</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/procsignal.c.html#L257" title="storage/ipc/procsignal.c:257">SendProcSignal</a>(<a href="#L127" title="access/transam/parallel.c:127">ParallelLeaderPid</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PROCSIG_PARALLEL_MESSAGE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L89" title="utils/init/globals.c:89">ParallelLeaderProcNumber</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/dsm.c.html#L803" title="storage/ipc/dsm.c:803">dsm_detach</a>((<a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *) DatumGetPointer(arg));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Look up (and possibly load) a parallel worker entry point function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> contained in the core code, we use library name &quot;postgres&quot;<br/></li>
<li></span><span class="Comment"> * and consult the <a href="#L137" title="access/transam/parallel.c:137">InternalParallelWorkers</a> array.&nbsp; External <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are<br/></li>
<li></span><span class="Comment"> * looked up, and loaded if necessary, using <a href="../../utils/fmgr/dfmgr.c.html#L105" title="utils/fmgr/dfmgr.c:105">load_external_function</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The point of this is to pass function names as strings across process<br/></li>
<li></span><span class="Comment"> * boundaries.&nbsp; We can't pass actual function addresses because of the<br/></li>
<li></span><span class="Comment"> * possibility that the function has been loaded at a different address<br/></li>
<li></span><span class="Comment"> * in a different process.&nbsp; This is obviously a hazard for <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in<br/></li>
<li></span><span class="Comment"> * loadable libraries, but it can happen even for <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in the core code<br/></li>
<li></span><span class="Comment"> * on platforms using EXEC_BACKEND (e.g., Windows).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At some point it might be worthwhile to get rid of <a href="#L137" title="access/transam/parallel.c:137">InternalParallelWorkers</a>[]<br/></li>
<li></span><span class="Comment"> * in favor of applying <a href="../../utils/fmgr/dfmgr.c.html#L105" title="utils/fmgr/dfmgr.c:105">load_external_function</a>() for core <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> too;<br/></li>
<li></span><span class="Comment"> * but that raises portability issues that are not worth addressing <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> parallel_worker_main_type<br/></li>
<li><a id="L1595">&#x200c;</a><span class="linkable">LookupParallelWorkerFunction</span>(<span class="Type">const</span> <span class="Type">char</span> *libraryname, <span class="Type">const</span> <span class="Type">char</span> *funcname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the function is to be loaded from postgres itself, search the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L137" title="access/transam/parallel.c:137">InternalParallelWorkers</a> array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(libraryname, <span class="Constant">&quot;postgres&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; lengthof(<a href="#L137" title="access/transam/parallel.c:137">InternalParallelWorkers</a>); i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(<a href="#L137" title="access/transam/parallel.c:137">InternalParallelWorkers</a>[i].fn_name, funcname) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L137" title="access/transam/parallel.c:137">InternalParallelWorkers</a>[i].fn_addr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can only reach this by programming error. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> function </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not found&quot;</span>, funcname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise load from external library. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (parallel_worker_main_type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/dfmgr.c.html#L105" title="utils/fmgr/dfmgr.c:105">load_external_function</a>(libraryname, funcname, <span class="Constant">true</span>, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
