<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/transam/generic_xlog.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/transam/generic_xlog.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L64">GenericXLogState</a></li>
<li><a href="#L58">PageData</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L444">GenericXLogAbort</a></li>
<li><a href="#L337">GenericXLogFinish</a></li>
<li><a href="#L299">GenericXLogRegisterBuffer</a></li>
<li><a href="#L269">GenericXLogStart</a></li>
<li><a href="#L453">applyPageRedo</a></li>
<li><a href="#L228">computeDelta</a></li>
<li><a href="#L121">computeRegionDelta</a></li>
<li><a href="#L539">generic_mask</a></li>
<li><a href="#L478">generic_redo</a></li>
<li><a href="#L90">writeFragment</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L45">FRAGMENT_HEADER_SIZE</a></li>
<li><a href="#L46">MATCH_THRESHOLD</a></li>
<li><a href="#L47">MAX_DELTA_SIZE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * generic_xlog.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Implementation of generic xlog <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * src/backend/access/transam/generic_xlog.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/bufmask.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/generic_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Internally, a delta between pages consists of a set of fragments.&nbsp; Each<br/></li>
<li></span><span class="Comment"> * fragment represents changes made in a given region of a page.&nbsp; A fragment<br/></li>
<li></span><span class="Comment"> * is made up as follows:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * - offset of page region (OffsetNumber)<br/></li>
<li></span><span class="Comment"> * - length of page region (OffsetNumber)<br/></li>
<li></span><span class="Comment"> * - data - the data to place into the region ('length' number of bytes)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unchanged regions of a page are not represented in its delta.&nbsp; As a result,<br/></li>
<li></span><span class="Comment"> * a delta can be more <a href="../../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a> than the full page image.&nbsp; But having an<br/></li>
<li></span><span class="Comment"> * unchanged region between two fragments that is smaller than the fragment<br/></li>
<li></span><span class="Comment"> * header (offset+length) does not pay off in terms of the overall size of<br/></li>
<li></span><span class="Comment"> * the delta.&nbsp; For this reason, we <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> adjacent fragments if the unchanged<br/></li>
<li></span><span class="Comment"> * region between them is &lt;= <a href="#L46" title="access/transam/generic_xlog.c:46">MATCH_THRESHOLD</a> bytes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We do not bother to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> fragments across the &quot;<a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>&quot; and &quot;<a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>&quot; parts<br/></li>
<li></span><span class="Comment"> * of a page; it's very seldom the case that pd_lower and pd_upper are within<br/></li>
<li></span><span class="Comment"> * <a href="#L46" title="access/transam/generic_xlog.c:46">MATCH_THRESHOLD</a> bytes of each other, and handling that infrequent case<br/></li>
<li></span><span class="Comment"> * would complicate and slow down the delta-computation code unduly.<br/></li>
<li></span><span class="Comment"> * Therefore, the worst-case delta size includes two fragment headers plus<br/></li>
<li></span><span class="Comment"> * a full page's worth of data.<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L45">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FRAGMENT_HEADER_SIZE</span>&nbsp; &nbsp; (</span><span class="Constant">2</span><span class="PreProc"> * </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(OffsetNumber))<br/></li>
<li><a id="L46">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MATCH_THRESHOLD</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L45" title="access/transam/generic_xlog.c:45">FRAGMENT_HEADER_SIZE</a><br/></li>
<li><a id="L47">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_DELTA_SIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (BLCKSZ + </span><span class="Constant">2</span><span class="PreProc"> * <a href="#L45" title="access/transam/generic_xlog.c:45">FRAGMENT_HEADER_SIZE</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Struct of generic xlog data for single page */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* registered buffer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* flags for this buffer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deltaLen;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* space consumed in delta field */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *image;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy of page image for modification, do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do it in-place to have aligned memory chunk */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; delta[<a href="#L47" title="access/transam/generic_xlog.c:47">MAX_DELTA_SIZE</a>];&nbsp; &nbsp; <span class="Comment">/* delta between page images */<br/></li>
<li><a id="L58">&#x200c;</a></span>} <span class="linkable">PageData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * State of generic xlog record construction.&nbsp; Must be allocated at an I/O<br/></li>
<li></span><span class="Comment"> * aligned address.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L64">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">GenericXLogState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Page images (properly aligned, must be first) */<br/></li>
<li></span>&nbsp; &nbsp; PGIOAlignedBlock images[MAX_GENERIC_XLOG_PAGES];<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Info about each page, see above */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L58" title="access/transam/generic_xlog.c:58">PageData</a>&nbsp; &nbsp; pages[MAX_GENERIC_XLOG_PAGES];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isLogged;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L90" title="access/transam/generic_xlog.c:90">writeFragment</a>(<a href="#L58" title="access/transam/generic_xlog.c:58">PageData</a> *pageData, OffsetNumber offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber length, <span class="Type">const</span> <span class="Type">char</span> *data);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L121" title="access/transam/generic_xlog.c:121">computeRegionDelta</a>(<a href="#L58" title="access/transam/generic_xlog.c:58">PageData</a> *pageData,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *curpage, <span class="Type">const</span> <span class="Type">char</span> *targetpage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> targetStart, <span class="Type">int</span> targetEnd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> validStart, <span class="Type">int</span> validEnd);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L228" title="access/transam/generic_xlog.c:228">computeDelta</a>(<a href="#L58" title="access/transam/generic_xlog.c:58">PageData</a> *pageData, Page curpage, Page targetpage);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L453" title="access/transam/generic_xlog.c:453">applyPageRedo</a>(Page page, <span class="Type">const</span> <span class="Type">char</span> *delta, Size deltaSize);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> fragment into pageData's delta.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The fragment has the given offset and length, and data points to the<br/></li>
<li></span><span class="Comment"> * actual data (of length length).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L90">&#x200c;</a></span><span class="linkable">writeFragment</span>(<a href="#L58" title="access/transam/generic_xlog.c:58">PageData</a> *pageData, OffsetNumber offset, OffsetNumber length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr = pageData-&gt;delta + pageData-&gt;deltaLen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Verify we have enough space */<br/></li>
<li></span>&nbsp; &nbsp; Assert(pageData-&gt;deltaLen + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(offset) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(length) + length &lt;= <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pageData-&gt;delta));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write fragment data */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(ptr, &amp;offset, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(offset));<br/></li>
<li>&nbsp; &nbsp; ptr += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(offset);<br/></li>
<li>&nbsp; &nbsp; memcpy(ptr, &amp;length, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(length));<br/></li>
<li>&nbsp; &nbsp; ptr += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(length);<br/></li>
<li>&nbsp; &nbsp; memcpy(ptr, data, length);<br/></li>
<li>&nbsp; &nbsp; ptr += length;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pageData-&gt;deltaLen = ptr - pageData-&gt;delta;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the XLOG fragments needed to transform a region of curpage into the<br/></li>
<li></span><span class="Comment"> * corresponding region of targetpage, and append them to pageData's delta<br/></li>
<li></span><span class="Comment"> * field.&nbsp; The region to transform runs from targetStart to targetEnd-1.<br/></li>
<li></span><span class="Comment"> * Bytes in curpage outside the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> validStart to validEnd-1 should be<br/></li>
<li></span><span class="Comment"> * considered invalid, and always overwritten with target data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is a hot spot, so it's worth being as tense as possible<br/></li>
<li></span><span class="Comment"> * about the data-matching loops.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L121">&#x200c;</a></span><span class="linkable">computeRegionDelta</span>(<a href="#L58" title="access/transam/generic_xlog.c:58">PageData</a> *pageData,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *curpage, <span class="Type">const</span> <span class="Type">char</span> *targetpage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> targetStart, <span class="Type">int</span> targetEnd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> validStart, <span class="Type">int</span> validEnd)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loopEnd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fragmentBegin = -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fragmentEnd = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Deal with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> invalid start region by including it in first fragment */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (validStart &gt; targetStart)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fragmentBegin = targetStart;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targetStart = validStart;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We'll deal with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> invalid end region after the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop */<br/></li>
<li></span>&nbsp; &nbsp; loopEnd = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(targetEnd, validEnd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Examine all the potentially matchable bytes */<br/></li>
<li></span>&nbsp; &nbsp; i = targetStart;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (i &lt; loopEnd)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curpage[i] != targetpage[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* On unmatched byte, start new fragment if not already in one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fragmentBegin &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fragmentBegin = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark unmatched-data endpoint as uncertain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fragmentEnd = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extend the fragment as far as possible in a tight loop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (i &lt; loopEnd &amp;&amp; curpage[i] != targetpage[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= loopEnd)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found a matched byte, so remember end of unmatched fragment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fragmentEnd = i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Extend the match as far as possible in a tight loop.&nbsp; (On typical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * workloads, this inner loop is the bulk of this function's runtime.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (i &lt; loopEnd &amp;&amp; curpage[i] == targetpage[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There are several possible cases at this point:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 1. We have no unwritten fragment (fragmentBegin &lt; 0).&nbsp; There's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nothing to write; and it doesn't matter what fragmentEnd is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 2. We found more than <a href="#L46" title="access/transam/generic_xlog.c:46">MATCH_THRESHOLD</a> consecutive matching bytes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Dump out the unwritten fragment, stopping at fragmentEnd.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 3. The match extends to loopEnd.&nbsp; We'll do nothing here, exit the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loop, and then <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> the unwritten fragment, after merging it with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the invalid end region if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; If we don't so <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>, fragmentEnd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * establishes how much the final <a href="#L90" title="access/transam/generic_xlog.c:90">writeFragment</a> call needs to write.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 4. We found an unmatched byte <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> loopEnd.&nbsp; The loop will <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and will enter the unmatched-byte stanza above.&nbsp; So in this case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * also, it doesn't matter what fragmentEnd is.&nbsp; The matched bytes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will get merged into the continuing unmatched fragment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only in case 3 do we reach the bottom of the loop with a meaningful<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fragmentEnd value, which is why it's OK that we unconditionally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assign &quot;fragmentEnd = i&quot; above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fragmentBegin &gt;= <span class="Constant">0</span> &amp;&amp; i - fragmentEnd &gt; <a href="#L46" title="access/transam/generic_xlog.c:46">MATCH_THRESHOLD</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L90" title="access/transam/generic_xlog.c:90">writeFragment</a>(pageData, fragmentBegin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fragmentEnd - fragmentBegin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetpage + fragmentBegin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fragmentBegin = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fragmentEnd = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* not really necessary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Deal with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> invalid end region by including it in final fragment */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (loopEnd &lt; targetEnd)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fragmentBegin &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fragmentBegin = loopEnd;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fragmentEnd = targetEnd;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write final fragment if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fragmentBegin &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fragmentEnd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fragmentEnd = targetEnd;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L90" title="access/transam/generic_xlog.c:90">writeFragment</a>(pageData, fragmentBegin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fragmentEnd - fragmentBegin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetpage + fragmentBegin);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the XLOG delta record needed to transform curpage into targetpage,<br/></li>
<li></span><span class="Comment"> * and store it in pageData's delta field.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L228">&#x200c;</a></span><span class="linkable">computeDelta</span>(<a href="#L58" title="access/transam/generic_xlog.c:58">PageData</a> *pageData, Page curpage, Page targetpage)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetLower = ((PageHeader) targetpage)-&gt;pd_lower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetUpper = ((PageHeader) targetpage)-&gt;pd_upper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curLower = ((PageHeader) curpage)-&gt;pd_lower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curUpper = ((PageHeader) curpage)-&gt;pd_upper;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pageData-&gt;deltaLen = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute delta <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> for <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> part of page ... */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L121" title="access/transam/generic_xlog.c:121">computeRegionDelta</a>(pageData, curpage, targetpage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, targetLower,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, curLower);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and for <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> part, ignoring what's between */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L121" title="access/transam/generic_xlog.c:121">computeRegionDelta</a>(pageData, curpage, targetpage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targetUpper, BLCKSZ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curUpper, BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If xlog debug is enabled, then check produced delta.&nbsp; Result of delta<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * application to curpage should be equivalent to targetpage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef WAL_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlog.c.html#L140" title="access/transam/xlog.c:140">XLOG_DEBUG</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGAlignedBlock tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(tmp.data, curpage, BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L453" title="access/transam/generic_xlog.c:453">applyPageRedo</a>(tmp.data, pageData-&gt;delta, pageData-&gt;deltaLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (memcmp(tmp.data, targetpage, targetLower) != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcmp(tmp.data + targetUpper, targetpage + targetUpper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BLCKSZ - targetUpper) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;result of generic xlog apply does not match&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Start new generic xlog record for modifications to specified relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L64" title="access/transam/generic_xlog.c:64">GenericXLogState</a> *<br/></li>
<li><a id="L269">&#x200c;</a><span class="linkable">GenericXLogStart</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L64" title="access/transam/generic_xlog.c:64">GenericXLogState</a> *state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = (<a href="#L64" title="access/transam/generic_xlog.c:64">GenericXLogState</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1510" title="utils/mmgr/mcxt.c:1510">palloc_aligned</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L64" title="access/transam/generic_xlog.c:64">GenericXLogState</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_IO_ALIGN_SIZE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; state-&gt;isLogged = RelationNeedsWAL(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; MAX_GENERIC_XLOG_PAGES; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;pages[i].image = state-&gt;images[i].data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;pages[i].buffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Register new buffer for generic xlog record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns pointer to the page's image in the <a href="#L64" title="access/transam/generic_xlog.c:64">GenericXLogState</a>, which<br/></li>
<li></span><span class="Comment"> * is what the caller should modify.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the buffer is already registered, just return its existing entry.<br/></li>
<li></span><span class="Comment"> * (It's not very clear what to do with the flags in such a case, but<br/></li>
<li></span><span class="Comment"> * for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we stay with the original flags.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Page<br/></li>
<li><a id="L299">&#x200c;</a><span class="linkable">GenericXLogRegisterBuffer</span>(<a href="#L64" title="access/transam/generic_xlog.c:64">GenericXLogState</a> *state, Buffer buffer, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Search array for existing entry or first unused slot */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (block_id = <span class="Constant">0</span>; block_id &lt; MAX_GENERIC_XLOG_PAGES; block_id++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L58" title="access/transam/generic_xlog.c:58">PageData</a>&nbsp;&nbsp; *page = &amp;state-&gt;pages[block_id];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsInvalid(page-&gt;buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Empty slot, so use it (there cannot be a match later) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page-&gt;buffer = buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page-&gt;flags = flags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(page-&gt;image, BufferGetPage(buffer), BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Page) page-&gt;image;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (page-&gt;buffer == buffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Buffer is already registered.&nbsp; Just return the image, which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already prepared.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Page) page-&gt;image;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;maximum number </span><span class="Special">%d</span><span class="Constant"> of generic xlog buffers is exceeded&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAX_GENERIC_XLOG_PAGES);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Apply changes represented by <a href="#L64" title="access/transam/generic_xlog.c:64">GenericXLogState</a> to the actual buffers,<br/></li>
<li></span><span class="Comment"> * and emit a generic xlog record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L337">&#x200c;</a><span class="linkable">GenericXLogFinish</span>(<a href="#L64" title="access/transam/generic_xlog.c:64">GenericXLogState</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;isLogged)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Logged relation: make xlog record in critical section. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compute deltas if necessary, write changes to buffers, mark buffers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dirty, and register changes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; MAX_GENERIC_XLOG_PAGES; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L58" title="access/transam/generic_xlog.c:58">PageData</a>&nbsp;&nbsp; *pageData = &amp;state-&gt;pages[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageHeader&nbsp; &nbsp; pageHeader;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsInvalid(pageData-&gt;buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(pageData-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageHeader = (PageHeader) pageData-&gt;image;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compute delta while we still have both the unmodified page and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the new image. Not needed if we are logging the full image.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(pageData-&gt;flags &amp; GENERIC_XLOG_FULL_IMAGE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L228" title="access/transam/generic_xlog.c:228">computeDelta</a>(pageData, page, (Page) pageData-&gt;image);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Apply the image, being careful to zero the &quot;hole&quot; between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pd_lower and pd_upper in order to avoid divergence between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actual page state and what replay would produce.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(page, pageData-&gt;image, pageHeader-&gt;pd_lower);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(page + pageHeader-&gt;pd_lower, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pageHeader-&gt;pd_upper - pageHeader-&gt;pd_lower);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(page + pageHeader-&gt;pd_upper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pageData-&gt;image + pageHeader-&gt;pd_upper,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BLCKSZ - pageHeader-&gt;pd_upper);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(pageData-&gt;buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pageData-&gt;flags &amp; GENERIC_XLOG_FULL_IMAGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(i, pageData-&gt;buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; REGBUF_FORCE_IMAGE | REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(i, pageData-&gt;buffer, REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(i, pageData-&gt;delta, pageData-&gt;deltaLen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> xlog record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lsn = <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_GENERIC_ID, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set LSN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; MAX_GENERIC_XLOG_PAGES; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L58" title="access/transam/generic_xlog.c:58">PageData</a>&nbsp;&nbsp; *pageData = &amp;state-&gt;pages[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsInvalid(pageData-&gt;buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(BufferGetPage(pageData-&gt;buffer), lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unlogged relation: <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> xlog-related stuff */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; MAX_GENERIC_XLOG_PAGES; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L58" title="access/transam/generic_xlog.c:58">PageData</a>&nbsp;&nbsp; *pageData = &amp;state-&gt;pages[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsInvalid(pageData-&gt;buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(BufferGetPage(pageData-&gt;buffer),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pageData-&gt;image,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't worry about zeroing the &quot;hole&quot; in this case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(pageData-&gt;buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't have a LSN to return, in this case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lsn;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Abort generic xlog record construction.&nbsp; No changes are applied to buffers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: caller is responsible for releasing locks/pins on buffers, if needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L444">&#x200c;</a></span><span class="linkable">GenericXLogAbort</span>(<a href="#L64" title="access/transam/generic_xlog.c:64">GenericXLogState</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Apply delta to given page image.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L453">&#x200c;</a></span><span class="linkable">applyPageRedo</span>(Page page, <span class="Type">const</span> <span class="Type">char</span> *delta, Size deltaSize)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *ptr = delta;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *end = delta + deltaSize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (ptr &lt; end)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; length;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;offset, ptr, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(offset));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;length, ptr, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(length));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(page + offset, ptr, length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += length;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Redo function for generic xlog record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L478">&#x200c;</a></span><span class="linkable">generic_redo</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffers[MAX_GENERIC_XLOG_PAGES];<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; block_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Protect limited size of buffers[] array */<br/></li>
<li></span>&nbsp; &nbsp; Assert(XLogRecMaxBlockId(record) &lt; MAX_GENERIC_XLOG_PAGES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Iterate over blocks */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (block_id = <span class="Constant">0</span>; block_id &lt;= XLogRecMaxBlockId(record); block_id++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRedoAction action;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecHasBlockRef(record, block_id))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffers[block_id] = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; action = <a href="xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, block_id, &amp;buffers[block_id]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Apply redo to given block if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (action == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageHeader&nbsp; &nbsp; pageHeader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *blockDelta;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; blockDeltaSize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffers[block_id]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blockDelta = <a href="xlogreader.c.html#L2025" title="access/transam/xlogreader.c:2025">XLogRecGetBlockData</a>(record, block_id, &amp;blockDeltaSize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L453" title="access/transam/generic_xlog.c:453">applyPageRedo</a>(page, blockDelta, blockDeltaSize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since the delta contains no information about what's in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;hole&quot; between pd_lower and pd_upper, set that to zero to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ensure we produce the same page state that application of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * logged action by <a href="#L337" title="access/transam/generic_xlog.c:337">GenericXLogFinish</a> did.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageHeader = (PageHeader) page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(page + pageHeader-&gt;pd_lower, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pageHeader-&gt;pd_upper - pageHeader-&gt;pd_lower);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffers[block_id]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Changes are done: unlock and release all buffers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (block_id = <span class="Constant">0</span>; block_id &lt;= XLogRecMaxBlockId(record); block_id++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffers[block_id]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffers[block_id]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Mask a generic page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> performing consistency checks on it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L539">&#x200c;</a></span><span class="linkable">generic_mask</span>(<span class="Type">char</span> *page, BlockNumber blkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../common/bufmask.c.html#L31" title="access/common/bufmask.c:31">mask_page_lsn_and_checksum</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../common/bufmask.c.html#L71" title="access/common/bufmask.c:71">mask_unused_space</a>(page);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
