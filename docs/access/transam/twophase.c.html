<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/transam/twophase.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/transam/twophase.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L196">MyLockedGxact</a></li>
<li><a href="#L188">TwoPhaseState</a></li>
<li><a href="#L115">max_prepared_xacts</a></li>
<li><a href="#L1025">records</a></li>
<li><a href="#L198">twophaseExitRegistered</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L147">GlobalTransactionData</a></li>
<li><a href="#L170">GlobalTransactionData</a></li>
<li><a href="#L1011">StateFileChunk</a></li>
<li><a href="#L1016">StateFileChunk</a></li>
<li><a href="#L991">TwoPhaseFileHeader</a></li>
<li><a href="#L999">TwoPhaseRecordOnDisk</a></li>
<li><a href="#L1004">TwoPhaseRecordOnDisk</a></li>
<li><a href="#L176">TwoPhaseStateData</a></li>
<li><a href="#L186">TwoPhaseStateData</a></li>
<li><a href="#L701">Working_State</a></li>
<li><a href="#L1018">xllist</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L936">AdjustToFullTransactionId</a></li>
<li><a href="#L304">AtAbort_Twophase</a></li>
<li><a href="#L294">AtProcExit_Twophase</a></li>
<li><a href="#L1816">CheckPointTwoPhase</a></li>
<li><a href="#L1158">EndPrepare</a></li>
<li><a href="#L1503">FinishPreparedTransaction</a></li>
<li><a href="#L504">GXactLoadSubxactData</a></li>
<li><a href="#L666">GetPreparedTransactionList</a></li>
<li><a href="#L552">LockGXact</a></li>
<li><a href="#L2634">LookupGXact</a></li>
<li><a href="#L530">MarkAsPrepared</a></li>
<li><a href="#L359">MarkAsPreparing</a></li>
<li><a href="#L433">MarkAsPreparingGuts</a></li>
<li><a href="#L344">PostPrepare_Twophase</a></li>
<li><a href="#L2480">PrepareRedoAdd</a></li>
<li><a href="#L2582">PrepareRedoRemove</a></li>
<li><a href="#L1962">PrescanPreparedTransactions</a></li>
<li><a href="#L1689">ProcessRecords</a></li>
<li><a href="#L2187">ProcessTwoPhaseBuffer</a></li>
<li><a href="#L1303">ReadTwoPhaseFile</a></li>
<li><a href="#L2405">RecordTransactionAbortPrepared</a></li>
<li><a href="#L2307">RecordTransactionCommitPrepared</a></li>
<li><a href="#L2084">RecoverPreparedTransactions</a></li>
<li><a href="#L1736">RecreateTwoPhaseFile</a></li>
<li><a href="#L1280">RegisterTwoPhaseRecord</a></li>
<li><a href="#L628">RemoveGXact</a></li>
<li><a href="#L1717">RemoveTwoPhaseFile</a></li>
<li><a href="#L2043">StandbyRecoverPreparedTransactions</a></li>
<li><a href="#L1475">StandbyTransactionIdIsPrepared</a></li>
<li><a href="#L1065">StartPrepare</a></li>
<li><a href="#L961">TwoPhaseFilePath</a></li>
<li><a href="#L918">TwoPhaseGetDummyProc</a></li>
<li><a href="#L903">TwoPhaseGetDummyProcNumber</a></li>
<li><a href="#L800">TwoPhaseGetGXact</a></li>
<li><a href="#L852">TwoPhaseGetXidByVirtualXID</a></li>
<li><a href="#L253">TwoPhaseShmemInit</a></li>
<li><a href="#L237">TwoPhaseShmemSize</a></li>
<li><a href="#L1420">XlogReadTwoPhaseData</a></li>
<li><a href="#L711">pg_prepared_xact</a></li>
<li><a href="#L1898">restoreTwoPhaseData</a></li>
<li><a href="#L1037">save_state_data</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L112">TWOPHASE_DIR</a></li>
<li><a href="#L989">TWOPHASE_MAGIC</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * twophase.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Two-phase commit support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; src/backend/access/transam/twophase.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Each global transaction is associated with a global transaction<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; identifier (GID). The client assigns a GID to a postgres<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; transaction with the PREPARE TRANSACTION command.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We keep all active global transactions in a shared memory array.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; When the PREPARE TRANSACTION command is issued, the GID is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; reserved for the transaction in the array. This is done <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a WAL entry is made, because the reservation checks for duplicate<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; GIDs and aborts the transaction if there already is a global<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; transaction in prepared state with the same GID.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; A global transaction (gxact) also has dummy PGPROC; this is what keeps<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the XID considered running by <a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a>.&nbsp; It is also<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; convenient as a PGPROC to hook the gxact's locks to.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Information to recover prepared transactions in case of crash is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> stored in WAL for the common case. In some cases there will be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; an extended period between preparing a GXACT and commit/abort, in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; which case we need to separately record prepared transaction data<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; in permanent storage. This includes locking information, pending<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; notifications etc. All that state information is written to the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; per-transaction state file in the pg_twophase directory.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; All prepared transactions will be written prior to shutdown.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Life track of state data is following:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; * On PREPARE TRANSACTION backend writes state data only to the WAL and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stores pointer to the start of the WAL record in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gxact-&gt;prepare_start_lsn.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; * If COMMIT occurs <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> checkpoint then backend reads data from WAL<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; using prepare_start_lsn.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; * On checkpoint state data copied to files in pg_twophase directory and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsynced<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; * If COMMIT happens after checkpoint then backend reads state data from<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; files<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; During replay and replication, <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a> also holds information<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; about active prepared transactions that haven't been moved to disk yet.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Replay of twophase <a href="#L1025" title="access/transam/twophase.c:1025">records</a> happens by the following rules:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; * At the beginning of recovery, pg_twophase is scanned once, filling<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a> with entries marked with gxact-&gt;inredo and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gxact-&gt;ondisk.&nbsp; Two-phase file data older than the XID horizon of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the redo position are discarded.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; * On PREPARE redo, the transaction is added to <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gxact-&gt;inredo is set to true for such entries.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; * On Checkpoint we iterate through <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts entries<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; that have gxact-&gt;inredo set and are behind the redo_horizon. We<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save them to disk and then switch gxact-&gt;ondisk to true.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; * On COMMIT/ABORT we delete the entry from <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; If gxact-&gt;ondisk is true, the corresponding entry from the disk<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is additionally deleted.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; * <a href="#L2084" title="access/transam/twophase.c:2084">RecoverPreparedTransactions</a>(), <a href="#L2043" title="access/transam/twophase.c:2043">StandbyRecoverPreparedTransactions</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; and <a href="#L1962" title="access/transam/twophase.c:1962">PrescanPreparedTransactions</a>() have been modified to go through<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gxact-&gt;inredo entries that have not made it to disk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;time.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/commit_ts.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/subtrans.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/twophase.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/twophase_rmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogrecovery.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/storage.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pg_trace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/origin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/syncrep.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/md.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Directory where Two-phase commit files reside within PGDATA<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L112">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TWOPHASE_DIR</span> </span><span class="Constant">&quot;pg_twophase&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* GUC variable, can't be changed after startup */<br/></li>
<li><a id="L115">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">max_prepared_xacts</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This struct describes one global transaction that is in prepared state<br/></li>
<li></span><span class="Comment"> * or attempting to become prepared.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The lifecycle of a global transaction is:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 1. After checking that the requested GID is not in use, set up an entry in<br/></li>
<li></span><span class="Comment"> * the <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts array with the correct GID and valid = false,<br/></li>
<li></span><span class="Comment"> * and mark it as locked by my backend.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 2. After successfully completing prepare, set valid = true and enter the<br/></li>
<li></span><span class="Comment"> * referenced PGPROC into the global ProcArray.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 3. To begin COMMIT PREPARED or ROLLBACK PREPARED, check that the entry is<br/></li>
<li></span><span class="Comment"> * valid and not locked, then mark the entry as locked by storing my current<br/></li>
<li></span><span class="Comment"> * proc number into locking_backend.&nbsp; This prevents concurrent attempts to<br/></li>
<li></span><span class="Comment"> * commit or rollback the same prepared xact.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 4. On completion of COMMIT PREPARED or ROLLBACK PREPARED, remove the entry<br/></li>
<li></span><span class="Comment"> * from the ProcArray and the <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts array and return it to<br/></li>
<li></span><span class="Comment"> * the freelist.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that if the preparing transaction fails between steps 1 and 2, the<br/></li>
<li></span><span class="Comment"> * entry must be removed so that the GID and the GlobalTransaction struct<br/></li>
<li></span><span class="Comment"> * can be reused.&nbsp; See <a href="#L304" title="access/transam/twophase.c:304">AtAbort_Twophase</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * typedef struct <a href="#L147" title="access/transam/twophase.c:147">GlobalTransactionData</a> *GlobalTransaction appears in<br/></li>
<li></span><span class="Comment"> * twophase.h<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L147">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">GlobalTransactionData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GlobalTransaction <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* list link for free list */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ID of associated dummy PGPROC */<br/></li>
<li></span>&nbsp; &nbsp; TimestampTz prepared_at;&nbsp; &nbsp; <span class="Comment">/* time of preparation */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we need to keep track of two LSNs for each GXACT. We keep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * track of the start LSN because this is the address we must use to read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state data back from WAL when committing a prepared GXACT. We keep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * track of the end LSN because that is the LSN we need to wait for prior<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to commit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; prepare_start_lsn;&nbsp; &nbsp; <span class="Comment">/* XLOG offset of prepare record start */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; prepare_end_lsn;&nbsp; &nbsp; <span class="Comment">/* XLOG offset of prepare record end */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId xid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The GXACT id */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; owner;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ID of user that executed the xact */<br/></li>
<li></span>&nbsp; &nbsp; ProcNumber&nbsp; &nbsp; locking_backend;&nbsp; &nbsp; <span class="Comment">/* backend currently working on the xact */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; valid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* true if PGPROC entry is in proc array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ondisk;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* true if prepare state file is on disk */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; inredo;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* true if entry was added via <a href="xlog.c.html#L8156" title="access/transam/xlog.c:8156">xlog_redo</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; gid[GIDSIZE];&nbsp; &nbsp; <span class="Comment">/* The GID assigned to the prepared xact */<br/></li>
<li><a id="L170">&#x200c;</a></span>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">GlobalTransactionData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Two Phase Commit shared state.&nbsp; Access to this struct is protected<br/></li>
<li></span><span class="Comment"> * by TwoPhaseStateLock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L176">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">TwoPhaseStateData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Head of linked list of free <a href="#L147" title="access/transam/twophase.c:147">GlobalTransactionData</a> structs */<br/></li>
<li></span>&nbsp; &nbsp; GlobalTransaction freeGXacts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Number of valid prepXacts entries. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numPrepXacts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There are <a href="#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a> items in this array */<br/></li>
<li></span>&nbsp; &nbsp; GlobalTransaction prepXacts[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L186">&#x200c;</a>} <span class="linkable">TwoPhaseStateData</span>;<br/></li>
<li><br/></li>
<li><a id="L188">&#x200c;</a><span class="Type">static</span> <a href="#L176" title="access/transam/twophase.c:176">TwoPhaseStateData</a> *<span class="linkable">TwoPhaseState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Global transaction entry currently locked by us, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; Note that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * access to the entry pointed to by this variable must be protected by<br/></li>
<li></span><span class="Comment"> * TwoPhaseStateLock, though obviously the pointer itself doesn't need to be<br/></li>
<li></span><span class="Comment"> * (since it's just local memory).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L196">&#x200c;</a></span><span class="Type">static</span> GlobalTransaction <span class="linkable">MyLockedGxact</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><a id="L198">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">twophaseExitRegistered</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2307" title="access/transam/twophase.c:2307">RecordTransactionCommitPrepared</a>(TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nchildren,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId *children,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator *rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nstats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_xact_stats_item *stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> ninvalmsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SharedInvalidationMessage *invalmsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> initfileinval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *gid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2405" title="access/transam/twophase.c:2405">RecordTransactionAbortPrepared</a>(TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nchildren,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId *children,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelFileLocator *rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nstats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xl_xact_stats_item *stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *gid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1689" title="access/transam/twophase.c:1689">ProcessRecords</a>(<span class="Type">char</span> *bufptr, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> TwoPhaseCallback callbacks[]);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L628" title="access/transam/twophase.c:628">RemoveGXact</a>(GlobalTransaction gxact);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1420" title="access/transam/twophase.c:1420">XlogReadTwoPhaseData</a>(XLogRecPtr lsn, <span class="Type">char</span> **buf, <span class="Type">int</span> *len);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L2187" title="access/transam/twophase.c:2187">ProcessTwoPhaseBuffer</a>(TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr prepare_start_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fromdisk, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> setParent, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> setNextXid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L433" title="access/transam/twophase.c:433">MarkAsPreparingGuts</a>(GlobalTransaction gxact, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *gid, TimestampTz prepared_at, Oid owner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid databaseid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1717" title="access/transam/twophase.c:1717">RemoveTwoPhaseFile</a>(TransactionId xid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> giveWarning);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1736" title="access/transam/twophase.c:1736">RecreateTwoPhaseFile</a>(TransactionId xid, <span class="Type">void</span> *content, <span class="Type">int</span> len);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialization of shared memory<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L237">&#x200c;</a><span class="linkable">TwoPhaseShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need the fixed struct, the array of pointers, and the GTD structs */<br/></li>
<li></span>&nbsp; &nbsp; size = offsetof(<a href="#L176" title="access/transam/twophase.c:176">TwoPhaseStateData</a>, prepXacts);<br/></li>
<li>&nbsp; &nbsp; size = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<a href="#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GlobalTransaction)));<br/></li>
<li>&nbsp; &nbsp; size = MAXALIGN(size);<br/></li>
<li>&nbsp; &nbsp; size = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<a href="#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L147" title="access/transam/twophase.c:147">GlobalTransactionData</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L253">&#x200c;</a></span><span class="linkable">TwoPhaseShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a> = <a href="../../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;Prepared Transaction Table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L237" title="access/transam/twophase.c:237">TwoPhaseShmemSize</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GlobalTransaction gxacts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;freeGXacts = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;numPrepXacts = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initialize the linked list of free <a href="#L147" title="access/transam/twophase.c:147">GlobalTransactionData</a> structs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; gxacts = (GlobalTransaction)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">char</span> *) <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAXALIGN(offsetof(<a href="#L176" title="access/transam/twophase.c:176">TwoPhaseStateData</a>, prepXacts) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(GlobalTransaction) * <a href="#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* insert into linked list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gxacts[i].<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;freeGXacts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;freeGXacts = &amp;gxacts[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* associate it with a PGPROC assigned by <a href="../../storage/lmgr/proc.c.html#L157" title="storage/lmgr/proc.c:157">InitProcGlobal</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gxacts[i].pgprocno = GetNumberFromPGProc(&amp;<a href="../../storage/lmgr/proc.c.html#L80" title="storage/lmgr/proc.c:80">PreparedXactProcs</a>[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Exit hook to unlock the global transaction entry we're working on.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L294">&#x200c;</a></span><span class="linkable">AtProcExit_Twophase</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* same logic as abort */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L304" title="access/transam/twophase.c:304">AtAbort_Twophase</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Abort hook to unlock the global transaction entry we're working on.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L304">&#x200c;</a></span><span class="linkable">AtAbort_Twophase</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L196" title="access/transam/twophase.c:196">MyLockedGxact</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * What to do with the locked global transaction entry?&nbsp; If we were in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process of preparing the transaction, but haven't written the WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record and state file yet, the transaction must not be considered as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prepared.&nbsp; Likewise, if we are in the process of finishing an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already-prepared transaction, and fail after having already written the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 2nd phase commit or rollback record to the WAL, the transaction should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not be considered as prepared anymore.&nbsp; In those cases, just remove the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entry from shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, the entry must be left in place so that the transaction can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be finished later, so just unlock it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we abort during prepare, after having written the WAL record, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might not have transferred all locks and other state to the prepared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction yet.&nbsp; Likewise, if we abort during commit or rollback,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after having written the WAL record, we might not have released all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * resources held by the transaction yet.&nbsp; In those cases, the in-memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state can be wrong, but it's too late to back out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(TwoPhaseStateLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L196" title="access/transam/twophase.c:196">MyLockedGxact</a>-&gt;valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L628" title="access/transam/twophase.c:628">RemoveGXact</a>(<a href="#L196" title="access/transam/twophase.c:196">MyLockedGxact</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L196" title="access/transam/twophase.c:196">MyLockedGxact</a>-&gt;locking_backend = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L196" title="access/transam/twophase.c:196">MyLockedGxact</a> = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This is called after we have finished transferring state to the prepared<br/></li>
<li></span><span class="Comment"> * PGPROC entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L344">&#x200c;</a></span><span class="linkable">PostPrepare_Twophase</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(TwoPhaseStateLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L196" title="access/transam/twophase.c:196">MyLockedGxact</a>-&gt;locking_backend = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L196" title="access/transam/twophase.c:196">MyLockedGxact</a> = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L359" title="access/transam/twophase.c:359">MarkAsPreparing</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Reserve the GID for the given transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>GlobalTransaction<br/></li>
<li><a id="L359">&#x200c;</a><span class="linkable">MarkAsPreparing</span>(TransactionId xid, <span class="Type">const</span> <span class="Type">char</span> *gid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz prepared_at, Oid owner, Oid databaseid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GlobalTransaction gxact;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strlen(gid) &gt;= GIDSIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;transaction identifier </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is too long&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fail immediately if feature is disabled */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;prepared transactions are disabled&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Set max_prepared_transactions to a nonzero value.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* on first call, register the exit hook */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L198" title="access/transam/twophase.c:198">twophaseExitRegistered</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>(<a href="#L294" title="access/transam/twophase.c:294">AtProcExit_Twophase</a>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L198" title="access/transam/twophase.c:198">twophaseExitRegistered</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(TwoPhaseStateLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for conflicting GID */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;numPrepXacts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gxact = <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(gxact-&gt;gid, gid) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;transaction identifier </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is already in use&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gid)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get a free gxact from the freelist */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;freeGXacts == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;maximum number of prepared transactions reached&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Increase max_prepared_transactions (currently </span><span class="Special">%d</span><span class="Constant">).&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>)));<br/></li>
<li>&nbsp; &nbsp; gxact = <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;freeGXacts;<br/></li>
<li>&nbsp; &nbsp; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;freeGXacts = gxact-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L433" title="access/transam/twophase.c:433">MarkAsPreparingGuts</a>(gxact, xid, gid, prepared_at, owner, databaseid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gxact-&gt;ondisk = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And insert it into the active array */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;numPrepXacts &lt; <a href="#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts[<a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;numPrepXacts++] = gxact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> gxact;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L433" title="access/transam/twophase.c:433">MarkAsPreparingGuts</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This uses a gxact struct and puts it into the active array.<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: this is also used when reloading a gxact after a crash; so avoid<br/></li>
<li></span><span class="Comment"> * assuming that we can use very much backend context.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: This function should be called with appropriate locks held.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L433">&#x200c;</a></span><span class="linkable">MarkAsPreparingGuts</span>(GlobalTransaction gxact, TransactionId xid, <span class="Type">const</span> <span class="Type">char</span> *gid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz prepared_at, Oid owner, Oid databaseid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(TwoPhaseStateLock, LW_EXCLUSIVE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(gxact != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; proc = GetPGProcByNumber(gxact-&gt;pgprocno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the PGPROC entry */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(proc, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(PGPROC));<br/></li>
<li>&nbsp; &nbsp; dlist_node_init(&amp;proc-&gt;links);<br/></li>
<li>&nbsp; &nbsp; proc-&gt;waitStatus = PROC_WAIT_STATUS_OK;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (LocalTransactionIdIsValid(<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.lxid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* clone VXID, for <a href="#L852" title="access/transam/twophase.c:852">TwoPhaseGetXidByVirtualXID</a>() to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;vxid.lxid = <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;vxid.lxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;vxid.procNumber = <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(AmStartupProcess() || !<a href="../../utils/init/globals.c.html#L116" title="utils/init/globals.c:116">IsPostmasterEnvironment</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/lmgr/lock.c.html#L2872" title="storage/lmgr/lock.c:2872">GetLockConflicts</a>() uses this to specify a wait on the XID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;vxid.lxid = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;vxid.procNumber = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; proc-&gt;xid = xid;<br/></li>
<li>&nbsp; &nbsp; Assert(proc-&gt;xmin == InvalidTransactionId);<br/></li>
<li>&nbsp; &nbsp; proc-&gt;delayChkptFlags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;statusFlags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;databaseId = databaseid;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;roleId = owner;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;tempNamespaceId = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;isBackgroundWorker = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;lwWaiting = LW_WS_NOT_WAITING;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;lwWaitMode = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;waitLock = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;waitProcLock = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pg_atomic_init_u64(&amp;proc-&gt;waitStart, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; NUM_LOCK_PARTITIONS; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;proc-&gt;myProcLocks[i]);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* subxid data must be filled later by <a href="#L504" title="access/transam/twophase.c:504">GXactLoadSubxactData</a> */<br/></li>
<li></span>&nbsp; &nbsp; proc-&gt;subxidStatus.overflowed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; proc-&gt;subxidStatus.count = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gxact-&gt;prepared_at = prepared_at;<br/></li>
<li>&nbsp; &nbsp; gxact-&gt;xid = xid;<br/></li>
<li>&nbsp; &nbsp; gxact-&gt;owner = owner;<br/></li>
<li>&nbsp; &nbsp; gxact-&gt;locking_backend = <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>;<br/></li>
<li>&nbsp; &nbsp; gxact-&gt;valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; gxact-&gt;inredo = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; strcpy(gxact-&gt;gid, gid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember that we have this GlobalTransaction entry locked for us. If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * abort after this, we must release it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L196" title="access/transam/twophase.c:196">MyLockedGxact</a> = gxact;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L504" title="access/transam/twophase.c:504">GXactLoadSubxactData</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the transaction being persisted had <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subtransactions, this must<br/></li>
<li></span><span class="Comment"> * be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="#L530" title="access/transam/twophase.c:530">MarkAsPrepared</a>() to load information into the dummy<br/></li>
<li></span><span class="Comment"> * PGPROC.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L504">&#x200c;</a></span><span class="linkable">GXactLoadSubxactData</span>(GlobalTransaction gxact, <span class="Type">int</span> nsubxacts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId *children)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = GetPGProcByNumber(gxact-&gt;pgprocno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need no extra lock since the GXACT isn't valid yet */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nsubxacts &gt; PGPROC_MAX_CACHED_SUBXIDS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;subxidStatus.overflowed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nsubxacts = PGPROC_MAX_CACHED_SUBXIDS;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nsubxacts &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(proc-&gt;subxids.xids, children,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nsubxacts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proc-&gt;subxidStatus.count = nsubxacts;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L530" title="access/transam/twophase.c:530">MarkAsPrepared</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Mark the GXACT as fully valid, and enter it into the global ProcArray.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * lock_held indicates whether caller already holds TwoPhaseStateLock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L530">&#x200c;</a></span><span class="linkable">MarkAsPrepared</span>(GlobalTransaction gxact, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> lock_held)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lock here may be overkill, but I'm not convinced of that ... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!lock_held)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(TwoPhaseStateLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; Assert(!gxact-&gt;valid);<br/></li>
<li>&nbsp; &nbsp; gxact-&gt;valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!lock_held)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Put it into the global ProcArray so <a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a> considers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the XID as still running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L468" title="storage/ipc/procarray.c:468">ProcArrayAdd</a>(GetPGProcByNumber(gxact-&gt;pgprocno));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L552" title="access/transam/twophase.c:552">LockGXact</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Locate the prepared transaction and mark it busy for COMMIT or PREPARE.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> GlobalTransaction<br/></li>
<li><a id="L552">&#x200c;</a><span class="linkable">LockGXact</span>(<span class="Type">const</span> <span class="Type">char</span> *gid, Oid user)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* on first call, register the exit hook */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L198" title="access/transam/twophase.c:198">twophaseExitRegistered</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>(<a href="#L294" title="access/transam/twophase.c:294">AtProcExit_Twophase</a>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L198" title="access/transam/twophase.c:198">twophaseExitRegistered</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(TwoPhaseStateLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;numPrepXacts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GlobalTransaction gxact = <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = GetPGProcByNumber(gxact-&gt;pgprocno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore not-yet-valid GIDs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!gxact-&gt;valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(gxact-&gt;gid, gid) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found it, but has someone else got it locked? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gxact-&gt;locking_backend != INVALID_PROC_NUMBER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;prepared transaction with identifier </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is busy&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (user != gxact-&gt;owner &amp;&amp; !<a href="../../utils/misc/superuser.c.html#L56" title="utils/misc/superuser.c:56">superuser_arg</a>(user))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;permission denied to finish prepared transaction&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Must be <a href="../../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a> or the user that prepared the transaction.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: it probably would be possible to allow committing from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * another database; but at the moment NOTIFY is known not to work and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there may be some other issues as well.&nbsp; Hence disallow until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * someone gets motivated to make it work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a> != proc-&gt;databaseId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;prepared transaction belongs to another database&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Connect to the database where the transaction was prepared to finish it.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK for me to lock it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; gxact-&gt;locking_backend = <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L196" title="access/transam/twophase.c:196">MyLockedGxact</a> = gxact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> gxact;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;prepared transaction with identifier </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NOTREACHED */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L628" title="access/transam/twophase.c:628">RemoveGXact</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Remove the prepared transaction from the shared memory array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: caller should have already removed it from ProcArray<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L628">&#x200c;</a></span><span class="linkable">RemoveGXact</span>(GlobalTransaction gxact)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(TwoPhaseStateLock, LW_EXCLUSIVE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;numPrepXacts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gxact == <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remove from the active array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;numPrepXacts--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts[i] = <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts[<a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;numPrepXacts];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and put it back in the freelist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gxact-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;freeGXacts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;freeGXacts = gxact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> </span><span class="Special">%p</span><span class="Constant"> in GlobalTransaction array&quot;</span>, gxact);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns an array of all prepared transactions for the user-level<br/></li>
<li></span><span class="Comment"> * function <a href="#L711" title="access/transam/twophase.c:711">pg_prepared_xact</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned array and all its elements are copies of <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> data<br/></li>
<li></span><span class="Comment"> * structures, to minimize the time we need to hold the TwoPhaseStateLock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * WARNING -- we return even those transactions that are not fully prepared<br/></li>
<li></span><span class="Comment"> * yet.&nbsp; The caller should filter them out if he doesn't want them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned array is <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L666">&#x200c;</a></span><span class="linkable">GetPreparedTransactionList</span>(GlobalTransaction *gxacts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GlobalTransaction array;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(TwoPhaseStateLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;numPrepXacts == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *gxacts = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; num = <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;numPrepXacts;<br/></li>
<li>&nbsp; &nbsp; array = (GlobalTransaction) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L147" title="access/transam/twophase.c:147">GlobalTransactionData</a>) * num);<br/></li>
<li>&nbsp; &nbsp; *gxacts = array;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(array + i, <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L147" title="access/transam/twophase.c:147">GlobalTransactionData</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> num;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Working status for <a href="#L711" title="access/transam/twophase.c:711">pg_prepared_xact</a> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; GlobalTransaction array;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ngxacts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currIdx;<br/></li>
<li><a id="L701">&#x200c;</a>} <span class="linkable">Working_State</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L711" title="access/transam/twophase.c:711">pg_prepared_xact</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Produce a view with one row per prepared transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is here so we don't have to export the<br/></li>
<li></span><span class="Comment"> * <a href="#L147" title="access/transam/twophase.c:147">GlobalTransactionData</a> struct definition.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L711">&#x200c;</a><span class="linkable">pg_prepared_xact</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FuncCallContext *funcctx;<br/></li>
<li>&nbsp; &nbsp; <a href="#L701" title="access/transam/twophase.c:701">Working_State</a> *status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (SRF_IS_FIRSTCALL())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* create a function context for cross-call persistence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; funcctx = SRF_FIRSTCALL_INIT();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Switch to memory context appropriate for multiple function calls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* build tupdesc for result tuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this had better match pg_prepared_xacts view in system_views.sql */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tupdesc = <a href="../common/tupdesc.c.html#L67" title="access/common/tupdesc.c:67">CreateTemplateTupleDesc</a>(<span class="Constant">5</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">1</span>, <span class="Constant">&quot;transaction&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XIDOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">2</span>, <span class="Constant">&quot;gid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TEXTOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">3</span>, <span class="Constant">&quot;prepared&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TIMESTAMPTZOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">4</span>, <span class="Constant">&quot;ownerid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OIDOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/tupdesc.c.html#L651" title="access/common/tupdesc.c:651">TupleDescInitEntry</a>(tupdesc, (AttrNumber) <span class="Constant">5</span>, <span class="Constant">&quot;dbid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OIDOID, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;tuple_desc = <a href="../../executor/execTuples.c.html#L2158" title="executor/execTuples.c:2158">BlessTupleDesc</a>(tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Collect all the 2PC status information that we will format and <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * out as a result set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; status = (<a href="#L701" title="access/transam/twophase.c:701">Working_State</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L701" title="access/transam/twophase.c:701">Working_State</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funcctx-&gt;user_fctx = (<span class="Type">void</span> *) status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; status-&gt;ngxacts = <a href="#L666" title="access/transam/twophase.c:666">GetPreparedTransactionList</a>(&amp;status-&gt;array);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; status-&gt;currIdx = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; funcctx = SRF_PERCALL_SETUP();<br/></li>
<li>&nbsp; &nbsp; status = (<a href="#L701" title="access/transam/twophase.c:701">Working_State</a> *) funcctx-&gt;user_fctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (status-&gt;array != <span class="Constant">NULL</span> &amp;&amp; status-&gt;currIdx &lt; status-&gt;ngxacts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GlobalTransaction gxact = &amp;status-&gt;array[status-&gt;currIdx++];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = GetPGProcByNumber(gxact-&gt;pgprocno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">5</span>] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<span class="Constant">5</span>] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!gxact-&gt;valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Form tuple with appropriate data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = TransactionIdGetDatum(proc-&gt;xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = CStringGetTextDatum(gxact-&gt;gid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = TimestampTzGetDatum(gxact-&gt;prepared_at);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">3</span>] = ObjectIdGetDatum(gxact-&gt;owner);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">4</span>] = ObjectIdGetDatum(proc-&gt;databaseId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(funcctx-&gt;tuple_desc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = HeapTupleGetDatum(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_NEXT(funcctx, result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SRF_RETURN_DONE(funcctx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L800" title="access/transam/twophase.c:800">TwoPhaseGetGXact</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the GlobalTransaction struct for a prepared transaction<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; specified by XID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If lock_held is set to true, TwoPhaseStateLock will not be taken, so the<br/></li>
<li></span><span class="Comment"> * caller had better hold it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> GlobalTransaction<br/></li>
<li><a id="L800">&#x200c;</a><span class="linkable">TwoPhaseGetGXact</span>(TransactionId xid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> lock_held)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GlobalTransaction result = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> TransactionId cached_xid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> GlobalTransaction cached_gxact = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!lock_held || <a href="../../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(TwoPhaseStateLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During a recovery, COMMIT PREPARED, or ABORT PREPARED, we'll be called<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * repeatedly for the same XID.&nbsp; We can save work with a simple cache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (xid == cached_xid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cached_gxact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!lock_held)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(TwoPhaseStateLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;numPrepXacts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GlobalTransaction gxact = <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gxact-&gt;xid == xid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = gxact;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!lock_held)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">NULL</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> GlobalTransaction for xid </span><span class="Special">%u</span><span class="Constant">&quot;</span>, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cached_xid = xid;<br/></li>
<li>&nbsp; &nbsp; cached_gxact = result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L852" title="access/transam/twophase.c:852">TwoPhaseGetXidByVirtualXID</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Lookup VXID among xacts prepared since last startup.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (This won't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> recovered xacts.)&nbsp; If more than one matches, return <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * and set &quot;have_more&quot; to true.&nbsp; To witness multiple matches, a single<br/></li>
<li></span><span class="Comment"> * proc number must consume 2^32 LXIDs, with no intervening database restart.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TransactionId<br/></li>
<li><a id="L852">&#x200c;</a><span class="linkable">TwoPhaseGetXidByVirtualXID</span>(VirtualTransactionId vxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *have_more)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; TransactionId result = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(VirtualTransactionIdIsValid(vxid));<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(TwoPhaseStateLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;numPrepXacts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GlobalTransaction gxact = <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VirtualTransactionId proc_vxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!gxact-&gt;valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; proc = GetPGProcByNumber(gxact-&gt;pgprocno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GET_VXID_FROM_PGPROC(proc_vxid, *proc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VirtualTransactionIdEquals(vxid, proc_vxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Startup process sets proc-&gt;vxid.procNumber to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * INVALID_PROC_NUMBER.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!gxact-&gt;inredo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != InvalidTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *have_more = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = gxact-&gt;xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L903" title="access/transam/twophase.c:903">TwoPhaseGetDummyProcNumber</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the dummy proc number for prepared transaction specified by XID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Dummy proc numbers are similar to proc numbers of real backends.&nbsp; They<br/></li>
<li></span><span class="Comment"> * start at <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>, and are unique across all currently active real<br/></li>
<li></span><span class="Comment"> * backends and prepared transactions.&nbsp; If lock_held is set to true,<br/></li>
<li></span><span class="Comment"> * TwoPhaseStateLock will not be taken, so the caller had better hold it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ProcNumber<br/></li>
<li><a id="L903">&#x200c;</a><span class="linkable">TwoPhaseGetDummyProcNumber</span>(TransactionId xid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> lock_held)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GlobalTransaction gxact = <a href="#L800" title="access/transam/twophase.c:800">TwoPhaseGetGXact</a>(xid, lock_held);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> gxact-&gt;pgprocno;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L918" title="access/transam/twophase.c:918">TwoPhaseGetDummyProc</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the PGPROC that represents a prepared transaction specified by XID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If lock_held is set to true, TwoPhaseStateLock will not be taken, so the<br/></li>
<li></span><span class="Comment"> * caller had better hold it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PGPROC *<br/></li>
<li><a id="L918">&#x200c;</a><span class="linkable">TwoPhaseGetDummyProc</span>(TransactionId xid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> lock_held)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GlobalTransaction gxact = <a href="#L800" title="access/transam/twophase.c:800">TwoPhaseGetGXact</a>(xid, lock_held);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> GetPGProcByNumber(gxact-&gt;pgprocno);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/************************************************************************/<br/></li>
<li></span><span class="Comment">/* State file support&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */<br/></li>
<li></span><span class="Comment">/************************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the FullTransactionId for the given TransactionId.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The wrap logic is safe here because the span of active xids cannot exceed one<br/></li>
<li></span><span class="Comment"> * epoch at <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> given time.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> FullTransactionId<br/></li>
<li><a id="L936">&#x200c;</a><span class="linkable">AdjustToFullTransactionId</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FullTransactionId nextFullXid;<br/></li>
<li>&nbsp; &nbsp; TransactionId nextXid;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; epoch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(XidGenLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; nextFullXid = <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(XidGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nextXid = XidFromFullTransactionId(nextFullXid);<br/></li>
<li>&nbsp; &nbsp; epoch = EpochFromFullTransactionId(nextFullXid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(xid &gt; nextXid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wraparound occurred, must be from a prev epoch. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(epoch &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; epoch--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> FullTransactionIdFromEpochAndXid(epoch, xid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L961">&#x200c;</a></span><span class="linkable">TwoPhaseFilePath</span>(<span class="Type">char</span> *path, TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FullTransactionId fxid = <a href="#L936" title="access/transam/twophase.c:936">AdjustToFullTransactionId</a>(xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> snprintf(path, MAXPGPATH, <a href="#L112" title="access/transam/twophase.c:112">TWOPHASE_DIR</a> <span class="Constant">&quot;/</span><span class="Special">%08X%08X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EpochFromFullTransactionId(fxid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XidFromFullTransactionId(fxid));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * 2PC state file format:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 1. <a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 2. TransactionId[] (subtransactions)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 3. RelFileLocator[] (files to be deleted at commit)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 4. RelFileLocator[] (files to be deleted at abort)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 5. SharedInvalidationMessage[] (inval messages to be sent at commit)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 6. <a href="#L999" title="access/transam/twophase.c:999">TwoPhaseRecordOnDisk</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 7. ...<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 8. <a href="#L999" title="access/transam/twophase.c:999">TwoPhaseRecordOnDisk</a> (end <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a>, rmid == TWOPHASE_RM_END_ID)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 9. checksum (CRC-32C)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Each segment except the final checksum is MAXALIGN'd.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Header for a 2PC state file<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L989">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TWOPHASE_MAGIC</span>&nbsp; &nbsp; </span><span class="Constant">0x57F94534</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* format identifier */<br/></li>
<li></span><br/></li>
<li><a id="L991">&#x200c;</a><span class="Type">typedef</span> xl_xact_prepare <span class="linkable">TwoPhaseFileHeader</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Header for each record in a state file<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: len counts only the rmgr data, not the <a href="#L999" title="access/transam/twophase.c:999">TwoPhaseRecordOnDisk</a> header.<br/></li>
<li></span><span class="Comment"> * The rmgr data will be stored starting on a MAXALIGN boundary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L999">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">TwoPhaseRecordOnDisk</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; len;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* length of rmgr data */<br/></li>
<li></span>&nbsp; &nbsp; TwoPhaseRmgrId rmid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* resource manager for this record */<br/></li>
<li></span>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; info;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* flag bits for use by rmgr */<br/></li>
<li><a id="L1004">&#x200c;</a></span>} <span class="linkable">TwoPhaseRecordOnDisk</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * During prepare, the state file is assembled in memory <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> writing it<br/></li>
<li></span><span class="Comment"> * to WAL and the actual state file.&nbsp; We use a chain of <a href="#L1011" title="access/transam/twophase.c:1011">StateFileChunk</a> blocks<br/></li>
<li></span><span class="Comment"> * for that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L1011">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">StateFileChunk</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *data;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L1011" title="access/transam/twophase.c:1011">StateFileChunk</a> *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><a id="L1016">&#x200c;</a>} <span class="linkable">StateFileChunk</span>;<br/></li>
<li><br/></li>
<li><a id="L1018">&#x200c;</a><span class="Type">static</span> <span class="Type">struct</span> <span class="linkable">xllist</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1011" title="access/transam/twophase.c:1011">StateFileChunk</a> *head;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first data block in the chain */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1011" title="access/transam/twophase.c:1011">StateFileChunk</a> *tail;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* last block in chain */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; num_chunks;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; bytes_free;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* free bytes left in tail block */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; total_len;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* total data bytes in chain */<br/></li>
<li><a id="L1025">&#x200c;</a></span>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">records</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Append a block of data to <a href="#L1025" title="access/transam/twophase.c:1025">records</a> data structure.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: each block is padded to a MAXALIGN multiple.&nbsp; This must be<br/></li>
<li></span><span class="Comment"> * accounted for when the file is later read!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The data is copied, so the caller is free to modify it afterwards.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1037">&#x200c;</a></span><span class="linkable">save_state_data</span>(<span class="Type">const</span> <span class="Type">void</span> *data, uint32 len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; padlen = MAXALIGN(len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (padlen &gt; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.bytes_free)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.tail-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L1011" title="access/transam/twophase.c:1011">StateFileChunk</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.tail = <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.tail-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.tail-&gt;len = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.tail-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.num_chunks++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.bytes_free = Max(padlen, <span class="Constant">512</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.tail-&gt;data = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="#L1025" title="access/transam/twophase.c:1025">records</a>.bytes_free);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(((<span class="Type">char</span> *) <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.tail-&gt;data) + <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.tail-&gt;len, data, len);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.tail-&gt;len += padlen;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.bytes_free -= padlen;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.total_len += padlen;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Start preparing a state file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Initializes data structure and inserts the 2PC file header record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1065">&#x200c;</a></span><span class="linkable">StartPrepare</span>(GlobalTransaction gxact)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc = GetPGProcByNumber(gxact-&gt;pgprocno);<br/></li>
<li>&nbsp; &nbsp; TransactionId xid = gxact-&gt;xid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a> hdr;<br/></li>
<li>&nbsp; &nbsp; TransactionId *children;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator *commitrels;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator *abortrels;<br/></li>
<li>&nbsp; &nbsp; xl_xact_stats_item *abortstats = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; xl_xact_stats_item *commitstats = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; SharedInvalidationMessage *invalmsgs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize linked list */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.head = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L1011" title="access/transam/twophase.c:1011">StateFileChunk</a>));<br/></li>
<li>&nbsp; &nbsp; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.head-&gt;len = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.head-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.bytes_free = Max(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a>), <span class="Constant">512</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.head-&gt;data = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="#L1025" title="access/transam/twophase.c:1025">records</a>.bytes_free);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.tail = <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.head;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.num_chunks = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.total_len = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create header */<br/></li>
<li></span>&nbsp; &nbsp; hdr.magic = <a href="#L989" title="access/transam/twophase.c:989">TWOPHASE_MAGIC</a>;<br/></li>
<li>&nbsp; &nbsp; hdr.total_len = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L1158" title="access/transam/twophase.c:1158">EndPrepare</a> will fill this in */<br/></li>
<li></span>&nbsp; &nbsp; hdr.xid = xid;<br/></li>
<li>&nbsp; &nbsp; hdr.database = proc-&gt;databaseId;<br/></li>
<li>&nbsp; &nbsp; hdr.prepared_at = gxact-&gt;prepared_at;<br/></li>
<li>&nbsp; &nbsp; hdr.owner = gxact-&gt;owner;<br/></li>
<li>&nbsp; &nbsp; hdr.nsubxacts = <a href="xact.c.html#L5741" title="access/transam/xact.c:5741">xactGetCommittedChildren</a>(&amp;children);<br/></li>
<li>&nbsp; &nbsp; hdr.ncommitrels = <a href="../../catalog/storage.c.html#L852" title="catalog/storage.c:852">smgrGetPendingDeletes</a>(<span class="Constant">true</span>, &amp;commitrels);<br/></li>
<li>&nbsp; &nbsp; hdr.nabortrels = <a href="../../catalog/storage.c.html#L852" title="catalog/storage.c:852">smgrGetPendingDeletes</a>(<span class="Constant">false</span>, &amp;abortrels);<br/></li>
<li>&nbsp; &nbsp; hdr.ncommitstats =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_xact.c.html#L270" title="utils/activity/pgstat_xact.c:270">pgstat_get_transactional_drops</a>(<span class="Constant">true</span>, &amp;commitstats);<br/></li>
<li>&nbsp; &nbsp; hdr.nabortstats =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_xact.c.html#L270" title="utils/activity/pgstat_xact.c:270">pgstat_get_transactional_drops</a>(<span class="Constant">false</span>, &amp;abortstats);<br/></li>
<li>&nbsp; &nbsp; hdr.ninvalmsgs = <a href="../../utils/cache/inval.c.html#L882" title="utils/cache/inval.c:882">xactGetCommittedInvalidationMessages</a>(&amp;invalmsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hdr.initfileinval);<br/></li>
<li>&nbsp; &nbsp; hdr.gidlen = strlen(gxact-&gt;gid) + <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* Include '\0' */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* <a href="#L1158" title="access/transam/twophase.c:1158">EndPrepare</a> will fill the origin data, if necessary */<br/></li>
<li></span>&nbsp; &nbsp; hdr.origin_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; hdr.origin_timestamp = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1037" title="access/transam/twophase.c:1037">save_state_data</a>(&amp;hdr, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a>));<br/></li>
<li>&nbsp; &nbsp; <a href="#L1037" title="access/transam/twophase.c:1037">save_state_data</a>(gxact-&gt;gid, hdr.gidlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add the additional info about subxacts, deletable files and cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invalidation messages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hdr.nsubxacts &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1037" title="access/transam/twophase.c:1037">save_state_data</a>(children, hdr.nsubxacts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* While we have the child-xact data, stuff it in the gxact too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L504" title="access/transam/twophase.c:504">GXactLoadSubxactData</a>(gxact, hdr.nsubxacts, children);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hdr.ncommitrels &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1037" title="access/transam/twophase.c:1037">save_state_data</a>(commitrels, hdr.ncommitrels * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(commitrels);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hdr.nabortrels &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1037" title="access/transam/twophase.c:1037">save_state_data</a>(abortrels, hdr.nabortrels * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(abortrels);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hdr.ncommitstats &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1037" title="access/transam/twophase.c:1037">save_state_data</a>(commitstats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdr.ncommitstats * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_xact_stats_item));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(commitstats);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hdr.nabortstats &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1037" title="access/transam/twophase.c:1037">save_state_data</a>(abortstats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdr.nabortstats * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_xact_stats_item));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(abortstats);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hdr.ninvalmsgs &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1037" title="access/transam/twophase.c:1037">save_state_data</a>(invalmsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdr.ninvalmsgs * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(invalmsgs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Finish preparing state data and writing it to WAL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1158">&#x200c;</a></span><span class="linkable">EndPrepare</span>(GlobalTransaction gxact)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a> *hdr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1011" title="access/transam/twophase.c:1011">StateFileChunk</a> *record;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; replorigin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add the end <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a> to the list of 2PC <a href="#L1025" title="access/transam/twophase.c:1025">records</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1280" title="access/transam/twophase.c:1280">RegisterTwoPhaseRecord</a>(TWOPHASE_RM_END_ID, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Go back and fill in total_len in the file header record */<br/></li>
<li></span>&nbsp; &nbsp; hdr = (<a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a> *) <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.head-&gt;data;<br/></li>
<li>&nbsp; &nbsp; Assert(hdr-&gt;magic == <a href="#L989" title="access/transam/twophase.c:989">TWOPHASE_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; hdr-&gt;total_len = <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.total_len + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pg_crc32c);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; replorigin = (<a href="../../replication/logical/origin.c.html#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a> != InvalidRepOriginId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/logical/origin.c.html#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a> != DoNotReplicateId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (replorigin)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hdr-&gt;origin_lsn = <a href="../../replication/logical/origin.c.html#L156" title="replication/logical/origin.c:156">replorigin_session_origin_lsn</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hdr-&gt;origin_timestamp = <a href="../../replication/logical/origin.c.html#L157" title="replication/logical/origin.c:157">replorigin_session_origin_timestamp</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the data size exceeds MaxAllocSize, we won't be able to read it in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1303" title="access/transam/twophase.c:1303">ReadTwoPhaseFile</a>. Check for that <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, rather than fail in the case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where we write data to file and then re-read at commit time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hdr-&gt;total_len &gt; MaxAllocSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;two-phase state file maximum length exceeded&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now writing 2PC state data to WAL. We let the WAL's CRC protection<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cover us, so no need to calculate a separate CRC.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to set DELAY_CHKPT_START here, too; otherwise a checkpoint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * starting immediately after the WAL record is inserted could complete<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without fsync'ing our state file.&nbsp; (This is essentially the same kind<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of race condition as the COMMIT-to-clog-write case that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="xact.c.html#L1304" title="access/transam/xact.c:1304">RecordTransactionCommit</a> uses DELAY_CHKPT_START for; see notes there.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We save the PREPARE record's location in the gxact for later use by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1816" title="access/transam/twophase.c:1816">CheckPointTwoPhase</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xloginsert.c.html#L175" title="access/transam/xloginsert.c:175">XLogEnsureRecordSpace</a>(<span class="Constant">0</span>, <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.num_chunks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert((<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags &amp; DELAY_CHKPT_START) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags |= DELAY_CHKPT_START;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (record = <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.head; record != <span class="Constant">NULL</span>; record = record-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>(record-&gt;data, record-&gt;len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L456" title="access/transam/xloginsert.c:456">XLogSetRecordFlags</a>(XLOG_INCLUDE_ORIGIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gxact-&gt;prepare_end_lsn = <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_XACT_ID, XLOG_XACT_PREPARE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (replorigin)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Move LSNs forward for this replication origin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/logical/origin.c.html#L1219" title="replication/logical/origin.c:1219">replorigin_session_advance</a>(<a href="../../replication/logical/origin.c.html#L156" title="replication/logical/origin.c:156">replorigin_session_origin_lsn</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gxact-&gt;prepare_end_lsn);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(gxact-&gt;prepare_end_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we crash <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we have prepared: WAL replay will fix things */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store record's start location to read that later on Commit */<br/></li>
<li></span>&nbsp; &nbsp; gxact-&gt;prepare_start_lsn = <a href="xlog.c.html#L253" title="access/transam/xlog.c:253">ProcLastRecPtr</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark the prepared transaction as valid.&nbsp; As soon as xact.c marks <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as not running our XID (which it will do immediately after this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function returns), others can commit/rollback the xact.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: a side effect of this is to make a dummy ProcArray entry for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prepared XID.&nbsp; This must happen <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we clear the XID from <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a> /<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[], else there is a window where the XID is not running<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * according to <a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a>, and onlookers would be entitled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to assume the xact crashed.&nbsp; Instead we have a window where the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XID appears twice in ProcArray, which is OK.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L530" title="access/transam/twophase.c:530">MarkAsPrepared</a>(gxact, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we can mark ourselves as out of the commit critical section: a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoint starting after this will certainly see the gxact as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * candidate for fsyncing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags &amp;= ~DELAY_CHKPT_START;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember that we have this GlobalTransaction entry locked for us.&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we crash after this point, it's too late to abort, but we must unlock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it so that the prepared transaction can be committed or rolled back.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L196" title="access/transam/twophase.c:196">MyLockedGxact</a> = gxact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Wait for synchronous replication, if required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that at this stage we have marked the prepare, but still show as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * running in the procarray (twice!) and continue to hold locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../replication/syncrep.c.html#L148" title="replication/syncrep.c:148">SyncRepWaitForLSN</a>(gxact-&gt;prepare_end_lsn, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.tail = <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.head = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.num_chunks = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Register a 2PC record to be written to state file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1280">&#x200c;</a></span><span class="linkable">RegisterTwoPhaseRecord</span>(TwoPhaseRmgrId rmid, uint16 info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">void</span> *data, uint32 len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L999" title="access/transam/twophase.c:999">TwoPhaseRecordOnDisk</a> record;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; record.rmid = rmid;<br/></li>
<li>&nbsp; &nbsp; record.info = info;<br/></li>
<li>&nbsp; &nbsp; record.len = len;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1037" title="access/transam/twophase.c:1037">save_state_data</a>(&amp;record, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L999" title="access/transam/twophase.c:999">TwoPhaseRecordOnDisk</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1037" title="access/transam/twophase.c:1037">save_state_data</a>(data, len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read and validate the state file for xid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If it looks OK (has a valid magic number and CRC), return the <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d<br/></li>
<li></span><span class="Comment"> * contents of the file, issuing an error when finding corrupted data.&nbsp; If<br/></li>
<li></span><span class="Comment"> * missing_ok is true, which indicates that missing files can be safely<br/></li>
<li></span><span class="Comment"> * ignored, then return NULL.&nbsp; This state can be reached when doing recovery.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1303">&#x200c;</a><span class="linkable">ReadTwoPhaseFile</span>(TransactionId xid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf;<br/></li>
<li>&nbsp; &nbsp; <a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a> *hdr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat stat;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; crc_offset;<br/></li>
<li>&nbsp; &nbsp; pg_crc32c&nbsp; &nbsp; calc_crc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file_crc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L961" title="access/transam/twophase.c:961">TwoPhaseFilePath</a>(path, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(path, O_RDONLY | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (missing_ok &amp;&amp; errno == <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check file length.&nbsp; We can determine a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound pretty easily. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set an <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound to avoid <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>() failure on a corrupt file, though<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can't guarantee that we won't get an out of memory error anyway,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * even on a valid file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fstat(fd, &amp;stat))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not stat file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat.st_size &lt; (MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a>)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L999" title="access/transam/twophase.c:999">TwoPhaseRecordOnDisk</a>)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pg_crc32c)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stat.st_size &gt; MaxAllocSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1182" title="utils/error/elog.c:1182">errmsg_plural</a>(<span class="Constant">&quot;incorrect size of file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%lld</span><span class="Constant"> byte&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;incorrect size of file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">%lld</span><span class="Constant"> bytes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span> <span class="Type">int</span>) stat.st_size, path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span> <span class="Type">int</span>) stat.st_size)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; crc_offset = stat.st_size - <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pg_crc32c);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (crc_offset != MAXALIGN(crc_offset))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;incorrect alignment of CRC offset for file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK, slurp in the file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; buf = (<span class="Type">char</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(stat.st_size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_TWOPHASE_FILE_READ);<br/></li>
<li>&nbsp; &nbsp; r = read(fd, buf, stat.st_size);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (r != stat.st_size)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: read </span><span class="Special">%d</span><span class="Constant"> of </span><span class="Special">%lld</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path, r, (<span class="Type">long</span> <span class="Type">long</span> <span class="Type">int</span>) stat.st_size)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hdr = (<a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a> *) buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hdr-&gt;magic != <a href="#L989" title="access/transam/twophase.c:989">TWOPHASE_MAGIC</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid magic number stored in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hdr-&gt;total_len != stat.st_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid size stored in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; INIT_CRC32C(calc_crc);<br/></li>
<li>&nbsp; &nbsp; COMP_CRC32C(calc_crc, buf, crc_offset);<br/></li>
<li>&nbsp; &nbsp; FIN_CRC32C(calc_crc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; file_crc = *((pg_crc32c *) (buf + crc_offset));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!EQ_CRC32C(calc_crc, file_crc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;calculated CRC checksum does not match value stored in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reads 2PC data from xlog. During checkpoint this data will be moved to<br/></li>
<li></span><span class="Comment"> * twophase files and <a href="#L1303" title="access/transam/twophase.c:1303">ReadTwoPhaseFile</a> should be used instead.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note clearly that this function can access WAL during normal operation,<br/></li>
<li></span><span class="Comment"> * similarly to the way WALSender or Logical Decoding would do.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1420">&#x200c;</a></span><span class="linkable">XlogReadTwoPhaseData</span>(XLogRecPtr lsn, <span class="Type">char</span> **buf, <span class="Type">int</span> *len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecord *record;<br/></li>
<li>&nbsp; &nbsp; XLogReaderState *<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *errormsg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a> = <a href="xlogreader.c.html#L106" title="access/transam/xlogreader.c:106">XLogReaderAllocate</a>(<a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XL_ROUTINE(.page_read = &amp;<a href="xlogutils.c.html#L861" title="access/transam/xlogutils.c:861">read_local_xlog_page</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; .segment_open = &amp;<a href="xlogutils.c.html#L817" title="access/transam/xlogutils.c:817">wal_segment_open</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; .segment_close = &amp;<a href="xlogutils.c.html#L842" title="access/transam/xlogutils.c:842">wal_segment_close</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed while allocating a WAL reading processor.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="xlogreader.c.html#L231" title="access/transam/xlogreader.c:231">XLogBeginRead</a>(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>, lsn);<br/></li>
<li>&nbsp; &nbsp; record = <a href="xlogreader.c.html#L389" title="access/transam/xlogreader.c:389">XLogReadRecord</a>(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>, &amp;errormsg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (record == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errormsg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read two-phase state from WAL at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(lsn), errormsg)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read two-phase state from WAL at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(lsn))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (XLogRecGetRmid(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>) != RM_XACT_ID ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (XLogRecGetInfo(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>) &amp; XLOG_XACT_OPMASK) != XLOG_XACT_PREPARE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;expected two-phase state data is not present in WAL at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(lsn))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *len = XLogRecGetDataLen(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *buf = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>) * XLogRecGetDataLen(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>));<br/></li>
<li>&nbsp; &nbsp; memcpy(*buf, XLogRecGetData(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span>) * XLogRecGetDataLen(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="xlogreader.c.html#L161" title="access/transam/xlogreader.c:161">XLogReaderFree</a>(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Confirms an xid is prepared, during recovery<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1475">&#x200c;</a></span><span class="linkable">StandbyTransactionIdIsPrepared</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf;<br/></li>
<li>&nbsp; &nbsp; <a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a> *hdr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a> &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Read and validate file */<br/></li>
<li></span>&nbsp; &nbsp; buf = <a href="#L1303" title="access/transam/twophase.c:1303">ReadTwoPhaseFile</a>(xid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (buf == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check header also */<br/></li>
<li></span>&nbsp; &nbsp; hdr = (<a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a> *) buf;<br/></li>
<li>&nbsp; &nbsp; result = TransactionIdEquals(hdr-&gt;xid, xid);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1503" title="access/transam/twophase.c:1503">FinishPreparedTransaction</a>: execute COMMIT PREPARED or ROLLBACK PREPARED<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1503">&#x200c;</a></span><span class="linkable">FinishPreparedTransaction</span>(<span class="Type">const</span> <span class="Type">char</span> *gid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GlobalTransaction gxact;<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *proc;<br/></li>
<li>&nbsp; &nbsp; TransactionId xid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *bufptr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a> *hdr;<br/></li>
<li>&nbsp; &nbsp; TransactionId latestXid;<br/></li>
<li>&nbsp; &nbsp; TransactionId *children;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator *commitrels;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator *abortrels;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator *delrels;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndelrels;<br/></li>
<li>&nbsp; &nbsp; xl_xact_stats_item *commitstats;<br/></li>
<li>&nbsp; &nbsp; xl_xact_stats_item *abortstats;<br/></li>
<li>&nbsp; &nbsp; SharedInvalidationMessage *invalmsgs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Validate the GID, and lock the GXACT to ensure that two backends do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * try to commit the same GID at once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; gxact = <a href="#L552" title="access/transam/twophase.c:552">LockGXact</a>(gid, <a href="../../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>());<br/></li>
<li>&nbsp; &nbsp; proc = GetPGProcByNumber(gxact-&gt;pgprocno);<br/></li>
<li>&nbsp; &nbsp; xid = gxact-&gt;xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read and validate 2PC state data. State data will typically be stored<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in WAL files if the LSN is after the last checkpoint record, or moved<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to disk if for some reason they have lived for a long time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (gxact-&gt;ondisk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L1303" title="access/transam/twophase.c:1303">ReadTwoPhaseFile</a>(xid, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1420" title="access/transam/twophase.c:1420">XlogReadTwoPhaseData</a>(gxact-&gt;prepare_start_lsn, &amp;buf, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Disassemble the header area<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hdr = (<a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a> *) buf;<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdEquals(hdr-&gt;xid, xid));<br/></li>
<li>&nbsp; &nbsp; bufptr = buf + MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a>));<br/></li>
<li>&nbsp; &nbsp; bufptr += MAXALIGN(hdr-&gt;gidlen);<br/></li>
<li>&nbsp; &nbsp; children = (TransactionId *) bufptr;<br/></li>
<li>&nbsp; &nbsp; bufptr += MAXALIGN(hdr-&gt;nsubxacts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; commitrels = (RelFileLocator *) bufptr;<br/></li>
<li>&nbsp; &nbsp; bufptr += MAXALIGN(hdr-&gt;ncommitrels * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator));<br/></li>
<li>&nbsp; &nbsp; abortrels = (RelFileLocator *) bufptr;<br/></li>
<li>&nbsp; &nbsp; bufptr += MAXALIGN(hdr-&gt;nabortrels * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator));<br/></li>
<li>&nbsp; &nbsp; commitstats = (xl_xact_stats_item *) bufptr;<br/></li>
<li>&nbsp; &nbsp; bufptr += MAXALIGN(hdr-&gt;ncommitstats * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_xact_stats_item));<br/></li>
<li>&nbsp; &nbsp; abortstats = (xl_xact_stats_item *) bufptr;<br/></li>
<li>&nbsp; &nbsp; bufptr += MAXALIGN(hdr-&gt;nabortstats * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_xact_stats_item));<br/></li>
<li>&nbsp; &nbsp; invalmsgs = (SharedInvalidationMessage *) bufptr;<br/></li>
<li>&nbsp; &nbsp; bufptr += MAXALIGN(hdr-&gt;ninvalmsgs * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* compute latestXid among all children */<br/></li>
<li></span>&nbsp; &nbsp; latestXid = <a href="transam.c.html#L345" title="access/transam/transam.c:345">TransactionIdLatest</a>(xid, hdr-&gt;nsubxacts, children);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prevent cancel/<a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> interrupt while cleaning up */<br/></li>
<li></span>&nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The order of operations here is critical: make the XLOG entry for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit or abort, then mark the transaction committed or aborted in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_xact, then remove its PGPROC from the global ProcArray (which means<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a> will stop saying the prepared xact is in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * progress), then run the post-commit or post-abort callbacks. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callbacks will release the locks the transaction held.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2307" title="access/transam/twophase.c:2307">RecordTransactionCommitPrepared</a>(xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdr-&gt;nsubxacts, children,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdr-&gt;ncommitrels, commitrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdr-&gt;ncommitstats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commitstats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdr-&gt;ninvalmsgs, invalmsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdr-&gt;initfileinval, gid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2405" title="access/transam/twophase.c:2405">RecordTransactionAbortPrepared</a>(xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hdr-&gt;nsubxacts, children,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hdr-&gt;nabortrels, abortrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hdr-&gt;nabortstats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; abortstats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L565" title="storage/ipc/procarray.c:565">ProcArrayRemove</a>(proc, latestXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In case we fail while running the callbacks, mark the gxact invalid so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no one else will try to commit/rollback, and so it will be recycled if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we fail after this point.&nbsp; It is still locked by our backend so it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * won't go away yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (We assume it's safe to do this without taking TwoPhaseStateLock.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; gxact-&gt;valid = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> files that were supposed to be dropped. For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consistency with the regular xact.c code paths, must do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * releasing locks, so do it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> running the callbacks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: this code knows that we couldn't be dropping <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> temp rels ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; delrels = commitrels;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndelrels = hdr-&gt;ncommitrels;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; delrels = abortrels;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndelrels = hdr-&gt;nabortrels;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure files supposed to be dropped are dropped */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/smgr/md.c.html#L1446" title="storage/smgr/md.c:1446">DropRelationFiles</a>(delrels, ndelrels, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_xact.c.html#L312" title="utils/activity/pgstat_xact.c:312">pgstat_execute_transactional_drops</a>(hdr-&gt;ncommitstats, commitstats, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_xact.c.html#L312" title="utils/activity/pgstat_xact.c:312">pgstat_execute_transactional_drops</a>(hdr-&gt;nabortstats, abortstats, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle cache invalidation messages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Relcache init file invalidation requires processing both <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after we <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the SI messages, only when committing.&nbsp; See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/cache/inval.c.html#L1025" title="utils/cache/inval.c:1025">AtEOXact_Inval</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hdr-&gt;initfileinval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L6754" title="utils/cache/relcache.c:6754">RelationCacheInitFilePreInvalidate</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/sinval.c.html#L47" title="storage/ipc/sinval.c:47">SendSharedInvalidMessages</a>(invalmsgs, hdr-&gt;ninvalmsgs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hdr-&gt;initfileinval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L6779" title="utils/cache/relcache.c:6779">RelationCacheInitFilePostInvalidate</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Acquire the two-phase lock.&nbsp; We want to work on the two-phase callbacks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * while holding it to avoid potential conflicts with other transactions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attempting to use the same GID, so the lock is released once the shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory state is cleared.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(TwoPhaseStateLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> do the callbacks */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1689" title="access/transam/twophase.c:1689">ProcessRecords</a>(bufptr, xid, <a href="twophase_rmgr.c.html#L33" title="access/transam/twophase_rmgr.c:33">twophase_postcommit_callbacks</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1689" title="access/transam/twophase.c:1689">ProcessRecords</a>(bufptr, xid, <a href="twophase_rmgr.c.html#L42" title="access/transam/twophase_rmgr.c:42">twophase_postabort_callbacks</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L4867" title="storage/lmgr/predicate.c:4867">PredicateLockTwoPhaseFinish</a>(xid, isCommit);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clear shared memory state */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L628" title="access/transam/twophase.c:628">RemoveGXact</a>(gxact);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release the lock as all callbacks are called and shared memory <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Count the prepared xact as committed or aborted */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_xact.c.html#L40" title="utils/activity/pgstat_xact.c:40">AtEOXact_PgStat</a>(isCommit, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we can clean up <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> files we may have left.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (gxact-&gt;ondisk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1717" title="access/transam/twophase.c:1717">RemoveTwoPhaseFile</a>(xid, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L196" title="access/transam/twophase.c:196">MyLockedGxact</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Scan 2PC state data in memory and call the indicated callbacks for each 2PC record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1689">&#x200c;</a></span><span class="linkable">ProcessRecords</span>(<span class="Type">char</span> *bufptr, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> TwoPhaseCallback callbacks[])<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L999" title="access/transam/twophase.c:999">TwoPhaseRecordOnDisk</a> *record = (<a href="#L999" title="access/transam/twophase.c:999">TwoPhaseRecordOnDisk</a> *) bufptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(record-&gt;rmid &lt;= TWOPHASE_RM_MAX_ID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (record-&gt;rmid == TWOPHASE_RM_END_ID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufptr += MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L999" title="access/transam/twophase.c:999">TwoPhaseRecordOnDisk</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (callbacks[record-&gt;rmid] != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; callbacks[record-&gt;rmid] (xid, record-&gt;info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) bufptr, record-&gt;len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufptr += MAXALIGN(record-&gt;len);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove the 2PC file for the specified XID.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If giveWarning is false, do not complain about file-not-present;<br/></li>
<li></span><span class="Comment"> * this is an expected case during WAL replay.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1717">&#x200c;</a></span><span class="linkable">RemoveTwoPhaseFile</span>(TransactionId xid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> giveWarning)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L961" title="access/transam/twophase.c:961">TwoPhaseFilePath</a>(path, xid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlink(path))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">ENOENT</span> || giveWarning)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recreates a state file. This is used in WAL replay and during<br/></li>
<li></span><span class="Comment"> * checkpoint creation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: content and len don't include CRC.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1736">&#x200c;</a></span><span class="linkable">RecreateTwoPhaseFile</span>(TransactionId xid, <span class="Type">void</span> *content, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; pg_crc32c&nbsp; &nbsp; statefile_crc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recompute CRC */<br/></li>
<li></span>&nbsp; &nbsp; INIT_CRC32C(statefile_crc);<br/></li>
<li>&nbsp; &nbsp; COMP_CRC32C(statefile_crc, content, len);<br/></li>
<li>&nbsp; &nbsp; FIN_CRC32C(statefile_crc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L961" title="access/transam/twophase.c:961">TwoPhaseFilePath</a>(path, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; O_CREAT | O_TRUNC | O_WRONLY | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not recreate file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write content and CRC */<br/></li>
<li></span>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_TWOPHASE_FILE_WRITE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (write(fd, content, len) != len)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if write didn't set errno, assume problem is no disk space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ENOSPC</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (write(fd, &amp;statefile_crc, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pg_crc32c)) != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pg_crc32c))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if write didn't set errno, assume problem is no disk space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ENOSPC</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must fsync the file because the end-of-replay checkpoint will not do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so, there being no GXACT in shared memory yet to tell it to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_TWOPHASE_FILE_SYNC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L386" title="storage/file/fd.c:386">pg_fsync</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fsync file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1816" title="access/transam/twophase.c:1816">CheckPointTwoPhase</a> -- handle 2PC component of checkpointing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We must fsync the state file of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> GXACT that is valid or has been<br/></li>
<li></span><span class="Comment"> * generated during redo and has a PREPARE LSN &lt;= the checkpoint's redo<br/></li>
<li></span><span class="Comment"> * horizon.&nbsp; (If the gxact isn't valid yet, has not been generated in<br/></li>
<li></span><span class="Comment"> * redo, or has a later LSN, this checkpoint is not responsible for<br/></li>
<li></span><span class="Comment"> * fsyncing it.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is deliberately run as late as possible in the checkpoint sequence,<br/></li>
<li></span><span class="Comment"> * because GXACTs ordinarily have short lifespans, and so it is quite<br/></li>
<li></span><span class="Comment"> * possible that GXACTs that were valid at checkpoint start will no longer<br/></li>
<li></span><span class="Comment"> * exist if we wait a little <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>. With typical checkpoint settings this<br/></li>
<li></span><span class="Comment"> * will be about 3 minutes for an online checkpoint, so as a result we<br/></li>
<li></span><span class="Comment"> * expect that there will be no GXACTs that need to be copied to disk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If a GXACT remains valid across multiple checkpoints, it will already<br/></li>
<li></span><span class="Comment"> * be on disk so we don't bother to <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> that write.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1816">&#x200c;</a></span><span class="linkable">CheckPointTwoPhase</span>(XLogRecPtr redo_horizon)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; serialized_xacts = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a> &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_TWOPHASE_CHECKPOINT_START();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We are expecting there to be zero GXACTs that need to be copied to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disk, so we perform all I/O while holding TwoPhaseStateLock for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * simplicity. This prevents <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new xacts from preparing while this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * occurs, which shouldn't be a problem since the presence of long-lived<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prepared xacts indicates the transaction manager isn't active.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's also possible to move I/O out of the lock, but on every error we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should check whether somebody committed our transaction in different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backend. Let's leave this optimization for future, if somebody will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * spot that this place cause bottleneck.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that it isn't possible for there to be a GXACT with a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prepare_end_lsn set prior to the last checkpoint yet is marked invalid,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because of the efforts with delayChkptFlags.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(TwoPhaseStateLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;numPrepXacts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we are using gxact not PGPROC so this works in recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; GlobalTransaction gxact = <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((gxact-&gt;valid || gxact-&gt;inredo) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !gxact-&gt;ondisk &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gxact-&gt;prepare_end_lsn &lt;= redo_horizon)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1420" title="access/transam/twophase.c:1420">XlogReadTwoPhaseData</a>(gxact-&gt;prepare_start_lsn, &amp;buf, &amp;len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1736" title="access/transam/twophase.c:1736">RecreateTwoPhaseFile</a>(gxact-&gt;xid, buf, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gxact-&gt;ondisk = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gxact-&gt;prepare_start_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gxact-&gt;prepare_end_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; serialized_xacts++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Flush unconditionally the parent directory to make <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> information<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * durable on disk.&nbsp; Two-phase files could have been removed and those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * removals need to be made persistent as well as <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> files newly created<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previously since the last checkpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L756" title="storage/file/fd.c:756">fsync_fname</a>(<a href="#L112" title="access/transam/twophase.c:112">TWOPHASE_DIR</a>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_TWOPHASE_CHECKPOINT_DONE();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlog.c.html#L129" title="access/transam/xlog.c:129">log_checkpoints</a> &amp;&amp; serialized_xacts &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1182" title="utils/error/elog.c:1182">errmsg_plural</a>(<span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant"> two-phase state file was written &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;for a long-running prepared transaction&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant"> two-phase state files were written &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;for long-running prepared transactions&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; serialized_xacts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; serialized_xacts)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1898" title="access/transam/twophase.c:1898">restoreTwoPhaseData</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Scan pg_twophase and fill <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a> depending on the on-disk data.<br/></li>
<li></span><span class="Comment"> * This is called once at the beginning of recovery, saving <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> extra<br/></li>
<li></span><span class="Comment"> * lookups in the future.&nbsp; Two-phase files that are newer than the<br/></li>
<li></span><span class="Comment"> * minimum XID horizon are discarded on the way.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1898">&#x200c;</a></span><span class="linkable">restoreTwoPhaseData</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *cldir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *clde;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(TwoPhaseStateLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; cldir = <a href="../../storage/file/fd.c.html#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(<a href="#L112" title="access/transam/twophase.c:112">TWOPHASE_DIR</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((clde = <a href="../../storage/file/fd.c.html#L2909" title="storage/file/fd.c:2909">ReadDir</a>(cldir, <a href="#L112" title="access/transam/twophase.c:112">TWOPHASE_DIR</a>)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strlen(clde-&gt;d_name) == <span class="Constant">16</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strspn(clde-&gt;d_name, <span class="Constant">&quot;0123456789ABCDEF&quot;</span>) == <span class="Constant">16</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FullTransactionId fxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fxid = FullTransactionIdFromU64(strtou64(clde-&gt;d_name, <span class="Constant">NULL</span>, <span class="Constant">16</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid = XidFromFullTransactionId(fxid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L2187" title="access/transam/twophase.c:2187">ProcessTwoPhaseBuffer</a>(xid, InvalidXLogRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2480" title="access/transam/twophase.c:2480">PrepareRedoAdd</a>(buf, InvalidXLogRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidXLogRecPtr, InvalidRepOriginId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2961" title="storage/file/fd.c:2961">FreeDir</a>(cldir);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1962" title="access/transam/twophase.c:1962">PrescanPreparedTransactions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Scan the shared memory entries of <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a> and determine the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment"> * of valid XIDs present.&nbsp; This is run during database startup, after we<br/></li>
<li></span><span class="Comment"> * have completed reading WAL.&nbsp; <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid has been set to<br/></li>
<li></span><span class="Comment"> * one more than the highest XID for which evidence exists in WAL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We throw away <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> prepared xacts with <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> XID beyond nextXid --- if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * are present, it suggests that the DBA has done a PITR recovery to an<br/></li>
<li></span><span class="Comment"> * earlier point in time without cleaning out pg_twophase.&nbsp; We dare not<br/></li>
<li></span><span class="Comment"> * try to recover such prepared xacts since they likely depend on database<br/></li>
<li></span><span class="Comment"> * state that doesn't exist <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * However, we will advance nextXid beyond <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subxact XIDs belonging to<br/></li>
<li></span><span class="Comment"> * valid prepared xacts.&nbsp; We need to do this since subxact commit doesn't<br/></li>
<li></span><span class="Comment"> * write a WAL entry, and so there might be no evidence in WAL of those<br/></li>
<li></span><span class="Comment"> * subxact XIDs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On corrupted two-phase files, fail immediately.&nbsp; Keeping around broken<br/></li>
<li></span><span class="Comment"> * entries and let replay continue causes harm on the system, and a new<br/></li>
<li></span><span class="Comment"> * backup should be rolled in.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Our other responsibility is to determine and return the oldest valid XID<br/></li>
<li></span><span class="Comment"> * among the prepared xacts (if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>, return <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid).<br/></li>
<li></span><span class="Comment"> * This is needed to synchronize pg_subtrans startup properly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If xids_p and nxids_p are not NULL, pointer to a <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d array of all<br/></li>
<li></span><span class="Comment"> * top-level xids is stored in *xids_p. The number of entries in the array<br/></li>
<li></span><span class="Comment"> * is returned in *nxids_p.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TransactionId<br/></li>
<li><a id="L1962">&#x200c;</a><span class="linkable">PrescanPreparedTransactions</span>(TransactionId **xids_p, <span class="Type">int</span> *nxids_p)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FullTransactionId nextXid = <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid;<br/></li>
<li>&nbsp; &nbsp; TransactionId origNextXid = XidFromFullTransactionId(nextXid);<br/></li>
<li>&nbsp; &nbsp; TransactionId result = origNextXid;<br/></li>
<li>&nbsp; &nbsp; TransactionId *xids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nxids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allocsize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(TwoPhaseStateLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;numPrepXacts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GlobalTransaction gxact = <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(gxact-&gt;inredo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xid = gxact-&gt;xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L2187" title="access/transam/twophase.c:2187">ProcessTwoPhaseBuffer</a>(xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gxact-&gt;prepare_start_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gxact-&gt;ondisk, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OK, we think this file is valid.&nbsp; Incorporate xid into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * running-minimum result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xids_p)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nxids == allocsize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nxids == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allocsize = <span class="Constant">10</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xids = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(allocsize * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allocsize = allocsize * <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xids = <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(xids, allocsize * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xids[nxids++] = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xids_p)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *xids_p = xids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *nxids_p = nxids;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2043" title="access/transam/twophase.c:2043">StandbyRecoverPreparedTransactions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Scan the shared memory entries of <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a> and setup all the required<br/></li>
<li></span><span class="Comment"> * information to allow standby queries to treat prepared transactions as still<br/></li>
<li></span><span class="Comment"> * active.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is never called at the end of recovery - we use<br/></li>
<li></span><span class="Comment"> * <a href="#L2084" title="access/transam/twophase.c:2084">RecoverPreparedTransactions</a>() at that point.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The lack of calls to <a href="subtrans.c.html#L85" title="access/transam/subtrans.c:85">SubTransSetParent</a>() calls here is by design;<br/></li>
<li></span><span class="Comment"> * those calls are made by <a href="#L2084" title="access/transam/twophase.c:2084">RecoverPreparedTransactions</a>() at the end of recovery<br/></li>
<li></span><span class="Comment"> * for those xacts that need this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2043">&#x200c;</a></span><span class="linkable">StandbyRecoverPreparedTransactions</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(TwoPhaseStateLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;numPrepXacts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GlobalTransaction gxact = <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(gxact-&gt;inredo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xid = gxact-&gt;xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L2187" title="access/transam/twophase.c:2187">ProcessTwoPhaseBuffer</a>(xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gxact-&gt;prepare_start_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gxact-&gt;ondisk, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2084" title="access/transam/twophase.c:2084">RecoverPreparedTransactions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Scan the shared memory entries of <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a> and reload the state for<br/></li>
<li></span><span class="Comment"> * each prepared transaction (reacquire locks, etc).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is run at the end of recovery, but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we allow backends to write<br/></li>
<li></span><span class="Comment"> * WAL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At the end of recovery the way we take snapshots will change. We <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> need<br/></li>
<li></span><span class="Comment"> * to mark all running transactions with their full <a href="subtrans.c.html#L85" title="access/transam/subtrans.c:85">SubTransSetParent</a>() info<br/></li>
<li></span><span class="Comment"> * to allow normal snapshots to work correctly if snapshots overflow.<br/></li>
<li></span><span class="Comment"> * We do this here because by definition prepared transactions are the only<br/></li>
<li></span><span class="Comment"> * type of write transaction still running, so this is necessary and<br/></li>
<li></span><span class="Comment"> * complete.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2084">&#x200c;</a></span><span class="linkable">RecoverPreparedTransactions</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(TwoPhaseStateLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;numPrepXacts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GlobalTransaction gxact = <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *bufptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a> *hdr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId *subxids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *gid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xid = gxact-&gt;xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reconstruct subtrans state for the transaction --- needed because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_subtrans is not preserved over a restart.&nbsp; Note that we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * linking all the subtransactions directly to the top-level XID;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there may originally have been a more complex hierarchy, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there's no need to restore that exactly. It's possible that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="subtrans.c.html#L85" title="access/transam/subtrans.c:85">SubTransSetParent</a> has been set <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, if the prepared transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generated xid assignment <a href="#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L2187" title="access/transam/twophase.c:2187">ProcessTwoPhaseBuffer</a>(xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gxact-&gt;prepare_start_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gxact-&gt;ondisk, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovering prepared transaction </span><span class="Special">%u</span><span class="Constant"> from shared memory&quot;</span>, xid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hdr = (<a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a> *) buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdEquals(hdr-&gt;xid, xid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufptr = buf + MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gid = (<span class="Type">const</span> <span class="Type">char</span> *) bufptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufptr += MAXALIGN(hdr-&gt;gidlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subxids = (TransactionId *) bufptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufptr += MAXALIGN(hdr-&gt;nsubxacts * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufptr += MAXALIGN(hdr-&gt;ncommitrels * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufptr += MAXALIGN(hdr-&gt;nabortrels * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufptr += MAXALIGN(hdr-&gt;ncommitstats * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_xact_stats_item));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufptr += MAXALIGN(hdr-&gt;nabortstats * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_xact_stats_item));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufptr += MAXALIGN(hdr-&gt;ninvalmsgs * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SharedInvalidationMessage));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Recreate its GXACT and dummy PGPROC. But, check whether it was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * added in redo and already has a shmem entry for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L433" title="access/transam/twophase.c:433">MarkAsPreparingGuts</a>(gxact, xid, gid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdr-&gt;prepared_at,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdr-&gt;owner, hdr-&gt;database);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recovered, so reset the flag for entries generated by redo */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; gxact-&gt;inredo = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L504" title="access/transam/twophase.c:504">GXactLoadSubxactData</a>(gxact, hdr-&gt;nsubxacts, subxids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L530" title="access/transam/twophase.c:530">MarkAsPrepared</a>(gxact, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Recover other state (notably locks) using resource managers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1689" title="access/transam/twophase.c:1689">ProcessRecords</a>(bufptr, xid, <a href="twophase_rmgr.c.html#L24" title="access/transam/twophase_rmgr.c:24">twophase_recover_callbacks</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Release locks held by the standby process after we process each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prepared transaction. As a result, we don't need too many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * additional locks at <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (InHotStandby)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/standby.c.html#L1091" title="storage/ipc/standby.c:1091">StandbyReleaseLockTree</a>(xid, hdr-&gt;nsubxacts, subxids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're done with recovering this transaction. Clear <a href="#L196" title="access/transam/twophase.c:196">MyLockedGxact</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * like we do in <a href="xact.c.html#L2460" title="access/transam/xact.c:2460">PrepareTransaction</a>() during normal operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L344" title="access/transam/twophase.c:344">PostPrepare_Twophase</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(TwoPhaseStateLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2187" title="access/transam/twophase.c:2187">ProcessTwoPhaseBuffer</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given a transaction id, read it either from disk or read it directly<br/></li>
<li></span><span class="Comment"> * via shmem xlog record pointer using the provided &quot;prepare_start_lsn&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If setParent is true, set up subtransaction parent linkages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If setNextXid is true, set <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid to the newest<br/></li>
<li></span><span class="Comment"> * value scanned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2187">&#x200c;</a><span class="linkable">ProcessTwoPhaseBuffer</span>(TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr prepare_start_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fromdisk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> setParent, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> setNextXid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FullTransactionId nextXid = <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid;<br/></li>
<li>&nbsp; &nbsp; TransactionId origNextXid = XidFromFullTransactionId(nextXid);<br/></li>
<li>&nbsp; &nbsp; TransactionId *subxids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf;<br/></li>
<li>&nbsp; &nbsp; <a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a> *hdr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(TwoPhaseStateLock, LW_EXCLUSIVE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!fromdisk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(prepare_start_lsn != InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Already processed? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>(xid) || <a href="transam.c.html#L188" title="access/transam/transam.c:188">TransactionIdDidAbort</a>(xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fromdisk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;removing stale two-phase state file for transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1717" title="access/transam/twophase.c:1717">RemoveTwoPhaseFile</a>(xid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;removing stale two-phase state from memory for transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2582" title="access/transam/twophase.c:2582">PrepareRedoRemove</a>(xid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reject XID if too new */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(xid, origNextXid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fromdisk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;removing future two-phase state file for transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1717" title="access/transam/twophase.c:1717">RemoveTwoPhaseFile</a>(xid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;removing future two-phase state from memory for transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2582" title="access/transam/twophase.c:2582">PrepareRedoRemove</a>(xid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fromdisk)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Read and validate file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L1303" title="access/transam/twophase.c:1303">ReadTwoPhaseFile</a>(xid, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Read xlog data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1420" title="access/transam/twophase.c:1420">XlogReadTwoPhaseData</a>(prepare_start_lsn, &amp;buf, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Deconstruct header */<br/></li>
<li></span>&nbsp; &nbsp; hdr = (<a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a> *) buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdEquals(hdr-&gt;xid, xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fromdisk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;corrupted two-phase state file for transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;corrupted two-phase state in memory for transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Examine subtransaction XIDs ... they should all follow <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> XID, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they may force us to advance nextXid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; subxids = (TransactionId *) (buf +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a>)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAXALIGN(hdr-&gt;gidlen));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; hdr-&gt;nsubxacts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId subxid = subxids[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="transam.c.html#L314" title="access/transam/transam.c:314">TransactionIdFollows</a>(subxid, xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update nextXid if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (setNextXid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="varsup.c.html#L304" title="access/transam/varsup.c:304">AdvanceNextFullTransactionIdPastXid</a>(subxid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (setParent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="subtrans.c.html#L85" title="access/transam/subtrans.c:85">SubTransSetParent</a>(subxid, xid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2307" title="access/transam/twophase.c:2307">RecordTransactionCommitPrepared</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is basically the same as <a href="xact.c.html#L1304" title="access/transam/xact.c:1304">RecordTransactionCommit</a> (q.v. if you change<br/></li>
<li></span><span class="Comment"> * this function): in particular, we must set DELAY_CHKPT_START to avoid a<br/></li>
<li></span><span class="Comment"> * race condition.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We know the transaction made at least one XLOG entry (its PREPARE),<br/></li>
<li></span><span class="Comment"> * so it is never possible to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> out the commit record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2307">&#x200c;</a></span><span class="linkable">RecordTransactionCommitPrepared</span>(TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nchildren,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId *children,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator *rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nstats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_xact_stats_item *stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> ninvalmsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SharedInvalidationMessage *invalmsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> initfileinval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *gid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; TimestampTz committs = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; replorigin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Are we using the replication origins feature?&nbsp; Or, in other words, are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we replaying remote actions?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; replorigin = (<a href="../../replication/logical/origin.c.html#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a> != InvalidRepOriginId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/logical/origin.c.html#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a> != DoNotReplicateId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See notes in <a href="xact.c.html#L1304" title="access/transam/xact.c:1304">RecordTransactionCommit</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert((<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags &amp; DELAY_CHKPT_START) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags |= DELAY_CHKPT_START;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Emit the XLOG commit record. Note that we mark 2PC commits as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * potentially having AccessExclusiveLocks since we don't know whether or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not they do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; recptr = <a href="xact.c.html#L5765" title="access/transam/xact.c:5765">XactLogCommitRecord</a>(committs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nchildren, children, nrels, rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nstats, stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ninvalmsgs, invalmsgs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; initfileinval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="xact.c.html#L134" title="access/transam/xact.c:134">MyXactFlags</a> | XACT_FLAGS_ACQUIREDACCESSEXCLUSIVELOCK,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xid, gid);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (replorigin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Move LSNs forward for this replication origin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/logical/origin.c.html#L1219" title="replication/logical/origin.c:1219">replorigin_session_advance</a>(<a href="../../replication/logical/origin.c.html#L156" title="replication/logical/origin.c:156">replorigin_session_origin_lsn</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Record commit timestamp.&nbsp; The value comes from plain commit timestamp<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if replorigin is not enabled, or replorigin already set a value for us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="../../replication/logical/origin.c.html#L157" title="replication/logical/origin.c:157">replorigin_session_origin_timestamp</a> otherwise.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't need to WAL-log anything here, as the commit record written<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above already contains the data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!replorigin || <a href="../../replication/logical/origin.c.html#L157" title="replication/logical/origin.c:157">replorigin_session_origin_timestamp</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/logical/origin.c.html#L157" title="replication/logical/origin.c:157">replorigin_session_origin_timestamp</a> = committs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="commit_ts.c.html#L141" title="access/transam/commit_ts.c:141">TransactionTreeSetCommitTsData</a>(xid, nchildren, children,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../replication/logical/origin.c.html#L157" title="replication/logical/origin.c:157">replorigin_session_origin_timestamp</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../replication/logical/origin.c.html#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't currently try to sleep <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> flush here ... nor is there <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * support for async commit of a prepared xact (the very idea is probably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a contradiction)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Flush XLOG to disk */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(recptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the transaction committed in pg_xact */<br/></li>
<li></span>&nbsp; &nbsp; <a href="transam.c.html#L240" title="access/transam/transam.c:240">TransactionIdCommitTree</a>(xid, nchildren, children);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Checkpoint can proceed <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags &amp;= ~DELAY_CHKPT_START;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Wait for synchronous replication, if required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that at this stage we have marked clog, but still show as running<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the procarray and continue to hold locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../replication/syncrep.c.html#L148" title="replication/syncrep.c:148">SyncRepWaitForLSN</a>(recptr, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2405" title="access/transam/twophase.c:2405">RecordTransactionAbortPrepared</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is basically the same as <a href="xact.c.html#L1723" title="access/transam/xact.c:1723">RecordTransactionAbort</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We know the transaction made at least one XLOG entry (its PREPARE),<br/></li>
<li></span><span class="Comment"> * so it is never possible to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> out the abort record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2405">&#x200c;</a></span><span class="linkable">RecordTransactionAbortPrepared</span>(TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nchildren,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId *children,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelFileLocator *rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nstats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xl_xact_stats_item *stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *gid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; replorigin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Are we using the replication origins feature?&nbsp; Or, in other words, are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we replaying remote actions?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; replorigin = (<a href="../../replication/logical/origin.c.html#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a> != InvalidRepOriginId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/logical/origin.c.html#L155" title="replication/logical/origin.c:155">replorigin_session_origin</a> != DoNotReplicateId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Catch the scenario where we aborted partway through<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2307" title="access/transam/twophase.c:2307">RecordTransactionCommitPrepared</a> ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;cannot abort transaction </span><span class="Special">%u</span><span class="Constant">, it was already committed&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Emit the XLOG commit record. Note that we mark 2PC aborts as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * potentially having AccessExclusiveLocks since we don't know whether or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not they do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; recptr = <a href="xact.c.html#L5937" title="access/transam/xact.c:5937">XactLogAbortRecord</a>(<a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nchildren, children,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrels, rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nstats, stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xact.c.html#L134" title="access/transam/xact.c:134">MyXactFlags</a> | XACT_FLAGS_ACQUIREDACCESSEXCLUSIVELOCK,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid, gid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (replorigin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Move LSNs forward for this replication origin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/logical/origin.c.html#L1219" title="replication/logical/origin.c:1219">replorigin_session_advance</a>(<a href="../../replication/logical/origin.c.html#L156" title="replication/logical/origin.c:156">replorigin_session_origin_lsn</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="xlog.c.html#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Always flush, since we're about to remove the 2PC state file */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(recptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark the transaction aborted in clog.&nbsp; This is not absolutely necessary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but we may as well do it while we are here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="transam.c.html#L270" title="access/transam/transam.c:270">TransactionIdAbortTree</a>(xid, nchildren, children);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Wait for synchronous replication, if required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that at this stage we have marked clog, but still show as running<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the procarray and continue to hold locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../replication/syncrep.c.html#L148" title="replication/syncrep.c:148">SyncRepWaitForLSN</a>(recptr, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2480" title="access/transam/twophase.c:2480">PrepareRedoAdd</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Store pointers to the start/end of the WAL record along with the xid in<br/></li>
<li></span><span class="Comment"> * a gxact entry in shared memory <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a> structure.&nbsp; If caller<br/></li>
<li></span><span class="Comment"> * specifies InvalidXLogRecPtr as WAL location to fetch the two-phase<br/></li>
<li></span><span class="Comment"> * data, the entry is marked as located on disk.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2480">&#x200c;</a></span><span class="linkable">PrepareRedoAdd</span>(<span class="Type">char</span> *buf, XLogRecPtr start_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr end_lsn, RepOriginId origin_id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a> *hdr = (<a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a> *) buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *bufptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *gid;<br/></li>
<li>&nbsp; &nbsp; GlobalTransaction gxact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(TwoPhaseStateLock, LW_EXCLUSIVE));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bufptr = buf + MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a>));<br/></li>
<li>&nbsp; &nbsp; gid = (<span class="Type">const</span> <span class="Type">char</span> *) bufptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reserve the GID for the given transaction in the redo code path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This creates a gxact struct and puts it into the active array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In redo, this struct is mainly used to track PREPARE/COMMIT entries in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared memory. Hence, we only fill up the bare minimum contents here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The gxact also gets marked with gxact-&gt;inredo set to true to indicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that it got added in the redo phase<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In the event of a crash while a checkpoint was running, it may be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible that some two-phase data found its way to disk while its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corresponding record needs to be replayed in the follow-up recovery. As<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the 2PC data was on disk, it has already been restored at the beginning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of recovery with <a href="#L1898" title="access/transam/twophase.c:1898">restoreTwoPhaseData</a>(), so <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this record to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * duplicates in <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>.&nbsp; If a consistent state has been reached,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the record is added to <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a> and it should have no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corresponding file in pg_twophase.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(start_lsn))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L961" title="access/transam/twophase.c:961">TwoPhaseFilePath</a>(path, hdr-&gt;xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (access(path, F_OK) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(<a href="xlogrecovery.c.html#L294" title="access/transam/xlogrecovery.c:294">reachedConsistency</a> ? ERROR : WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not recover two-phase state file for transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdr-&gt;xid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Two-phase state file has been found in WAL record </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, but this transaction has already been restored from disk.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(start_lsn))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not access file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get a free gxact from the freelist */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;freeGXacts == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;maximum number of prepared transactions reached&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Increase max_prepared_transactions (currently </span><span class="Special">%d</span><span class="Constant">).&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>)));<br/></li>
<li>&nbsp; &nbsp; gxact = <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;freeGXacts;<br/></li>
<li>&nbsp; &nbsp; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;freeGXacts = gxact-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; gxact-&gt;prepared_at = hdr-&gt;prepared_at;<br/></li>
<li>&nbsp; &nbsp; gxact-&gt;prepare_start_lsn = start_lsn;<br/></li>
<li>&nbsp; &nbsp; gxact-&gt;prepare_end_lsn = end_lsn;<br/></li>
<li>&nbsp; &nbsp; gxact-&gt;xid = hdr-&gt;xid;<br/></li>
<li>&nbsp; &nbsp; gxact-&gt;owner = hdr-&gt;owner;<br/></li>
<li>&nbsp; &nbsp; gxact-&gt;locking_backend = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; gxact-&gt;valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; gxact-&gt;ondisk = XLogRecPtrIsInvalid(start_lsn);<br/></li>
<li>&nbsp; &nbsp; gxact-&gt;inredo = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* yes, added in redo */<br/></li>
<li></span>&nbsp; &nbsp; strcpy(gxact-&gt;gid, gid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And insert it into the active array */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;numPrepXacts &lt; <a href="#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts[<a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;numPrepXacts++] = gxact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (origin_id != InvalidRepOriginId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recover apply progress */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/logical/origin.c.html#L888" title="replication/logical/origin.c:888">replorigin_advance</a>(origin_id, hdr-&gt;origin_lsn, end_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span> <span class="Comment">/* backward */</span> , <span class="Constant">false</span> <span class="Comment">/* WAL */</span> );<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;added 2PC data in shared memory for transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>, gxact-&gt;xid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2582" title="access/transam/twophase.c:2582">PrepareRedoRemove</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Remove the corresponding gxact entry from <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>. Also remove<br/></li>
<li></span><span class="Comment"> * the 2PC file if a prepared transaction was saved via an earlier checkpoint.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must hold TwoPhaseStateLock in exclusive mode, because <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a><br/></li>
<li></span><span class="Comment"> * is updated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2582">&#x200c;</a></span><span class="linkable">PrepareRedoRemove</span>(TransactionId xid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> giveWarning)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; GlobalTransaction gxact = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(TwoPhaseStateLock, LW_EXCLUSIVE));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;numPrepXacts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gxact = <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gxact-&gt;xid == xid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(gxact-&gt;inredo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Just leave if there is nothing, this is expected during WAL replay.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we can clean up <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> files we may have left.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;removing 2PC data for transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>, xid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (gxact-&gt;ondisk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1717" title="access/transam/twophase.c:1717">RemoveTwoPhaseFile</a>(xid, giveWarning);<br/></li>
<li>&nbsp; &nbsp; <a href="#L628" title="access/transam/twophase.c:628">RemoveGXact</a>(gxact);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2634" title="access/transam/twophase.c:2634">LookupGXact</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check if the prepared transaction with the given GID, lsn and timestamp<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; exists.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we always <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> with the LSN where prepare ends because that is<br/></li>
<li></span><span class="Comment"> * what is stored as origin_lsn in the 2PC file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is primarily used to check if the prepared transaction<br/></li>
<li></span><span class="Comment"> * received from the upstream (remote node) already exists. Checking only GID<br/></li>
<li></span><span class="Comment"> * is not sufficient because a different prepared xact with the same GID can<br/></li>
<li></span><span class="Comment"> * exist on the same node. So, we are ensuring to match origin_lsn and<br/></li>
<li></span><span class="Comment"> * origin_timestamp of prepared xact to avoid the possibility of a match of<br/></li>
<li></span><span class="Comment"> * prepared xact from two different nodes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2634">&#x200c;</a></span><span class="linkable">LookupGXact</span>(<span class="Type">const</span> <span class="Type">char</span> *gid, XLogRecPtr prepare_end_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz origin_prepare_timestamp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(TwoPhaseStateLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;numPrepXacts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GlobalTransaction gxact = <a href="#L188" title="access/transam/twophase.c:188">TwoPhaseState</a>-&gt;prepXacts[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore not-yet-valid GIDs. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gxact-&gt;valid &amp;&amp; strcmp(gxact-&gt;gid, gid) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a> *hdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are not expecting collisions of GXACTs (same gid) between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * publisher and subscribers, so we perform all I/O while holding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TwoPhaseStateLock for simplicity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To move the I/O out of the lock, we need to ensure that no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other backend commits the prepared xact in the meantime. We can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do this optimization if we encounter many collisions in GID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * between publisher and subscriber.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gxact-&gt;ondisk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L1303" title="access/transam/twophase.c:1303">ReadTwoPhaseFile</a>(gxact-&gt;xid, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(gxact-&gt;prepare_start_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1420" title="access/transam/twophase.c:1420">XlogReadTwoPhaseData</a>(gxact-&gt;prepare_start_lsn, &amp;buf, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdr = (<a href="#L991" title="access/transam/twophase.c:991">TwoPhaseFileHeader</a> *) buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hdr-&gt;origin_lsn == prepare_end_lsn &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdr-&gt;origin_timestamp == origin_prepare_timestamp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(TwoPhaseStateLock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> found;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
