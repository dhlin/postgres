<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/transam/xlogrecovery.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/transam/xlogrecovery.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L137">ArchiveRecoveryRequested</a></li>
<li><a href="#L167">CheckPointLoc</a></li>
<li><a href="#L168">CheckPointTLI</a></li>
<li><a href="#L138">InArchiveRecovery</a></li>
<li><a href="#L203">InRedo</a></li>
<li><a href="#L176">LocalHotStandbyActive</a></li>
<li><a href="#L182">LocalPromoteIsTriggered</a></li>
<li><a href="#L96">PrimaryConnInfo</a></li>
<li><a href="#L97">PrimarySlotName</a></li>
<li><a href="#L169">RedoStartLSN</a></li>
<li><a href="#L170">RedoStartTLI</a></li>
<li><a href="#L147">StandbyMode</a></li>
<li><a href="#L146">StandbyModeRequested</a></li>
<li><a href="#L259">XLogReceiptSource</a></li>
<li><a href="#L258">XLogReceiptTime</a></li>
<li><a href="#L364">XLogRecoveryCtl</a></li>
<li><a href="#L372">abortedRecPtr</a></li>
<li><a href="#L84">archiveCleanupCommand</a></li>
<li><a href="#L282">backupEndPoint</a></li>
<li><a href="#L283">backupEndRequired</a></li>
<li><a href="#L281">backupStartPoint</a></li>
<li><a href="#L124">curFileTLI</a></li>
<li><a href="#L246">currentSource</a></li>
<li><a href="#L185">doRequestWalReceiverReply</a></li>
<li><a href="#L123">expectedTLEs</a></li>
<li><a href="#L262">flushedUpto</a></li>
<li><a href="#L247">lastSourceFailed</a></li>
<li><a href="#L278">minRecoveryPoint</a></li>
<li><a href="#L279">minRecoveryPointTLI</a></li>
<li><a href="#L373">missingContrecPtr</a></li>
<li><a href="#L248">pendingWalRcvRestart</a></li>
<li><a href="#L298">primary_image_masked</a></li>
<li><a href="#L294">reachedConsistency</a></li>
<li><a href="#L230">readFile</a></li>
<li><a href="#L233">readLen</a></li>
<li><a href="#L232">readOff</a></li>
<li><a href="#L231">readSegNo</a></li>
<li><a href="#L234">readSource</a></li>
<li><a href="#L263">receiveTLI</a></li>
<li><a href="#L83">recoveryEndCommand</a></li>
<li><a href="#L82">recoveryRestoreCommand</a></li>
<li><a href="#L383">recoveryStopAfter</a></li>
<li><a href="#L381">recoveryStopLSN</a></li>
<li><a href="#L382">recoveryStopName</a></li>
<li><a href="#L380">recoveryStopTime</a></li>
<li><a href="#L379">recoveryStopXid</a></li>
<li><a href="#L85">recoveryTarget</a></li>
<li><a href="#L87">recoveryTargetAction</a></li>
<li><a href="#L86">recoveryTargetInclusive</a></li>
<li><a href="#L92">recoveryTargetLSN</a></li>
<li><a href="#L91">recoveryTargetName</a></li>
<li><a href="#L122">recoveryTargetTLI</a></li>
<li><a href="#L121">recoveryTargetTLIRequested</a></li>
<li><a href="#L90">recoveryTargetTime</a></li>
<li><a href="#L120">recoveryTargetTimeLineGoal</a></li>
<li><a href="#L88">recoveryTargetXid</a></li>
<li><a href="#L93">recovery_min_apply_delay</a></li>
<li><a href="#L151">recovery_signal_file_found</a></li>
<li><a href="#L74">recovery_target_action_options</a></li>
<li><a href="#L89">recovery_target_time_string</a></li>
<li><a href="#L297">replay_image_masked</a></li>
<li><a href="#L150">standby_signal_file_found</a></li>
<li><a href="#L98">wal_receiver_create_temp_slot</a></li>
<li><a href="#L218">xlogSourceNames</a></li>
<li><a href="#L191">xlogprefetcher</a></li>
<li><a href="#L188">xlogreader</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L194">XLogPageReadPrivate</a></li>
<li><a href="#L200">XLogPageReadPrivate</a></li>
<li><a href="#L304">XLogRecoveryCtlData</a></li>
<li><a href="#L362">XLogRecoveryCtlData</a></li>
<li><a href="#L215">XLogSource</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1908">ApplyWalRecord</a></li>
<li><a href="#L4433">CheckForStandbyTrigger</a></li>
<li><a href="#L4463">CheckPromoteSignal</a></li>
<li><a href="#L2175">CheckRecoveryConsistency</a></li>
<li><a href="#L2143">CheckTablespaceDirectory</a></li>
<li><a href="#L3110">ConfirmRecoveryPaused</a></li>
<li><a href="#L478">EnableStandbyMode</a></li>
<li><a href="#L1458">FinishWalRecovery</a></li>
<li><a href="#L4626">GetCurrentChunkReplayStartTime</a></li>
<li><a href="#L4562">GetCurrentReplayRecPtr</a></li>
<li><a href="#L4596">GetLatestXTime</a></li>
<li><a href="#L3070">GetRecoveryPauseState</a></li>
<li><a href="#L4642">GetXLogReceiptTime</a></li>
<li><a href="#L4539">GetXLogReplayRecPtr</a></li>
<li><a href="#L4502">HotStandbyActive</a></li>
<li><a href="#L4527">HotStandbyActiveInReplay</a></li>
<li><a href="#L512">InitWalRecovery</a></li>
<li><a href="#L1652">PerformWalRecovery</a></li>
<li><a href="#L4394">PromoteIsTriggered</a></li>
<li><a href="#L4049">ReadCheckpointRecord</a></li>
<li><a href="#L3131">ReadRecord</a></li>
<li><a href="#L4659">RecoveryRequiresIntParameter</a></li>
<li><a href="#L4454">RemovePromoteSignalFiles</a></li>
<li><a href="#L4614">SetCurrentChunkStartTime</a></li>
<li><a href="#L4585">SetLatestXTime</a></li>
<li><a href="#L4412">SetPromoteIsTriggered</a></li>
<li><a href="#L3090">SetRecoveryPause</a></li>
<li><a href="#L1608">ShutdownWalRecovery</a></li>
<li><a href="#L4375">StartupRequestWalReceiverRestart</a></li>
<li><a href="#L3541">WaitForWALToBecomeAvailable</a></li>
<li><a href="#L4478">WakeupRecovery</a></li>
<li><a href="#L4191">XLogFileRead</a></li>
<li><a href="#L4273">XLogFileReadAnyTLI</a></li>
<li><a href="#L3298">XLogPageRead</a></li>
<li><a href="#L458">XLogRecoveryShmemInit</a></li>
<li><a href="#L447">XLogRecoveryShmemSize</a></li>
<li><a href="#L4487">XLogRequestWalReceiverReply</a></li>
<li><a href="#L4795">assign_recovery_target</a></li>
<li><a href="#L4834">assign_recovery_target_lsn</a></li>
<li><a href="#L4869">assign_recovery_target_name</a></li>
<li><a href="#L4949">assign_recovery_target_time</a></li>
<li><a href="#L4998">assign_recovery_target_timeline</a></li>
<li><a href="#L5034">assign_recovery_target_xid</a></li>
<li><a href="#L2377">checkTimeLineSwitch</a></li>
<li><a href="#L4740">check_primary_slot_name</a></li>
<li><a href="#L4781">check_recovery_target</a></li>
<li><a href="#L4811">check_recovery_target_lsn</a></li>
<li><a href="#L4853">check_recovery_target_name</a></li>
<li><a href="#L4894">check_recovery_target_time</a></li>
<li><a href="#L4965">check_recovery_target_timeline</a></li>
<li><a href="#L5011">check_recovery_target_xid</a></li>
<li><a href="#L4030">emode_for_corrupt_record</a></li>
<li><a href="#L4769">error_multiple_recovery_targets</a></li>
<li><a href="#L2426">getRecordTimestamp</a></li>
<li><a href="#L2886">getRecoveryStopReason</a></li>
<li><a href="#L1027">readRecoverySignalFile</a></li>
<li><a href="#L1208">read_backup_label</a></li>
<li><a href="#L1354">read_tablespace_map</a></li>
<li><a href="#L2982">recoveryApplyDelay</a></li>
<li><a href="#L2925">recoveryPausesHere</a></li>
<li><a href="#L2726">recoveryStopsAfter</a></li>
<li><a href="#L2573">recoveryStopsBefore</a></li>
<li><a href="#L4104">rescanLatestTimeLine</a></li>
<li><a href="#L2275">rm_redo_error_callback</a></li>
<li><a href="#L1109">validateRecoveryParameters</a></li>
<li><a href="#L2461">verifyBackupPageConsistency</a></li>
<li><a href="#L2336">xlog_block_info</a></li>
<li><a href="#L2297">xlog_outdesc</a></li>
<li><a href="#L2318">xlog_outrec</a></li>
<li><a href="#L2072">xlogrecovery_redo</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L69">RECOVERY_COMMAND_DONE</a></li>
<li><a href="#L68">RECOVERY_COMMAND_FILE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * xlogrecovery.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Functions for WAL recovery, standby mode<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This source file contains <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> controlling WAL recovery.<br/></li>
<li></span><span class="Comment"> * <a href="#L512" title="access/transam/xlogrecovery.c:512">InitWalRecovery</a>() initializes the system for crash or archive recovery,<br/></li>
<li></span><span class="Comment"> * or standby mode, depending on configuration options and the state of<br/></li>
<li></span><span class="Comment"> * the control file and possible backup label file.&nbsp; <a href="#L1652" title="access/transam/xlogrecovery.c:1652">PerformWalRecovery</a>()<br/></li>
<li></span><span class="Comment"> * performs the actual WAL replay, calling the rmgr-specific redo routines.<br/></li>
<li></span><span class="Comment"> * <a href="#L1458" title="access/transam/xlogrecovery.c:1458">FinishWalRecovery</a>() performs end-of-recovery checks and <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> actions,<br/></li>
<li></span><span class="Comment"> * and prepares information needed to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the WAL for writes.&nbsp; In<br/></li>
<li></span><span class="Comment"> * addition to these three <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, there are a bunch of <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * for interrogating recovery state and controlling the recovery process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * src/backend/access/transam/xlogrecovery.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;time.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/time.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/timeline.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogarchive.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogrecovery.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;backup/basebackup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_control.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/tablespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/file_utils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/bgwriter.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/startup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/slot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/slotsync.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walreceiver.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/latch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pmsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/spin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datetime.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_lsn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ps_status.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_rusage.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Unsupported old recovery command file names (relative to $PGDATA) */<br/></li>
<li><a id="L68">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RECOVERY_COMMAND_FILE</span>&nbsp; &nbsp; </span><span class="Constant">&quot;recovery.conf&quot;<br/></li>
<li><a id="L69">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RECOVERY_COMMAND_DONE</span>&nbsp; &nbsp; </span><span class="Constant">&quot;recovery.done&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC support<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L74">&#x200c;</a></span><span class="Type">const</span> <span class="Type">struct</span> config_enum_entry <span class="linkable">recovery_target_action_options</span>[] = {<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;pause&quot;</span>, RECOVERY_TARGET_ACTION_PAUSE, <span class="Constant">false</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;promote&quot;</span>, RECOVERY_TARGET_ACTION_PROMOTE, <span class="Constant">false</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;shutdown&quot;</span>, RECOVERY_TARGET_ACTION_SHUTDOWN, <span class="Constant">false</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">false</span>}<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* options formerly taken from recovery.conf for archive recovery */<br/></li>
<li><a id="L82">&#x200c;</a></span><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">recoveryRestoreCommand</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L83">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">recoveryEndCommand</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L84">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">archiveCleanupCommand</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L85">&#x200c;</a>RecoveryTargetType <span class="linkable">recoveryTarget</span> = RECOVERY_TARGET_UNSET;<br/></li>
<li><a id="L86">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">recoveryTargetInclusive</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L87">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">recoveryTargetAction</span> = RECOVERY_TARGET_ACTION_PAUSE;<br/></li>
<li><a id="L88">&#x200c;</a>TransactionId <span class="linkable">recoveryTargetXid</span>;<br/></li>
<li><a id="L89">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">recovery_target_time_string</span>;<br/></li>
<li><a id="L90">&#x200c;</a>TimestampTz <span class="linkable">recoveryTargetTime</span>;<br/></li>
<li><a id="L91">&#x200c;</a><span class="Type">const</span> <span class="Type">char</span> *<span class="linkable">recoveryTargetName</span>;<br/></li>
<li><a id="L92">&#x200c;</a>XLogRecPtr&nbsp; &nbsp; <span class="linkable">recoveryTargetLSN</span>;<br/></li>
<li><a id="L93">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">recovery_min_apply_delay</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* options formerly taken from recovery.conf for XLOG streaming */<br/></li>
<li><a id="L96">&#x200c;</a></span><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">PrimaryConnInfo</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L97">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">PrimarySlotName</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L98">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">wal_receiver_create_temp_slot</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L120" title="access/transam/xlogrecovery.c:120">recoveryTargetTimeLineGoal</a>: what the user requested, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L121" title="access/transam/xlogrecovery.c:121">recoveryTargetTLIRequested</a>: <a href="../../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> value of requested timeline, if constant<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a>: the currently understood target timeline; changes<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a>: a list of TimeLineHistoryEntries for <a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a> and<br/></li>
<li></span><span class="Comment"> * the timelines of its known parents, newest first (so <a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a> is<br/></li>
<li></span><span class="Comment"> * always the first list member).&nbsp; Only these TLIs are expected to be seen in<br/></li>
<li></span><span class="Comment"> * the WAL segments we read, and indeed only these TLIs will be considered as<br/></li>
<li></span><span class="Comment"> * candidate WAL files to open at all.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L124" title="access/transam/xlogrecovery.c:124">curFileTLI</a>: the TLI appearing in the name of the current input WAL file.<br/></li>
<li></span><span class="Comment"> * (This is not necessarily the same as the timeline from which we are<br/></li>
<li></span><span class="Comment"> * replaying WAL, which <a href="xlog.c.html#L5388" title="access/transam/xlog.c:5388">StartupXLOG</a> calls replayTLI, because we could be<br/></li>
<li></span><span class="Comment"> * scanning data that was copied from an ancestor timeline when the current<br/></li>
<li></span><span class="Comment"> * file was created.)&nbsp; During a sequential scan we do not allow this value<br/></li>
<li></span><span class="Comment"> * to decrease.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L120">&#x200c;</a></span>RecoveryTargetTimeLineGoal <span class="linkable">recoveryTargetTimeLineGoal</span> = RECOVERY_TARGET_TIMELINE_LATEST;<br/></li>
<li><a id="L121">&#x200c;</a>TimeLineID&nbsp; &nbsp; <span class="linkable">recoveryTargetTLIRequested</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L122">&#x200c;</a>TimeLineID&nbsp; &nbsp; <span class="linkable">recoveryTargetTLI</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L123">&#x200c;</a><span class="Type">static</span> List *<span class="linkable">expectedTLEs</span>;<br/></li>
<li><a id="L124">&#x200c;</a><span class="Type">static</span> TimeLineID <span class="linkable">curFileTLI</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When <a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a> is set, archive recovery was requested,<br/></li>
<li></span><span class="Comment"> * ie. signal files were present.&nbsp; When <a href="#L138" title="access/transam/xlogrecovery.c:138">InArchiveRecovery</a> is set, we are<br/></li>
<li></span><span class="Comment"> * currently recovering using offline XLOG archives.&nbsp; These variables are only<br/></li>
<li></span><span class="Comment"> * valid in the startup process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When <a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a> is true, but <a href="#L138" title="access/transam/xlogrecovery.c:138">InArchiveRecovery</a> is false, we're<br/></li>
<li></span><span class="Comment"> * currently performing crash recovery using only XLOG files in pg_wal, but<br/></li>
<li></span><span class="Comment"> * will switch to using offline XLOG archives as soon as we reach the end of<br/></li>
<li></span><span class="Comment"> * WAL in pg_wal.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L137">&#x200c;</a></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">ArchiveRecoveryRequested</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L138">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">InArchiveRecovery</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When <a href="#L146" title="access/transam/xlogrecovery.c:146">StandbyModeRequested</a> is set, standby mode was requested, i.e.<br/></li>
<li></span><span class="Comment"> * standby.signal file was present.&nbsp; When <a href="#L147" title="access/transam/xlogrecovery.c:147">StandbyMode</a> is set, we are currently<br/></li>
<li></span><span class="Comment"> * in standby mode.&nbsp; These variables are only valid in the startup process.<br/></li>
<li></span><span class="Comment"> * They work similarly to <a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a> and <a href="#L138" title="access/transam/xlogrecovery.c:138">InArchiveRecovery</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L146">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">StandbyModeRequested</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L147">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">StandbyMode</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* was a signal file present at startup? */<br/></li>
<li><a id="L150">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">standby_signal_file_found</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L151">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">recovery_signal_file_found</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L167" title="access/transam/xlogrecovery.c:167">CheckPointLoc</a> is the position of the checkpoint record that determines<br/></li>
<li></span><span class="Comment"> * where to start the replay.&nbsp; It comes from the backup label file or the<br/></li>
<li></span><span class="Comment"> * control file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L169" title="access/transam/xlogrecovery.c:169">RedoStartLSN</a> is the checkpoint's REDO location, also from the backup label<br/></li>
<li></span><span class="Comment"> * file or the control file.&nbsp; In standby mode, XLOG streaming usually starts<br/></li>
<li></span><span class="Comment"> * from the position where an invalid record was found.&nbsp; But if we fail to<br/></li>
<li></span><span class="Comment"> * read even the initial checkpoint record, we use the REDO location instead<br/></li>
<li></span><span class="Comment"> * of the checkpoint location as the start position of XLOG streaming.<br/></li>
<li></span><span class="Comment"> * Otherwise we would have to jump backwards to the REDO location after<br/></li>
<li></span><span class="Comment"> * reading the checkpoint record, because the REDO record can precede the<br/></li>
<li></span><span class="Comment"> * checkpoint record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L167">&#x200c;</a></span><span class="Type">static</span> XLogRecPtr <span class="linkable">CheckPointLoc</span> = InvalidXLogRecPtr;<br/></li>
<li><a id="L168">&#x200c;</a><span class="Type">static</span> TimeLineID <span class="linkable">CheckPointTLI</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L169">&#x200c;</a><span class="Type">static</span> XLogRecPtr <span class="linkable">RedoStartLSN</span> = InvalidXLogRecPtr;<br/></li>
<li><a id="L170">&#x200c;</a><span class="Type">static</span> TimeLineID <span class="linkable">RedoStartTLI</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Local copy of SharedHotStandbyActive variable. False actually means &quot;not<br/></li>
<li></span><span class="Comment"> * known, need to check the shared state&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L176">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">LocalHotStandbyActive</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Local copy of SharedPromoteIsTriggered variable. False actually means &quot;not<br/></li>
<li></span><span class="Comment"> * known, need to check the shared state&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L182">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">LocalPromoteIsTriggered</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Has the recovery code requested a walreceiver <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a>? */<br/></li>
<li><a id="L185">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">doRequestWalReceiverReply</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* XLogReader object used to <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> */<br/></li>
<li><a id="L188">&#x200c;</a></span><span class="Type">static</span> XLogReaderState *<span class="linkable">xlogreader</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="xlogprefetcher.c.html#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> object used to consume WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> with read-ahead */<br/></li>
<li><a id="L191">&#x200c;</a></span><span class="Type">static</span> <a href="xlogprefetcher.c.html#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> *<span class="linkable">xlogprefetcher</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Parameters passed down from <a href="#L3131" title="access/transam/xlogrecovery.c:3131">ReadRecord</a> to the <a href="#L3298" title="access/transam/xlogrecovery.c:3298">XLogPageRead</a> callback. */<br/></li>
<li><a id="L194">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">XLogPageReadPrivate</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; emode;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; fetching_ckpt;&nbsp; &nbsp; <span class="Comment">/* are we fetching a checkpoint record? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; randAccess;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; replayTLI;<br/></li>
<li><a id="L200">&#x200c;</a>} <span class="linkable">XLogPageReadPrivate</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* flag to tell <a href="#L3298" title="access/transam/xlogrecovery.c:3298">XLogPageRead</a> that we have started replaying */<br/></li>
<li><a id="L203">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">InRedo</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Codes indicating where we got a WAL file from during recovery, or where<br/></li>
<li></span><span class="Comment"> * to attempt to get one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; XLOG_FROM_ANY = <span class="Constant">0</span>,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* request to read WAL from <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> source */<br/></li>
<li></span>&nbsp; &nbsp; XLOG_FROM_ARCHIVE,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* restored using restore_command */<br/></li>
<li></span>&nbsp; &nbsp; XLOG_FROM_PG_WAL,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* existing file in pg_wal */<br/></li>
<li></span>&nbsp; &nbsp; XLOG_FROM_STREAM,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* streamed from primary */<br/></li>
<li><a id="L215">&#x200c;</a></span>} <span class="linkable">XLogSource</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* human-readable names for XLogSources, for debugging output */<br/></li>
<li><a id="L218">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<span class="Type">const</span> <span class="linkable">xlogSourceNames</span>[] = {<span class="Constant">&quot;<a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>&quot;</span>, <span class="Constant">&quot;archive&quot;</span>, <span class="Constant">&quot;pg_wal&quot;</span>, <span class="Constant">&quot;stream&quot;</span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> is -1 or a kernel FD for the log file segment that's currently<br/></li>
<li></span><span class="Comment"> * open for reading.&nbsp; <a href="#L231" title="access/transam/xlogrecovery.c:231">readSegNo</a> identifies the segment.&nbsp; <a href="#L232" title="access/transam/xlogrecovery.c:232">readOff</a> is the offset<br/></li>
<li></span><span class="Comment"> * of the page just read, <a href="#L233" title="access/transam/xlogrecovery.c:233">readLen</a> indicates how much of it has been read into<br/></li>
<li></span><span class="Comment"> * readBuf, and <a href="#L234" title="access/transam/xlogrecovery.c:234">readSource</a> indicates where we got the currently open file from.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we could use Reserve/<a href="../../storage/file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a> to track consumption of this<br/></li>
<li></span><span class="Comment"> * FD too (like for <a href="xlog.c.html#L630" title="access/transam/xlog.c:630">openLogFile</a> in xlog.c); but it doesn't currently seem<br/></li>
<li></span><span class="Comment"> * worthwhile, since the XLOG is not read by general-purpose sessions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L230">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">readFile</span> = -<span class="Constant">1</span>;<br/></li>
<li><a id="L231">&#x200c;</a><span class="Type">static</span> XLogSegNo <span class="linkable">readSegNo</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L232">&#x200c;</a><span class="Type">static</span> uint32 <span class="linkable">readOff</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L233">&#x200c;</a><span class="Type">static</span> uint32 <span class="linkable">readLen</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L234">&#x200c;</a><span class="Type">static</span> <a href="#L215" title="access/transam/xlogrecovery.c:215">XLogSource</a> <span class="linkable">readSource</span> = XLOG_FROM_ANY;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Keeps track of which source we're currently reading from. This is<br/></li>
<li></span><span class="Comment"> * different from <a href="#L234" title="access/transam/xlogrecovery.c:234">readSource</a> in that this is always set, even when we don't<br/></li>
<li></span><span class="Comment"> * currently have a WAL file open. If <a href="#L247" title="access/transam/xlogrecovery.c:247">lastSourceFailed</a> is set, our last<br/></li>
<li></span><span class="Comment"> * attempt to read from <a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a> failed, and we should try another source<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L248" title="access/transam/xlogrecovery.c:248">pendingWalRcvRestart</a> is set when a config change occurs that requires a<br/></li>
<li></span><span class="Comment"> * walreceiver restart.&nbsp; This is only valid in XLOG_FROM_STREAM state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L246">&#x200c;</a></span><span class="Type">static</span> <a href="#L215" title="access/transam/xlogrecovery.c:215">XLogSource</a> <span class="linkable">currentSource</span> = XLOG_FROM_ANY;<br/></li>
<li><a id="L247">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">lastSourceFailed</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L248">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">pendingWalRcvRestart</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These variables track when we last obtained some WAL data to process,<br/></li>
<li></span><span class="Comment"> * and where we got it from.&nbsp; (<a href="#L259" title="access/transam/xlogrecovery.c:259">XLogReceiptSource</a> is initially the same as<br/></li>
<li></span><span class="Comment"> * <a href="#L234" title="access/transam/xlogrecovery.c:234">readSource</a>, but <a href="#L234" title="access/transam/xlogrecovery.c:234">readSource</a> gets reset to zero when we don't have data<br/></li>
<li></span><span class="Comment"> * to process right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; It is also different from <a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a>, which<br/></li>
<li></span><span class="Comment"> * also changes when we try to read from a source and fail, while<br/></li>
<li></span><span class="Comment"> * <a href="#L259" title="access/transam/xlogrecovery.c:259">XLogReceiptSource</a> tracks where we last successfully read some WAL.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L258">&#x200c;</a></span><span class="Type">static</span> TimestampTz <span class="linkable">XLogReceiptTime</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L259">&#x200c;</a><span class="Type">static</span> <a href="#L215" title="access/transam/xlogrecovery.c:215">XLogSource</a> <span class="linkable">XLogReceiptSource</span> = XLOG_FROM_ANY;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Local copy of <a href="../../replication/walreceiverfuncs.c.html#L33" title="replication/walreceiverfuncs.c:33">WalRcv</a>-&gt;<a href="#L262" title="access/transam/xlogrecovery.c:262">flushedUpto</a> */<br/></li>
<li><a id="L262">&#x200c;</a></span><span class="Type">static</span> XLogRecPtr <span class="linkable">flushedUpto</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L263">&#x200c;</a><span class="Type">static</span> TimeLineID <span class="linkable">receiveTLI</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy of <a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> and <a href="#L282" title="access/transam/xlogrecovery.c:282">backupEndPoint</a> from the control file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In order to reach consistency, we must replay the WAL up to<br/></li>
<li></span><span class="Comment"> * <a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>.&nbsp; If <a href="#L283" title="access/transam/xlogrecovery.c:283">backupEndRequired</a> is true, we must also reach<br/></li>
<li></span><span class="Comment"> * <a href="#L282" title="access/transam/xlogrecovery.c:282">backupEndPoint</a>, or if it's invalid, an end-of-backup record corresponding<br/></li>
<li></span><span class="Comment"> * to <a href="#L281" title="access/transam/xlogrecovery.c:281">backupStartPoint</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: In archive recovery, after consistency has been reached, the<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in xlog.c will start updating <a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> in the control<br/></li>
<li></span><span class="Comment"> * file.&nbsp; But this copy of <a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> variable reflects the value at the<br/></li>
<li></span><span class="Comment"> * beginning of recovery, and is *not* updated after consistency is reached.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L278">&#x200c;</a></span><span class="Type">static</span> XLogRecPtr <span class="linkable">minRecoveryPoint</span>;<br/></li>
<li><a id="L279">&#x200c;</a><span class="Type">static</span> TimeLineID <span class="linkable">minRecoveryPointTLI</span>;<br/></li>
<li><br/></li>
<li><a id="L281">&#x200c;</a><span class="Type">static</span> XLogRecPtr <span class="linkable">backupStartPoint</span>;<br/></li>
<li><a id="L282">&#x200c;</a><span class="Type">static</span> XLogRecPtr <span class="linkable">backupEndPoint</span>;<br/></li>
<li><a id="L283">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">backupEndRequired</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Have we reached a consistent database state?&nbsp; In crash recovery, we have<br/></li>
<li></span><span class="Comment"> * to replay all the WAL, so <a href="#L294" title="access/transam/xlogrecovery.c:294">reachedConsistency</a> is never set.&nbsp; During archive<br/></li>
<li></span><span class="Comment"> * recovery, the database is consistent once <a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> is reached.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Consistent state means that the system is internally consistent, all<br/></li>
<li></span><span class="Comment"> * the WAL has been replayed up to a certain point, and importantly, there<br/></li>
<li></span><span class="Comment"> * is no trace of later actions on disk.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L294">&#x200c;</a></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">reachedConsistency</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Buffers dedicated to consistency checks of size BLCKSZ */<br/></li>
<li><a id="L297">&#x200c;</a></span><span class="Type">static</span> <span class="Type">char</span> *<span class="linkable">replay_image_masked</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L298">&#x200c;</a><span class="Type">static</span> <span class="Type">char</span> *<span class="linkable">primary_image_masked</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Shared-memory state for WAL recovery.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L304">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">XLogRecoveryCtlData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SharedHotStandbyActive indicates if we allow hot standby queries to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * run.&nbsp; Protected by info_lck.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; SharedHotStandbyActive;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SharedPromoteIsTriggered indicates if a standby promotion has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * triggered.&nbsp; Protected by info_lck.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; SharedPromoteIsTriggered;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recoveryWakeupLatch is used to wake up the startup process to continue<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WAL replay, if it is <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for WAL to arrive or promotion to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requested.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that the startup process also uses another latch, its procLatch,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to wait for recovery conflict. If we get rid of recoveryWakeupLatch for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * signaling the startup process in favor of using its procLatch, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comports better with possible generic signal handlers using that latch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * But we should not do that because the startup process doesn't assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that it's waken up by walreceiver process or SIGHUP signal handler<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * while it's <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for recovery conflict. The separate latches,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recoveryWakeupLatch and procLatch, should be used for inter-process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * communication for WAL replay and recovery conflict, respectively.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Latch&nbsp; &nbsp; &nbsp; &nbsp; recoveryWakeupLatch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Last record successfully replayed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lastReplayedReadRecPtr; <span class="Comment">/* start position */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lastReplayedEndRecPtr;&nbsp; &nbsp; <span class="Comment">/* end+1 position */<br/></li>
<li></span>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; lastReplayedTLI;&nbsp; &nbsp; <span class="Comment">/* timeline */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When we're currently replaying a record, ie. in a redo function,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replayEndRecPtr points to the end+1 of the record being replayed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise it's <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to lastReplayedEndRecPtr.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; replayEndRecPtr;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; replayEndTLI;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* timestamp of last COMMIT/ABORT record replayed (or being replayed) */<br/></li>
<li></span>&nbsp; &nbsp; TimestampTz recoveryLastXTime;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timestamp of when we started replaying the current chunk of WAL data,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only relevant for replication or archive recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TimestampTz currentChunkStartTime;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recovery pause state */<br/></li>
<li></span>&nbsp; &nbsp; RecoveryPauseState recoveryPauseState;<br/></li>
<li>&nbsp; &nbsp; ConditionVariable recoveryNotPausedCV;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slock_t&nbsp; &nbsp; &nbsp; &nbsp; info_lck;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* locks shared variables shown above */<br/></li>
<li><a id="L362">&#x200c;</a></span>} <span class="linkable">XLogRecoveryCtlData</span>;<br/></li>
<li><br/></li>
<li><a id="L364">&#x200c;</a><span class="Type">static</span> <a href="#L304" title="access/transam/xlogrecovery.c:304">XLogRecoveryCtlData</a> *<span class="linkable">XLogRecoveryCtl</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L372" title="access/transam/xlogrecovery.c:372">abortedRecPtr</a> is the start pointer of a broken record at end of WAL when<br/></li>
<li></span><span class="Comment"> * recovery completes; <a href="#L373" title="access/transam/xlogrecovery.c:373">missingContrecPtr</a> is the location of the first<br/></li>
<li></span><span class="Comment"> * contrecord that went missing.&nbsp; See <a href="xlog.c.html#L7361" title="access/transam/xlog.c:7361">CreateOverwriteContrecordRecord</a> for<br/></li>
<li></span><span class="Comment"> * details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L372">&#x200c;</a></span><span class="Type">static</span> XLogRecPtr <span class="linkable">abortedRecPtr</span>;<br/></li>
<li><a id="L373">&#x200c;</a><span class="Type">static</span> XLogRecPtr <span class="linkable">missingContrecPtr</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * if <a href="#L2573" title="access/transam/xlogrecovery.c:2573">recoveryStopsBefore</a>/After returns true, it saves information of the stop<br/></li>
<li></span><span class="Comment"> * point here<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L379">&#x200c;</a></span><span class="Type">static</span> TransactionId <span class="linkable">recoveryStopXid</span>;<br/></li>
<li><a id="L380">&#x200c;</a><span class="Type">static</span> TimestampTz <span class="linkable">recoveryStopTime</span>;<br/></li>
<li><a id="L381">&#x200c;</a><span class="Type">static</span> XLogRecPtr <span class="linkable">recoveryStopLSN</span>;<br/></li>
<li><a id="L382">&#x200c;</a><span class="Type">static</span> <span class="Type">char</span> <span class="linkable">recoveryStopName</span>[MAXFNAMELEN];<br/></li>
<li><a id="L383">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">recoveryStopAfter</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* prototypes for local <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1908" title="access/transam/xlogrecovery.c:1908">ApplyWalRecord</a>(XLogReaderState *<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>, XLogRecord *record, TimeLineID *replayTLI);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L478" title="access/transam/xlogrecovery.c:478">EnableStandbyMode</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1027" title="access/transam/xlogrecovery.c:1027">readRecoverySignalFile</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1109" title="access/transam/xlogrecovery.c:1109">validateRecoveryParameters</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1208" title="access/transam/xlogrecovery.c:1208">read_backup_label</a>(XLogRecPtr *checkPointLoc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID *backupLabelTLI,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *<a href="#L283" title="access/transam/xlogrecovery.c:283">backupEndRequired</a>, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *backupFromStandby);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1354" title="access/transam/xlogrecovery.c:1354">read_tablespace_map</a>(List **tablespaces);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2072" title="access/transam/xlogrecovery.c:2072">xlogrecovery_redo</a>(XLogReaderState *record, TimeLineID replayTLI);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2175" title="access/transam/xlogrecovery.c:2175">CheckRecoveryConsistency</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2275" title="access/transam/xlogrecovery.c:2275">rm_redo_error_callback</a>(<span class="Type">void</span> *arg);<br/></li>
<li><span class="PreProc">#ifdef WAL_DEBUG<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L2318" title="access/transam/xlogrecovery.c:2318">xlog_outrec</a>(StringInfo buf, XLogReaderState *record);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L2336" title="access/transam/xlogrecovery.c:2336">xlog_block_info</a>(StringInfo buf, XLogReaderState *record);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2377" title="access/transam/xlogrecovery.c:2377">checkTimeLineSwitch</a>(XLogRecPtr lsn, TimeLineID newTLI,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID prevTLI, TimeLineID replayTLI);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2426" title="access/transam/xlogrecovery.c:2426">getRecordTimestamp</a>(XLogReaderState *record, TimestampTz *recordXtime);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2461" title="access/transam/xlogrecovery.c:2461">verifyBackupPageConsistency</a>(XLogReaderState *record);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2573" title="access/transam/xlogrecovery.c:2573">recoveryStopsBefore</a>(XLogReaderState *record);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2726" title="access/transam/xlogrecovery.c:2726">recoveryStopsAfter</a>(XLogReaderState *record);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L2886" title="access/transam/xlogrecovery.c:2886">getRecoveryStopReason</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2925" title="access/transam/xlogrecovery.c:2925">recoveryPausesHere</a>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> endOfRecovery);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2982" title="access/transam/xlogrecovery.c:2982">recoveryApplyDelay</a>(XLogReaderState *record);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3110" title="access/transam/xlogrecovery.c:3110">ConfirmRecoveryPaused</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> XLogRecord *<a href="#L3131" title="access/transam/xlogrecovery.c:3131">ReadRecord</a>(<a href="xlogprefetcher.c.html#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> *<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> emode, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fetching_ckpt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID replayTLI);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L3298" title="access/transam/xlogrecovery.c:3298">XLogPageRead</a>(XLogReaderState *<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>, XLogRecPtr targetPagePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> reqLen, XLogRecPtr targetRecPtr, <span class="Type">char</span> *readBuf);<br/></li>
<li><span class="Type">static</span> XLogPageReadResult <a href="#L3541" title="access/transam/xlogrecovery.c:3541">WaitForWALToBecomeAvailable</a>(XLogRecPtr RecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> randAccess,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fetching_ckpt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr tliRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID replayTLI,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr replayLSN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nonblocking);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L4030" title="access/transam/xlogrecovery.c:4030">emode_for_corrupt_record</a>(<span class="Type">int</span> emode, XLogRecPtr RecPtr);<br/></li>
<li><span class="Type">static</span> XLogRecord *<a href="#L4049" title="access/transam/xlogrecovery.c:4049">ReadCheckpointRecord</a>(<a href="xlogprefetcher.c.html#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> *<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr RecPtr, TimeLineID replayTLI);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L4104" title="access/transam/xlogrecovery.c:4104">rescanLatestTimeLine</a>(TimeLineID replayTLI, XLogRecPtr replayLSN);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L4191" title="access/transam/xlogrecovery.c:4191">XLogFileRead</a>(XLogSegNo segno, <span class="Type">int</span> emode, TimeLineID tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L215" title="access/transam/xlogrecovery.c:215">XLogSource</a> source, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> notfoundOk);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L4273" title="access/transam/xlogrecovery.c:4273">XLogFileReadAnyTLI</a>(XLogSegNo segno, <span class="Type">int</span> emode, <a href="#L215" title="access/transam/xlogrecovery.c:215">XLogSource</a> source);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L4433" title="access/transam/xlogrecovery.c:4433">CheckForStandbyTrigger</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4412" title="access/transam/xlogrecovery.c:4412">SetPromoteIsTriggered</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L4527" title="access/transam/xlogrecovery.c:4527">HotStandbyActiveInReplay</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4614" title="access/transam/xlogrecovery.c:4614">SetCurrentChunkStartTime</a>(TimestampTz xtime);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4585" title="access/transam/xlogrecovery.c:4585">SetLatestXTime</a>(TimestampTz xtime);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialization of shared memory for WAL recovery<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L447">&#x200c;</a><span class="linkable">XLogRecoveryShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a> */<br/></li>
<li></span>&nbsp; &nbsp; size = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L304" title="access/transam/xlogrecovery.c:304">XLogRecoveryCtlData</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L458">&#x200c;</a></span><span class="linkable">XLogRecoveryShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a> = (<a href="#L304" title="access/transam/xlogrecovery.c:304">XLogRecoveryCtlData</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;XLOG Recovery Ctl&quot;</span>, <a href="#L447" title="access/transam/xlogrecovery.c:447">XLogRecoveryShmemSize</a>(), &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; memset(<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L304" title="access/transam/xlogrecovery.c:304">XLogRecoveryCtlData</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockInit(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L430" title="storage/ipc/latch.c:430">InitSharedLatch</a>(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryWakeupLatch);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L35" title="storage/lmgr/condition_variable.c:35">ConditionVariableInit</a>(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryNotPausedCV);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A thin wrapper to enable <a href="#L147" title="access/transam/xlogrecovery.c:147">StandbyMode</a> and do other preparatory work as<br/></li>
<li></span><span class="Comment"> * needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L478">&#x200c;</a></span><span class="linkable">EnableStandbyMode</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L147" title="access/transam/xlogrecovery.c:147">StandbyMode</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To avoid server log bloat, we don't report recovery progress in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * standby as it will always be in recovery unless promoted. We disable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * startup progress timeout in standby mode to avoid calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../postmaster/startup.c.html#L303" title="postmaster/startup.c:303">startup_progress_timeout_handler</a>() unnecessarily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../postmaster/startup.c.html#L309" title="postmaster/startup.c:309">disable_startup_progress_timeout</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare the system for WAL recovery, if needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called by <a href="xlog.c.html#L5388" title="access/transam/xlog.c:5388">StartupXLOG</a>() which coordinates the server startup<br/></li>
<li></span><span class="Comment"> * sequence.&nbsp; This function analyzes the control file and the backup label<br/></li>
<li></span><span class="Comment"> * file, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, and figures out whether we need to perform crash recovery or<br/></li>
<li></span><span class="Comment"> * archive recovery, and how far we need to replay the WAL to reach a<br/></li>
<li></span><span class="Comment"> * consistent state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This doesn't yet change the on-disk state, except for creating the symlinks<br/></li>
<li></span><span class="Comment"> * from table space map file if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, and for fetching WAL files needed to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment"> * the checkpoint record.&nbsp; On entry, the caller has already read the control<br/></li>
<li></span><span class="Comment"> * file into memory, and passes it as argument.&nbsp; This function updates it to<br/></li>
<li></span><span class="Comment"> * reflect the recovery state, and the caller is expected to write it back to<br/></li>
<li></span><span class="Comment"> * disk does after initializing other subsystems, but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling<br/></li>
<li></span><span class="Comment"> * <a href="#L1652" title="access/transam/xlogrecovery.c:1652">PerformWalRecovery</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This initializes some global variables like <a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a>, and<br/></li>
<li></span><span class="Comment"> * <a href="#L146" title="access/transam/xlogrecovery.c:146">StandbyModeRequested</a> and <a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L512">&#x200c;</a></span><span class="linkable">InitWalRecovery</span>(ControlFileData *<a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *wasShutdown_ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *haveBackupLabel_ptr, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *haveTblspcMap_ptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L194" title="access/transam/xlogrecovery.c:194">XLogPageReadPrivate</a> *private;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat st;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; wasShutdown;<br/></li>
<li>&nbsp; &nbsp; XLogRecord *record;<br/></li>
<li>&nbsp; &nbsp; DBState&nbsp; &nbsp; &nbsp; &nbsp; dbstate_at_startup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; haveTblspcMap = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; haveBackupLabel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; CheckPoint&nbsp; &nbsp; checkPoint;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; backupFromStandby = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dbstate_at_startup = <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize on the assumption we want to recover to the latest timeline<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that's active according to pg_control.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a> &gt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.ThisTimeLineID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a> = <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a> = <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.ThisTimeLineID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for signal files, and if so set up state for offline recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1027" title="access/transam/xlogrecovery.c:1027">readRecoverySignalFile</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L1109" title="access/transam/xlogrecovery.c:1109">validateRecoveryParameters</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Take ownership of the <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> latch if we're going to sleep during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery, if required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L463" title="storage/ipc/latch.c:463">OwnLatch</a>(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryWakeupLatch);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the WAL reading processor <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, as it will be needed when reading<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the checkpoint record required (backup_label or not).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; private = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L194" title="access/transam/xlogrecovery.c:194">XLogPageReadPrivate</a>));<br/></li>
<li>&nbsp; &nbsp; <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogreader.c.html#L106" title="access/transam/xlogreader.c:106">XLogReaderAllocate</a>(<a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XL_ROUTINE(.page_read = &amp;<a href="#L3298" title="access/transam/xlogrecovery.c:3298">XLogPageRead</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .segment_open = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .segment_close = <a href="xlogutils.c.html#L842" title="access/transam/xlogutils.c:842">wal_segment_close</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; private);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed while allocating a WAL reading processor.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;system_identifier = <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;system_identifier;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the WAL decode buffer size.&nbsp; This limits how far ahead we can read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the WAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xlogreader.c.html#L90" title="access/transam/xlogreader.c:90">XLogReaderSetDecodeBuffer</a>(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>, <span class="Constant">NULL</span>, <a href="xlog.c.html#L136" title="access/transam/xlog.c:136">wal_decode_buffer_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a WAL prefetcher. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a> = <a href="xlogprefetcher.c.html#L362" title="access/transam/xlogprefetcher.c:362">XLogPrefetcherAllocate</a>(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate two page buffers dedicated to WAL consistency checks.&nbsp; We do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it this way, rather than just making static arrays, for two reasons:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (1) no need to waste the storage in most instantiations of the backend;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (2) a static char array isn't guaranteed to have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> particular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * alignment, whereas <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>() will provide MAXALIGN'd storage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L297" title="access/transam/xlogrecovery.c:297">replay_image_masked</a> = (<span class="Type">char</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="access/transam/xlogrecovery.c:298">primary_image_masked</a> = (<span class="Type">char</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read the backup_label file.&nbsp; We want to run this part of the recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process after checking for signal files and after performing validation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the recovery parameters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1208" title="access/transam/xlogrecovery.c:1208">read_backup_label</a>(&amp;<a href="#L167" title="access/transam/xlogrecovery.c:167">CheckPointLoc</a>, &amp;<a href="#L168" title="access/transam/xlogrecovery.c:168">CheckPointTLI</a>, &amp;<a href="#L283" title="access/transam/xlogrecovery.c:283">backupEndRequired</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;backupFromStandby))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tablespaces = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Archive recovery was requested, and thanks to the backup label<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file, we know how far we need to replay to reach consistency. Enter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * archive recovery directly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L138" title="access/transam/xlogrecovery.c:138">InArchiveRecovery</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L146" title="access/transam/xlogrecovery.c:146">StandbyModeRequested</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L478" title="access/transam/xlogrecovery.c:478">EnableStandbyMode</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Omitting backup_label when creating a new replica, PITR node etc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unfortunately is a common cause of corruption.&nbsp; Logging that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backup_label was used makes it a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> easier to exclude that as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cause of observed corruption.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do so <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we try to read the checkpoint record (which can fail),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as otherwise it can be hard to understand why a checkpoint other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPoint is used.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;starting backup recovery with redo LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, checkpoint LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, on timeline ID </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="#L169" title="access/transam/xlogrecovery.c:169">RedoStartLSN</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="#L167" title="access/transam/xlogrecovery.c:167">CheckPointLoc</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L168" title="access/transam/xlogrecovery.c:168">CheckPointTLI</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When a backup_label file is present, we want to roll forward from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the checkpoint it identifies, rather than using pg_control.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; record = <a href="#L4049" title="access/transam/xlogrecovery.c:4049">ReadCheckpointRecord</a>(<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>, <a href="#L167" title="access/transam/xlogrecovery.c:167">CheckPointLoc</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L168" title="access/transam/xlogrecovery.c:168">CheckPointTLI</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (record != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;checkPoint, XLogRecGetData(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CheckPoint));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wasShutdown = ((record-&gt;xl_info &amp; ~XLR_INFO_MASK) == XLOG_CHECKPOINT_SHUTDOWN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;checkpoint record is at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="#L167" title="access/transam/xlogrecovery.c:167">CheckPointLoc</a>))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a> = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* force recovery even if SHUTDOWNED */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure that REDO location exists. This may not be the case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if there was a crash during an online backup, which left a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backup_label around that references a WAL segment that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already been archived.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (checkPoint.redo &lt; <a href="#L167" title="access/transam/xlogrecovery.c:167">CheckPointLoc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogprefetcher.c.html#L964" title="access/transam/xlogprefetcher.c:964">XLogPrefetcherBeginRead</a>(<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>, checkPoint.redo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3131" title="access/transam/xlogrecovery.c:3131">ReadRecord</a>(<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>, LOG, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checkPoint.ThisTimeLineID))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> redo location </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> referenced by checkpoint record at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(checkPoint.redo), LSN_FORMAT_ARGS(<a href="#L167" title="access/transam/xlogrecovery.c:167">CheckPointLoc</a>)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;If you are restoring from a backup, touch </span><span class="Special">\&quot;%s</span><span class="Constant">/recovery.signal</span><span class="Special">\&quot;</span><span class="Constant"> or </span><span class="Special">\&quot;%s</span><span class="Constant">/standby.signal</span><span class="Special">\&quot;</span><span class="Constant"> and add required recovery options.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;If you are not restoring from a backup, try removing the file </span><span class="Special">\&quot;%s</span><span class="Constant">/backup_label</span><span class="Special">\&quot;</span><span class="Constant">.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Be careful: removing </span><span class="Special">\&quot;%s</span><span class="Constant">/backup_label</span><span class="Special">\&quot;</span><span class="Constant"> will result in a corrupt <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> if restoring from a backup.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, <a href="../../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, <a href="../../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, <a href="../../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not locate required checkpoint record at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="#L167" title="access/transam/xlogrecovery.c:167">CheckPointLoc</a>)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;If you are restoring from a backup, touch </span><span class="Special">\&quot;%s</span><span class="Constant">/recovery.signal</span><span class="Special">\&quot;</span><span class="Constant"> or </span><span class="Special">\&quot;%s</span><span class="Constant">/standby.signal</span><span class="Special">\&quot;</span><span class="Constant"> and add required recovery options.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;If you are not restoring from a backup, try removing the file </span><span class="Special">\&quot;%s</span><span class="Constant">/backup_label</span><span class="Special">\&quot;</span><span class="Constant">.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Be careful: removing </span><span class="Special">\&quot;%s</span><span class="Constant">/backup_label</span><span class="Special">\&quot;</span><span class="Constant"> will result in a corrupt <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> if restoring from a backup.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, <a href="../../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, <a href="../../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, <a href="../../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wasShutdown = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Read the <a href="xlogfuncs.c.html#L41" title="access/transam/xlogfuncs.c:41">tablespace_map</a> file if present and create symlinks. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1354" title="access/transam/xlogrecovery.c:1354">read_tablespace_map</a>(&amp;tablespaces))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, tablespaces)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tablespaceinfo *ti = lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *linkloc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linkloc = psprintf(<span class="Constant">&quot;pg_tblspc/</span><span class="Special">%u</span><span class="Constant">&quot;</span>, ti-&gt;oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remove the existing symlink if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> and Create the symlink<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * under PGDATA.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/tablespace.c.html#L883" title="commands/tablespace.c:883">remove_tablespace_symlink</a>(linkloc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (symlink(ti-&gt;path, linkloc) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create symbolic link </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linkloc)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ti-&gt;path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ti);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tell the caller to delete it later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; haveTblspcMap = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tell the caller to delete it later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; haveBackupLabel = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No backup_label file has been found if we are here. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="xlogfuncs.c.html#L41" title="access/transam/xlogfuncs.c:41">tablespace_map</a> file is present without backup_label file, there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is no use of such file.&nbsp; There is no harm in retaining it, but it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is better to get rid of the map file so that we don't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * redundant file in data directory and it will avoid <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sort of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * confusion.&nbsp; It seems prudent though to just rename the file out of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the way rather than delete it completely, also we ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that occurs in rename operation as even if map file is present<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * without backup_label file, it is harmless.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stat(TABLESPACE_MAP, &amp;st) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unlink(TABLESPACE_MAP_OLD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L782" title="storage/file/fd.c:782">durable_rename</a>(TABLESPACE_MAP, TABLESPACE_MAP_OLD, DEBUG1) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ignoring file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> because no file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> exists&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TABLESPACE_MAP, BACKUP_LABEL_FILE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;File </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> was renamed to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TABLESPACE_MAP, TABLESPACE_MAP_OLD)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ignoring file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> because no file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> exists&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TABLESPACE_MAP, BACKUP_LABEL_FILE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Could not rename file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TABLESPACE_MAP, TABLESPACE_MAP_OLD)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's possible that archive recovery was requested, but we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * know how far we need to replay the WAL <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we reach consistency.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This can happen for example if a base backup is taken from a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * running server using an atomic filesystem snapshot, without calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="xlogfuncs.c.html#L56" title="access/transam/xlogfuncs.c:56">pg_backup_start</a>/stop. Or if you just kill a running primary server<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and put it into archive recovery by creating a recovery signal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Our strategy in that case is to perform crash recovery first,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * replaying all the WAL present in pg_wal, and only enter archive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recovery after that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * But usually we already know how far we need to replay the WAL (up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to <a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>, up to <a href="#L282" title="access/transam/xlogrecovery.c:282">backupEndPoint</a>, or until we see an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end-of-backup record), and we can enter archive recovery directly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> != InvalidXLogRecPtr ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L283" title="access/transam/xlogrecovery.c:283">backupEndRequired</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L282" title="access/transam/xlogrecovery.c:282">backupEndPoint</a> != InvalidXLogRecPtr ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;state == DB_SHUTDOWNED))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L138" title="access/transam/xlogrecovery.c:138">InArchiveRecovery</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L146" title="access/transam/xlogrecovery.c:146">StandbyModeRequested</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L478" title="access/transam/xlogrecovery.c:478">EnableStandbyMode</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For the same reason as when starting up with backup_label present,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * emit a log message when we continue initializing from a base<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(<a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L281" title="access/transam/xlogrecovery.c:281">backupStartPoint</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;restarting backup recovery with redo LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L281" title="access/transam/xlogrecovery.c:281">backupStartPoint</a>))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the last valid checkpoint record. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L167" title="access/transam/xlogrecovery.c:167">CheckPointLoc</a> = <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPoint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L168" title="access/transam/xlogrecovery.c:168">CheckPointTLI</a> = <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.ThisTimeLineID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L169" title="access/transam/xlogrecovery.c:169">RedoStartLSN</a> = <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.redo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L170" title="access/transam/xlogrecovery.c:170">RedoStartTLI</a> = <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.ThisTimeLineID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record = <a href="#L4049" title="access/transam/xlogrecovery.c:4049">ReadCheckpointRecord</a>(<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>, <a href="#L167" title="access/transam/xlogrecovery.c:167">CheckPointLoc</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L168" title="access/transam/xlogrecovery.c:168">CheckPointTLI</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (record != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;checkpoint record is at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="#L167" title="access/transam/xlogrecovery.c:167">CheckPointLoc</a>))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We used to attempt to go back to a secondary checkpoint record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here, but only when not in standby mode. We <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> just fail if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't read the last checkpoint because this allows us to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * simplify processing around checkpoints.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not locate a valid checkpoint record at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="#L167" title="access/transam/xlogrecovery.c:167">CheckPointLoc</a>))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;checkPoint, XLogRecGetData(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CheckPoint));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wasShutdown = ((record-&gt;xl_info &amp; ~XLR_INFO_MASK) == XLOG_CHECKPOINT_SHUTDOWN);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L146" title="access/transam/xlogrecovery.c:146">StandbyModeRequested</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;entering standby mode&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> == RECOVERY_TARGET_XID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;starting point-in-time recovery to XID </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="access/transam/xlogrecovery.c:88">recoveryTargetXid</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> == RECOVERY_TARGET_TIME)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;starting point-in-time recovery to </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1853" title="utils/adt/timestamp.c:1853">timestamptz_to_str</a>(<a href="#L90" title="access/transam/xlogrecovery.c:90">recoveryTargetTime</a>))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> == RECOVERY_TARGET_NAME)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;starting point-in-time recovery to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L91" title="access/transam/xlogrecovery.c:91">recoveryTargetName</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> == RECOVERY_TARGET_LSN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;starting point-in-time recovery to WAL location (LSN) </span><span class="Special">\&quot;%X</span><span class="Constant">/</span><span class="Special">%X\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="#L92" title="access/transam/xlogrecovery.c:92">recoveryTargetLSN</a>))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> == RECOVERY_TARGET_IMMEDIATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;starting point-in-time recovery to earliest consistent point&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;starting archive recovery&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the location of the checkpoint record is not on the expected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timeline in the history of the requested timeline, we cannot proceed:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the backup is not part of the history of the requested timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* was initialized by reading checkpoint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * record */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="timeline.c.html#L544" title="access/transam/timeline.c:544">tliOfPointInHistory</a>(<a href="#L167" title="access/transam/xlogrecovery.c:167">CheckPointLoc</a>, <a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a>) !=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L168" title="access/transam/xlogrecovery.c:168">CheckPointTLI</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; switchpoint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="timeline.c.html#L572" title="access/transam/timeline.c:572">tliSwitchPoint</a> will throw an error if the checkpoint's timeline is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not in <a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a> at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; switchpoint = <a href="timeline.c.html#L572" title="access/transam/timeline.c:572">tliSwitchPoint</a>(<a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.ThisTimeLineID, <a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested timeline </span><span class="Special">%u</span><span class="Constant"> is not a child of this server's history&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Latest checkpoint is at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> on timeline </span><span class="Special">%u</span><span class="Constant">, but in the history of the requested timeline, the server forked off from that timeline at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPoint),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.ThisTimeLineID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(switchpoint))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The min recovery point should be part of the requested timeline's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * history, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(<a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="timeline.c.html#L544" title="access/transam/timeline.c:544">tliOfPointInHistory</a>(<a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> - <span class="Constant">1</span>, <a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a>) !=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested timeline </span><span class="Special">%u</span><span class="Constant"> does not contain minimum recovery point </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> on timeline </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;redo record is at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">; shutdown </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(checkPoint.redo),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wasShutdown ? <span class="Constant">&quot;true&quot;</span> : <span class="Constant">&quot;false&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> transaction ID: &quot;</span> UINT64_FORMAT <span class="Constant">&quot;; <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> OID: </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; U64FromFullTransactionId(checkPoint.nextXid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; checkPoint.nextOid)));<br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> MultiXactId: </span><span class="Special">%u</span><span class="Constant">; <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> MultiXactOffset: </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; checkPoint.nextMulti, checkPoint.nextMultiOffset)));<br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;oldest unfrozen transaction ID: </span><span class="Special">%u</span><span class="Constant">, in database </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; checkPoint.oldestXid, checkPoint.oldestXidDB)));<br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;oldest MultiXactId: </span><span class="Special">%u</span><span class="Constant">, in database </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; checkPoint.oldestMulti, checkPoint.oldestMultiDB)));<br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;commit timestamp Xid oldest/newest: </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; checkPoint.oldestCommitTsXid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; checkPoint.newestCommitTsXid)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsNormal(XidFromFullTransactionId(checkPoint.nextXid)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> transaction ID&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (checkPoint.redo &gt; <a href="#L167" title="access/transam/xlogrecovery.c:167">CheckPointLoc</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid redo in checkpoint record&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check whether we need to force recovery from WAL.&nbsp; If it appears to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have been a clean shutdown and we did not have a recovery signal file,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then assume no recovery needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (checkPoint.redo &lt; <a href="#L167" title="access/transam/xlogrecovery.c:167">CheckPointLoc</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wasShutdown)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid redo record in shutdown checkpoint&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;state != DB_SHUTDOWNED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* force recovery due to presence of recovery signal file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If recovery is needed, update our in-memory copy of pg_control to show<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we are recovering and to show the selected checkpoint as the place<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we are starting from. We also mark pg_control with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> minimum recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stop point obtained from a backup history file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't write the changes to disk yet, though. Only do that after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initializing various subsystems.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L138" title="access/transam/xlogrecovery.c:138">InArchiveRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;state = DB_IN_ARCHIVE_RECOVERY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database system was not properly shut down; &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;automatic recovery in progress&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a> &gt; <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.ThisTimeLineID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;crash recovery starts in timeline </span><span class="Special">%u</span><span class="Constant"> &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;and has target timeline </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.ThisTimeLineID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;state = DB_IN_CRASH_RECOVERY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPoint = <a href="#L167" title="access/transam/xlogrecovery.c:167">CheckPointLoc</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy = checkPoint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L138" title="access/transam/xlogrecovery.c:138">InArchiveRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> <a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> if not set yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> &lt; checkPoint.redo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> = checkPoint.redo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a> = checkPoint.ThisTimeLineID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set <a href="#L281" title="access/transam/xlogrecovery.c:281">backupStartPoint</a> if we're starting recovery from a base backup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also set <a href="#L282" title="access/transam/xlogrecovery.c:282">backupEndPoint</a> and use <a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> as the backup end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * location if we're starting recovery from a base backup which was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * taken from a standby. In this case, the database system status in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_control must indicate that the database was already in recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Usually that will be DB_IN_ARCHIVE_RECOVERY but also can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * DB_SHUTDOWNED_IN_RECOVERY if recovery previously was interrupted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> reaching this point; e.g. because restore_command or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * primary_conninfo were faulty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Any other state indicates that the backup somehow became corrupted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and we can't sensibly continue with recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (haveBackupLabel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L281" title="access/transam/xlogrecovery.c:281">backupStartPoint</a> = checkPoint.redo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L283" title="access/transam/xlogrecovery.c:283">backupEndRequired</a> = <a href="#L283" title="access/transam/xlogrecovery.c:283">backupEndRequired</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (backupFromStandby)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dbstate_at_startup != DB_IN_ARCHIVE_RECOVERY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dbstate_at_startup != DB_SHUTDOWNED_IN_RECOVERY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;backup_label contains data inconsistent with control file&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;This means that the backup is corrupted and you will &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;have to use another backup for recovery.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L282" title="access/transam/xlogrecovery.c:282">backupEndPoint</a> = <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remember these, so that we know when we have reached consistency */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L281" title="access/transam/xlogrecovery.c:281">backupStartPoint</a> = <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L281" title="access/transam/xlogrecovery.c:281">backupStartPoint</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L283" title="access/transam/xlogrecovery.c:283">backupEndRequired</a> = <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L283" title="access/transam/xlogrecovery.c:283">backupEndRequired</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L282" title="access/transam/xlogrecovery.c:282">backupEndPoint</a> = <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L282" title="access/transam/xlogrecovery.c:282">backupEndPoint</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L138" title="access/transam/xlogrecovery.c:138">InArchiveRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> = <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a> = <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start recovery assuming that the final record isn't lost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L372" title="access/transam/xlogrecovery.c:372">abortedRecPtr</a> = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L373" title="access/transam/xlogrecovery.c:373">missingContrecPtr</a> = InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *wasShutdown_ptr = wasShutdown;<br/></li>
<li>&nbsp; &nbsp; *haveBackupLabel_ptr = haveBackupLabel;<br/></li>
<li>&nbsp; &nbsp; *haveTblspcMap_ptr = haveTblspcMap;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * See if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> recovery signal files and if so, set state for<br/></li>
<li></span><span class="Comment"> * recovery.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See if there is a recovery command file (recovery.conf), and if so<br/></li>
<li></span><span class="Comment"> * throw an ERROR since as of PG12 we no longer recognize that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1027">&#x200c;</a></span><span class="linkable">readRecoverySignalFile</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat stat_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for old recovery API file: recovery.conf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stat(<a href="#L68" title="access/transam/xlogrecovery.c:68">RECOVERY_COMMAND_FILE</a>, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;using recovery command file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not supported&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L68" title="access/transam/xlogrecovery.c:68">RECOVERY_COMMAND_FILE</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove unused .done file, if present. Ignore if absent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; unlink(<a href="#L69" title="access/transam/xlogrecovery.c:69">RECOVERY_COMMAND_DONE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for recovery signal files and if found, fsync them since they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * represent server state information.&nbsp; We don't sweat too much about the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibility of fsync failure, however.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If present, standby signal file takes precedence. If neither is present<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then we won't enter archive recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stat(STANDBY_SIGNAL_FILE, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L1109" title="storage/file/fd.c:1109">BasicOpenFilePerm</a>(STANDBY_SIGNAL_FILE, O_RDWR | PG_BINARY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; S_IRUSR | S_IWUSR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fd &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../storage/file/fd.c.html#L386" title="storage/file/fd.c:386">pg_fsync</a>(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; close(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L150" title="access/transam/xlogrecovery.c:150">standby_signal_file_found</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (stat(RECOVERY_SIGNAL_FILE, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L1109" title="storage/file/fd.c:1109">BasicOpenFilePerm</a>(RECOVERY_SIGNAL_FILE, O_RDWR | PG_BINARY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; S_IRUSR | S_IWUSR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fd &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../storage/file/fd.c.html#L386" title="storage/file/fd.c:386">pg_fsync</a>(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; close(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L151" title="access/transam/xlogrecovery.c:151">recovery_signal_file_found</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L146" title="access/transam/xlogrecovery.c:146">StandbyModeRequested</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L150" title="access/transam/xlogrecovery.c:150">standby_signal_file_found</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L146" title="access/transam/xlogrecovery.c:146">StandbyModeRequested</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L151" title="access/transam/xlogrecovery.c:151">recovery_signal_file_found</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L146" title="access/transam/xlogrecovery.c:146">StandbyModeRequested</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't support standby mode in standalone backends; that requires<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other processes such as the WAL receiver to be alive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L146" title="access/transam/xlogrecovery.c:146">StandbyModeRequested</a> &amp;&amp; !<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;standby mode is not supported by single-user servers&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1109">&#x200c;</a></span><span class="linkable">validateRecoveryParameters</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for compulsory parameters<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L146" title="access/transam/xlogrecovery.c:146">StandbyModeRequested</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((<a href="#L96" title="access/transam/xlogrecovery.c:96">PrimaryConnInfo</a> == <span class="Constant">NULL</span> || strcmp(<a href="#L96" title="access/transam/xlogrecovery.c:96">PrimaryConnInfo</a>, <span class="Constant">&quot;&quot;</span>) == <span class="Constant">0</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L82" title="access/transam/xlogrecovery.c:82">recoveryRestoreCommand</a> == <span class="Constant">NULL</span> || strcmp(<a href="#L82" title="access/transam/xlogrecovery.c:82">recoveryRestoreCommand</a>, <span class="Constant">&quot;&quot;</span>) == <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;specified neither primary_conninfo nor restore_command&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;The database server will regularly poll the pg_wal subdirectory to check for files placed there.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L82" title="access/transam/xlogrecovery.c:82">recoveryRestoreCommand</a> == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(<a href="#L82" title="access/transam/xlogrecovery.c:82">recoveryRestoreCommand</a>, <span class="Constant">&quot;&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;must specify restore_command when standby mode is not enabled&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Override <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> inconsistent requests. Note that this is a change of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * behaviour in 9.5; prior to this we simply ignored a request to pause if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hot_standby = off, which was surprising behaviour.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L87" title="access/transam/xlogrecovery.c:87">recoveryTargetAction</a> == RECOVERY_TARGET_ACTION_PAUSE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="xlog.c.html#L121" title="access/transam/xlog.c:121">EnableHotStandby</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="access/transam/xlogrecovery.c:87">recoveryTargetAction</a> = RECOVERY_TARGET_ACTION_SHUTDOWN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Final parsing of recovery_target_time string; see also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L4894" title="access/transam/xlogrecovery.c:4894">check_recovery_target_time</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> == RECOVERY_TARGET_TIME)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L90" title="access/transam/xlogrecovery.c:90">recoveryTargetTime</a> = DatumGetTimestampTz(DirectFunctionCall3(<a href="../../utils/adt/timestamp.c.html#L416" title="utils/adt/timestamp.c:416">timestamptz_in</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CStringGetDatum(<a href="#L89" title="access/transam/xlogrecovery.c:89">recovery_target_time_string</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(InvalidOid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int32GetDatum(-<span class="Constant">1</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If user specified recovery_target_timeline, validate it or compute the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;latest&quot; value.&nbsp; We can't do this until after we've gotten the restore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * command and set <a href="#L138" title="access/transam/xlogrecovery.c:138">InArchiveRecovery</a>, because we need to fetch timeline<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * history files from the archive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L120" title="access/transam/xlogrecovery.c:120">recoveryTargetTimeLineGoal</a> == RECOVERY_TARGET_TIMELINE_NUMERIC)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeLineID&nbsp; &nbsp; rtli = <a href="#L121" title="access/transam/xlogrecovery.c:121">recoveryTargetTLIRequested</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Timeline 1 does not have a history file, all else should */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rtli != <span class="Constant">1</span> &amp;&amp; !<a href="timeline.c.html#L222" title="access/transam/timeline.c:222">existsTimeLineHistory</a>(rtli))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovery target timeline </span><span class="Special">%u</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtli)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a> = rtli;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L120" title="access/transam/xlogrecovery.c:120">recoveryTargetTimeLineGoal</a> == RECOVERY_TARGET_TIMELINE_LATEST)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We start the &quot;latest&quot; search from pg_control's timeline */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a> = <a href="timeline.c.html#L264" title="access/transam/timeline.c:264">findNewestTimeLine</a>(<a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * else we just use the <a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a> as already read from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="xlog.c.html#L569" title="access/transam/xlog.c:569">ControlFile</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L120" title="access/transam/xlogrecovery.c:120">recoveryTargetTimeLineGoal</a> == RECOVERY_TARGET_TIMELINE_CONTROLFILE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1208" title="access/transam/xlogrecovery.c:1208">read_backup_label</a>: check to see if a backup_label file is present<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we see a backup_label during recovery, we assume that we are recovering<br/></li>
<li></span><span class="Comment"> * from a backup <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> file, and we therefore roll forward from the checkpoint<br/></li>
<li></span><span class="Comment"> * identified by the label file, NOT what pg_control says.&nbsp; This avoids the<br/></li>
<li></span><span class="Comment"> * problem that pg_control might have been archived one or more checkpoints<br/></li>
<li></span><span class="Comment"> * later than the start of the <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a>, and so if we rely on it as the start<br/></li>
<li></span><span class="Comment"> * point, we will fail to restore a consistent database state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if a backup_label was found (and fills the checkpoint<br/></li>
<li></span><span class="Comment"> * location and TLI into *checkPointLoc and *backupLabelTLI, respectively);<br/></li>
<li></span><span class="Comment"> * returns false if not. If this backup_label came from a streamed backup,<br/></li>
<li></span><span class="Comment"> * *<a href="#L283" title="access/transam/xlogrecovery.c:283">backupEndRequired</a> is set to true. If this backup_label was created during<br/></li>
<li></span><span class="Comment"> * recovery, *backupFromStandby is set to true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also sets the global variables <a href="#L169" title="access/transam/xlogrecovery.c:169">RedoStartLSN</a> and <a href="#L170" title="access/transam/xlogrecovery.c:170">RedoStartTLI</a> with the LSN<br/></li>
<li></span><span class="Comment"> * and TLI read from the backup file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1208">&#x200c;</a></span><span class="linkable">read_backup_label</span>(XLogRecPtr *checkPointLoc, TimeLineID *backupLabelTLI,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *<a href="#L283" title="access/transam/xlogrecovery.c:283">backupEndRequired</a>, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *backupFromStandby)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; startxlogfilename[MAXFNAMELEN];<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; tli_from_walseg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tli_from_file;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *lfp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; ch;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; backuptype[<span class="Constant">20</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; backupfrom[<span class="Constant">20</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; backuplabel[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; backuptime[<span class="Constant">128</span>];<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hi,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* suppress possible uninitialized-variable warnings */<br/></li>
<li></span>&nbsp; &nbsp; *checkPointLoc = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; *backupLabelTLI = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; *<a href="#L283" title="access/transam/xlogrecovery.c:283">backupEndRequired</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; *backupFromStandby = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if label file is present<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lfp = <a href="../../storage/file/fd.c.html#L2583" title="storage/file/fd.c:2583">AllocateFile</a>(BACKUP_LABEL_FILE, <span class="Constant">&quot;r&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!lfp)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BACKUP_LABEL_FILE)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it's not there, all is fine */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read and <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the START WAL LOCATION and CHECKPOINT lines (this code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is pretty crude, but we are not expecting <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> variability in the file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * format).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fscanf(lfp, <span class="Constant">&quot;START WAL LOCATION: </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> (file </span><span class="Special">%08X%16s</span><span class="Constant">)</span><span class="Special">%c</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;hi, &amp;lo, &amp;tli_from_walseg, startxlogfilename, &amp;ch) != <span class="Constant">5</span> || ch != <span class="Special">'\n'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid data in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, BACKUP_LABEL_FILE)));<br/></li>
<li>&nbsp; &nbsp; <a href="#L169" title="access/transam/xlogrecovery.c:169">RedoStartLSN</a> = ((uint64) hi) &lt;&lt; <span class="Constant">32</span> | lo;<br/></li>
<li>&nbsp; &nbsp; <a href="#L170" title="access/transam/xlogrecovery.c:170">RedoStartTLI</a> = tli_from_walseg;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fscanf(lfp, <span class="Constant">&quot;CHECKPOINT LOCATION: </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X%c</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;hi, &amp;lo, &amp;ch) != <span class="Constant">3</span> || ch != <span class="Special">'\n'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid data in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, BACKUP_LABEL_FILE)));<br/></li>
<li>&nbsp; &nbsp; *checkPointLoc = ((uint64) hi) &lt;&lt; <span class="Constant">32</span> | lo;<br/></li>
<li>&nbsp; &nbsp; *backupLabelTLI = tli_from_walseg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * BACKUP METHOD lets us know if this was a typical backup (&quot;streamed&quot;,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which could mean either pg_basebackup or the <a href="xlogfuncs.c.html#L56" title="access/transam/xlogfuncs.c:56">pg_backup_start</a>/stop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * method was used) or if this label came from somewhere else (the only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other option today being from pg_rewind).&nbsp; If this was a streamed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backup then we know that we need to play through until we get to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end of the WAL which was generated during the backup (at which point we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will have reached consistency and <a href="#L283" title="access/transam/xlogrecovery.c:283">backupEndRequired</a> will be reset to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * false).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fscanf(lfp, <span class="Constant">&quot;BACKUP METHOD: </span><span class="Special">%19s\n</span><span class="Constant">&quot;</span>, backuptype) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(backuptype, <span class="Constant">&quot;streamed&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *<a href="#L283" title="access/transam/xlogrecovery.c:283">backupEndRequired</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * BACKUP FROM lets us know if this was from a primary or a standby.&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it was from a standby, we'll double-check that the control file state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matches that of a standby.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fscanf(lfp, <span class="Constant">&quot;BACKUP FROM: </span><span class="Special">%19s\n</span><span class="Constant">&quot;</span>, backupfrom) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(backupfrom, <span class="Constant">&quot;standby&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *backupFromStandby = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Parse START TIME and LABEL. Those are not mandatory fields for recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but checking for their presence is useful for debugging and the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sanity checks. Cope also with the fact that the result buffers have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pre-allocated size, hence if the backup_label file has been generated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with strings longer than the maximum assumed here an incorrect parsing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happens. That's fine as only minor consistency checks are done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * afterwards.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fscanf(lfp, <span class="Constant">&quot;START TIME: </span><span class="Special">%127[^\n]\n</span><span class="Constant">&quot;</span>, backuptime) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;backup time </span><span class="Special">%s</span><span class="Constant"> in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; backuptime, BACKUP_LABEL_FILE)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fscanf(lfp, <span class="Constant">&quot;LABEL: </span><span class="Special">%1023[^\n]\n</span><span class="Constant">&quot;</span>, backuplabel) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;backup label </span><span class="Special">%s</span><span class="Constant"> in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; backuplabel, BACKUP_LABEL_FILE)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * START TIMELINE is new as of 11. Its parsing is not mandatory, still use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it as a sanity check if present.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fscanf(lfp, <span class="Constant">&quot;START TIMELINE: </span><span class="Special">%u\n</span><span class="Constant">&quot;</span>, &amp;tli_from_file) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tli_from_walseg != tli_from_file)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid data in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, BACKUP_LABEL_FILE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Timeline ID parsed is </span><span class="Special">%u</span><span class="Constant">, but expected </span><span class="Special">%u</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tli_from_file, tli_from_walseg)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;backup timeline </span><span class="Special">%u</span><span class="Constant"> in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tli_from_file, BACKUP_LABEL_FILE)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fscanf(lfp, <span class="Constant">&quot;INCREMENTAL FROM LSN: </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X\n</span><span class="Constant">&quot;</span>, &amp;hi, &amp;lo) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;this is an incremental backup, not a data directory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use pg_combinebackup to reconstruct a valid data directory.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ferror(lfp) || <a href="../../storage/file/fd.c.html#L2781" title="storage/file/fd.c:2781">FreeFile</a>(lfp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BACKUP_LABEL_FILE)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1354" title="access/transam/xlogrecovery.c:1354">read_tablespace_map</a>: check to see if a <a href="xlogfuncs.c.html#L41" title="access/transam/xlogfuncs.c:41">tablespace_map</a> file is present<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we see a <a href="xlogfuncs.c.html#L41" title="access/transam/xlogfuncs.c:41">tablespace_map</a> file during recovery, we assume that we are<br/></li>
<li></span><span class="Comment"> * recovering from a backup <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> file, and we therefore need to create symlinks<br/></li>
<li></span><span class="Comment"> * as per the information present in <a href="xlogfuncs.c.html#L41" title="access/transam/xlogfuncs.c:41">tablespace_map</a> file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if a <a href="xlogfuncs.c.html#L41" title="access/transam/xlogfuncs.c:41">tablespace_map</a> file was found (and fills *tablespaces<br/></li>
<li></span><span class="Comment"> * with a tablespaceinfo struct for each tablespace listed in the file);<br/></li>
<li></span><span class="Comment"> * returns false if not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1354">&#x200c;</a></span><span class="linkable">read_tablespace_map</span>(List **tablespaces)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; tablespaceinfo *ti;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *lfp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; str[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; was_backslash;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if <a href="xlogfuncs.c.html#L41" title="access/transam/xlogfuncs.c:41">tablespace_map</a> file is present<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lfp = <a href="../../storage/file/fd.c.html#L2583" title="storage/file/fd.c:2583">AllocateFile</a>(TABLESPACE_MAP, <span class="Constant">&quot;r&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!lfp)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TABLESPACE_MAP)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it's not there, all is fine */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read and <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the link name and path lines from <a href="xlogfuncs.c.html#L41" title="access/transam/xlogfuncs.c:41">tablespace_map</a> file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (this code is pretty crude, but we are not expecting <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> variability in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the file format).&nbsp; De-escape <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backslashes that were inserted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; was_backslash = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((ch = fgetc(lfp)) != <span class="Constant">EOF</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!was_backslash &amp;&amp; (ch == <span class="Special">'\n'</span> || ch == <span class="Special">'\r'</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* \r immediately followed by \n */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The de-escaped line should contain an OID followed by exactly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one space followed by a path.&nbsp; The path might start with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * spaces, so don't be too liberal about parsing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str[i] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (str[n] &amp;&amp; str[n] != <span class="Constant">' '</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (n &lt; <span class="Constant">1</span> || n &gt;= i - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid data in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, TABLESPACE_MAP)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str[n++] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ti = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tablespaceinfo));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ti-&gt;oid = strtoul(str, &amp;endp, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*endp != <span class="Special">'\0'</span> || errno == <span class="Constant">EINVAL</span> || errno == <span class="Constant">ERANGE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid data in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, TABLESPACE_MAP)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ti-&gt;path = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(str + n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tablespaces = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*tablespaces, ti);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!was_backslash &amp;&amp; ch == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; was_backslash = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(str) - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str[i++] = ch;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; was_backslash = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (i != <span class="Constant">0</span> || was_backslash)&nbsp; &nbsp; <span class="Comment">/* last line not terminated? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid data in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, TABLESPACE_MAP)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ferror(lfp) || <a href="../../storage/file/fd.c.html#L2781" title="storage/file/fd.c:2781">FreeFile</a>(lfp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TABLESPACE_MAP)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Finish WAL recovery.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This does not close the '<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>' yet, because in some cases the caller<br/></li>
<li></span><span class="Comment"> * still wants to re-read the last checkpoint record by calling<br/></li>
<li></span><span class="Comment"> * <a href="#L4049" title="access/transam/xlogrecovery.c:4049">ReadCheckpointRecord</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the position of the last valid or applied record, after which new<br/></li>
<li></span><span class="Comment"> * WAL should be appended, information about why recovery was ended, and some<br/></li>
<li></span><span class="Comment"> * other things. See the EndOfWalRecoveryInfo struct for details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>EndOfWalRecoveryInfo *<br/></li>
<li><a id="L1458">&#x200c;</a><span class="linkable">FinishWalRecovery</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; EndOfWalRecoveryInfo *result = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(EndOfWalRecoveryInfo));<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lastRec;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; lastRecTLI;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; endOfLog;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Kill WAL receiver, if it's still running, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we continue to write<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the startup checkpoint and aborted-contrecord <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>. It will trump<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * over these <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> and subsequent ones if it's still alive when we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * start writing WAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xlog.c.html#L9393" title="access/transam/xlog.c:9393">XLogShutdownWalRcv</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../postmaster/postmaster.c.html#L269" title="postmaster/postmaster.c:269">Shutdown</a> the slot sync worker to drop <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> temporary slots acquired by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it and to prevent it from keep trying to fetch the failover slots.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do not update the 'synced' column in 'pg_replication_slots' system<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * view from true to false here, as <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> failed update could leave 'synced'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * column false for some slots. This could cause issues during slot sync<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after restarting the server as a standby. While updating the 'synced'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * column after switching to the new timeline is an option, it does not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * simplify the handling for the 'synced' column. Therefore, we retain the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'synced' column as true after promotion as it may provide useful<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * information about the slot origin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../replication/logical/slotsync.c.html#L1562" title="replication/logical/slotsync.c:1562">ShutDownSlotSync</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> done reading the xlog from stream. Turn off streaming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery to force fetching the files (which would be required at end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery, e.g., timeline history file) from archive or pg_wal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that standby mode must be turned off after killing WAL receiver,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * i.e., calling <a href="xlog.c.html#L9393" title="access/transam/xlog.c:9393">XLogShutdownWalRcv</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="../../replication/walreceiverfuncs.c.html#L126" title="replication/walreceiverfuncs.c:126">WalRcvStreaming</a>());<br/></li>
<li>&nbsp; &nbsp; <a href="#L147" title="access/transam/xlogrecovery.c:147">StandbyMode</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine where to start writing WAL <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Re-fetch the last valid or last applied record, so we can identify the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exact endpoint of what we consider the valid portion of WAL.&nbsp; There may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be an incomplete continuation record after that, in which case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * '<a href="#L372" title="access/transam/xlogrecovery.c:372">abortedRecPtr</a>' and '<a href="#L373" title="access/transam/xlogrecovery.c:373">missingContrecPtr</a>' are set and the caller will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * write a special OVERWRITE_CONTRECORD message to mark that the rest of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it is intentionally missing.&nbsp; See <a href="xlog.c.html#L7361" title="access/transam/xlog.c:7361">CreateOverwriteContrecordRecord</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * An important side-effect of this is to load the last page into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>. The caller uses it to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the WAL for writing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lastRec = <a href="#L167" title="access/transam/xlogrecovery.c:167">CheckPointLoc</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lastRecTLI = <a href="#L168" title="access/transam/xlogrecovery.c:168">CheckPointTLI</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lastRec = <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;lastReplayedReadRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lastRecTLI = <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;lastReplayedTLI;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="xlogprefetcher.c.html#L964" title="access/transam/xlogprefetcher.c:964">XLogPrefetcherBeginRead</a>(<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>, lastRec);<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L3131" title="access/transam/xlogrecovery.c:3131">ReadRecord</a>(<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>, PANIC, <span class="Constant">false</span>, lastRecTLI);<br/></li>
<li>&nbsp; &nbsp; endOfLog = <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember the TLI in the filename of the XLOG segment containing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end-of-log.&nbsp; It could be different from the timeline that endOfLog<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nominally belongs to, if there was a timeline switch in that segment,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and we were reading the old WAL from a segment belonging to a higher<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;endOfLogTLI = <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;seg.ws_tli;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are no longer in archive recovery state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> done reading the old WAL.&nbsp; Turn off archive fetching if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it was active.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L138" title="access/transam/xlogrecovery.c:138">InArchiveRecovery</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L138" title="access/transam/xlogrecovery.c:138">InArchiveRecovery</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the ending log segment is still open, close it (to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * problems on Windows with trying to rename or delete an open file).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; close(<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the last partial block to the caller, for initializing the WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer for appending new WAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (endOfLog % XLOG_BLCKSZ != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; pageBeginPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageBeginPtr = endOfLog - (endOfLog % XLOG_BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L232" title="access/transam/xlogrecovery.c:232">readOff</a> == XLogSegmentOffset(pageBeginPtr, <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy the valid part of the last block */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; len = endOfLog % XLOG_BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(page, <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;readBuf, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;lastPageBeginPtr = pageBeginPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;lastPage = page;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There is no partial block to copy. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;lastPageBeginPtr = endOfLog;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result-&gt;lastPage = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a comment for the history file to explain why and where timeline<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * changed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;recoveryStopReason = <a href="#L2886" title="access/transam/xlogrecovery.c:2886">getRecoveryStopReason</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;lastRec = lastRec;<br/></li>
<li>&nbsp; &nbsp; result-&gt;lastRecTLI = lastRecTLI;<br/></li>
<li>&nbsp; &nbsp; result-&gt;endOfLog = endOfLog;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;<a href="#L372" title="access/transam/xlogrecovery.c:372">abortedRecPtr</a> = <a href="#L372" title="access/transam/xlogrecovery.c:372">abortedRecPtr</a>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;<a href="#L373" title="access/transam/xlogrecovery.c:373">missingContrecPtr</a> = <a href="#L373" title="access/transam/xlogrecovery.c:373">missingContrecPtr</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;<a href="#L150" title="access/transam/xlogrecovery.c:150">standby_signal_file_found</a> = <a href="#L150" title="access/transam/xlogrecovery.c:150">standby_signal_file_found</a>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;<a href="#L151" title="access/transam/xlogrecovery.c:151">recovery_signal_file_found</a> = <a href="#L151" title="access/transam/xlogrecovery.c:151">recovery_signal_file_found</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Clean up the WAL reader and leftovers from restoring WAL from archive<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1608">&#x200c;</a></span><span class="linkable">ShutdownWalRecovery</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; recoveryPath[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Final update of pg_stat_recovery_prefetch. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xlogprefetcher.c.html#L412" title="access/transam/xlogprefetcher.c:412">XLogPrefetcherComputeStats</a>(<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shut down <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close(<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="xlogreader.c.html#L161" title="access/transam/xlogreader.c:161">XLogReaderFree</a>(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="xlogprefetcher.c.html#L392" title="access/transam/xlogprefetcher.c:392">XLogPrefetcherFree</a>(<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since there might be a partial WAL segment named RECOVERYXLOG, get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rid of it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(recoveryPath, MAXPGPATH, XLOGDIR <span class="Constant">&quot;/RECOVERYXLOG&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unlink(recoveryPath);&nbsp; &nbsp; <span class="Comment">/* ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get rid of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining recovered timeline-history file, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(recoveryPath, MAXPGPATH, XLOGDIR <span class="Constant">&quot;/RECOVERYHISTORY&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unlink(recoveryPath);&nbsp; &nbsp; <span class="Comment">/* ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't need the latch anymore. It's not strictly necessary to disown<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it, but let's do it for the sake of tidiness.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L489" title="storage/ipc/latch.c:489">DisownLatch</a>(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryWakeupLatch);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform WAL recovery.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the system was shut down cleanly, this is never called.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1652">&#x200c;</a></span><span class="linkable">PerformWalRecovery</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecord *record;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; reachedRecoveryTarget = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; replayTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize shared variables for tracking progress of WAL replay, as if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we had just replayed the record <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the REDO location (or the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoint record itself, if it's a shutdown checkpoint).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L169" title="access/transam/xlogrecovery.c:169">RedoStartLSN</a> &lt; <a href="#L167" title="access/transam/xlogrecovery.c:167">CheckPointLoc</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;lastReplayedReadRecPtr = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;lastReplayedEndRecPtr = <a href="#L169" title="access/transam/xlogrecovery.c:169">RedoStartLSN</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;lastReplayedTLI = <a href="#L170" title="access/transam/xlogrecovery.c:170">RedoStartTLI</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;lastReplayedReadRecPtr = <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;ReadRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;lastReplayedEndRecPtr = <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;lastReplayedTLI = <a href="#L168" title="access/transam/xlogrecovery.c:168">CheckPointTLI</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;replayEndRecPtr = <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;lastReplayedEndRecPtr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;replayEndTLI = <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;lastReplayedTLI;<br/></li>
<li>&nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryLastXTime = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;currentChunkStartTime = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryPauseState = RECOVERY_NOT_PAUSED;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Also ensure <a href="#L258" title="access/transam/xlogrecovery.c:258">XLogReceiptTime</a> has a sane value */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L258" title="access/transam/xlogrecovery.c:258">XLogReceiptTime</a> = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Let postmaster know we've started redo <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, so that it can launch the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * archiver if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/pmsignal.c.html#L181" title="storage/ipc/pmsignal.c:181">SendPostmasterSignal</a>(PMSIGNAL_RECOVERY_STARTED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allow read-only connections immediately if we're consistent already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2175" title="access/transam/xlogrecovery.c:2175">CheckRecoveryConsistency</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find the first record that logically follows the checkpoint --- it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might physically precede it, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L169" title="access/transam/xlogrecovery.c:169">RedoStartLSN</a> &lt; <a href="#L167" title="access/transam/xlogrecovery.c:167">CheckPointLoc</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* back up to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; replayTLI = <a href="#L170" title="access/transam/xlogrecovery.c:170">RedoStartTLI</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogprefetcher.c.html#L964" title="access/transam/xlogprefetcher.c:964">XLogPrefetcherBeginRead</a>(<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>, <a href="#L169" title="access/transam/xlogrecovery.c:169">RedoStartLSN</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record = <a href="#L3131" title="access/transam/xlogrecovery.c:3131">ReadRecord</a>(<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>, PANIC, <span class="Constant">false</span>, replayTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a checkpoint record's redo pointer points back to an earlier<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LSN, the record at that LSN should be an XLOG_CHECKPOINT_REDO<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (record-&gt;xl_rmid != RM_XLOG_ID ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (record-&gt;xl_info &amp; ~XLR_INFO_MASK) != XLOG_CHECKPOINT_REDO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected record type found at redo point </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;ReadRecPtr))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just have to read <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> record after CheckPoint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;ReadRecPtr == <a href="#L167" title="access/transam/xlogrecovery.c:167">CheckPointLoc</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; replayTLI = <a href="#L168" title="access/transam/xlogrecovery.c:168">CheckPointTLI</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record = <a href="#L3131" title="access/transam/xlogrecovery.c:3131">ReadRecord</a>(<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>, LOG, <span class="Constant">false</span>, replayTLI);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (record != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz xtime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGRUsage&nbsp; &nbsp; ru0;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/pg_rusage.c.html#L27" title="utils/misc/pg_rusage.c:27">pg_rusage_init</a>(&amp;ru0);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L203" title="access/transam/xlogrecovery.c:203">InRedo</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="rmgr.c.html#L58" title="access/transam/rmgr.c:58">RmgrStartup</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;redo starts at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;ReadRecPtr))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepare to report progress of the redo phase. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L147" title="access/transam/xlogrecovery.c:147">StandbyMode</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/startup.c.html#L343" title="postmaster/startup.c:343">begin_startup_progress_phase</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> redo apply loop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L147" title="access/transam/xlogrecovery.c:147">StandbyMode</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport_startup_progress(<span class="Constant">&quot;redo in progress, elapsed time: </span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%02d</span><span class="Constant"> s, current LSN: </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;ReadRecPtr));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WAL_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlog.c.html#L140" title="access/transam/xlog.c:140">XLOG_DEBUG</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;REDO @ </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">; LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">: &quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;ReadRecPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2318" title="access/transam/xlogrecovery.c:2318">xlog_outrec</a>(&amp;buf, <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot; - &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2297" title="access/transam/xlogrecovery.c:2297">xlog_outdesc</a>(&amp;buf, <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, buf.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle interrupt signals of startup process */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/startup.c.html#L154" title="postmaster/startup.c:154">HandleStartupProcInterrupts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pause WAL replay, if requested by a hot-standby session via<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3090" title="access/transam/xlogrecovery.c:3090">SetRecoveryPause</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we intentionally don't take the info_lck spinlock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here.&nbsp; We might therefore read a slightly stale value of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recoveryPause flag, but it can't be very stale (no worse than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the last spinlock we did acquire).&nbsp; Since a pause request is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pretty asynchronous thing anyway, possibly responding to it one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL record later than we otherwise would is a minor issue, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it doesn't seem worth adding another spinlock cycle to prevent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((<span class="Type">volatile</span> <a href="#L304" title="access/transam/xlogrecovery.c:304">XLogRecoveryCtlData</a> *) <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>)-&gt;recoveryPauseState !=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RECOVERY_NOT_PAUSED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2925" title="access/transam/xlogrecovery.c:2925">recoveryPausesHere</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Have we reached our recovery target?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2573" title="access/transam/xlogrecovery.c:2573">recoveryStopsBefore</a>(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reachedRecoveryTarget = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we've been asked to lag the primary, wait on latch until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enough time has passed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2982" title="access/transam/xlogrecovery.c:2982">recoveryApplyDelay</a>(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We test for paused recovery again here. If user sets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * delayed apply, it may be because they expect to pause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recovery in case of problems, so we must test again here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise pausing during the delay-wait wouldn't work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((<span class="Type">volatile</span> <a href="#L304" title="access/transam/xlogrecovery.c:304">XLogRecoveryCtlData</a> *) <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>)-&gt;recoveryPauseState !=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RECOVERY_NOT_PAUSED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2925" title="access/transam/xlogrecovery.c:2925">recoveryPausesHere</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Apply the record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1908" title="access/transam/xlogrecovery.c:1908">ApplyWalRecord</a>(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>, record, &amp;replayTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Exit loop if we reached inclusive recovery target */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2726" title="access/transam/xlogrecovery.c:2726">recoveryStopsAfter</a>(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reachedRecoveryTarget = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Else, try to fetch the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> WAL record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record = <a href="#L3131" title="access/transam/xlogrecovery.c:3131">ReadRecord</a>(<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>, LOG, <span class="Constant">false</span>, replayTLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (record != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end of <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> redo apply loop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reachedRecoveryTarget)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L294" title="access/transam/xlogrecovery.c:294">reachedConsistency</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested recovery stop point is <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> consistent recovery point&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is the last point where we can restart recovery with a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recovery target, if we shutdown and begin again. After this,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Resource Managers may choose to do permanent corrective actions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at end of recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L87" title="access/transam/xlogrecovery.c:87">recoveryTargetAction</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RECOVERY_TARGET_ACTION_SHUTDOWN:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exit with special return code to request shutdown of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * postmaster.&nbsp; Log messages issued from postmaster.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">3</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RECOVERY_TARGET_ACTION_PAUSE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3090" title="access/transam/xlogrecovery.c:3090">SetRecoveryPause</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2925" title="access/transam/xlogrecovery.c:2925">recoveryPausesHere</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* drop into promote */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RECOVERY_TARGET_ACTION_PROMOTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="rmgr.c.html#L74" title="access/transam/rmgr.c:74">RmgrCleanup</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;redo done at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> system usage: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;ReadRecPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/pg_rusage.c.html#L40" title="utils/misc/pg_rusage.c:40">pg_rusage_show</a>(&amp;ru0))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xtime = <a href="#L4596" title="access/transam/xlogrecovery.c:4596">GetLatestXTime</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xtime)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;last completed transaction was at log time </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1853" title="utils/adt/timestamp.c:1853">timestamptz_to_str</a>(xtime))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L203" title="access/transam/xlogrecovery.c:203">InRedo</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there are no WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> following the checkpoint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;redo is not required&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This check is intentionally after the above log messages that indicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * how far recovery went.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> != RECOVERY_TARGET_UNSET &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !reachedRecoveryTarget)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovery ended <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> configured recovery target was reached&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine of <a href="#L1652" title="access/transam/xlogrecovery.c:1652">PerformWalRecovery</a>, to apply one WAL record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1908">&#x200c;</a></span><span class="linkable">ApplyWalRecord</span>(XLogReaderState *<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>, XLogRecord *record, TimeLineID *replayTLI)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; switchedTLI = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Setup error traceback support for ereport() */<br/></li>
<li></span>&nbsp; &nbsp; errcallback.callback = <a href="#L2275" title="access/transam/xlogrecovery.c:2275">rm_redo_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = (<span class="Type">void</span> *) <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid must be beyond record's xid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="varsup.c.html#L304" title="access/transam/varsup.c:304">AdvanceNextFullTransactionIdPastXid</a>(record-&gt;xl_xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Before replaying this record, check if this record causes the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timeline to change. The record is already considered to be part of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new timeline, so we update replayTLI <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> replaying it. That's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * important so that replayEndTLI, which is recorded as the minimum<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery point's TLI if recovery stops after this record, is set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * correctly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (record-&gt;xl_rmid == RM_XLOG_ID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeLineID&nbsp; &nbsp; newReplayTLI = *replayTLI;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeLineID&nbsp; &nbsp; prevReplayTLI = *replayTLI;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = record-&gt;xl_info &amp; ~XLR_INFO_MASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (info == XLOG_CHECKPOINT_SHUTDOWN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CheckPoint&nbsp; &nbsp; checkPoint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;checkPoint, XLogRecGetData(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CheckPoint));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newReplayTLI = checkPoint.ThisTimeLineID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevReplayTLI = checkPoint.PrevTimeLineID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_END_OF_RECOVERY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_end_of_recovery xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;xlrec, XLogRecGetData(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_end_of_recovery));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newReplayTLI = xlrec.ThisTimeLineID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevReplayTLI = xlrec.PrevTimeLineID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newReplayTLI != *replayTLI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check that it's OK to switch to this TLI */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2377" title="access/transam/xlogrecovery.c:2377">checkTimeLineSwitch</a>(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newReplayTLI, prevReplayTLI, *replayTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Following WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> should be run with new TLI */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *replayTLI = newReplayTLI;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; switchedTLI = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update shared replayEndRecPtr <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> replaying this record, so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a> will update <a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> correctly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;replayEndRecPtr = <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;replayEndTLI = *replayTLI;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are attempting to enter Hot Standby mode, process XIDs we see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> &gt;= STANDBY_INITIALIZED &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionIdIsValid(record-&gt;xl_xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L4387" title="storage/ipc/procarray.c:4387">RecordKnownAssignedTransactionIds</a>(record-&gt;xl_xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some XLOG record types that are related to recovery are processed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * directly here, rather than in <a href="xlog.c.html#L8156" title="access/transam/xlog.c:8156">xlog_redo</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (record-&gt;xl_rmid == RM_XLOG_ID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2072" title="access/transam/xlogrecovery.c:2072">xlogrecovery_redo</a>(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>, *replayTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now apply the WAL record itself */<br/></li>
<li></span>&nbsp; &nbsp; GetRmgr(record-&gt;xl_rmid).rm_redo(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * After redo, check whether the backup pages associated with the WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record are consistent with the existing pages. This check is done only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if consistency check is enabled for this record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((record-&gt;xl_info &amp; XLR_CHECK_CONSISTENCY) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2461" title="access/transam/xlogrecovery.c:2461">verifyBackupPageConsistency</a>(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update lastReplayedEndRecPtr after this record has been successfully<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replayed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;lastReplayedReadRecPtr = <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;ReadRecPtr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;lastReplayedEndRecPtr = <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;lastReplayedTLI = *replayTLI;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Wakeup walsenders:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On the standby, the WAL is flushed first (which will only wake up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * physical walsenders) and then applied, which will only wake up logical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * walsenders.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Indeed, logical walsenders on standby can't decode and <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> data until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's been applied.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Physical walsenders don't need to be woken up during replay unless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cascading replication is allowed and time line change occurred (so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they can notice that they are on a new time line).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * That's why the wake up conditions are for:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; - physical walsenders in case of new time line and cascade<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; replication is allowed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; - logical walsenders in case cascade replication is allowed (could not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; be created otherwise)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (AllowCascadeReplication())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/walsender.c.html#L3666" title="replication/walsender.c:3666">WalSndWakeup</a>(switchedTLI, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If rm_redo called <a href="#L4487" title="access/transam/xlogrecovery.c:4487">XLogRequestWalReceiverReply</a>, then we wake up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * receiver so that it notices the updated lastReplayedEndRecPtr and sends<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a reply to the primary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L185" title="access/transam/xlogrecovery.c:185">doRequestWalReceiverReply</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L185" title="access/transam/xlogrecovery.c:185">doRequestWalReceiverReply</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/walreceiver.c.html#L1358" title="replication/walreceiver.c:1358">WalRcvForceReply</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allow read-only connections if we're consistent <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2175" title="access/transam/xlogrecovery.c:2175">CheckRecoveryConsistency</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Is this a timeline switch? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (switchedTLI)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before we continue on the new timeline, clean up <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> (possibly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bogus) future WAL segments on the old timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L3929" title="access/transam/xlog.c:3929">RemoveNonParentXlogFiles</a>(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr, *replayTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset the prefetcher. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogprefetcher.c.html#L340" title="access/transam/xlogprefetcher.c:340">XLogPrefetchReconfigure</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Some XLOG RM record types that are directly related to WAL recovery are<br/></li>
<li></span><span class="Comment"> * handled here rather than in the <a href="xlog.c.html#L8156" title="access/transam/xlog.c:8156">xlog_redo</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2072">&#x200c;</a></span><span class="linkable">xlogrecovery_redo</span>(XLogReaderState *record, TimeLineID replayTLI)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(record) &amp; ~XLR_INFO_MASK;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(XLogRecGetRmid(record) == RM_XLOG_ID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (info == XLOG_OVERWRITE_CONTRECORD)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Verify the payload of a XLOG_OVERWRITE_CONTRECORD record. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xl_overwrite_contrecord xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;xlrec, XLogRecGetData(record), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_overwrite_contrecord));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec.overwritten_lsn != record-&gt;overwrittenRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;mismatching overwritten LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> -&gt; </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(xlrec.overwritten_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(record-&gt;overwrittenRecPtr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have safely skipped the aborted record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L372" title="access/transam/xlogrecovery.c:372">abortedRecPtr</a> = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L373" title="access/transam/xlogrecovery.c:373">missingContrecPtr</a> = InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;successfully skipped missing contrecord at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, overwritten at </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(xlrec.overwritten_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1853" title="utils/adt/timestamp.c:1853">timestamptz_to_str</a>(xlrec.overwrite_time))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Verifying the record should only happen once */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; record-&gt;overwrittenRecPtr = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_BACKUP_END)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; startpoint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;startpoint, XLogRecGetData(record), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(startpoint));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L281" title="access/transam/xlogrecovery.c:281">backupStartPoint</a> == startpoint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have reached the end of base backup, the point where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="xlogfuncs.c.html#L123" title="access/transam/xlogfuncs.c:123">pg_backup_stop</a>() was done.&nbsp; The data on disk is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> consistent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (assuming we have also reached <a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>).&nbsp; Set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L282" title="access/transam/xlogrecovery.c:282">backupEndPoint</a> to the current LSN, so that the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2175" title="access/transam/xlogrecovery.c:2175">CheckRecoveryConsistency</a>() will notice it and do the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end-of-backup processing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;end of backup record reached&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L282" title="access/transam/xlogrecovery.c:282">backupEndPoint</a> = lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;saw end-of-backup record for backup starting at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(startpoint), LSN_FORMAT_ARGS(<a href="#L281" title="access/transam/xlogrecovery.c:281">backupStartPoint</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Verify that, in non-test mode, ./pg_tblspc doesn't contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> real<br/></li>
<li></span><span class="Comment"> * directories.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Replay of database creation XLOG <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> for databases that were later<br/></li>
<li></span><span class="Comment"> * dropped can create fake directories in pg_tblspc.&nbsp; By the time consistency<br/></li>
<li></span><span class="Comment"> * is reached these directories should have been removed; here we verify<br/></li>
<li></span><span class="Comment"> * that this did indeed happen.&nbsp; This is to be called at the point where<br/></li>
<li></span><span class="Comment"> * consistent state is reached.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../commands/tablespace.c.html#L85" title="commands/tablespace.c:85">allow_in_place_tablespaces</a> turns the PANIC into a WARNING, which is<br/></li>
<li></span><span class="Comment"> * useful for testing purposes, and also allows for an escape hatch in case<br/></li>
<li></span><span class="Comment"> * things go south.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2143">&#x200c;</a></span><span class="linkable">CheckTablespaceDirectory</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *de;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dir = <a href="../../storage/file/fd.c.html#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(<span class="Constant">&quot;pg_tblspc&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((de = <a href="../../storage/file/fd.c.html#L2909" title="storage/file/fd.c:2909">ReadDir</a>(dir, <span class="Constant">&quot;pg_tblspc&quot;</span>)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH + <span class="Constant">10</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip entries of non-oid names */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strspn(de-&gt;d_name, <span class="Constant">&quot;0123456789&quot;</span>) != strlen(de-&gt;d_name))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(path, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(path), <span class="Constant">&quot;pg_tblspc/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, de-&gt;d_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (get_dirent_type(path, de, <span class="Constant">false</span>, ERROR) != PGFILETYPE_LNK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(<a href="../../commands/tablespace.c.html#L85" title="commands/tablespace.c:85">allow_in_place_tablespaces</a> ? WARNING : PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected directory entry </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> found in </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; de-&gt;d_name, <span class="Constant">&quot;pg_tblspc/&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;All directory entries in pg_tblspc/ should be symbolic links.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Remove those directories, or set <a href="../../commands/tablespace.c.html#L85" title="commands/tablespace.c:85">allow_in_place_tablespaces</a> to ON transiently to let recovery complete.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Checks if recovery has reached a consistent state. When consistency is<br/></li>
<li></span><span class="Comment"> * reached and we have a valid starting standby snapshot, tell postmaster<br/></li>
<li></span><span class="Comment"> * that it can start accepting read-only connections.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2175">&#x200c;</a></span><span class="linkable">CheckRecoveryConsistency</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lastReplayedEndRecPtr;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; lastReplayedTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During crash recovery, we don't reach a consistent state until we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replayed all the WAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(<a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L138" title="access/transam/xlogrecovery.c:138">InArchiveRecovery</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume that we are called in the startup process, and hence don't need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a lock to read lastReplayedEndRecPtr<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lastReplayedEndRecPtr = <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;lastReplayedEndRecPtr;<br/></li>
<li>&nbsp; &nbsp; lastReplayedTLI = <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;lastReplayedTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Have we reached the point where our base backup was completed?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(<a href="#L282" title="access/transam/xlogrecovery.c:282">backupEndPoint</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L282" title="access/transam/xlogrecovery.c:282">backupEndPoint</a> &lt;= lastReplayedEndRecPtr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; saveBackupStartPoint = <a href="#L281" title="access/transam/xlogrecovery.c:281">backupStartPoint</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; saveBackupEndPoint = <a href="#L282" title="access/transam/xlogrecovery.c:282">backupEndPoint</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;end of backup reached&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have reached the end of base backup, as indicated by pg_control.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update the control file accordingly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L6203" title="access/transam/xlog.c:6203">ReachedEndOfBackup</a>(lastReplayedEndRecPtr, lastReplayedTLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L281" title="access/transam/xlogrecovery.c:281">backupStartPoint</a> = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L282" title="access/transam/xlogrecovery.c:282">backupEndPoint</a> = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L283" title="access/transam/xlogrecovery.c:283">backupEndRequired</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;completed backup recovery with redo LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> and end LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(saveBackupStartPoint),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(saveBackupEndPoint))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Have we passed our safe starting point? Note that <a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * known to be incorrectly set if recovering from a backup, until the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLOG_BACKUP_END arrives to advise us of the correct <a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All we know prior to that is that we're not consistent yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L294" title="access/transam/xlogrecovery.c:294">reachedConsistency</a> &amp;&amp; !<a href="#L283" title="access/transam/xlogrecovery.c:283">backupEndRequired</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> &lt;= lastReplayedEndRecPtr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check to see if the XLOG sequence contained <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unresolved<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * references to uninitialized pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogutils.c.html#L245" title="access/transam/xlogutils.c:245">XLogCheckInvalidPages</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that pg_tblspc doesn't contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> real directories. Replay<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of Database/CREATE_* <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> may have created fictitious tablespace<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * directories that should have been removed by the time consistency<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * was reached.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2143" title="access/transam/xlogrecovery.c:2143">CheckTablespaceDirectory</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L294" title="access/transam/xlogrecovery.c:294">reachedConsistency</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;consistent recovery state reached at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(lastReplayedEndRecPtr))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Have we got a valid starting snapshot that will allow queries to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * run? If so, we can tell postmaster that the database is consistent <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enabling connections.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> == STANDBY_SNAPSHOT_READY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L176" title="access/transam/xlogrecovery.c:176">LocalHotStandbyActive</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L294" title="access/transam/xlogrecovery.c:294">reachedConsistency</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;SharedHotStandbyActive = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L176" title="access/transam/xlogrecovery.c:176">LocalHotStandbyActive</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/pmsignal.c.html#L181" title="storage/ipc/pmsignal.c:181">SendPostmasterSignal</a>(PMSIGNAL_BEGIN_HOT_STANDBY);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Error context callback for errors occurring during rm_redo().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2275">&#x200c;</a></span><span class="linkable">rm_redo_error_callback</span>(<span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogReaderState *record = (XLogReaderState *) arg;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; <a href="#L2297" title="access/transam/xlogrecovery.c:2297">xlog_outdesc</a>(&amp;buf, record);<br/></li>
<li>&nbsp; &nbsp; <a href="#L2336" title="access/transam/xlogrecovery.c:2336">xlog_block_info</a>(&amp;buf, record);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* translator: %s is a WAL record description */<br/></li>
<li></span>&nbsp; &nbsp; errcontext(<span class="Constant">&quot;WAL redo at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> for </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(record-&gt;ReadRecPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buf.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns a string describing an XLogRecord, consisting of its identity<br/></li>
<li></span><span class="Comment"> * optionally followed by a colon, a space, and a further description.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2297">&#x200c;</a></span><span class="linkable">xlog_outdesc</span>(StringInfo buf, XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RmgrData&nbsp; &nbsp; rmgr = GetRmgr(XLogRecGetRmid(record));<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(record);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(buf, rmgr.rm_name);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(buf, <span class="Constant">'/'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; id = rmgr.rm_identify(info);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (id == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;UNKNOWN (</span><span class="Special">%X</span><span class="Constant">): &quot;</span>, info &amp; ~XLR_INFO_MASK);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: &quot;</span>, id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rmgr.rm_desc(buf, record);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WAL_DEBUG<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2318">&#x200c;</a></span><span class="linkable">xlog_outrec</span>(StringInfo buf, XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;prev </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">; xid </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(XLogRecGetPrev(record)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecGetXid(record));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;; len </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecGetDataLen(record));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2336" title="access/transam/xlogrecovery.c:2336">xlog_block_info</a>(buf, record);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WAL_DEBUG */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns a string giving information about all the blocks in an<br/></li>
<li></span><span class="Comment"> * XLogRecord.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2336">&#x200c;</a></span><span class="linkable">xlog_block_info</span>(StringInfo buf, XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* decode block references */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (block_id = <span class="Constant">0</span>; block_id &lt;= XLogRecMaxBlockId(record); block_id++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forknum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="xlogreader.c.html#L1997" title="access/transam/xlogreader.c:1997">XLogRecGetBlockTagExtended</a>(record, block_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;rlocator, &amp;forknum, &amp;blk, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (forknum != MAIN_FORKNUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;; blkref #</span><span class="Special">%d</span><span class="Constant">: rel </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">, fork </span><span class="Special">%u</span><span class="Constant">, blk </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; block_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rlocator.spcOid, rlocator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rlocator.relNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(buf, <span class="Constant">&quot;; blkref #</span><span class="Special">%d</span><span class="Constant">: rel </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">, blk </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; block_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rlocator.spcOid, rlocator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rlocator.relNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecHasBlockImage(record, block_id))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(buf, <span class="Constant">&quot; FPW&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check that it's OK to switch to new timeline during recovery.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'lsn' is the address of the shutdown checkpoint record we're about to<br/></li>
<li></span><span class="Comment"> * replay. (Currently, timeline can only change at a shutdown checkpoint).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2377">&#x200c;</a></span><span class="linkable">checkTimeLineSwitch</span>(XLogRecPtr lsn, TimeLineID newTLI, TimeLineID prevTLI,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID replayTLI)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that the record agrees on what the current (old) timeline is */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (prevTLI != replayTLI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected previous timeline ID </span><span class="Special">%u</span><span class="Constant"> (current timeline ID </span><span class="Special">%u</span><span class="Constant">) in checkpoint record&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevTLI, replayTLI)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The new timeline better be in the list of timelines we expect to see,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * according to the timeline history. It should also not decrease.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newTLI &lt; replayTLI || !<a href="timeline.c.html#L526" title="access/transam/timeline.c:526">tliInHistory</a>(newTLI, <a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected timeline ID </span><span class="Special">%u</span><span class="Constant"> (after </span><span class="Special">%u</span><span class="Constant">) in checkpoint record&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newTLI, replayTLI)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have not yet reached min recovery point, and we're about to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * switch to a timeline greater than the timeline of the min recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point: trouble. After switching to the new timeline, we could not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibly visit the min recovery point on the correct timeline anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This can happen if there is a newer timeline in the archive that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * branched <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the timeline the min recovery point is on, and you<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attempt to do PITR to the new timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(<a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lsn &lt; <a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newTLI &gt; <a href="#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected timeline ID </span><span class="Special">%u</span><span class="Constant"> in checkpoint record, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> reaching minimum recovery point </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> on timeline </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newTLI,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Looks good */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract timestamp from WAL record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the record contains a timestamp, returns true, and saves the timestamp<br/></li>
<li></span><span class="Comment"> * in *recordXtime. If the record type has no timestamp, returns false.<br/></li>
<li></span><span class="Comment"> * Currently, only transaction commit/abort <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> and restore points contain<br/></li>
<li></span><span class="Comment"> * timestamps.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2426">&#x200c;</a></span><span class="linkable">getRecordTimestamp</span>(XLogReaderState *record, TimestampTz *recordXtime)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(record) &amp; ~XLR_INFO_MASK;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; xact_info = info &amp; XLOG_XACT_OPMASK;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; rmid = XLogRecGetRmid(record);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rmid == RM_XLOG_ID &amp;&amp; info == XLOG_RESTORE_POINT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *recordXtime = ((xl_restore_point *) XLogRecGetData(record))-&gt;rp_time;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rmid == RM_XACT_ID &amp;&amp; (xact_info == XLOG_XACT_COMMIT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xact_info == XLOG_XACT_COMMIT_PREPARED))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *recordXtime = ((xl_xact_commit *) XLogRecGetData(record))-&gt;xact_time;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rmid == RM_XACT_ID &amp;&amp; (xact_info == XLOG_XACT_ABORT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xact_info == XLOG_XACT_ABORT_PREPARED))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *recordXtime = ((xl_xact_abort *) XLogRecGetData(record))-&gt;xact_time;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Checks whether the current buffer page and backup page stored in the<br/></li>
<li></span><span class="Comment"> * WAL record are consistent or not. Before comparing the two pages, a<br/></li>
<li></span><span class="Comment"> * masking can be applied to the pages to ignore certain areas like hint bits,<br/></li>
<li></span><span class="Comment"> * unused space between pd_lower and pd_upper among other things. This<br/></li>
<li></span><span class="Comment"> * function should be called once WAL replay has been completed for a<br/></li>
<li></span><span class="Comment"> * given record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2461">&#x200c;</a></span><span class="linkable">verifyBackupPageConsistency</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RmgrData&nbsp; &nbsp; rmgr = GetRmgr(XLogRecGetRmid(record));<br/></li>
<li>&nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li>&nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forknum;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Records with no backup blocks have no need for consistency checks. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecHasAnyBlockRefs(record))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert((XLogRecGetInfo(record) &amp; XLR_CHECK_CONSISTENCY) != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (block_id = <span class="Constant">0</span>; block_id &lt;= XLogRecMaxBlockId(record); block_id++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="xlogreader.c.html#L1997" title="access/transam/xlogreader.c:1997">XLogRecGetBlockTagExtended</a>(record, block_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;rlocator, &amp;forknum, &amp;blkno, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL record doesn't contain a block reference with the given id.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do nothing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(XLogRecHasBlockImage(record, block_id));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecBlockImageApply(record, block_id))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL record has already applied the page, so bypass the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consistency check as that would result in comparing the full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page stored in the record with itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Read the contents from the current buffer and store it in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * temporary page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="xlogutils.c.html#L471" title="access/transam/xlogutils.c:471">XLogReadBufferExtended</a>(rlocator, forknum, blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RBM_NORMAL_NO_LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidBuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Take a copy of the local page where WAL has been applied to have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comparison base <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> masking it...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(<a href="#L297" title="access/transam/xlogrecovery.c:297">replay_image_masked</a>, page, BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No need for this page anymore <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that a copy is in. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the block LSN is already ahead of this WAL record, we can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expect contents to match.&nbsp; This can happen if recovery is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * restarted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageGetLSN(<a href="#L297" title="access/transam/xlogrecovery.c:297">replay_image_masked</a>) &gt; record-&gt;EndRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Read the contents from the backup copy, stored in WAL record and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * store it in a temporary page. There is no need to allocate a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page here, a local buffer is fine to hold its contents and a mask<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can be directly applied on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="xlogreader.c.html#L2056" title="access/transam/xlogreader.c:2056">RestoreBlockImage</a>(record, block_id, <a href="#L298" title="access/transam/xlogrecovery.c:298">primary_image_masked</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERNAL_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, record-&gt;errormsg_buf)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If masking function is defined, mask both the primary and replay<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * images<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rmgr.rm_mask != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rmgr.rm_mask(<a href="#L297" title="access/transam/xlogrecovery.c:297">replay_image_masked</a>, blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rmgr.rm_mask(<a href="#L298" title="access/transam/xlogrecovery.c:298">primary_image_masked</a>, blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Time to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the primary and replay images. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (memcmp(<a href="#L297" title="access/transam/xlogrecovery.c:297">replay_image_masked</a>, <a href="#L298" title="access/transam/xlogrecovery.c:298">primary_image_masked</a>, BLCKSZ) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;inconsistent page found, rel </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">, forknum </span><span class="Special">%u</span><span class="Constant">, blkno </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rlocator.spcOid, rlocator.dbOid, rlocator.relNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; forknum, blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * For point-in-time recovery, this function decides whether we want to<br/></li>
<li></span><span class="Comment"> * stop applying the XLOG <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the current record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if we are stopping, false otherwise. If stopping, some<br/></li>
<li></span><span class="Comment"> * information is saved in <a href="#L379" title="access/transam/xlogrecovery.c:379">recoveryStopXid</a> et al for use in annotating the<br/></li>
<li></span><span class="Comment"> * new timeline's history file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2573">&#x200c;</a></span><span class="linkable">recoveryStopsBefore</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; stopsHere = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; xact_info;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isCommit;<br/></li>
<li>&nbsp; &nbsp; TimestampTz recordXtime = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; TransactionId recordXid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ignore recovery target settings when not in archive recovery (meaning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we are in crash recovery).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if we should stop as soon as reaching consistency */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> == RECOVERY_TARGET_IMMEDIATE &amp;&amp; <a href="#L294" title="access/transam/xlogrecovery.c:294">reachedConsistency</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovery stopping after reaching consistency&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L383" title="access/transam/xlogrecovery.c:383">recoveryStopAfter</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L379" title="access/transam/xlogrecovery.c:379">recoveryStopXid</a> = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L381" title="access/transam/xlogrecovery.c:381">recoveryStopLSN</a> = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L380" title="access/transam/xlogrecovery.c:380">recoveryStopTime</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L382" title="access/transam/xlogrecovery.c:382">recoveryStopName</a>[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if target LSN has been reached */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> == RECOVERY_TARGET_LSN &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L86" title="access/transam/xlogrecovery.c:86">recoveryTargetInclusive</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record-&gt;ReadRecPtr &gt;= <a href="#L92" title="access/transam/xlogrecovery.c:92">recoveryTargetLSN</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L383" title="access/transam/xlogrecovery.c:383">recoveryStopAfter</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L379" title="access/transam/xlogrecovery.c:379">recoveryStopXid</a> = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L381" title="access/transam/xlogrecovery.c:381">recoveryStopLSN</a> = record-&gt;ReadRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L380" title="access/transam/xlogrecovery.c:380">recoveryStopTime</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L382" title="access/transam/xlogrecovery.c:382">recoveryStopName</a>[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovery stopping <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> WAL location (LSN) </span><span class="Special">\&quot;%X</span><span class="Constant">/</span><span class="Special">%X\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="#L381" title="access/transam/xlogrecovery.c:381">recoveryStopLSN</a>))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise we only consider stopping <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> COMMIT or ABORT <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (XLogRecGetRmid(record) != RM_XACT_ID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xact_info = XLogRecGetInfo(record) &amp; XLOG_XACT_OPMASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xact_info == XLOG_XACT_COMMIT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isCommit = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recordXid = XLogRecGetXid(record);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (xact_info == XLOG_XACT_COMMIT_PREPARED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xact_commit *xlrec = (xl_xact_commit *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xact_parsed_commit parsed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isCommit = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../rmgrdesc/xactdesc.c.html#L35" title="access/rmgrdesc/xactdesc.c:35">ParseCommitRecord</a>(XLogRecGetInfo(record),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;parsed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recordXid = parsed.twophase_xid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (xact_info == XLOG_XACT_ABORT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isCommit = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recordXid = XLogRecGetXid(record);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (xact_info == XLOG_XACT_ABORT_PREPARED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xact_abort *xlrec = (xl_xact_abort *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xact_parsed_abort parsed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isCommit = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../rmgrdesc/xactdesc.c.html#L141" title="access/rmgrdesc/xactdesc.c:141">ParseAbortRecord</a>(XLogRecGetInfo(record),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;parsed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recordXid = parsed.twophase_xid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> == RECOVERY_TARGET_XID &amp;&amp; !<a href="#L86" title="access/transam/xlogrecovery.c:86">recoveryTargetInclusive</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There can be only one transaction end record with this exact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactionid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when testing for an xid, we MUST test for equality only, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions are numbered in the order they start, not the order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they complete. A higher numbered xid will complete <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> you about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 50% of the time...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stopsHere = (recordXid == <a href="#L88" title="access/transam/xlogrecovery.c:88">recoveryTargetXid</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we must fetch recordXtime regardless of <a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> setting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't expect <a href="#L2426" title="access/transam/xlogrecovery.c:2426">getRecordTimestamp</a> ever to fail, since we already know<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this is a commit or abort record; but test its result anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2426" title="access/transam/xlogrecovery.c:2426">getRecordTimestamp</a>(record, &amp;recordXtime) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> == RECOVERY_TARGET_TIME)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There can be many transactions that share the same commit time, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we stop after the last one, if we are inclusive, or stop at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first one if we are exclusive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L86" title="access/transam/xlogrecovery.c:86">recoveryTargetInclusive</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stopsHere = (recordXtime &gt; <a href="#L90" title="access/transam/xlogrecovery.c:90">recoveryTargetTime</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stopsHere = (recordXtime &gt;= <a href="#L90" title="access/transam/xlogrecovery.c:90">recoveryTargetTime</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stopsHere)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L383" title="access/transam/xlogrecovery.c:383">recoveryStopAfter</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L379" title="access/transam/xlogrecovery.c:379">recoveryStopXid</a> = recordXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L380" title="access/transam/xlogrecovery.c:380">recoveryStopTime</a> = recordXtime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L381" title="access/transam/xlogrecovery.c:381">recoveryStopLSN</a> = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L382" title="access/transam/xlogrecovery.c:382">recoveryStopName</a>[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovery stopping <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> commit of transaction </span><span class="Special">%u</span><span class="Constant">, time </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L379" title="access/transam/xlogrecovery.c:379">recoveryStopXid</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1853" title="utils/adt/timestamp.c:1853">timestamptz_to_str</a>(<a href="#L380" title="access/transam/xlogrecovery.c:380">recoveryStopTime</a>))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovery stopping <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> abort of transaction </span><span class="Special">%u</span><span class="Constant">, time </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L379" title="access/transam/xlogrecovery.c:379">recoveryStopXid</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1853" title="utils/adt/timestamp.c:1853">timestamptz_to_str</a>(<a href="#L380" title="access/transam/xlogrecovery.c:380">recoveryStopTime</a>))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stopsHere;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Same as <a href="#L2573" title="access/transam/xlogrecovery.c:2573">recoveryStopsBefore</a>, but called after applying the record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also track the timestamp of the latest applied COMMIT/ABORT<br/></li>
<li></span><span class="Comment"> * record in <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryLastXTime.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2726">&#x200c;</a></span><span class="linkable">recoveryStopsAfter</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; xact_info;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; rmid;<br/></li>
<li>&nbsp; &nbsp; TimestampTz recordXtime = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ignore recovery target settings when not in archive recovery (meaning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we are in crash recovery).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; info = XLogRecGetInfo(record) &amp; ~XLR_INFO_MASK;<br/></li>
<li>&nbsp; &nbsp; rmid = XLogRecGetRmid(record);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There can be many restore points that share the same name; we stop at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the first one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> == RECOVERY_TARGET_NAME &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rmid == RM_XLOG_ID &amp;&amp; info == XLOG_RESTORE_POINT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_restore_point *recordRestorePointData;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recordRestorePointData = (xl_restore_point *) XLogRecGetData(record);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(recordRestorePointData-&gt;rp_name, <a href="#L91" title="access/transam/xlogrecovery.c:91">recoveryTargetName</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L383" title="access/transam/xlogrecovery.c:383">recoveryStopAfter</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L379" title="access/transam/xlogrecovery.c:379">recoveryStopXid</a> = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L381" title="access/transam/xlogrecovery.c:381">recoveryStopLSN</a> = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L2426" title="access/transam/xlogrecovery.c:2426">getRecordTimestamp</a>(record, &amp;<a href="#L380" title="access/transam/xlogrecovery.c:380">recoveryStopTime</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strlcpy(<a href="#L382" title="access/transam/xlogrecovery.c:382">recoveryStopName</a>, recordRestorePointData-&gt;rp_name, MAXFNAMELEN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovery stopping at restore point </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, time </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L382" title="access/transam/xlogrecovery.c:382">recoveryStopName</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1853" title="utils/adt/timestamp.c:1853">timestamptz_to_str</a>(<a href="#L380" title="access/transam/xlogrecovery.c:380">recoveryStopTime</a>))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if the target LSN has been reached */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> == RECOVERY_TARGET_LSN &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L86" title="access/transam/xlogrecovery.c:86">recoveryTargetInclusive</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record-&gt;ReadRecPtr &gt;= <a href="#L92" title="access/transam/xlogrecovery.c:92">recoveryTargetLSN</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L383" title="access/transam/xlogrecovery.c:383">recoveryStopAfter</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L379" title="access/transam/xlogrecovery.c:379">recoveryStopXid</a> = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L381" title="access/transam/xlogrecovery.c:381">recoveryStopLSN</a> = record-&gt;ReadRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L380" title="access/transam/xlogrecovery.c:380">recoveryStopTime</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L382" title="access/transam/xlogrecovery.c:382">recoveryStopName</a>[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovery stopping after WAL location (LSN) </span><span class="Special">\&quot;%X</span><span class="Constant">/</span><span class="Special">%X\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="#L381" title="access/transam/xlogrecovery.c:381">recoveryStopLSN</a>))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rmid != RM_XACT_ID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xact_info = info &amp; XLOG_XACT_OPMASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xact_info == XLOG_XACT_COMMIT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xact_info == XLOG_XACT_COMMIT_PREPARED ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xact_info == XLOG_XACT_ABORT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xact_info == XLOG_XACT_ABORT_PREPARED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId recordXid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update the last applied transaction timestamp */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2426" title="access/transam/xlogrecovery.c:2426">getRecordTimestamp</a>(record, &amp;recordXtime))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4585" title="access/transam/xlogrecovery.c:4585">SetLatestXTime</a>(recordXtime);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract the XID of the committed/aborted transaction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xact_info == XLOG_XACT_COMMIT_PREPARED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_xact_commit *xlrec = (xl_xact_commit *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_xact_parsed_commit parsed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../rmgrdesc/xactdesc.c.html#L35" title="access/rmgrdesc/xactdesc.c:35">ParseCommitRecord</a>(XLogRecGetInfo(record),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;parsed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recordXid = parsed.twophase_xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (xact_info == XLOG_XACT_ABORT_PREPARED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_xact_abort *xlrec = (xl_xact_abort *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_xact_parsed_abort parsed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../rmgrdesc/xactdesc.c.html#L141" title="access/rmgrdesc/xactdesc.c:141">ParseAbortRecord</a>(XLogRecGetInfo(record),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;parsed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recordXid = parsed.twophase_xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recordXid = XLogRecGetXid(record);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There can be only one transaction end record with this exact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactionid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when testing for an xid, we MUST test for equality only, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions are numbered in the order they start, not the order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they complete. A higher numbered xid will complete <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> you about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 50% of the time...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> == RECOVERY_TARGET_XID &amp;&amp; <a href="#L86" title="access/transam/xlogrecovery.c:86">recoveryTargetInclusive</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recordXid == <a href="#L88" title="access/transam/xlogrecovery.c:88">recoveryTargetXid</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L383" title="access/transam/xlogrecovery.c:383">recoveryStopAfter</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L379" title="access/transam/xlogrecovery.c:379">recoveryStopXid</a> = recordXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L380" title="access/transam/xlogrecovery.c:380">recoveryStopTime</a> = recordXtime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L381" title="access/transam/xlogrecovery.c:381">recoveryStopLSN</a> = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L382" title="access/transam/xlogrecovery.c:382">recoveryStopName</a>[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xact_info == XLOG_XACT_COMMIT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xact_info == XLOG_XACT_COMMIT_PREPARED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovery stopping after commit of transaction </span><span class="Special">%u</span><span class="Constant">, time </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L379" title="access/transam/xlogrecovery.c:379">recoveryStopXid</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1853" title="utils/adt/timestamp.c:1853">timestamptz_to_str</a>(<a href="#L380" title="access/transam/xlogrecovery.c:380">recoveryStopTime</a>))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (xact_info == XLOG_XACT_ABORT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xact_info == XLOG_XACT_ABORT_PREPARED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovery stopping after abort of transaction </span><span class="Special">%u</span><span class="Constant">, time </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L379" title="access/transam/xlogrecovery.c:379">recoveryStopXid</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1853" title="utils/adt/timestamp.c:1853">timestamptz_to_str</a>(<a href="#L380" title="access/transam/xlogrecovery.c:380">recoveryStopTime</a>))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if we should stop as soon as reaching consistency */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> == RECOVERY_TARGET_IMMEDIATE &amp;&amp; <a href="#L294" title="access/transam/xlogrecovery.c:294">reachedConsistency</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovery stopping after reaching consistency&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L383" title="access/transam/xlogrecovery.c:383">recoveryStopAfter</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L379" title="access/transam/xlogrecovery.c:379">recoveryStopXid</a> = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L380" title="access/transam/xlogrecovery.c:380">recoveryStopTime</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L381" title="access/transam/xlogrecovery.c:381">recoveryStopLSN</a> = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L382" title="access/transam/xlogrecovery.c:382">recoveryStopName</a>[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a comment for the history file to explain why and where<br/></li>
<li></span><span class="Comment"> * timeline changed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L2886">&#x200c;</a><span class="linkable">getRecoveryStopReason</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; reason[<span class="Constant">200</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> == RECOVERY_TARGET_XID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(reason, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(reason),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L383" title="access/transam/xlogrecovery.c:383">recoveryStopAfter</a> ? <span class="Constant">&quot;after&quot;</span> : <span class="Constant">&quot;<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L379" title="access/transam/xlogrecovery.c:379">recoveryStopXid</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> == RECOVERY_TARGET_TIME)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(reason, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(reason),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L383" title="access/transam/xlogrecovery.c:383">recoveryStopAfter</a> ? <span class="Constant">&quot;after&quot;</span> : <span class="Constant">&quot;<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/adt/timestamp.c.html#L1853" title="utils/adt/timestamp.c:1853">timestamptz_to_str</a>(<a href="#L380" title="access/transam/xlogrecovery.c:380">recoveryStopTime</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> == RECOVERY_TARGET_LSN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(reason, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(reason),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L383" title="access/transam/xlogrecovery.c:383">recoveryStopAfter</a> ? <span class="Constant">&quot;after&quot;</span> : <span class="Constant">&quot;<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="#L381" title="access/transam/xlogrecovery.c:381">recoveryStopLSN</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> == RECOVERY_TARGET_NAME)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(reason, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(reason),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;at restore point </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L382" title="access/transam/xlogrecovery.c:382">recoveryStopName</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> == RECOVERY_TARGET_IMMEDIATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(reason, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(reason), <span class="Constant">&quot;reached consistency&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(reason, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(reason), <span class="Constant">&quot;no recovery target specified&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(reason);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait until shared recoveryPauseState is set to RECOVERY_NOT_PAUSED.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * endOfRecovery is true if the recovery target is reached and<br/></li>
<li></span><span class="Comment"> * the paused state starts at the end of recovery because of<br/></li>
<li></span><span class="Comment"> * recovery_target_action=pause, and false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2925">&#x200c;</a></span><span class="linkable">recoveryPausesHere</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> endOfRecovery)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't pause unless users can <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a>! */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L176" title="access/transam/xlogrecovery.c:176">LocalHotStandbyActive</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't pause after standby promotion has been triggered */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L182" title="access/transam/xlogrecovery.c:182">LocalPromoteIsTriggered</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (endOfRecovery)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;pausing at the end of recovery&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Execute <a href="xlogfuncs.c.html#L547" title="access/transam/xlogfuncs.c:547">pg_wal_replay_resume</a>() to promote.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovery has paused&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Execute <a href="xlogfuncs.c.html#L547" title="access/transam/xlogfuncs.c:547">pg_wal_replay_resume</a>() to continue.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* loop until recoveryPauseState is set to RECOVERY_NOT_PAUSED */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L3070" title="access/transam/xlogrecovery.c:3070">GetRecoveryPauseState</a>() != RECOVERY_NOT_PAUSED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/startup.c.html#L154" title="postmaster/startup.c:154">HandleStartupProcInterrupts</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4433" title="access/transam/xlogrecovery.c:4433">CheckForStandbyTrigger</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If recovery pause is requested then set it paused.&nbsp; While we are in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the loop, user might resume and pause again so set this every time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3110" title="access/transam/xlogrecovery.c:3110">ConfirmRecoveryPaused</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We wait on a condition variable that will wake us as soon as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pause ends, but we use a timeout so we can check the above exit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * condition periodically too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L112" title="storage/lmgr/condition_variable.c:112">ConditionVariableTimedSleep</a>(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryNotPausedCV, <span class="Constant">1000</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WAIT_EVENT_RECOVERY_PAUSE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When <a href="#L93" title="access/transam/xlogrecovery.c:93">recovery_min_apply_delay</a> is set, we wait long enough to make sure<br/></li>
<li></span><span class="Comment"> * certain record types are applied at least that interval behind the primary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if we waited.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the delay is calculated between the WAL record log time and<br/></li>
<li></span><span class="Comment"> * the current time on standby. We would prefer to keep track of when this<br/></li>
<li></span><span class="Comment"> * standby received each WAL record, which would allow a more consistent<br/></li>
<li></span><span class="Comment"> * approach and one not affected by time synchronisation issues, but that<br/></li>
<li></span><span class="Comment"> * is significantly more effort and complexity for little actual gain in<br/></li>
<li></span><span class="Comment"> * usability.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2982">&#x200c;</a></span><span class="linkable">recoveryApplyDelay</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; xact_info;<br/></li>
<li>&nbsp; &nbsp; TimestampTz xtime;<br/></li>
<li>&nbsp; &nbsp; TimestampTz delayUntil;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; msecs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nothing to do if no delay configured */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L93" title="access/transam/xlogrecovery.c:93">recovery_min_apply_delay</a> &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no delay is applied on a database not yet consistent */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L294" title="access/transam/xlogrecovery.c:294">reachedConsistency</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nothing to do if crash recovery is requested */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Is it a COMMIT record?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We deliberately choose not to delay aborts since they have no effect on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MVCC. We already allow replay of <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> that don't have a timestamp,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so there is already opportunity for issues caused by early conflicts on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * standbys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (XLogRecGetRmid(record) != RM_XACT_ID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xact_info = XLogRecGetInfo(record) &amp; XLOG_XACT_OPMASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xact_info != XLOG_XACT_COMMIT &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xact_info != XLOG_XACT_COMMIT_PREPARED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2426" title="access/transam/xlogrecovery.c:2426">getRecordTimestamp</a>(record, &amp;xtime))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delayUntil = TimestampTzPlusMilliseconds(xtime, <a href="#L93" title="access/transam/xlogrecovery.c:93">recovery_min_apply_delay</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Exit without arming the latch if it's already past time to apply this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; msecs = <a href="../../utils/adt/timestamp.c.html#L1766" title="utils/adt/timestamp.c:1766">TimestampDifferenceMilliseconds</a>(<a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>(), delayUntil);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (msecs &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryWakeupLatch);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This might change <a href="#L93" title="access/transam/xlogrecovery.c:93">recovery_min_apply_delay</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/startup.c.html#L154" title="postmaster/startup.c:154">HandleStartupProcInterrupts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4433" title="access/transam/xlogrecovery.c:4433">CheckForStandbyTrigger</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Recalculate delayUntil as <a href="#L93" title="access/transam/xlogrecovery.c:93">recovery_min_apply_delay</a> could have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changed while <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> in this loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; delayUntil = TimestampTzPlusMilliseconds(xtime, <a href="#L93" title="access/transam/xlogrecovery.c:93">recovery_min_apply_delay</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait for difference between <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>() and delayUntil.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; msecs = <a href="../../utils/adt/timestamp.c.html#L1766" title="utils/adt/timestamp.c:1766">TimestampDifferenceMilliseconds</a>(<a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delayUntil);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (msecs &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;recovery apply delay </span><span class="Special">%ld</span><span class="Constant"> milliseconds&quot;</span>, msecs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryWakeupLatch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_TIMEOUT | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; msecs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_RECOVERY_APPLY_DELAY);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the current state of the recovery pause request.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RecoveryPauseState<br/></li>
<li><a id="L3070">&#x200c;</a><span class="linkable">GetRecoveryPauseState</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RecoveryPauseState state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; state = <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryPauseState;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set the recovery pause state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If recovery pause is requested then sets the recovery pause state to<br/></li>
<li></span><span class="Comment"> * 'pause requested' if it is not already 'paused'.&nbsp; Otherwise, sets it<br/></li>
<li></span><span class="Comment"> * to 'not paused' to resume the recovery.&nbsp; The recovery pause will be<br/></li>
<li></span><span class="Comment"> * confirmed by the <a href="#L3110" title="access/transam/xlogrecovery.c:3110">ConfirmRecoveryPaused</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3090">&#x200c;</a></span><span class="linkable">SetRecoveryPause</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recoveryPause)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!recoveryPause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryPauseState = RECOVERY_NOT_PAUSED;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryPauseState == RECOVERY_NOT_PAUSED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryPauseState = RECOVERY_PAUSE_REQUESTED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!recoveryPause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryNotPausedCV);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Confirm the recovery pause by setting the recovery pause state to<br/></li>
<li></span><span class="Comment"> * RECOVERY_PAUSED.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3110">&#x200c;</a></span><span class="linkable">ConfirmRecoveryPaused</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If recovery pause is requested then set it paused */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryPauseState == RECOVERY_PAUSE_REQUESTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryPauseState = RECOVERY_PAUSED;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attempt to read the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> XLOG record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Before first call, the reader needs to be positioned to the first record<br/></li>
<li></span><span class="Comment"> * by calling <a href="xlogprefetcher.c.html#L964" title="access/transam/xlogprefetcher.c:964">XLogPrefetcherBeginRead</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If no valid record is available, returns NULL, or fails if emode is PANIC.<br/></li>
<li></span><span class="Comment"> * (emode must be either PANIC, LOG). In standby mode, retries until a valid<br/></li>
<li></span><span class="Comment"> * record is available.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> XLogRecord *<br/></li>
<li><a id="L3131">&#x200c;</a><span class="linkable">ReadRecord</span>(<a href="xlogprefetcher.c.html#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> *<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>, <span class="Type">int</span> emode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fetching_ckpt, TimeLineID replayTLI)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecord *record;<br/></li>
<li>&nbsp; &nbsp; XLogReaderState *<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a> = <a href="xlogprefetcher.c.html#L403" title="access/transam/xlogprefetcher.c:403">XLogPrefetcherGetReader</a>(<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L194" title="access/transam/xlogrecovery.c:194">XLogPageReadPrivate</a> *private = (<a href="#L194" title="access/transam/xlogrecovery.c:194">XLogPageReadPrivate</a> *) <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;private_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pass through parameters to <a href="#L3298" title="access/transam/xlogrecovery.c:3298">XLogPageRead</a> */<br/></li>
<li></span>&nbsp; &nbsp; private-&gt;fetching_ckpt = fetching_ckpt;<br/></li>
<li>&nbsp; &nbsp; private-&gt;emode = emode;<br/></li>
<li>&nbsp; &nbsp; private-&gt;randAccess = (<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;ReadRecPtr == InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; private-&gt;replayTLI = replayTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is the first attempt to read this page. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L247" title="access/transam/xlogrecovery.c:247">lastSourceFailed</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *errormsg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record = <a href="xlogprefetcher.c.html#L983" title="access/transam/xlogprefetcher.c:983">XLogPrefetcherReadRecord</a>(<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>, &amp;errormsg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (record == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> that WAL ends in an incomplete record, keep track<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of that record.&nbsp; After recovery is done, we'll write a record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to indicate to downstream WAL readers that that portion is to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be ignored.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, when <a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a> = true, we're going to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * switch to a new timeline at the end of recovery. We will only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * copy WAL over to the new timeline up to the end of the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * complete record, so if we did this, we would later create an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overwrite contrecord in the wrong place, breaking everything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !XLogRecPtrIsInvalid(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;<a href="#L372" title="access/transam/xlogrecovery.c:372">abortedRecPtr</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L372" title="access/transam/xlogrecovery.c:372">abortedRecPtr</a> = <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;<a href="#L372" title="access/transam/xlogrecovery.c:372">abortedRecPtr</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L373" title="access/transam/xlogrecovery.c:373">missingContrecPtr</a> = <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;<a href="#L373" title="access/transam/xlogrecovery.c:373">missingContrecPtr</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; close(<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We only end up here without a message when <a href="#L3298" title="access/transam/xlogrecovery.c:3298">XLogPageRead</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * failed - in that case we already logged something. In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L147" title="access/transam/xlogrecovery.c:147">StandbyMode</a> that only happens if we have been triggered, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shouldn't loop anymore in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errormsg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(<a href="#L4030" title="access/transam/xlogrecovery.c:4030">emode_for_corrupt_record</a>(emode, <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, errormsg) <span class="Comment">/* already translated */</span> ));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check page TLI is one of the expected <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="timeline.c.html#L526" title="access/transam/timeline.c:526">tliInHistory</a>(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;latestPageTLI, <a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; fname[MAXFNAMELEN];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; segno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLByteToSeg(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;latestPagePtr, segno, <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset = XLogSegmentOffset(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;latestPagePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(fname, <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;seg.ws_tli, segno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(<a href="#L4030" title="access/transam/xlogrecovery.c:4030">emode_for_corrupt_record</a>(emode, <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected timeline ID </span><span class="Special">%u</span><span class="Constant"> in WAL segment </span><span class="Special">%s</span><span class="Constant">, LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, offset </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;latestPageTLI,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;latestPagePtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (record)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Great, got a record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> record;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No valid record available from this source */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L247" title="access/transam/xlogrecovery.c:247">lastSourceFailed</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If archive recovery was requested, but we were still doing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * crash recovery, switch to archive recovery and retry using the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * offline archive. We have <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> replayed all the valid WAL in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_wal, so we are presumably <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> consistent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We require that there's at least some valid WAL present in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_wal, however (!fetching_ckpt).&nbsp; We could recover using the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL from the archive, even if pg_wal is completely empty, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'd have no idea how far we'd have to replay to reach<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consistency.&nbsp; So err on the safe side and give up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L138" title="access/transam/xlogrecovery.c:138">InArchiveRecovery</a> &amp;&amp; <a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !fetching_ckpt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;reached end of WAL in pg_wal, entering archive recovery&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L138" title="access/transam/xlogrecovery.c:138">InArchiveRecovery</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L146" title="access/transam/xlogrecovery.c:146">StandbyModeRequested</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L478" title="access/transam/xlogrecovery.c:478">EnableStandbyMode</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L6165" title="access/transam/xlog.c:6165">SwitchIntoArchiveRecovery</a>(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr, replayTLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> = <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a> = replayTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2175" title="access/transam/xlogrecovery.c:2175">CheckRecoveryConsistency</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before we retry, reset <a href="#L247" title="access/transam/xlogrecovery.c:247">lastSourceFailed</a> and <a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so that we will check the archive <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L247" title="access/transam/xlogrecovery.c:247">lastSourceFailed</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a> = XLOG_FROM_ANY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In standby mode, loop back to retry. Otherwise, give up. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L147" title="access/transam/xlogrecovery.c:147">StandbyMode</a> &amp;&amp; !<a href="#L4433" title="access/transam/xlogrecovery.c:4433">CheckForStandbyTrigger</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read the XLOG page containing targetPagePtr into readBuf (if not read<br/></li>
<li></span><span class="Comment"> * already).&nbsp; Returns number of bytes read, if the page is read successfully,<br/></li>
<li></span><span class="Comment"> * or XLREAD_FAIL in case of errors.&nbsp; When errors occur, they are ereport'ed,<br/></li>
<li></span><span class="Comment"> * but only if they have not been previously reported.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See XLogReaderRoutine.page_read for more details.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * While prefetching, <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;nonblocking may be set.&nbsp; In that case,<br/></li>
<li></span><span class="Comment"> * returns XLREAD_WOULDBLOCK if we'd otherwise have to wait for more WAL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is responsible for restoring files from archive as needed, as well<br/></li>
<li></span><span class="Comment"> * as for <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the requested WAL record to arrive in standby mode.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;private_data-&gt;emode specifies the log level used for reporting<br/></li>
<li></span><span class="Comment"> * &quot;file not found&quot; or &quot;end of WAL&quot; situations in archive recovery, or in<br/></li>
<li></span><span class="Comment"> * standby mode when promotion is triggered. If set to WARNING or below,<br/></li>
<li></span><span class="Comment"> * <a href="#L3298" title="access/transam/xlogrecovery.c:3298">XLogPageRead</a>() returns XLREAD_FAIL in those situations, on higher log<br/></li>
<li></span><span class="Comment"> * levels the ereport() won't return.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In standby mode, if after a successful return of <a href="#L3298" title="access/transam/xlogrecovery.c:3298">XLogPageRead</a>() the<br/></li>
<li></span><span class="Comment"> * caller finds the record it's interested in to be broken, it should<br/></li>
<li></span><span class="Comment"> * ereport the error with the level determined by<br/></li>
<li></span><span class="Comment"> * <a href="#L4030" title="access/transam/xlogrecovery.c:4030">emode_for_corrupt_record</a>(), and then set <a href="#L247" title="access/transam/xlogrecovery.c:247">lastSourceFailed</a><br/></li>
<li></span><span class="Comment"> * and call <a href="#L3298" title="access/transam/xlogrecovery.c:3298">XLogPageRead</a>() again with the same arguments. This lets<br/></li>
<li></span><span class="Comment"> * <a href="#L3298" title="access/transam/xlogrecovery.c:3298">XLogPageRead</a>() to try fetching the record from another source, or to<br/></li>
<li></span><span class="Comment"> * sleep and retry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L3298">&#x200c;</a></span><span class="linkable">XLogPageRead</span>(XLogReaderState *<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>, XLogRecPtr targetPagePtr, <span class="Type">int</span> reqLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr targetRecPtr, <span class="Type">char</span> *readBuf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L194" title="access/transam/xlogrecovery.c:194">XLogPageReadPrivate</a> *private =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L194" title="access/transam/xlogrecovery.c:194">XLogPageReadPrivate</a> *) <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; emode = private-&gt;emode;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; targetPageOff;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; targetSegNo <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLByteToSeg(targetPagePtr, targetSegNo, <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; targetPageOff = XLogSegmentOffset(targetPagePtr, <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if we need to switch to a new segment because the requested record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is not in the currently open one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !XLByteInSeg(targetPagePtr, <a href="#L231" title="access/transam/xlogrecovery.c:231">readSegNo</a>, <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Request a restartpoint if we've replayed too much xlog since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * last one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a> &amp;&amp; <a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlog.c.html#L2285" title="access/transam/xlog.c:2285">XLogCheckpointNeeded</a>(<a href="#L231" title="access/transam/xlogrecovery.c:231">readSegNo</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="xlog.c.html#L6393" title="access/transam/xlog.c:6393">GetRedoRecPtr</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlog.c.html#L2285" title="access/transam/xlog.c:2285">XLogCheckpointNeeded</a>(<a href="#L231" title="access/transam/xlogrecovery.c:231">readSegNo</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/checkpointer.c.html#L941" title="postmaster/checkpointer.c:941">RequestCheckpoint</a>(CHECKPOINT_CAUSE_XLOG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close(<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L234" title="access/transam/xlogrecovery.c:234">readSource</a> = XLOG_FROM_ANY;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLByteToSeg(targetPagePtr, <a href="#L231" title="access/transam/xlogrecovery.c:231">readSegNo</a>, <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li><span class="Statement">retry</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* See if we need to retrieve more data */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L234" title="access/transam/xlogrecovery.c:234">readSource</a> == XLOG_FROM_STREAM &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L262" title="access/transam/xlogrecovery.c:262">flushedUpto</a> &lt; targetPagePtr + reqLen))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;nonblocking &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L234" title="access/transam/xlogrecovery.c:234">readSource</a> == XLOG_FROM_STREAM &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L262" title="access/transam/xlogrecovery.c:262">flushedUpto</a> &lt; targetPagePtr + reqLen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XLREAD_WOULDBLOCK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L3541" title="access/transam/xlogrecovery.c:3541">WaitForWALToBecomeAvailable</a>(targetPagePtr + reqLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; private-&gt;randAccess,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; private-&gt;fetching_ckpt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; private-&gt;replayTLI,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;nonblocking))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLREAD_WOULDBLOCK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XLREAD_WOULDBLOCK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLREAD_FAIL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; close(<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L233" title="access/transam/xlogrecovery.c:233">readLen</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L234" title="access/transam/xlogrecovery.c:234">readSource</a> = XLOG_FROM_ANY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XLREAD_FAIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLREAD_SUCCESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point, we have the right segment open and if we're streaming we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * know the requested record is in it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> != -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the current segment is being streamed from the primary, calculate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * how much of the current page we have received already. We know the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requested record has been received, but this is for the benefit of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * future calls, to allow quick exit at the top of this function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L234" title="access/transam/xlogrecovery.c:234">readSource</a> == XLOG_FROM_STREAM)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((targetPagePtr) / XLOG_BLCKSZ) != (<a href="#L262" title="access/transam/xlogrecovery.c:262">flushedUpto</a> / XLOG_BLCKSZ))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L233" title="access/transam/xlogrecovery.c:233">readLen</a> = XLOG_BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L233" title="access/transam/xlogrecovery.c:233">readLen</a> = XLogSegmentOffset(<a href="#L262" title="access/transam/xlogrecovery.c:262">flushedUpto</a>, <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>) -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetPageOff;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L233" title="access/transam/xlogrecovery.c:233">readLen</a> = XLOG_BLCKSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Read the requested page */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L232" title="access/transam/xlogrecovery.c:232">readOff</a> = targetPageOff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_WAL_READ);<br/></li>
<li>&nbsp; &nbsp; r = pg_pread(<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a>, readBuf, XLOG_BLCKSZ, (<span class="Type">off_t</span>) <a href="#L232" title="access/transam/xlogrecovery.c:232">readOff</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (r != XLOG_BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; fname[MAXFNAMELEN];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(fname, <a href="#L124" title="access/transam/xlogrecovery.c:124">curFileTLI</a>, <a href="#L231" title="access/transam/xlogrecovery.c:231">readSegNo</a>, <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(<a href="#L4030" title="access/transam/xlogrecovery.c:4030">emode_for_corrupt_record</a>(emode, targetPagePtr + reqLen),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read from WAL segment </span><span class="Special">%s</span><span class="Constant">, LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, offset </span><span class="Special">%u</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fname, LSN_FORMAT_ARGS(targetPagePtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L232" title="access/transam/xlogrecovery.c:232">readOff</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(<a href="#L4030" title="access/transam/xlogrecovery.c:4030">emode_for_corrupt_record</a>(emode, targetPagePtr + reqLen),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read from WAL segment </span><span class="Special">%s</span><span class="Constant">, LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, offset </span><span class="Special">%u</span><span class="Constant">: read </span><span class="Special">%d</span><span class="Constant"> of </span><span class="Special">%zu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fname, LSN_FORMAT_ARGS(targetPagePtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L232" title="access/transam/xlogrecovery.c:232">readOff</a>, r, (Size) XLOG_BLCKSZ)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> next_record_is_invalid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(targetSegNo == <a href="#L231" title="access/transam/xlogrecovery.c:231">readSegNo</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(targetPageOff == <a href="#L232" title="access/transam/xlogrecovery.c:232">readOff</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(reqLen &lt;= <a href="#L233" title="access/transam/xlogrecovery.c:233">readLen</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;seg.ws_tli = <a href="#L124" title="access/transam/xlogrecovery.c:124">curFileTLI</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check the page header immediately, so that we can retry immediately if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's not valid. This may seem unnecessary, because <a href="xlogreader.c.html#L1000" title="access/transam/xlogreader.c:1000">ReadPageInternal</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * validates the page header anyway, and would propagate the failure up to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L3131" title="access/transam/xlogrecovery.c:3131">ReadRecord</a>(), which would retry. However, there's a corner case with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * continuation <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, if a record is split across two pages such that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we would need to read the two pages from different sources. For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * example, imagine a scenario where a streaming replica is started up,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and replay reaches a record that's split across two WAL segments. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first page is only available locally, in pg_wal, because it's already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been recycled on the primary. The second page, however, is not present<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in pg_wal, and we should stream it from the primary. There is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recycled WAL segment present in pg_wal, with garbage contents, however.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We would read the first page from the local WAL segment, but when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reading the second page, we would read the bogus, recycled, WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * segment. If we didn't catch that case here, we would never recover,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because <a href="#L3131" title="access/transam/xlogrecovery.c:3131">ReadRecord</a>() would retry reading the whole record from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * beginning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Of course, this only catches errors in the page header, which is what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happens in the case of a recycled WAL segment. Other kinds of errors or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corruption still has the same problem. But this at least fixes the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * common case, which can happen as part of normal operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Validating the page header is cheap enough that doing it twice<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shouldn't be a big deal from a performance point of view.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When not in standby mode, an invalid page header should cause recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to end, not retry reading the page, so we don't need to validate the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page header here for the retry. Instead, <a href="xlogreader.c.html#L1000" title="access/transam/xlogreader.c:1000">ReadPageInternal</a>() is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * responsible for the validation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L147" title="access/transam/xlogrecovery.c:147">StandbyMode</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="xlogreader.c.html#L1224" title="access/transam/xlogreader.c:1224">XLogReaderValidatePageHeader</a>(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>, targetPagePtr, readBuf))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Emit this error right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> then retry this page immediately. Use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>() because the message was already translated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;errormsg_buf[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(<a href="#L4030" title="access/transam/xlogrecovery.c:4030">emode_for_corrupt_record</a>(emode, <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;errormsg_buf)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error <a href="xlogreader.c.html#L1224" title="access/transam/xlogreader.c:1224">XLogReaderValidatePageHeader</a>() might have set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogreader.c.html#L1365" title="access/transam/xlogreader.c:1365">XLogReaderResetError</a>(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> next_record_is_invalid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L233" title="access/transam/xlogrecovery.c:233">readLen</a>;<br/></li>
<li><br/></li>
<li><span class="Statement">next_record_is_invalid</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're reading ahead, give up fast.&nbsp; Retries and error reporting will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be handled by a later read when recovery catches up to this point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;nonblocking)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XLREAD_WOULDBLOCK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L247" title="access/transam/xlogrecovery.c:247">lastSourceFailed</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close(<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L233" title="access/transam/xlogrecovery.c:233">readLen</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L234" title="access/transam/xlogrecovery.c:234">readSource</a> = XLOG_FROM_ANY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* In standby-mode, keep trying */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L147" title="access/transam/xlogrecovery.c:147">StandbyMode</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> retry;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XLREAD_FAIL;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Open the WAL segment containing WAL location 'RecPtr'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The segment can be fetched via restore_command, or via walreceiver having<br/></li>
<li></span><span class="Comment"> * streamed the record, or it can already be present in pg_wal. Checking<br/></li>
<li></span><span class="Comment"> * pg_wal is mainly for crash recovery, but it will be polled in standby mode<br/></li>
<li></span><span class="Comment"> * too, in case someone copies a new segment directly to pg_wal. That is not<br/></li>
<li></span><span class="Comment"> * documented or recommended, though.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If 'fetching_ckpt' is true, we're fetching a checkpoint record, and should<br/></li>
<li></span><span class="Comment"> * prepare to read WAL starting from <a href="#L169" title="access/transam/xlogrecovery.c:169">RedoStartLSN</a> after this.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'RecPtr' might not point to the beginning of the record we're interested<br/></li>
<li></span><span class="Comment"> * in, it might also point to the page or segment header. In that case,<br/></li>
<li></span><span class="Comment"> * 'tliRecPtr' is the position of the WAL record we're interested in. It is<br/></li>
<li></span><span class="Comment"> * used to decide which timeline to stream the requested WAL from.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'replayLSN' is the current replay LSN, so that if we scan for new<br/></li>
<li></span><span class="Comment"> * timelines, we can reject a switch to a timeline that branched off <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * this point.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the record is not immediately available, the function returns false<br/></li>
<li></span><span class="Comment"> * if we're not in standby mode. In standby mode, waits for it to become<br/></li>
<li></span><span class="Comment"> * available.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When the requested record becomes available, the function opens the file<br/></li>
<li></span><span class="Comment"> * containing it (if not open already), and returns XLREAD_SUCCESS. When end<br/></li>
<li></span><span class="Comment"> * of standby mode is triggered by the user, and there is no more WAL<br/></li>
<li></span><span class="Comment"> * available, returns XLREAD_FAIL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If nonblocking is true, then give up immediately if we can't satisfy the<br/></li>
<li></span><span class="Comment"> * request, returning XLREAD_WOULDBLOCK instead of <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> XLogPageReadResult<br/></li>
<li><a id="L3541">&#x200c;</a><span class="linkable">WaitForWALToBecomeAvailable</span>(XLogRecPtr RecPtr, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> randAccess,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fetching_ckpt, XLogRecPtr tliRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID replayTLI, XLogRecPtr replayLSN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nonblocking)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> TimestampTz last_fail_time = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; TimestampTz <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; streaming_reply_sent = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*-------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Standby mode is implemented by a state machine:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 1. Read from either archive or pg_wal (XLOG_FROM_ARCHIVE), or just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; pg_wal (XLOG_FROM_PG_WAL)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 2. Check for promotion <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> request<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 3. Read from primary server via walreceiver (XLOG_FROM_STREAM)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 4. Rescan timelines<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 5. Sleep <a href="xlog.c.html#L134" title="access/transam/xlog.c:134">wal_retrieve_retry_interval</a> milliseconds, and loop back to 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Failure to read from the current source advances the state machine to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * '<a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a>' indicates the current state. There are no <a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for &quot;check <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>&quot;, &quot;rescan timelines&quot;, and &quot;sleep&quot; states,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those actions are taken when reading from the previous source fails, as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * part of advancing to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If standby mode is turned off while reading WAL from stream, we move<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to XLOG_FROM_ARCHIVE and reset <a href="#L247" title="access/transam/xlogrecovery.c:247">lastSourceFailed</a>, to force fetching<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the files (which would be required at end of recovery, e.g., timeline<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * history file) from archive or pg_wal. We don't need to kill WAL receiver<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here because it's already stopped when standby mode is turned off at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the end of recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *-------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L138" title="access/transam/xlogrecovery.c:138">InArchiveRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a> = XLOG_FROM_PG_WAL;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a> == XLOG_FROM_ANY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (!<a href="#L147" title="access/transam/xlogrecovery.c:147">StandbyMode</a> &amp;&amp; <a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a> == XLOG_FROM_STREAM))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L247" title="access/transam/xlogrecovery.c:247">lastSourceFailed</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a> = XLOG_FROM_ARCHIVE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L215" title="access/transam/xlogrecovery.c:215">XLogSource</a>&nbsp; &nbsp; oldSource = <a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; startWalReceiver = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First check if we failed to read from the current source, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * advance the state machine if so. The failure to read might've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happened outside this function, e.g when a CRC check fails on a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * record, or within this loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L247" title="access/transam/xlogrecovery.c:247">lastSourceFailed</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't allow <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> retry loops to occur during nonblocking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * readahead.&nbsp; Let the caller process everything that has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decoded already first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nonblocking)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XLREAD_WOULDBLOCK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_FROM_ARCHIVE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_FROM_PG_WAL:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check to see if promotion is requested. Note that we do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this only after failure, so when you promote, we still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * finish replaying as much as we can from archive and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_wal <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> failover.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L147" title="access/transam/xlogrecovery.c:147">StandbyMode</a> &amp;&amp; <a href="#L4433" title="access/transam/xlogrecovery.c:4433">CheckForStandbyTrigger</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L9393" title="access/transam/xlog.c:9393">XLogShutdownWalRcv</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XLREAD_FAIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Not in standby mode, and we've <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> tried the archive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and pg_wal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L147" title="access/transam/xlogrecovery.c:147">StandbyMode</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XLREAD_FAIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Move to XLOG_FROM_STREAM state, and set to start a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * walreceiver if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a> = XLOG_FROM_STREAM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startWalReceiver = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_FROM_STREAM:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Failure while streaming. Most likely, we got here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because streaming replication was terminated, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * promotion was triggered. But we also get here if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an invalid record in the WAL streamed from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * primary, in which case something is seriously wrong.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's little chance that the problem will just go<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * away, but PANIC is not good for availability either,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * especially in hot standby mode. So, we treat that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same as disconnection, and retry from archive/pg_wal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * again. The WAL in the archive should be identical to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * what was streamed, so it's unlikely that it helps, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one can hope...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should be able to move to XLOG_FROM_STREAM only in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * standby mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L147" title="access/transam/xlogrecovery.c:147">StandbyMode</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before we leave XLOG_FROM_STREAM state, make sure that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * walreceiver is not active, so that it won't overwrite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL that we restore from archive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L9393" title="access/transam/xlog.c:9393">XLogShutdownWalRcv</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before we sleep, re-scan for possible new timelines if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we were requested to recover to the latest timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L120" title="access/transam/xlogrecovery.c:120">recoveryTargetTimeLineGoal</a> == RECOVERY_TARGET_TIMELINE_LATEST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4104" title="access/transam/xlogrecovery.c:4104">rescanLatestTimeLine</a>(replayTLI, replayLSN))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a> = XLOG_FROM_ARCHIVE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * XLOG_FROM_STREAM is the last state in our state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * machine, so we've exhausted all the options for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * obtaining the requested WAL. We're going to loop back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and retry from the archive, but if it hasn't been long<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since last attempt, sleep <a href="xlog.c.html#L134" title="access/transam/xlog.c:134">wal_retrieve_retry_interval</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * milliseconds to avoid busy-<a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/adt/timestamp.c.html#L1790" title="utils/adt/timestamp.c:1790">TimestampDifferenceExceeds</a>(last_fail_time, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L134" title="access/transam/xlog.c:134">wal_retrieve_retry_interval</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; wait_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wait_time = <a href="xlog.c.html#L134" title="access/transam/xlog.c:134">wal_retrieve_retry_interval</a> -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1766" title="utils/adt/timestamp.c:1766">TimestampDifferenceMilliseconds</a>(last_fail_time, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;<a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for WAL to become available at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(RecPtr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do background tasks that might benefit us later. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L4524" title="storage/ipc/procarray.c:4524">KnownAssignedTransactionIdsIdleMaintenance</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryWakeupLatch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_TIMEOUT |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wait_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_RECOVERY_RETRIEVE_RETRY_INTERVAL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryWakeupLatch);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle interrupt signals of startup process */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/startup.c.html#L154" title="postmaster/startup.c:154">HandleStartupProcInterrupts</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_fail_time = <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a> = XLOG_FROM_ARCHIVE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected WAL source </span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a> == XLOG_FROM_PG_WAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We just successfully read a file in pg_wal. We prefer files in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the archive over ones in pg_wal, so try the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> file again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from the archive first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L138" title="access/transam/xlogrecovery.c:138">InArchiveRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a> = XLOG_FROM_ARCHIVE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a> != oldSource)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;switched WAL source from </span><span class="Special">%s</span><span class="Constant"> to </span><span class="Special">%s</span><span class="Constant"> after </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L218" title="access/transam/xlogrecovery.c:218">xlogSourceNames</a>[oldSource], <a href="#L218" title="access/transam/xlogrecovery.c:218">xlogSourceNames</a>[<a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L247" title="access/transam/xlogrecovery.c:247">lastSourceFailed</a> ? <span class="Constant">&quot;failure&quot;</span> : <span class="Constant">&quot;success&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> handled possible failure. Try to read from the chosen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * source.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L247" title="access/transam/xlogrecovery.c:247">lastSourceFailed</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_FROM_ARCHIVE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_FROM_PG_WAL:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL receiver must not be running when reading WAL from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * archive or pg_wal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../../replication/walreceiverfuncs.c.html#L126" title="replication/walreceiverfuncs.c:126">WalRcvStreaming</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Close <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> old file we might have open. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; close(<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset <a href="#L124" title="access/transam/xlogrecovery.c:124">curFileTLI</a> if random fetch. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (randAccess)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L124" title="access/transam/xlogrecovery.c:124">curFileTLI</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to restore the file from archive, or read an existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file from pg_wal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> = <a href="#L4273" title="access/transam/xlogrecovery.c:4273">XLogFileReadAnyTLI</a>(<a href="#L231" title="access/transam/xlogrecovery.c:231">readSegNo</a>, DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a> == XLOG_FROM_ARCHIVE ? XLOG_FROM_ANY :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XLREAD_SUCCESS;&nbsp; &nbsp; <span class="Comment">/* success! */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Nope, not found in archive or pg_wal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L247" title="access/transam/xlogrecovery.c:247">lastSourceFailed</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_FROM_STREAM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; havedata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should be able to move to XLOG_FROM_STREAM only in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * standby mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L147" title="access/transam/xlogrecovery.c:147">StandbyMode</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First, shutdown walreceiver if its restart has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requested -- but no point if we're already slated for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * starting it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L248" title="access/transam/xlogrecovery.c:248">pendingWalRcvRestart</a> &amp;&amp; !startWalReceiver)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L9393" title="access/transam/xlog.c:9393">XLogShutdownWalRcv</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Re-scan for possible new timelines if we were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requested to recover to the latest timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L120" title="access/transam/xlogrecovery.c:120">recoveryTargetTimeLineGoal</a> ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RECOVERY_TARGET_TIMELINE_LATEST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4104" title="access/transam/xlogrecovery.c:4104">rescanLatestTimeLine</a>(replayTLI, replayLSN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startWalReceiver = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L248" title="access/transam/xlogrecovery.c:248">pendingWalRcvRestart</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Launch walreceiver if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If fetching_ckpt is true, RecPtr points to the initial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checkpoint location. In that case, we use <a href="#L169" title="access/transam/xlogrecovery.c:169">RedoStartLSN</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as the streaming start position instead of RecPtr, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that when we later jump backwards to start redo at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L169" title="access/transam/xlogrecovery.c:169">RedoStartLSN</a>, we will have the logs streamed already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (startWalReceiver &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L96" title="access/transam/xlogrecovery.c:96">PrimaryConnInfo</a> &amp;&amp; strcmp(<a href="#L96" title="access/transam/xlogrecovery.c:96">PrimaryConnInfo</a>, <span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID&nbsp; &nbsp; tli;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fetching_ckpt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = <a href="#L169" title="access/transam/xlogrecovery.c:169">RedoStartLSN</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tli = <a href="#L170" title="access/transam/xlogrecovery.c:170">RedoStartTLI</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = RecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use the record begin position to determine the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TLI, rather than the position we're reading.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tli = <a href="timeline.c.html#L544" title="access/transam/timeline.c:544">tliOfPointInHistory</a>(tliRecPtr, <a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L124" title="access/transam/xlogrecovery.c:124">curFileTLI</a> &gt; <span class="Constant">0</span> &amp;&amp; tli &lt; <a href="#L124" title="access/transam/xlogrecovery.c:124">curFileTLI</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;according to history file, WAL location </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> belongs to timeline </span><span class="Special">%u</span><span class="Constant">, but previous recovered WAL file came from timeline </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(tliRecPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tli, <a href="#L124" title="access/transam/xlogrecovery.c:124">curFileTLI</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L124" title="access/transam/xlogrecovery.c:124">curFileTLI</a> = tli;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L9404" title="access/transam/xlog.c:9404">SetInstallXLogFileSegmentActive</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/walreceiverfuncs.c.html#L245" title="replication/walreceiverfuncs.c:245">RequestXLogStreaming</a>(tli, ptr, <a href="#L96" title="access/transam/xlogrecovery.c:96">PrimaryConnInfo</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L97" title="access/transam/xlogrecovery.c:97">PrimarySlotName</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L98" title="access/transam/xlogrecovery.c:98">wal_receiver_create_temp_slot</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L262" title="access/transam/xlogrecovery.c:262">flushedUpto</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if WAL receiver is active or wait to start up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../replication/walreceiverfuncs.c.html#L126" title="replication/walreceiverfuncs.c:126">WalRcvStreaming</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L247" title="access/transam/xlogrecovery.c:247">lastSourceFailed</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Walreceiver is active, so see if new data has arrived.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We only advance <a href="#L258" title="access/transam/xlogrecovery.c:258">XLogReceiptTime</a> when we obtain fresh<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL from walreceiver and observe that we had already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processed everything <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the most recent &quot;chunk&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that it flushed to disk.&nbsp; In steady state where we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keeping up with the incoming data, <a href="#L258" title="access/transam/xlogrecovery.c:258">XLogReceiptTime</a> will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be updated on each cycle. When we are behind,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L258" title="access/transam/xlogrecovery.c:258">XLogReceiptTime</a> will not advance, so the grace time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allotted to conflicting queries will decrease.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RecPtr &lt; <a href="#L262" title="access/transam/xlogrecovery.c:262">flushedUpto</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; havedata = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; latestChunkStart;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L262" title="access/transam/xlogrecovery.c:262">flushedUpto</a> = <a href="../../replication/walreceiverfuncs.c.html#L331" title="replication/walreceiverfuncs.c:331">GetWalRcvFlushRecPtr</a>(&amp;latestChunkStart, &amp;<a href="#L263" title="access/transam/xlogrecovery.c:263">receiveTLI</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RecPtr &lt; <a href="#L262" title="access/transam/xlogrecovery.c:262">flushedUpto</a> &amp;&amp; <a href="#L263" title="access/transam/xlogrecovery.c:263">receiveTLI</a> == <a href="#L124" title="access/transam/xlogrecovery.c:124">curFileTLI</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; havedata = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (latestChunkStart &lt;= RecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L258" title="access/transam/xlogrecovery.c:258">XLogReceiptTime</a> = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4614" title="access/transam/xlogrecovery.c:4614">SetCurrentChunkStartTime</a>(<a href="#L258" title="access/transam/xlogrecovery.c:258">XLogReceiptTime</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; havedata = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (havedata)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Great, streamed far enough.&nbsp; Open the file if it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not open already.&nbsp; Also read the timeline history<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file if we haven't initialized timeline history<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * yet; it should be streamed over and present in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_wal by <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; Use XLOG_FROM_STREAM so that source<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * info is set correctly and <a href="#L258" title="access/transam/xlogrecovery.c:258">XLogReceiptTime</a> isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB: We must set <a href="timeline.c.html#L76" title="access/transam/timeline.c:76">readTimeLineHistory</a> based on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a>, not <a href="#L263" title="access/transam/xlogrecovery.c:263">receiveTLI</a>. Normally they'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be the same, but if recovery_target_timeline is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 'latest' and archiving is configured, then it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible that we managed to retrieve one or more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new timeline history files from the archive,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * updating <a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a> = <a href="timeline.c.html#L76" title="access/transam/timeline.c:76">readTimeLineHistory</a>(<a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> = <a href="#L4191" title="access/transam/xlogrecovery.c:4191">XLogFileRead</a>(<a href="#L231" title="access/transam/xlogrecovery.c:231">readSegNo</a>, PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L263" title="access/transam/xlogrecovery.c:263">receiveTLI</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLOG_FROM_STREAM, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L230" title="access/transam/xlogrecovery.c:230">readFile</a> &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just make sure source info is correct... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L234" title="access/transam/xlogrecovery.c:234">readSource</a> = XLOG_FROM_STREAM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L259" title="access/transam/xlogrecovery.c:259">XLogReceiptSource</a> = XLOG_FROM_STREAM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XLREAD_SUCCESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In nonblocking mode, return rather than sleeping. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nonblocking)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XLREAD_WOULDBLOCK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Data not here yet. Check for <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>, then wait for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * walreceiver to wake us up when new WAL arrives.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4433" title="access/transam/xlogrecovery.c:4433">CheckForStandbyTrigger</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we don't return XLREAD_FAIL immediately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here. After being triggered, we still want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * replay all the WAL that was already streamed. It's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in pg_wal <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, so we just treat this as a failure,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and the state machine will move on to replay the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * streamed WAL from pg_wal, and then recheck the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> and exit replay.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L247" title="access/transam/xlogrecovery.c:247">lastSourceFailed</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we have replayed everything we have received so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * far and are about to start <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for more WAL, let's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tell the upstream server our replay location <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that pg_stat_replication doesn't show stale<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * information.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!streaming_reply_sent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/walreceiver.c.html#L1358" title="replication/walreceiver.c:1358">WalRcvForceReply</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; streaming_reply_sent = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> background tasks that might benefit us later. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L4524" title="storage/ipc/procarray.c:4524">KnownAssignedTransactionIdsIdleMaintenance</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update pg_stat_recovery_prefetch <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> sleeping. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogprefetcher.c.html#L412" title="access/transam/xlogprefetcher.c:412">XLogPrefetcherComputeStats</a>(<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait for more WAL to arrive, when we will be woken<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * immediately by the WAL receiver.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryWakeupLatch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1L</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_RECOVERY_WAL_STREAM);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryWakeupLatch);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected WAL source </span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for recovery pause here so that we can confirm more quickly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that a requested pause has actually taken effect.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((<span class="Type">volatile</span> <a href="#L304" title="access/transam/xlogrecovery.c:304">XLogRecoveryCtlData</a> *) <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>)-&gt;recoveryPauseState !=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RECOVERY_NOT_PAUSED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2925" title="access/transam/xlogrecovery.c:2925">recoveryPausesHere</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This possibly-long loop needs to handle interrupts of startup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/startup.c.html#L154" title="postmaster/startup.c:154">HandleStartupProcInterrupts</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> XLREAD_FAIL;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not reached */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine what log level should be used to report a corrupt WAL record<br/></li>
<li></span><span class="Comment"> * in the current WAL page, previously read by <a href="#L3298" title="access/transam/xlogrecovery.c:3298">XLogPageRead</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'emode' is the error mode that would be used to report a file-not-found<br/></li>
<li></span><span class="Comment"> * or legitimate end-of-WAL situation.&nbsp;&nbsp; Generally, we use it as-is, but if<br/></li>
<li></span><span class="Comment"> * we're retrying the exact same record that we've tried previously, only<br/></li>
<li></span><span class="Comment"> * complain the first time to keep the noise down.&nbsp; However, we only do when<br/></li>
<li></span><span class="Comment"> * reading from pg_wal, because we don't expect <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> invalid <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> in archive<br/></li>
<li></span><span class="Comment"> * or in <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> streamed from the primary. Files in the archive should be complete,<br/></li>
<li></span><span class="Comment"> * and we should never hit the end of WAL because we stop and wait for more WAL<br/></li>
<li></span><span class="Comment"> * to arrive <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> replaying it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: This function remembers the RecPtr value it was last called with,<br/></li>
<li></span><span class="Comment"> * to suppress repeated messages about the same record. Only call this when<br/></li>
<li></span><span class="Comment"> * you are about to ereport(), or you might cause a later message to be<br/></li>
<li></span><span class="Comment"> * erroneously suppressed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L4030">&#x200c;</a></span><span class="linkable">emode_for_corrupt_record</span>(<span class="Type">int</span> emode, XLogRecPtr RecPtr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> XLogRecPtr lastComplaint = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L234" title="access/transam/xlogrecovery.c:234">readSource</a> == XLOG_FROM_PG_WAL &amp;&amp; emode == LOG)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RecPtr == lastComplaint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; emode = DEBUG1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastComplaint = RecPtr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> emode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine to try to fetch and validate a prior checkpoint record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> XLogRecord *<br/></li>
<li><a id="L4049">&#x200c;</a><span class="linkable">ReadCheckpointRecord</span>(<a href="xlogprefetcher.c.html#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> *<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>, XLogRecPtr RecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimeLineID replayTLI)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecord *record;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!XRecOffIsValid(RecPtr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid checkpoint location&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="xlogprefetcher.c.html#L964" title="access/transam/xlogprefetcher.c:964">XLogPrefetcherBeginRead</a>(<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>, RecPtr);<br/></li>
<li>&nbsp; &nbsp; record = <a href="#L3131" title="access/transam/xlogrecovery.c:3131">ReadRecord</a>(<a href="#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>, LOG, <span class="Constant">true</span>, replayTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (record == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid checkpoint record&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (record-&gt;xl_rmid != RM_XLOG_ID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid resource manager ID in checkpoint record&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; info = record-&gt;xl_info &amp; ~XLR_INFO_MASK;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (info != XLOG_CHECKPOINT_SHUTDOWN &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info != XLOG_CHECKPOINT_ONLINE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid xl_info in checkpoint record&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (record-&gt;xl_tot_len != SizeOfXLogRecord + SizeOfXLogRecordDataHeaderShort + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CheckPoint))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid length of checkpoint record&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> record;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Scan for new timelines that might have appeared in the archive since we<br/></li>
<li></span><span class="Comment"> * started recovery.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, the function changes recovery target TLI to the latest<br/></li>
<li></span><span class="Comment"> * one and returns 'true'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4104">&#x200c;</a></span><span class="linkable">rescanLatestTimeLine</span>(TimeLineID replayTLI, XLogRecPtr replayLSN)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newExpectedTLEs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; newtarget;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; oldtarget = <a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a>;<br/></li>
<li>&nbsp; &nbsp; TimeLineHistoryEntry *currentTle = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newtarget = <a href="timeline.c.html#L264" title="access/transam/timeline.c:264">findNewestTimeLine</a>(<a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newtarget == <a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No new timelines found */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the list of expected TLIs for the new TLI<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; newExpectedTLEs = <a href="timeline.c.html#L76" title="access/transam/timeline.c:76">readTimeLineHistory</a>(newtarget);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the current timeline is not part of the history of the new timeline,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we cannot proceed to it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(cell, newExpectedTLEs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; currentTle = (TimeLineHistoryEntry *) lfirst(cell);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (currentTle-&gt;tli == <a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;new timeline </span><span class="Special">%u</span><span class="Constant"> is not a child of database system timeline </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replayTLI)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The current timeline was found in the history file, but check that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> timeline was forked off from it *after* the current recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * location.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (currentTle-&gt;end &lt; replayLSN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;new timeline </span><span class="Special">%u</span><span class="Constant"> forked off current database system timeline </span><span class="Special">%u</span><span class="Constant"> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> current recovery point </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtarget,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replayTLI,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(replayLSN))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The new timeline history seems valid. Switch target */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a> = newtarget;<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(<a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a> = newExpectedTLEs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As in <a href="xlog.c.html#L5388" title="access/transam/xlog.c:5388">StartupXLOG</a>(), try to ensure we have all the history files<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * between the old target and new target in pg_wal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="timeline.c.html#L50" title="access/transam/timeline.c:50">restoreTimeLineHistoryFiles</a>(oldtarget + <span class="Constant">1</span>, newtarget);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;new target timeline is </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Open a logfile segment for reading (during recovery).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If source == XLOG_FROM_ARCHIVE, the segment is retrieved from archive.<br/></li>
<li></span><span class="Comment"> * Otherwise, it's assumed to be already available in pg_wal.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L4191">&#x200c;</a></span><span class="linkable">XLogFileRead</span>(XLogSegNo segno, <span class="Type">int</span> emode, TimeLineID tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L215" title="access/transam/xlogrecovery.c:215">XLogSource</a> source, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> notfoundOk)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; xlogfname[MAXFNAMELEN];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; activitymsg[MAXFNAMELEN + <span class="Constant">16</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLogFileName(xlogfname, tli, segno, <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (source)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_FROM_ARCHIVE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report recovery progress in PS display */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(activitymsg, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(activitymsg), <span class="Constant">&quot;<a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlogfname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(activitymsg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="xlogarchive.c.html#L54" title="access/transam/xlogarchive.c:54">RestoreArchivedFile</a>(path, xlogfname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;RECOVERYXLOG&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L203" title="access/transam/xlogrecovery.c:203">InRedo</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_FROM_PG_WAL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_FROM_STREAM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogFilePath(path, tli, segno, <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid <a href="#L4191" title="access/transam/xlogrecovery.c:4191">XLogFileRead</a> source </span><span class="Special">%d</span><span class="Constant">&quot;</span>, source);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the segment was fetched from archival storage, replace the existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xlog segment (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) with the archival version.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (source == XLOG_FROM_ARCHIVE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="xlog.c.html#L9412" title="access/transam/xlog.c:9412">IsInstallXLogFileSegmentActive</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogarchive.c.html#L358" title="access/transam/xlogarchive.c:358">KeepFileRestoredFromArchive</a>(path, xlogfname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set path to point at the new file in pg_wal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(path, MAXPGPATH, XLOGDIR <span class="Constant">&quot;/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, xlogfname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L1087" title="storage/file/fd.c:1087">BasicOpenFile</a>(path, O_RDONLY | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Success! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L124" title="access/transam/xlogrecovery.c:124">curFileTLI</a> = tli;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report recovery progress in PS display */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(activitymsg, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(activitymsg), <span class="Constant">&quot;recovering </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlogfname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(activitymsg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Track source of data in assorted state variables */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L234" title="access/transam/xlogrecovery.c:234">readSource</a> = source;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L259" title="access/transam/xlogrecovery.c:259">XLogReceiptSource</a> = source;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In FROM_STREAM case, caller tracks receipt time, not me */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (source != XLOG_FROM_STREAM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L258" title="access/transam/xlogrecovery.c:258">XLogReceiptTime</a> = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> fd;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">ENOENT</span> || !notfoundOk) <span class="Comment">/* unexpected failure? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Open a logfile segment for reading (during recovery).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This version searches for the segment with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> TLI listed in <a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L4273">&#x200c;</a></span><span class="linkable">XLogFileReadAnyTLI</span>(XLogSegNo segno, <span class="Type">int</span> emode, <a href="#L215" title="access/transam/xlogrecovery.c:215">XLogSource</a> source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tles;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop looking for a suitable timeline ID: we might need to read <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the timelines listed in <a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We expect <a href="#L124" title="access/transam/xlogrecovery.c:124">curFileTLI</a> on entry to be the TLI of the preceding file in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sequence, or 0 if there was no predecessor.&nbsp; We do not allow <a href="#L124" title="access/transam/xlogrecovery.c:124">curFileTLI</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to go backwards; this prevents us from picking up the wrong file when a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent timeline extends to higher segment numbers than the child we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * want to read.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we haven't read the timeline history file yet, read it <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we know which TLIs to scan.&nbsp; We don't save the list in <a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * however, unless we actually <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a valid segment.&nbsp; That way if there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * neither a timeline history file nor a WAL segment in the archive, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * streaming replication is set up, we'll read the timeline history file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * streamed from the primary when we start streaming, instead of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovering with a dummy history generated here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tles = <a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tles = <a href="timeline.c.html#L76" title="access/transam/timeline.c:76">readTimeLineHistory</a>(<a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(cell, tles)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeLineHistoryEntry *hent = (TimeLineHistoryEntry *) lfirst(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeLineID&nbsp; &nbsp; tli = hent-&gt;tli;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tli &lt; <a href="#L124" title="access/transam/xlogrecovery.c:124">curFileTLI</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't bother looking at too-old TLIs */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Skip scanning the timeline ID that the logfile segment to read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doesn't belong to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hent-&gt;begin != InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; beginseg = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLByteToSeg(hent-&gt;begin, beginseg, <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The logfile segment that doesn't belong to the timeline is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * older or newer than the segment that the timeline started or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ended at, respectively. It's sufficient to check only the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * starting segment of the timeline here. Since the timelines are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scanned in descending order in this loop, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> segments newer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than the ending segment should belong to newer timeline and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have already been read <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>. So it's not necessary to check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the ending segment of the timeline here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (segno &lt; beginseg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (source == XLOG_FROM_ANY || source == XLOG_FROM_ARCHIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd = <a href="#L4191" title="access/transam/xlogrecovery.c:4191">XLogFileRead</a>(segno, emode, tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLOG_FROM_ARCHIVE, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fd != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;got WAL segment from archive&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a> = tles;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> fd;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (source == XLOG_FROM_ANY || source == XLOG_FROM_PG_WAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd = <a href="#L4191" title="access/transam/xlogrecovery.c:4191">XLogFileRead</a>(segno, emode, tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLOG_FROM_PG_WAL, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fd != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a> = tles;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> fd;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Couldn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it.&nbsp; For simplicity, complain about front timeline */<br/></li>
<li></span>&nbsp; &nbsp; XLogFilePath(path, <a href="#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a>, segno, <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">ENOENT</span>;<br/></li>
<li>&nbsp; &nbsp; ereport(emode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set flag to signal the walreceiver to restart.&nbsp; (The startup process calls<br/></li>
<li></span><span class="Comment"> * this on noticing a relevant configuration change.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4375">&#x200c;</a></span><span class="linkable">StartupRequestWalReceiverRestart</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L246" title="access/transam/xlogrecovery.c:246">currentSource</a> == XLOG_FROM_STREAM &amp;&amp; <a href="../../replication/walreceiverfuncs.c.html#L75" title="replication/walreceiverfuncs.c:75">WalRcvRunning</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;WAL receiver process shutdown requested&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L248" title="access/transam/xlogrecovery.c:248">pendingWalRcvRestart</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Has a standby promotion already been triggered?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike <a href="#L4433" title="access/transam/xlogrecovery.c:4433">CheckForStandbyTrigger</a>(), this works in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> process<br/></li>
<li></span><span class="Comment"> * that's connected to shared memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4394">&#x200c;</a></span><span class="linkable">PromoteIsTriggered</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We check shared state each time only until a standby promotion is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * triggered. We can't <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> a promotion again, so there's no need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keep checking after the shared variable has once been seen true.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L182" title="access/transam/xlogrecovery.c:182">LocalPromoteIsTriggered</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; <a href="#L182" title="access/transam/xlogrecovery.c:182">LocalPromoteIsTriggered</a> = <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;SharedPromoteIsTriggered;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L182" title="access/transam/xlogrecovery.c:182">LocalPromoteIsTriggered</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4412">&#x200c;</a></span><span class="linkable">SetPromoteIsTriggered</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;SharedPromoteIsTriggered = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark the recovery pause state as 'not paused' because the paused state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ends and promotion continues if a promotion is triggered while recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is paused. Otherwise <a href="xlogfuncs.c.html#L592" title="access/transam/xlogfuncs.c:592">pg_get_wal_replay_pause_state</a>() can mistakenly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return 'paused' while a promotion is ongoing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3090" title="access/transam/xlogrecovery.c:3090">SetRecoveryPause</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L182" title="access/transam/xlogrecovery.c:182">LocalPromoteIsTriggered</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether a promote request has arrived.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4433">&#x200c;</a></span><span class="linkable">CheckForStandbyTrigger</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L182" title="access/transam/xlogrecovery.c:182">LocalPromoteIsTriggered</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../postmaster/startup.c.html#L288" title="postmaster/startup.c:288">IsPromoteSignaled</a>() &amp;&amp; <a href="#L4463" title="access/transam/xlogrecovery.c:4463">CheckPromoteSignal</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG, (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;received promote request&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4454" title="access/transam/xlogrecovery.c:4454">RemovePromoteSignalFiles</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/startup.c.html#L294" title="postmaster/startup.c:294">ResetPromoteSignaled</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4412" title="access/transam/xlogrecovery.c:4412">SetPromoteIsTriggered</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove the files signaling a standby promotion request.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4454">&#x200c;</a></span><span class="linkable">RemovePromoteSignalFiles</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; unlink(PROMOTE_SIGNAL_FILE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check to see if a promote request has arrived.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4463">&#x200c;</a></span><span class="linkable">CheckPromoteSignal</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat stat_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(PROMOTE_SIGNAL_FILE, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wake up startup process to replay newly arrived WAL, or to notice that<br/></li>
<li></span><span class="Comment"> * failover has been requested.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4478">&#x200c;</a></span><span class="linkable">WakeupRecovery</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryWakeupLatch);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Schedule a walreceiver <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> in the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> recovery loop.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4487">&#x200c;</a></span><span class="linkable">XLogRequestWalReceiverReply</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L185" title="access/transam/xlogrecovery.c:185">doRequestWalReceiverReply</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Is HotStandby active yet? This is only important in special backends<br/></li>
<li></span><span class="Comment"> * since normal backends won't ever be able to <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> until this returns<br/></li>
<li></span><span class="Comment"> * true. Postmaster knows this by way of signal, not via shared memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike testing <a href="xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a>, this works in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> process that's connected to<br/></li>
<li></span><span class="Comment"> * shared memory.&nbsp; (And note that <a href="xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> alone doesn't tell the truth<br/></li>
<li></span><span class="Comment"> * anyway.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4502">&#x200c;</a></span><span class="linkable">HotStandbyActive</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We check shared state each time only until Hot Standby is active. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't de-activate Hot Standby, so there's no need to keep checking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after the shared variable has once been seen true.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L176" title="access/transam/xlogrecovery.c:176">LocalHotStandbyActive</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* spinlock is essential on machines with weak memory ordering! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L176" title="access/transam/xlogrecovery.c:176">LocalHotStandbyActive</a> = <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;SharedHotStandbyActive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L176" title="access/transam/xlogrecovery.c:176">LocalHotStandbyActive</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Like <a href="#L4502" title="access/transam/xlogrecovery.c:4502">HotStandbyActive</a>(), but to be used only in WAL replay code,<br/></li>
<li></span><span class="Comment"> * where we don't need to ask <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other process what the state is.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4527">&#x200c;</a></span><span class="linkable">HotStandbyActiveInReplay</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(AmStartupProcess() || !<a href="../../utils/init/globals.c.html#L116" title="utils/init/globals.c:116">IsPostmasterEnvironment</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L176" title="access/transam/xlogrecovery.c:176">LocalHotStandbyActive</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get latest redo apply position.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Exported to allow WALReceiver to read the pointer directly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L4539">&#x200c;</a><span class="linkable">GetXLogReplayRecPtr</span>(TimeLineID *replayTLI)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; tli;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; recptr = <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;lastReplayedEndRecPtr;<br/></li>
<li>&nbsp; &nbsp; tli = <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;lastReplayedTLI;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (replayTLI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *replayTLI = tli;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> recptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get position of last applied, or the record being applied.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is different from <a href="#L4539" title="access/transam/xlogrecovery.c:4539">GetXLogReplayRecPtr</a>() in that if a WAL<br/></li>
<li></span><span class="Comment"> * record is currently being applied, this includes that record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L4562">&#x200c;</a><span class="linkable">GetCurrentReplayRecPtr</span>(TimeLineID *replayEndTLI)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; tli;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; recptr = <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;replayEndRecPtr;<br/></li>
<li>&nbsp; &nbsp; tli = <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;replayEndTLI;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (replayEndTLI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *replayEndTLI = tli;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> recptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Save timestamp of latest processed commit/abort record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We keep this in <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>, not a simple static variable, so that it can be<br/></li>
<li></span><span class="Comment"> * seen by processes other than the startup process.&nbsp; Note in particular<br/></li>
<li></span><span class="Comment"> * that <a href="xlog.c.html#L7512" title="access/transam/xlog.c:7512">CreateRestartPoint</a> is executed in the checkpointer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4585">&#x200c;</a></span><span class="linkable">SetLatestXTime</span>(TimestampTz xtime)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryLastXTime = xtime;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch timestamp of latest processed commit/abort record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TimestampTz<br/></li>
<li><a id="L4596">&#x200c;</a><span class="linkable">GetLatestXTime</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz xtime;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; xtime = <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryLastXTime;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> xtime;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Save timestamp of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> chunk of WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> to apply.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We keep this in <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>, not a simple static variable, so that it can be<br/></li>
<li></span><span class="Comment"> * seen by all backends.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4614">&#x200c;</a></span><span class="linkable">SetCurrentChunkStartTime</span>(TimestampTz xtime)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;currentChunkStartTime = xtime;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch timestamp of latest processed commit/abort record.<br/></li>
<li></span><span class="Comment"> * Startup process maintains an accurate local copy in <a href="#L258" title="access/transam/xlogrecovery.c:258">XLogReceiptTime</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TimestampTz<br/></li>
<li><a id="L4626">&#x200c;</a><span class="linkable">GetCurrentChunkReplayStartTime</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz xtime;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; xtime = <a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;currentChunkStartTime;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> xtime;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns time of receipt of current chunk of XLOG data, as well as<br/></li>
<li></span><span class="Comment"> * whether it was received from streaming replication or from archives.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4642">&#x200c;</a></span><span class="linkable">GetXLogReceiptTime</span>(TimestampTz *rtime, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *fromStream)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This must be executed in the startup process, since we don't export the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relevant state to shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *rtime = <a href="#L258" title="access/transam/xlogrecovery.c:258">XLogReceiptTime</a>;<br/></li>
<li>&nbsp; &nbsp; *fromStream = (<a href="#L259" title="access/transam/xlogrecovery.c:259">XLogReceiptSource</a> == XLOG_FROM_STREAM);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Note that text field supplied is a parameter name and does not require<br/></li>
<li></span><span class="Comment"> * translation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4659">&#x200c;</a></span><span class="linkable">RecoveryRequiresIntParameter</span>(<span class="Type">const</span> <span class="Type">char</span> *param_name, <span class="Type">int</span> currValue, <span class="Type">int</span> minValue)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (currValue &lt; minValue)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4527" title="access/transam/xlogrecovery.c:4527">HotStandbyActiveInReplay</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; warned_for_promote = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;hot standby is not possible because of insufficient parameter settings&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> = </span><span class="Special">%d</span><span class="Constant"> is a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> setting than on the primary server, where its value was </span><span class="Special">%d</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; param_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; currValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; minValue)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3090" title="access/transam/xlogrecovery.c:3090">SetRecoveryPause</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovery has paused&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;If recovery is unpaused, the server will shut down.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You can then restart the server after making the necessary configuration changes.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L3070" title="access/transam/xlogrecovery.c:3070">GetRecoveryPauseState</a>() != RECOVERY_NOT_PAUSED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/startup.c.html#L154" title="postmaster/startup.c:154">HandleStartupProcInterrupts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4433" title="access/transam/xlogrecovery.c:4433">CheckForStandbyTrigger</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!warned_for_promote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;promotion is not possible because of insufficient parameter settings&quot;</span>),<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Repeat the detail from above so it's easy to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the log.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> = </span><span class="Special">%d</span><span class="Constant"> is a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> setting than on the primary server, where its value was </span><span class="Special">%d</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; param_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; currValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; minValue),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Restart the server after making the necessary configuration changes.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; warned_for_promote = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If recovery pause is requested then set it paused.&nbsp; While<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we are in the loop, user might resume and pause again so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set this every time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3110" title="access/transam/xlogrecovery.c:3110">ConfirmRecoveryPaused</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We wait on a condition variable that will wake us as soon<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as the pause ends, but we use a timeout so we can check the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * above conditions periodically too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L112" title="storage/lmgr/condition_variable.c:112">ConditionVariableTimedSleep</a>(&amp;<a href="#L364" title="access/transam/xlogrecovery.c:364">XLogRecoveryCtl</a>-&gt;recoveryNotPausedCV, <span class="Constant">1000</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WAIT_EVENT_RECOVERY_PAUSE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovery aborted because of insufficient parameter settings&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Repeat the detail from above so it's easy to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> in the log. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> = </span><span class="Special">%d</span><span class="Constant"> is a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> setting than on the primary server, where its value was </span><span class="Special">%d</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; param_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; currValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; minValue),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You can restart the server after making the necessary configuration changes.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for primary_slot_name<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4740">&#x200c;</a></span><span class="linkable">check_primary_slot_name</span>(<span class="Type">char</span> **<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> &amp;&amp; strcmp(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../replication/slot.c.html#L252" title="replication/slot.c:252">ReplicationSlotValidateName</a>(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, WARNING))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recovery target settings: Only one of the several recovery_target* settings<br/></li>
<li></span><span class="Comment"> * may be set.&nbsp; Setting a second one results in an error.&nbsp; The global variable<br/></li>
<li></span><span class="Comment"> * <a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> tracks which kind of recovery target was chosen.&nbsp; Other<br/></li>
<li></span><span class="Comment"> * variables store the actual target value (for example a string or a xid).<br/></li>
<li></span><span class="Comment"> * The assign <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> of the parameters check whether a competing parameter<br/></li>
<li></span><span class="Comment"> * was already set.&nbsp; But we want to allow setting the same parameter multiple<br/></li>
<li></span><span class="Comment"> * times.&nbsp; We also want to allow unsetting a parameter and setting a different<br/></li>
<li></span><span class="Comment"> * one, so we unset <a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> when the parameter is set to an empty<br/></li>
<li></span><span class="Comment"> * string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> this code is broken by design.&nbsp; Throwing an error from a GUC assign<br/></li>
<li></span><span class="Comment"> * hook breaks fundamental assumptions of guc.c.&nbsp; So long as all the variables<br/></li>
<li></span><span class="Comment"> * for which this can happen are PGC_POSTMASTER, the consequences are limited,<br/></li>
<li></span><span class="Comment"> * since we'd just abort postmaster startup anyway.&nbsp; Nonetheless it's likely<br/></li>
<li></span><span class="Comment"> * that we have odd behaviors such as unexpected GUC ordering dependencies.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li></span>pg_attribute_noreturn()<br/></li>
<li><a id="L4769">&#x200c;</a><span class="linkable">error_multiple_recovery_targets</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;multiple recovery targets specified&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;At most one of recovery_target, recovery_target_lsn, recovery_target_name, recovery_target_time, recovery_target_xid may be set.&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for recovery_target<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4781">&#x200c;</a></span><span class="linkable">check_recovery_target</span>(<span class="Type">char</span> **<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">&quot;immediate&quot;</span>) != <span class="Constant">0</span> &amp;&amp; strcmp(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;The only allowed value is </span><span class="Special">\&quot;</span><span class="Constant">immediate</span><span class="Special">\&quot;</span><span class="Constant">.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC assign_hook for recovery_target<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4795">&#x200c;</a></span><span class="linkable">assign_recovery_target</span>(<span class="Type">const</span> <span class="Type">char</span> *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> != RECOVERY_TARGET_UNSET &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> != RECOVERY_TARGET_IMMEDIATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4769" title="access/transam/xlogrecovery.c:4769">error_multiple_recovery_targets</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> &amp;&amp; strcmp(<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> = RECOVERY_TARGET_IMMEDIATE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> = RECOVERY_TARGET_UNSET;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for recovery_target_lsn<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4811">&#x200c;</a></span><span class="linkable">check_recovery_target_lsn</span>(<span class="Type">char</span> **<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr *myextra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_error = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lsn = <a href="../../utils/adt/pg_lsn.c.html#L29" title="utils/adt/pg_lsn.c:29">pg_lsn_in_internal</a>(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, &amp;have_error);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; myextra = (XLogRecPtr *) <a href="../../utils/misc/guc.c.html#L640" title="utils/misc/guc.c:640">guc_malloc</a>(ERROR, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(XLogRecPtr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *myextra = lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *extra = (<span class="Type">void</span> *) myextra;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC assign_hook for recovery_target_lsn<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4834">&#x200c;</a></span><span class="linkable">assign_recovery_target_lsn</span>(<span class="Type">const</span> <span class="Type">char</span> *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> != RECOVERY_TARGET_UNSET &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> != RECOVERY_TARGET_LSN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4769" title="access/transam/xlogrecovery.c:4769">error_multiple_recovery_targets</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> &amp;&amp; strcmp(<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> = RECOVERY_TARGET_LSN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L92" title="access/transam/xlogrecovery.c:92">recoveryTargetLSN</a> = *((XLogRecPtr *) extra);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> = RECOVERY_TARGET_UNSET;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for recovery_target_name<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4853">&#x200c;</a></span><span class="linkable">check_recovery_target_name</span>(<span class="Type">char</span> **<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use the value of <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> directly */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strlen(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>) &gt;= MAXFNAMELEN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> is too long (maximum </span><span class="Special">%d</span><span class="Constant"> characters).&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;recovery_target_name&quot;</span>, MAXFNAMELEN - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC assign_hook for recovery_target_name<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4869">&#x200c;</a></span><span class="linkable">assign_recovery_target_name</span>(<span class="Type">const</span> <span class="Type">char</span> *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> != RECOVERY_TARGET_UNSET &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> != RECOVERY_TARGET_NAME)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4769" title="access/transam/xlogrecovery.c:4769">error_multiple_recovery_targets</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> &amp;&amp; strcmp(<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> = RECOVERY_TARGET_NAME;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L91" title="access/transam/xlogrecovery.c:91">recoveryTargetName</a> = <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> = RECOVERY_TARGET_UNSET;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for recovery_target_time<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The interpretation of the recovery_target_time string can depend on the<br/></li>
<li></span><span class="Comment"> * time zone setting, so we need to wait until after all GUC processing is<br/></li>
<li></span><span class="Comment"> * done <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can do the final parsing of the string.&nbsp; This check function<br/></li>
<li></span><span class="Comment"> * only does a parsing pass to catch syntax errors, but we store the string<br/></li>
<li></span><span class="Comment"> * and <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> it again when we need to use it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4894">&#x200c;</a></span><span class="linkable">check_recovery_target_time</span>(<span class="Type">char</span> **<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reject some special <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">&quot;<a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>&quot;</span>) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">&quot;today&quot;</span>) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">&quot;tomorrow&quot;</span>) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">&quot;yesterday&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> timestamp value (see also <a href="../../utils/adt/timestamp.c.html#L416" title="utils/adt/timestamp.c:416">timestamptz_in</a>())<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fsec_t&nbsp; &nbsp; &nbsp; &nbsp; fsec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> pg_tm tt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tm = &amp;tt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *field[MAXDATEFIELDS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftype[MAXDATEFIELDS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; workbuf[MAXDATELEN + MAXDATEFIELDS];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DateTimeErrorExtra dtextra;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz timestamp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="../../utils/adt/datetime.c.html#L754" title="utils/adt/datetime.c:754">ParseDateTime</a>(str, workbuf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(workbuf),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; field, ftype, MAXDATEFIELDS, &amp;nf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dterr = <a href="../../utils/adt/datetime.c.html#L978" title="utils/adt/datetime.c:978">DecodeDateTime</a>(field, ftype, nf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;dtype, tm, &amp;fsec, &amp;tz, &amp;dtextra);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dterr != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dtype != DTK_DATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/adt/timestamp.c.html#L1997" title="utils/adt/timestamp.c:1997">tm2timestamp</a>(tm, fsec, &amp;tz, &amp;timestamp) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;timestamp out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC assign_hook for recovery_target_time<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4949">&#x200c;</a></span><span class="linkable">assign_recovery_target_time</span>(<span class="Type">const</span> <span class="Type">char</span> *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> != RECOVERY_TARGET_UNSET &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> != RECOVERY_TARGET_TIME)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4769" title="access/transam/xlogrecovery.c:4769">error_multiple_recovery_targets</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> &amp;&amp; strcmp(<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> = RECOVERY_TARGET_TIME;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> = RECOVERY_TARGET_UNSET;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for recovery_target_timeline<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4965">&#x200c;</a></span><span class="linkable">check_recovery_target_timeline</span>(<span class="Type">char</span> **<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RecoveryTargetTimeLineGoal rttg;<br/></li>
<li>&nbsp; &nbsp; RecoveryTargetTimeLineGoal *myextra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">&quot;current&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rttg = RECOVERY_TARGET_TIMELINE_CONTROLFILE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">&quot;latest&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rttg = RECOVERY_TARGET_TIMELINE_LATEST;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rttg = RECOVERY_TARGET_TIMELINE_NUMERIC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strtoul(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EINVAL</span> || errno == <span class="Constant">ERANGE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;recovery_target_timeline is not a valid number.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; myextra = (RecoveryTargetTimeLineGoal *) <a href="../../utils/misc/guc.c.html#L640" title="utils/misc/guc.c:640">guc_malloc</a>(ERROR, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RecoveryTargetTimeLineGoal));<br/></li>
<li>&nbsp; &nbsp; *myextra = rttg;<br/></li>
<li>&nbsp; &nbsp; *extra = (<span class="Type">void</span> *) myextra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC assign_hook for recovery_target_timeline<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4998">&#x200c;</a></span><span class="linkable">assign_recovery_target_timeline</span>(<span class="Type">const</span> <span class="Type">char</span> *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L120" title="access/transam/xlogrecovery.c:120">recoveryTargetTimeLineGoal</a> = *((RecoveryTargetTimeLineGoal *) extra);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L120" title="access/transam/xlogrecovery.c:120">recoveryTargetTimeLineGoal</a> == RECOVERY_TARGET_TIMELINE_NUMERIC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L121" title="access/transam/xlogrecovery.c:121">recoveryTargetTLIRequested</a> = (TimeLineID) strtoul(<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L121" title="access/transam/xlogrecovery.c:121">recoveryTargetTLIRequested</a> = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for recovery_target_xid<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L5011">&#x200c;</a></span><span class="linkable">check_recovery_target_xid</span>(<span class="Type">char</span> **<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId *myextra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xid = (TransactionId) strtou64(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EINVAL</span> || errno == <span class="Constant">ERANGE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; myextra = (TransactionId *) <a href="../../utils/misc/guc.c.html#L640" title="utils/misc/guc.c:640">guc_malloc</a>(ERROR, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *myextra = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *extra = (<span class="Type">void</span> *) myextra;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC assign_hook for recovery_target_xid<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5034">&#x200c;</a></span><span class="linkable">assign_recovery_target_xid</span>(<span class="Type">const</span> <span class="Type">char</span> *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> != RECOVERY_TARGET_UNSET &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> != RECOVERY_TARGET_XID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4769" title="access/transam/xlogrecovery.c:4769">error_multiple_recovery_targets</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> &amp;&amp; strcmp(<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> = RECOVERY_TARGET_XID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="access/transam/xlogrecovery.c:88">recoveryTargetXid</a> = *((TransactionId *) extra);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="access/transam/xlogrecovery.c:85">recoveryTarget</a> = RECOVERY_TARGET_UNSET;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
