<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/transam/multixact.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/transam/multixact.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L329">MXactCache</a></li>
<li><a href="#L330">MXactContext</a></li>
<li><a href="#L188">MultiXactMemberCtlData</a></li>
<li><a href="#L187">MultiXactOffsetCtlData</a></li>
<li><a href="#L298">MultiXactState</a></li>
<li><a href="#L299">OldestMemberMXactId</a></li>
<li><a href="#L300">OldestVisibleMXactId</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L200">MultiXactStateData</a></li>
<li><a href="#L290">MultiXactStateData</a></li>
<li><a href="#L320">mXactCacheEnt</a></li>
<li><a href="#L326">mXactCacheEnt</a></li>
<li><a href="#L2959">mxtruncinfo</a></li>
<li><a href="#L2962">mxtruncinfo</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1759">AtEOXact_MultiXact</a></li>
<li><a href="#L1787">AtPrepare_MultiXact</a></li>
<li><a href="#L1985">BootStrapMultiXact</a></li>
<li><a href="#L2255">CheckPointMultiXact</a></li>
<li><a href="#L2536">ExtendMultiXactMember</a></li>
<li><a href="#L2504">ExtendMultiXactOffset</a></li>
<li><a href="#L1252">GetMultiXactIdMembers</a></li>
<li><a href="#L985">GetNewMultiXactId</a></li>
<li><a href="#L2611">GetOldestMultiXactId</a></li>
<li><a href="#L2069">MaybeExtendOffsetSlru</a></li>
<li><a href="#L2462">MultiXactAdvanceNextMXact</a></li>
<li><a href="#L2487">MultiXactAdvanceOldest</a></li>
<li><a href="#L2233">MultiXactGetCheckptMulti</a></li>
<li><a href="#L392">MultiXactIdCreate</a></li>
<li><a href="#L773">MultiXactIdCreateFromMembers</a></li>
<li><a href="#L445">MultiXactIdExpand</a></li>
<li><a href="#L557">MultiXactIdIsRunning</a></li>
<li><a href="#L3260">MultiXactIdPrecedes</a></li>
<li><a href="#L3274">MultiXactIdPrecedesOrEquals</a></li>
<li><a href="#L631">MultiXactIdSetOldestMember</a></li>
<li><a href="#L688">MultiXactIdSetOldestVisible</a></li>
<li><a href="#L2929">MultiXactMemberFreezeThreshold</a></li>
<li><a href="#L3240">MultiXactMemberPagePrecedes</a></li>
<li><a href="#L3220">MultiXactOffsetPagePrecedes</a></li>
<li><a href="#L3286">MultiXactOffsetPrecedes</a></li>
<li><a href="#L2791">MultiXactOffsetWouldWrap</a></li>
<li><a href="#L2279">MultiXactSetNextMXact</a></li>
<li><a href="#L1915">MultiXactShmemInit</a></li>
<li><a href="#L1898">MultiXactShmemSize</a></li>
<li><a href="#L2992">PerformMembersTruncation</a></li>
<li><a href="#L3020">PerformOffsetsTruncation</a></li>
<li><a href="#L1801">PostPrepare_MultiXact</a></li>
<li><a href="#L2877">ReadMultiXactCounts</a></li>
<li><a href="#L749">ReadMultiXactIdRange</a></li>
<li><a href="#L729">ReadNextMultiXactId</a></li>
<li><a href="#L869">RecordNewMultiXact</a></li>
<li><a href="#L2313">SetMultiXactIdLimit</a></li>
<li><a href="#L2664">SetOffsetVacuumLimit</a></li>
<li><a href="#L2969">SlruScanDirCbFindEarliest</a></li>
<li><a href="#L2104">StartupMultiXact</a></li>
<li><a href="#L2129">TrimMultiXact</a></li>
<li><a href="#L3045">TruncateMultiXact</a></li>
<li><a href="#L3312">WriteMTruncateXlogRec</a></li>
<li><a href="#L3298">WriteMZeroPageXlogRec</a></li>
<li><a href="#L2041">ZeroMultiXactMemberPage</a></li>
<li><a href="#L2025">ZeroMultiXactOffsetPage</a></li>
<li><a href="#L1974">check_multixact_member_buffers</a></li>
<li><a href="#L1965">check_multixact_offset_buffers</a></li>
<li><a href="#L2839">find_multixact_start</a></li>
<li><a href="#L1613">mXactCacheGetById</a></li>
<li><a href="#L1570">mXactCacheGetBySet</a></li>
<li><a href="#L1660">mXactCachePut</a></li>
<li><a href="#L3337">multixact_redo</a></li>
<li><a href="#L1886">multixact_twophase_postabort</a></li>
<li><a href="#L1871">multixact_twophase_postcommit</a></li>
<li><a href="#L1850">multixact_twophase_recover</a></li>
<li><a href="#L3527">multixactmemberssyncfiletag</a></li>
<li><a href="#L3518">multixactoffsetssyncfiletag</a></li>
<li><a href="#L1540">mxactMemberComparator</a></li>
<li><a href="#L1728">mxid_to_string</a></li>
<li><a href="#L1705">mxstatus_to_string</a></li>
<li><a href="#L3453">pg_get_multixact_members</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L328">MAX_CACHE_ENTRIES</a></li>
<li><a href="#L155">MAX_MEMBERS_IN_LAST_MEMBERS_PAGE</a></li>
<li><a href="#L135">MULTIXACT_FLAGBYTES_PER_GROUP</a></li>
<li><a href="#L141">MULTIXACT_MEMBERGROUPS_PER_PAGE</a></li>
<li><a href="#L139">MULTIXACT_MEMBERGROUP_SIZE</a></li>
<li><a href="#L136">MULTIXACT_MEMBERS_PER_MEMBERGROUP</a></li>
<li><a href="#L142">MULTIXACT_MEMBERS_PER_PAGE</a></li>
<li><a href="#L178">MULTIXACT_MEMBER_DANGER_THRESHOLD</a></li>
<li><a href="#L177">MULTIXACT_MEMBER_SAFE_THRESHOLD</a></li>
<li><a href="#L109">MULTIXACT_OFFSETS_PER_PAGE</a></li>
<li><a href="#L130">MXACT_MEMBER_BITS_PER_XACT</a></li>
<li><a href="#L131">MXACT_MEMBER_FLAGS_PER_BYTE</a></li>
<li><a href="#L132">MXACT_MEMBER_XACT_BITMASK</a></li>
<li><a href="#L167">MXOffsetToFlagsBitShift</a></li>
<li><a href="#L163">MXOffsetToFlagsOffset</a></li>
<li><a href="#L172">MXOffsetToMemberOffset</a></li>
<li><a href="#L159">MXOffsetToMemberPage</a></li>
<li><a href="#L160">MXOffsetToMemberSegment</a></li>
<li><a href="#L295">MaxOldestSlot</a></li>
<li><a href="#L113">MultiXactIdToOffsetEntry</a></li>
<li><a href="#L111">MultiXactIdToOffsetPage</a></li>
<li><a href="#L115">MultiXactIdToOffsetSegment</a></li>
<li><a href="#L191">MultiXactMemberCtl</a></li>
<li><a href="#L190">MultiXactOffsetCtl</a></li>
<li><a href="#L1138">OFFSET_WARN_SEGMENTS</a></li>
<li><a href="#L181">PreviousMultiXactId</a></li>
<li><a href="#L1903">SHARED_MULTIXACT_STATE_SIZE</a></li>
<li><a href="#L333">debug_elog2</a></li>
<li><a href="#L339">debug_elog2</a></li>
<li><a href="#L334">debug_elog3</a></li>
<li><a href="#L340">debug_elog3</a></li>
<li><a href="#L335">debug_elog4</a></li>
<li><a href="#L341">debug_elog4</a></li>
<li><a href="#L336">debug_elog5</a></li>
<li><a href="#L342">debug_elog5</a></li>
<li><a href="#L337">debug_elog6</a></li>
<li><a href="#L343">debug_elog6</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * multixact.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PostgreSQL multi-transaction-log manager<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The pg_multixact manager is a pg_xact-like manager that stores an array of<br/></li>
<li></span><span class="Comment"> * MultiXactMember for each MultiXactId.&nbsp; It is a fundamental part of the<br/></li>
<li></span><span class="Comment"> * shared-row-lock implementation.&nbsp; Each MultiXactMember is comprised of a<br/></li>
<li></span><span class="Comment"> * TransactionId and a set of flag bits.&nbsp; The name is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> historical:<br/></li>
<li></span><span class="Comment"> * originally, a MultiXactId consisted of more than one TransactionId (except<br/></li>
<li></span><span class="Comment"> * in rare corner cases), hence &quot;multi&quot;.&nbsp; Nowadays, however, it's perfectly<br/></li>
<li></span><span class="Comment"> * legitimate to have MultiXactIds that only include a single Xid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The meaning of the flag bits is opaque to this module, but they are mostly<br/></li>
<li></span><span class="Comment"> * used in heapam.c to identify lock modes that each of the member transactions<br/></li>
<li></span><span class="Comment"> * is holding on <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> given tuple.&nbsp; This module just contains support to store<br/></li>
<li></span><span class="Comment"> * and retrieve the arrays.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use two SLRU areas, one for storing the offsets at which the data<br/></li>
<li></span><span class="Comment"> * starts for each MultiXactId in the other one.&nbsp; This trick allows us to<br/></li>
<li></span><span class="Comment"> * store variable length arrays of TransactionIds.&nbsp; (We could alternatively<br/></li>
<li></span><span class="Comment"> * use one area containing counts and TransactionIds, with valid MultiXactId<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> pointing at slots containing counts; but that way seems less robust<br/></li>
<li></span><span class="Comment"> * since it would get completely confused if someone inquired about a bogus<br/></li>
<li></span><span class="Comment"> * MultiXactId that pointed to an intermediate slot containing an XID.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * XLOG interactions: this module generates a record whenever a new OFFSETs or<br/></li>
<li></span><span class="Comment"> * MEMBERs page is initialized to zeroes, as well as an<br/></li>
<li></span><span class="Comment"> * XLOG_MULTIXACT_CREATE_ID record whenever a new MultiXactId is defined.<br/></li>
<li></span><span class="Comment"> * This module ignores the WAL rule &quot;write xlog <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> data,&quot; because it<br/></li>
<li></span><span class="Comment"> * suffices that actions recording a MultiXactId in a heap xmax do follow that<br/></li>
<li></span><span class="Comment"> * rule.&nbsp; The only way for the MXID to be referenced from <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data page is for<br/></li>
<li></span><span class="Comment"> * <a href="../heap/heapam.c.html#L4306" title="access/heap/heapam.c:4306">heap_lock_tuple</a>() or <a href="../heap/heapam.c.html#L3146" title="access/heap/heapam.c:3146">heap_update</a>() to have put it there, and each generates<br/></li>
<li></span><span class="Comment"> * an XLOG record that must follow ours.&nbsp; The normal LSN interlock between the<br/></li>
<li></span><span class="Comment"> * data page and that XLOG record will ensure that our XLOG record reaches<br/></li>
<li></span><span class="Comment"> * disk first.&nbsp; If the SLRU members/offsets data reaches disk sooner than the<br/></li>
<li></span><span class="Comment"> * XLOG <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, we do not care; after recovery, no xmax will refer to it.&nbsp; On<br/></li>
<li></span><span class="Comment"> * the flip side, to ensure that all referenced entries _do_ reach disk, this<br/></li>
<li></span><span class="Comment"> * module's XLOG <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> completely rebuild the data entered since the last<br/></li>
<li></span><span class="Comment"> * checkpoint.&nbsp; We flush and sync all dirty OFFSETs and MEMBERs pages to disk<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> each checkpoint is considered complete.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Like clog.c, and unlike subtrans.c, we have to preserve state across<br/></li>
<li></span><span class="Comment"> * crashes and ensure that MXID and offset numbering increases monotonically<br/></li>
<li></span><span class="Comment"> * across a crash.&nbsp; We do this in the same way as it's done for transaction<br/></li>
<li></span><span class="Comment"> * IDs: the WAL record is guaranteed to contain evidence of every MXID we<br/></li>
<li></span><span class="Comment"> * could need to worry about, and we just make sure that at the end of<br/></li>
<li></span><span class="Comment"> * replay, the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-MXID and <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-offset counters are at least as large as<br/></li>
<li></span><span class="Comment"> * anything we saw during replay.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We are able to remove segments no longer necessary by carefully tracking<br/></li>
<li></span><span class="Comment"> * each table's used <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>: during <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> multixact older than a certain<br/></li>
<li></span><span class="Comment"> * value is removed; the cutoff value is stored in pg_class.&nbsp; The minimum value<br/></li>
<li></span><span class="Comment"> * across all tables in each database is stored in pg_database, and the global<br/></li>
<li></span><span class="Comment"> * minimum across all databases is part of pg_control and is kept in shared<br/></li>
<li></span><span class="Comment"> * memory.&nbsp; Whenever that minimum is advanced, the SLRUs are truncated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When new multixactid <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are to be created, care is taken that the<br/></li>
<li></span><span class="Comment"> * counter does not fall within the wraparound horizon considering the global<br/></li>
<li></span><span class="Comment"> * minimum value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * src/backend/access/transam/multixact.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/multixact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/slru.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/twophase.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/twophase_rmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/dbcommands.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/ilist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pg_trace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/autovacuum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pmsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Defines for MultiXactOffset page sizes.&nbsp; A page is the same BLCKSZ as is<br/></li>
<li></span><span class="Comment"> * used everywhere else in Postgres.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: because MultiXactOffsets are 32 bits and wrap around at 0xFFFFFFFF,<br/></li>
<li></span><span class="Comment"> * MultiXact page numbering also wraps around at<br/></li>
<li></span><span class="Comment"> * 0xFFFFFFFF/<a href="#L109" title="access/transam/multixact.c:109">MULTIXACT_OFFSETS_PER_PAGE</a>, and segment numbering at<br/></li>
<li></span><span class="Comment"> * 0xFFFFFFFF/<a href="#L109" title="access/transam/multixact.c:109">MULTIXACT_OFFSETS_PER_PAGE</a>/SLRU_PAGES_PER_SEGMENT.&nbsp; We need<br/></li>
<li></span><span class="Comment"> * take no explicit notice of that fact in this module, except when comparing<br/></li>
<li></span><span class="Comment"> * segment and page numbers in <a href="#L3045" title="access/transam/multixact.c:3045">TruncateMultiXact</a> (see<br/></li>
<li></span><span class="Comment"> * <a href="#L3220" title="access/transam/multixact.c:3220">MultiXactOffsetPagePrecedes</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* We need four bytes per offset */<br/></li>
<li><a id="L109">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MULTIXACT_OFFSETS_PER_PAGE</span> (BLCKSZ / </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(MultiXactOffset))<br/></li>
<li></span><br/></li>
<li><a id="L111">&#x200c;</a><span class="PreProc">#define <span class="linkable">MultiXactIdToOffsetPage</span>(xid) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((xid) / (MultiXactOffset) <a href="#L109" title="access/transam/multixact.c:109">MULTIXACT_OFFSETS_PER_PAGE</a>)<br/></li>
<li><a id="L113">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MultiXactIdToOffsetEntry</span>(xid) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((xid) % (MultiXactOffset) <a href="#L109" title="access/transam/multixact.c:109">MULTIXACT_OFFSETS_PER_PAGE</a>)<br/></li>
<li><a id="L115">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MultiXactIdToOffsetSegment</span>(xid) (<a href="#L111" title="access/transam/multixact.c:111">MultiXactIdToOffsetPage</a>(xid) / SLRU_PAGES_PER_SEGMENT)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The situation for members is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> more complex: we store one byte of<br/></li>
<li></span><span class="Comment"> * additional flag bits for each TransactionId.&nbsp; To do this without getting<br/></li>
<li></span><span class="Comment"> * into alignment issues, we store four bytes of flags, and then the<br/></li>
<li></span><span class="Comment"> * corresponding 4 Xids.&nbsp; Each such 5-<a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> (20-byte) set we call a &quot;group&quot;, and<br/></li>
<li></span><span class="Comment"> * are stored as a whole in pages.&nbsp; Thus, with 8kB BLCKSZ, we keep 409 groups<br/></li>
<li></span><span class="Comment"> * per page.&nbsp; This wastes 12 bytes per page, but that's OK -- simplicity (and<br/></li>
<li></span><span class="Comment"> * performance) trumps space efficiency here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the &quot;offset&quot; macros work with byte offset, not array indexes, so<br/></li>
<li></span><span class="Comment"> * arithmetic must be done using &quot;char *&quot; pointers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Comment">/* We need eight bits per xact, so one xact fits in a byte */<br/></li>
<li><a id="L130">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MXACT_MEMBER_BITS_PER_XACT</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">8<br/></li>
<li><a id="L131">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MXACT_MEMBER_FLAGS_PER_BYTE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1<br/></li>
<li><a id="L132">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MXACT_MEMBER_XACT_BITMASK</span>&nbsp; &nbsp; ((</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; <a href="#L130" title="access/transam/multixact.c:130">MXACT_MEMBER_BITS_PER_XACT</a>) - </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* how many full bytes of flags are there in a group? */<br/></li>
<li><a id="L135">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MULTIXACT_FLAGBYTES_PER_GROUP</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">4<br/></li>
<li><a id="L136">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MULTIXACT_MEMBERS_PER_MEMBERGROUP</span>&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="#L135" title="access/transam/multixact.c:135">MULTIXACT_FLAGBYTES_PER_GROUP</a> * <a href="#L131" title="access/transam/multixact.c:131">MXACT_MEMBER_FLAGS_PER_BYTE</a>)<br/></li>
<li></span><span class="Comment">/* size in bytes of a complete group */<br/></li>
<li><a id="L139">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MULTIXACT_MEMBERGROUP_SIZE</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (</span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(TransactionId) * <a href="#L136" title="access/transam/multixact.c:136">MULTIXACT_MEMBERS_PER_MEMBERGROUP</a> + <a href="#L135" title="access/transam/multixact.c:135">MULTIXACT_FLAGBYTES_PER_GROUP</a>)<br/></li>
<li><a id="L141">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MULTIXACT_MEMBERGROUPS_PER_PAGE</span> (BLCKSZ / <a href="#L139" title="access/transam/multixact.c:139">MULTIXACT_MEMBERGROUP_SIZE</a>)<br/></li>
<li><a id="L142">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MULTIXACT_MEMBERS_PER_PAGE</span>&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="#L141" title="access/transam/multixact.c:141">MULTIXACT_MEMBERGROUPS_PER_PAGE</a> * <a href="#L136" title="access/transam/multixact.c:136">MULTIXACT_MEMBERS_PER_MEMBERGROUP</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Because the number of items per page is not a divisor of the last item<br/></li>
<li></span><span class="Comment"> * number (member 0xFFFFFFFF), the last segment does not use the maximum number<br/></li>
<li></span><span class="Comment"> * of pages, and moreover the last used page therein does not use the same<br/></li>
<li></span><span class="Comment"> * number of items as previous pages.&nbsp; (Another way to say it is that the<br/></li>
<li></span><span class="Comment"> * 0xFFFFFFFF member is somewhere in the middle of the last page, so the page<br/></li>
<li></span><span class="Comment"> * has some empty space after that item.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This constant is the number of members in the last page of the last segment.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L155">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_MEMBERS_IN_LAST_MEMBERS_PAGE</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; ((uint32) ((</span><span class="Constant">0xFFFFFFFF</span><span class="PreProc"> % <a href="#L142" title="access/transam/multixact.c:142">MULTIXACT_MEMBERS_PER_PAGE</a>) + </span><span class="Constant">1</span><span class="PreProc">))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* page in which a member is to be found */<br/></li>
<li><a id="L159">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MXOffsetToMemberPage</span>(xid) ((xid) / (TransactionId) <a href="#L142" title="access/transam/multixact.c:142">MULTIXACT_MEMBERS_PER_PAGE</a>)<br/></li>
<li><a id="L160">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MXOffsetToMemberSegment</span>(xid) (<a href="#L159" title="access/transam/multixact.c:159">MXOffsetToMemberPage</a>(xid) / SLRU_PAGES_PER_SEGMENT)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Location (byte offset within page) of flag <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> for a given member */<br/></li>
<li><a id="L163">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MXOffsetToFlagsOffset</span>(xid) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((((xid) / (TransactionId) <a href="#L136" title="access/transam/multixact.c:136">MULTIXACT_MEMBERS_PER_MEMBERGROUP</a>) % \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; (TransactionId) <a href="#L141" title="access/transam/multixact.c:141">MULTIXACT_MEMBERGROUPS_PER_PAGE</a>) * \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; (TransactionId) <a href="#L139" title="access/transam/multixact.c:139">MULTIXACT_MEMBERGROUP_SIZE</a>)<br/></li>
<li><a id="L167">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MXOffsetToFlagsBitShift</span>(xid) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (((xid) % (TransactionId) <a href="#L136" title="access/transam/multixact.c:136">MULTIXACT_MEMBERS_PER_MEMBERGROUP</a>) * \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; <a href="#L130" title="access/transam/multixact.c:130">MXACT_MEMBER_BITS_PER_XACT</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Location (byte offset within page) of TransactionId of given member */<br/></li>
<li><a id="L172">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MXOffsetToMemberOffset</span>(xid) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="#L163" title="access/transam/multixact.c:163">MXOffsetToFlagsOffset</a>(xid) + <a href="#L135" title="access/transam/multixact.c:135">MULTIXACT_FLAGBYTES_PER_GROUP</a> + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; ((xid) % <a href="#L136" title="access/transam/multixact.c:136">MULTIXACT_MEMBERS_PER_MEMBERGROUP</a>) * </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(TransactionId))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Multixact members wraparound thresholds. */<br/></li>
<li><a id="L177">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MULTIXACT_MEMBER_SAFE_THRESHOLD</span>&nbsp; &nbsp; &nbsp; &nbsp; (MaxMultiXactOffset / </span><span class="Constant">2</span><span class="PreProc">)<br/></li>
<li><a id="L178">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MULTIXACT_MEMBER_DANGER_THRESHOLD</span>&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (MaxMultiXactOffset - MaxMultiXactOffset / </span><span class="Constant">4</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><a id="L181">&#x200c;</a><span class="PreProc">#define <span class="linkable">PreviousMultiXactId</span>(xid) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((xid) == FirstMultiXactId ? MaxMultiXactId : (xid) - </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Links to shared-memory data structures for MultiXact control<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L187">&#x200c;</a></span><span class="Type">static</span> SlruCtlData <span class="linkable">MultiXactOffsetCtlData</span>;<br/></li>
<li><a id="L188">&#x200c;</a><span class="Type">static</span> SlruCtlData <span class="linkable">MultiXactMemberCtlData</span>;<br/></li>
<li><br/></li>
<li><a id="L190">&#x200c;</a><span class="PreProc">#define <span class="linkable">MultiXactOffsetCtl</span>&nbsp; &nbsp; (&amp;<a href="#L187" title="access/transam/multixact.c:187">MultiXactOffsetCtlData</a>)<br/></li>
<li><a id="L191">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MultiXactMemberCtl</span>&nbsp; &nbsp; (&amp;<a href="#L188" title="access/transam/multixact.c:188">MultiXactMemberCtlData</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * MultiXact state shared across all backends.&nbsp; All this state is protected<br/></li>
<li></span><span class="Comment"> * by MultiXactGenLock.&nbsp; (We also use SLRU bank's lock of MultiXactOffset and<br/></li>
<li></span><span class="Comment"> * MultiXactMember to guard accesses to the two sets of SLRU buffers.&nbsp; For<br/></li>
<li></span><span class="Comment"> * concurrency's sake, we avoid holding more than one of these locks at a<br/></li>
<li></span><span class="Comment"> * time.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L200">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">MultiXactStateData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-to-be-assigned MultiXactId */<br/></li>
<li></span>&nbsp; &nbsp; MultiXactId nextMXact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-to-be-assigned offset */<br/></li>
<li></span>&nbsp; &nbsp; MultiXactOffset nextOffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Have we completed multixact startup? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; finishedStartup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Oldest multixact that is still potentially referenced by a relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Anything older than this should not be consulted.&nbsp; These <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * updated by <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MultiXactId oldestMultiXactId;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestMultiXactDB;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Oldest multixact offset that is potentially referenced by a multixact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * referenced by a relation.&nbsp; We don't always know this value, so there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a flag here to indicate whether or not we currently do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MultiXactOffset oldestOffset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; oldestOffsetKnown;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* support for anti-wraparound measures */<br/></li>
<li></span>&nbsp; &nbsp; MultiXactId multiVacLimit;<br/></li>
<li>&nbsp; &nbsp; MultiXactId multiWarnLimit;<br/></li>
<li>&nbsp; &nbsp; MultiXactId multiStopLimit;<br/></li>
<li>&nbsp; &nbsp; MultiXactId multiWrapLimit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* support for members anti-wraparound measures */<br/></li>
<li></span>&nbsp; &nbsp; MultiXactOffset offsetStopLimit;&nbsp; &nbsp; <span class="Comment">/* known if oldestOffsetKnown */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is used to sleep until a multixact offset is written when we want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to create the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ConditionVariable nextoff_cv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Per-backend data starts here.&nbsp; We have two arrays stored in the area<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediately following the <a href="#L200" title="access/transam/multixact.c:200">MultiXactStateData</a> struct. Each is indexed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ProcNumber.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In both arrays, there's a slot for all normal backends<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (0..<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>-1) followed by a slot for <a href="twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a> prepared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a>[k] is the oldest MultiXactId each backend's current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction(s) could possibly be a member of, or InvalidMultiXactId<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when the backend has no live transaction that could possibly be a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * member of a MultiXact.&nbsp; Each backend sets its entry to the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nextMXact counter just <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> first acquiring a shared lock in a given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction, and clears it at transaction end. (This works because only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during or after acquiring a shared lock could an XID possibly become a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * member of a MultiXact, and that MultiXact would have to be created<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during or after the lock acquisition.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L300" title="access/transam/multixact.c:300">OldestVisibleMXactId</a>[k] is the oldest MultiXactId each backend's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current transaction(s) think is potentially live, or InvalidMultiXactId<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when not in a transaction or not in a transaction that's paid <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attention to MultiXacts yet.&nbsp; This is computed when first needed in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * given transaction, and cleared at transaction end.&nbsp; We can compute it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as the minimum of the valid <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a>[] entries at the time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we compute it (using nextMXact if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> are valid).&nbsp; Each backend is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * required not to attempt to access <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SLRU data for MultiXactIds older<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than its own <a href="#L300" title="access/transam/multixact.c:300">OldestVisibleMXactId</a>[] setting; this is necessary because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the relevant SLRU data can be concurrently truncated away.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The oldest valid value among all of the <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a>[] and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L300" title="access/transam/multixact.c:300">OldestVisibleMXactId</a>[] entries is considered by <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> as the earliest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible value still having <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> live member transaction -- OldestMxact.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Any value older than that is typically removed from tuple headers, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;frozen&quot; via being replaced with a new xmax.&nbsp; VACUUM can sometimes even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remove an individual MultiXact xmax whose value is &gt;= its OldestMxact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cutoff, though typically only when no individual member XID is still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * running.&nbsp; See <a href="../heap/heapam.c.html#L6191" title="access/heap/heapam.c:6191">FreezeMultiXactId</a> for full details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Whenever VACUUM advances relminmxid, then either its OldestMxact cutoff<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or the oldest extant Multi remaining in the table is used as the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_class.relminmxid value (whichever is earlier).&nbsp; The minimum of all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relminmxid <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in each database is stored in pg_database.datminmxid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In turn, the minimum of all of those <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> is stored in pg_control.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is used as the truncation point for pg_multixact when unneeded<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * segments get removed by <a href="../../commands/vacuum.c.html#L1779" title="commands/vacuum.c:1779">vac_truncate_clog</a>() during vacuuming.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MultiXactId perBackendXactIds[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L290">&#x200c;</a>} <span class="linkable">MultiXactStateData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Size of <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a> and <a href="#L300" title="access/transam/multixact.c:300">OldestVisibleMXactId</a> arrays.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L295">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MaxOldestSlot</span>&nbsp; &nbsp; (<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> + <a href="twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Pointers to the state data in shared memory */<br/></li>
<li><a id="L298">&#x200c;</a></span><span class="Type">static</span> <a href="#L200" title="access/transam/multixact.c:200">MultiXactStateData</a> *<span class="linkable">MultiXactState</span>;<br/></li>
<li><a id="L299">&#x200c;</a><span class="Type">static</span> MultiXactId *<span class="linkable">OldestMemberMXactId</span>;<br/></li>
<li><a id="L300">&#x200c;</a><span class="Type">static</span> MultiXactId *<span class="linkable">OldestVisibleMXactId</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Definitions for the backend-local MultiXactId cache.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use this cache to store known MultiXacts, so we don't need to go to<br/></li>
<li></span><span class="Comment"> * SLRU areas every time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The cache lasts for the duration of a single transaction, the rationale<br/></li>
<li></span><span class="Comment"> * for this being that most entries will contain our own TransactionId and<br/></li>
<li></span><span class="Comment"> * so they will be uninteresting by the time our <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> transaction starts.<br/></li>
<li></span><span class="Comment"> * (</span><span class="Todo">XXX</span><span class="Comment"> not clear that this is correct --- other members of the MultiXact<br/></li>
<li></span><span class="Comment"> * could hang around longer than we did.&nbsp; However, it's not clear what a<br/></li>
<li></span><span class="Comment"> * better policy for flushing old cache entries would be.)&nbsp; &nbsp; </span><span class="Todo">FIXME</span><span class="Comment"> actually<br/></li>
<li></span><span class="Comment"> * this is plain wrong <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that multixact's may contain update Xids.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We allocate the cache entries in a memory context that is deleted at<br/></li>
<li></span><span class="Comment"> * transaction end, so we don't need to do retail freeing of entries.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L320">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">mXactCacheEnt</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactId multi;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmembers;<br/></li>
<li>&nbsp; &nbsp; dlist_node&nbsp; &nbsp; node;<br/></li>
<li>&nbsp; &nbsp; MultiXactMember members[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L326">&#x200c;</a>} <span class="linkable">mXactCacheEnt</span>;<br/></li>
<li><br/></li>
<li><a id="L328">&#x200c;</a><span class="PreProc">#define <span class="linkable">MAX_CACHE_ENTRIES</span>&nbsp; &nbsp; </span><span class="Constant">256<br/></li>
<li><a id="L329">&#x200c;</a></span><span class="Type">static</span> dclist_head <span class="linkable">MXactCache</span> = DCLIST_STATIC_INIT(<span class="linkable">MXactCache</span>);<br/></li>
<li><a id="L330">&#x200c;</a><span class="Type">static</span> MemoryContext <span class="linkable">MXactContext</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef MULTIXACT_DEBUG<br/></li>
<li><a id="L333">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">debug_elog2</span>(a,b) elog(a,b)<br/></li>
<li><a id="L334">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">debug_elog3</span>(a,b,c) elog(a,b,c)<br/></li>
<li><a id="L335">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">debug_elog4</span>(a,b,c,d) elog(a,b,c,d)<br/></li>
<li><a id="L336">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">debug_elog5</span>(a,b,c,d,e) elog(a,b,c,d,e)<br/></li>
<li><a id="L337">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">debug_elog6</span>(a,b,c,d,e,f) elog(a,b,c,d,e,f)<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L339">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">debug_elog2</span>(a,b)<br/></li>
<li><a id="L340">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">debug_elog3</span>(a,b,c)<br/></li>
<li><a id="L341">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">debug_elog4</span>(a,b,c,d)<br/></li>
<li><a id="L342">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">debug_elog5</span>(a,b,c,d,e)<br/></li>
<li><a id="L343">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">debug_elog6</span>(a,b,c,d,e,f)<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> MultiXactId management */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L688" title="access/transam/multixact.c:688">MultiXactIdSetOldestVisible</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L869" title="access/transam/multixact.c:869">RecordNewMultiXact</a>(MultiXactId multi, MultiXactOffset offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nmembers, MultiXactMember *members);<br/></li>
<li><span class="Type">static</span> MultiXactId <a href="#L985" title="access/transam/multixact.c:985">GetNewMultiXactId</a>(<span class="Type">int</span> nmembers, MultiXactOffset *offset);<br/></li>
<li><br/></li>
<li><span class="Comment">/* MultiXact cache management */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1540" title="access/transam/multixact.c:1540">mxactMemberComparator</a>(<span class="Type">const</span> <span class="Type">void</span> *arg1, <span class="Type">const</span> <span class="Type">void</span> *arg2);<br/></li>
<li><span class="Type">static</span> MultiXactId <a href="#L1570" title="access/transam/multixact.c:1570">mXactCacheGetBySet</a>(<span class="Type">int</span> nmembers, MultiXactMember *members);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1613" title="access/transam/multixact.c:1613">mXactCacheGetById</a>(MultiXactId multi, MultiXactMember **members);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1660" title="access/transam/multixact.c:1660">mXactCachePut</a>(MultiXactId multi, <span class="Type">int</span> nmembers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactMember *members);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L1705" title="access/transam/multixact.c:1705">mxstatus_to_string</a>(MultiXactStatus status);<br/></li>
<li><br/></li>
<li><span class="Comment">/* management of SLRU infrastructure */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2025" title="access/transam/multixact.c:2025">ZeroMultiXactOffsetPage</a>(int64 pageno, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> writeXlog);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2041" title="access/transam/multixact.c:2041">ZeroMultiXactMemberPage</a>(int64 pageno, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> writeXlog);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3220" title="access/transam/multixact.c:3220">MultiXactOffsetPagePrecedes</a>(int64 page1, int64 page2);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3240" title="access/transam/multixact.c:3240">MultiXactMemberPagePrecedes</a>(int64 page1, int64 page2);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3286" title="access/transam/multixact.c:3286">MultiXactOffsetPrecedes</a>(MultiXactOffset offset1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactOffset offset2);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2504" title="access/transam/multixact.c:2504">ExtendMultiXactOffset</a>(MultiXactId multi);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2536" title="access/transam/multixact.c:2536">ExtendMultiXactMember</a>(MultiXactOffset offset, <span class="Type">int</span> nmembers);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2791" title="access/transam/multixact.c:2791">MultiXactOffsetWouldWrap</a>(MultiXactOffset boundary,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MultiXactOffset start, uint32 distance);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2664" title="access/transam/multixact.c:2664">SetOffsetVacuumLimit</a>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_startup);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2839" title="access/transam/multixact.c:2839">find_multixact_start</a>(MultiXactId multi, MultiXactOffset *result);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3298" title="access/transam/multixact.c:3298">WriteMZeroPageXlogRec</a>(int64 pageno, uint8 info);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3312" title="access/transam/multixact.c:3312">WriteMTruncateXlogRec</a>(Oid oldestMultiDB,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactId startTruncOff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactId endTruncOff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactOffset startTruncMemb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactOffset endTruncMemb);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L392" title="access/transam/multixact.c:392">MultiXactIdCreate</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Construct a MultiXactId representing two TransactionIds.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The two XIDs must be different, or be requesting different statuses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB - we don't worry about our local MultiXactId cache here, because that<br/></li>
<li></span><span class="Comment"> * is handled by the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level routines.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MultiXactId<br/></li>
<li><a id="L392">&#x200c;</a><span class="linkable">MultiXactIdCreate</span>(TransactionId xid1, MultiXactStatus status1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid2, MultiXactStatus status2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactId newMulti;<br/></li>
<li>&nbsp; &nbsp; MultiXactMember members[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid1));<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!TransactionIdEquals(xid1, xid2) || (status1 != status2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L631" title="access/transam/multixact.c:631">MultiXactIdSetOldestMember</a>() must have been called already. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(MultiXactIdIsValid(<a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a>[<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>]));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: unlike <a href="#L445" title="access/transam/multixact.c:445">MultiXactIdExpand</a>, we don't bother to check that both XIDs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are still running.&nbsp; In typical usage, xid2 will be our own XID and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caller just did a check on xid1, so it'd be wasted effort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; members[<span class="Constant">0</span>].xid = xid1;<br/></li>
<li>&nbsp; &nbsp; members[<span class="Constant">0</span>].status = status1;<br/></li>
<li>&nbsp; &nbsp; members[<span class="Constant">1</span>].xid = xid2;<br/></li>
<li>&nbsp; &nbsp; members[<span class="Constant">1</span>].status = status2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newMulti = <a href="#L773" title="access/transam/multixact.c:773">MultiXactIdCreateFromMembers</a>(<span class="Constant">2</span>, members);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L334" title="access/transam/multixact.c:334">debug_elog3</a>(DEBUG2, <span class="Constant">&quot;Create: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1728" title="access/transam/multixact.c:1728">mxid_to_string</a>(newMulti, <span class="Constant">2</span>, members));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newMulti;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L445" title="access/transam/multixact.c:445">MultiXactIdExpand</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Add a TransactionId to a pre-existing MultiXactId.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the TransactionId is already a member of the passed MultiXactId with the<br/></li>
<li></span><span class="Comment"> * same status, just return it as-is.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we do NOT actually modify the membership of a pre-existing<br/></li>
<li></span><span class="Comment"> * MultiXactId; instead we create a new one.&nbsp; This is necessary to avoid<br/></li>
<li></span><span class="Comment"> * a race condition against code trying to wait for one MultiXactId to finish;<br/></li>
<li></span><span class="Comment"> * see notes in heapam.c.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB - we don't worry about our local MultiXactId cache here, because that<br/></li>
<li></span><span class="Comment"> * is handled by the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level routines.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: It is critical that MultiXactIds that come from an old <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> (i.e.<br/></li>
<li></span><span class="Comment"> * one upgraded by pg_upgrade from a <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> older than this feature) are not<br/></li>
<li></span><span class="Comment"> * passed in.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MultiXactId<br/></li>
<li><a id="L445">&#x200c;</a><span class="linkable">MultiXactIdExpand</span>(MultiXactId multi, TransactionId xid, MultiXactStatus status)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactId newMulti;<br/></li>
<li>&nbsp; &nbsp; MultiXactMember *members;<br/></li>
<li>&nbsp; &nbsp; MultiXactMember *newMembers;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmembers;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(MultiXactIdIsValid(multi));<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L631" title="access/transam/multixact.c:631">MultiXactIdSetOldestMember</a>() must have been called already. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(MultiXactIdIsValid(<a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a>[<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>]));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L336" title="access/transam/multixact.c:336">debug_elog5</a>(DEBUG2, <span class="Constant">&quot;Expand: received multi </span><span class="Special">%u</span><span class="Constant">, xid </span><span class="Special">%u</span><span class="Constant"> status </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multi, xid, <a href="#L1705" title="access/transam/multixact.c:1705">mxstatus_to_string</a>(status));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we don't allow for old multis here.&nbsp; The reason is that the only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caller of this function does a check that the multixact is no longer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nmembers = <a href="#L1252" title="access/transam/multixact.c:1252">GetMultiXactIdMembers</a>(multi, &amp;members, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nmembers &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactMember member;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The MultiXactId is obsolete.&nbsp; This can only happen if all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * MultiXactId members stop running between the caller checking and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * passing it to us.&nbsp; It would be better to return that fact to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller, but it would complicate the API and it's unlikely to happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * too often, so just deal with it by creating a singleton MultiXact.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; member.xid = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; member.status = status;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newMulti = <a href="#L773" title="access/transam/multixact.c:773">MultiXactIdCreateFromMembers</a>(<span class="Constant">1</span>, &amp;member);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L335" title="access/transam/multixact.c:335">debug_elog4</a>(DEBUG2, <span class="Constant">&quot;Expand: </span><span class="Special">%u</span><span class="Constant"> has no members, create singleton </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multi, newMulti);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> newMulti;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the TransactionId is already a member of the MultiXactId with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same status, just return the existing MultiXactId.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nmembers; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdEquals(members[i].xid, xid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (members[i].status == status))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L335" title="access/transam/multixact.c:335">debug_elog4</a>(DEBUG2, <span class="Constant">&quot;Expand: </span><span class="Special">%u</span><span class="Constant"> is already a member of </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid, multi);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(members);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> multi;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine which of the members of the MultiXactId are still of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interest. This is <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> running transaction, and also <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that grabbed something stronger than just a lock and was committed. (An<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update that aborted is of no interest here; and having more than one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update Xid in a multixact would cause errors elsewhere.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Removing dead members is not just an optimization: freezing of tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whose Xmax are multis depends on this behavior.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note we have the same race condition here as above: j could be 0 at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end of the loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newMembers = (MultiXactMember *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MultiXactMember) * (nmembers + <span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>, j = <span class="Constant">0</span>; i &lt; nmembers; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a>(members[i].xid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ISUPDATE_from_mxstatus(members[i].status) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>(members[i].xid)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newMembers[j].xid = members[i].xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newMembers[j++].status = members[i].status;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newMembers[j].xid = xid;<br/></li>
<li>&nbsp; &nbsp; newMembers[j++].status = status;<br/></li>
<li>&nbsp; &nbsp; newMulti = <a href="#L773" title="access/transam/multixact.c:773">MultiXactIdCreateFromMembers</a>(j, newMembers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(members);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(newMembers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L334" title="access/transam/multixact.c:334">debug_elog3</a>(DEBUG2, <span class="Constant">&quot;Expand: returning new multi </span><span class="Special">%u</span><span class="Constant">&quot;</span>, newMulti);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newMulti;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L557" title="access/transam/multixact.c:557">MultiXactIdIsRunning</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns whether a MultiXactId is &quot;running&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We return true if at least one member of the given MultiXactId is still<br/></li>
<li></span><span class="Comment"> * running.&nbsp; Note that a &quot;false&quot; result is certain not to change,<br/></li>
<li></span><span class="Comment"> * because it is not legal to add members to an existing MultiXactId.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller is expected to have verified that the multixact does not come from<br/></li>
<li></span><span class="Comment"> * a pg_upgraded share-locked tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L557">&#x200c;</a></span><span class="linkable">MultiXactIdIsRunning</span>(MultiXactId multi, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isLockOnly)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactMember *members;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmembers;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L334" title="access/transam/multixact.c:334">debug_elog3</a>(DEBUG2, <span class="Constant">&quot;IsRunning </span><span class="Special">%u</span><span class="Constant">?&quot;</span>, multi);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;false&quot; here means we assume our callers have checked that the given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multi cannot possibly come from a pg_upgraded database.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nmembers = <a href="#L1252" title="access/transam/multixact.c:1252">GetMultiXactIdMembers</a>(multi, &amp;members, <span class="Constant">false</span>, isLockOnly);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nmembers &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L333" title="access/transam/multixact.c:333">debug_elog2</a>(DEBUG2, <span class="Constant">&quot;IsRunning: no members&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Checking for myself is cheap compared to looking in shared memory;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return true if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> live subtransaction of the current top-level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction is a member.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is not needed for correctness, it's just a fast path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nmembers; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>(members[i].xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L334" title="access/transam/multixact.c:334">debug_elog3</a>(DEBUG2, <span class="Constant">&quot;IsRunning: I (</span><span class="Special">%d</span><span class="Constant">) am running!&quot;</span>, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(members);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This could be made faster by having another entry point in procarray.c,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * walking the PGPROC array only once for all the members.&nbsp; But in most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases nmembers should be small enough that it doesn't much matter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nmembers; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a>(members[i].xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L335" title="access/transam/multixact.c:335">debug_elog4</a>(DEBUG2, <span class="Constant">&quot;IsRunning: member </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%u</span><span class="Constant">) is running&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i, members[i].xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(members);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(members);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L334" title="access/transam/multixact.c:334">debug_elog3</a>(DEBUG2, <span class="Constant">&quot;IsRunning: </span><span class="Special">%u</span><span class="Constant"> is not running&quot;</span>, multi);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L631" title="access/transam/multixact.c:631">MultiXactIdSetOldestMember</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Save the oldest MultiXactId this transaction could be a member of.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We set the <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a> for a given transaction the first time it's<br/></li>
<li></span><span class="Comment"> * going to do some operation that might require a MultiXactId (tuple lock,<br/></li>
<li></span><span class="Comment"> * update or delete).&nbsp; We need to do this even if we end up using a<br/></li>
<li></span><span class="Comment"> * TransactionId instead of a MultiXactId, because there is a chance that<br/></li>
<li></span><span class="Comment"> * another transaction would add our XID to a MultiXactId.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The value to set is the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-to-be-assigned MultiXactId, so this is meant to<br/></li>
<li></span><span class="Comment"> * be called just <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such possibly-MultiXactId-able operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L631">&#x200c;</a></span><span class="linkable">MultiXactIdSetOldestMember</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!MultiXactIdIsValid(<a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a>[<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>]))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactId nextMXact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * You might think we don't need to acquire a lock here, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fetching and storing of TransactionIds is probably atomic, but in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fact we do: suppose we pick up nextMXact and then lose the CPU for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a long time.&nbsp; Someone else could advance nextMXact, and then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * another someone else could compute an <a href="#L300" title="access/transam/multixact.c:300">OldestVisibleMXactId</a> that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would be after the value we are going to store when we get control<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * back.&nbsp; Which would be wrong.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that a shared lock is sufficient, because it's enough to stop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * someone from advancing nextMXact; and nobody else could be trying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to write to our OldestMember entry, only reading (and we assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * storing it is atomic.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactGenLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to beware of the possibility that nextMXact is in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wrapped-around state.&nbsp; We don't fix the counter itself here, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must be sure to store a valid value in our array entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nextMXact = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nextMXact &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextMXact = FirstMultiXactId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a>[<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>] = nextMXact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L335" title="access/transam/multixact.c:335">debug_elog4</a>(DEBUG2, <span class="Constant">&quot;MultiXact: setting OldestMember[</span><span class="Special">%d</span><span class="Constant">] = </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>, nextMXact);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L688" title="access/transam/multixact.c:688">MultiXactIdSetOldestVisible</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Save the oldest MultiXactId this transaction considers possibly live.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We set the <a href="#L300" title="access/transam/multixact.c:300">OldestVisibleMXactId</a> for a given transaction the first time<br/></li>
<li></span><span class="Comment"> * it's going to inspect <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> MultiXactId.&nbsp; Once we have set this, we are<br/></li>
<li></span><span class="Comment"> * guaranteed that SLRU data for MultiXactIds &gt;= our own <a href="#L300" title="access/transam/multixact.c:300">OldestVisibleMXactId</a><br/></li>
<li></span><span class="Comment"> * won't be truncated away.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The value to set is the oldest of nextMXact and all the valid per-backend<br/></li>
<li></span><span class="Comment"> * <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a>[] entries.&nbsp; Because of the locking we do, we can be<br/></li>
<li></span><span class="Comment"> * certain that no subsequent call to <a href="#L631" title="access/transam/multixact.c:631">MultiXactIdSetOldestMember</a> can set<br/></li>
<li></span><span class="Comment"> * an <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a>[] entry older than what we compute here.&nbsp; Therefore<br/></li>
<li></span><span class="Comment"> * there is no live transaction, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> or later, that can be a member of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * MultiXactId older than the <a href="#L300" title="access/transam/multixact.c:300">OldestVisibleMXactId</a> we compute here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L688">&#x200c;</a></span><span class="linkable">MultiXactIdSetOldestVisible</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!MultiXactIdIsValid(<a href="#L300" title="access/transam/multixact.c:300">OldestVisibleMXactId</a>[<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>]))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactId oldestMXact;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactGenLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to beware of the possibility that nextMXact is in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wrapped-around state.&nbsp; We don't fix the counter itself here, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must be sure to store a valid value in our array entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldestMXact = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldestMXact &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestMXact = FirstMultiXactId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L295" title="access/transam/multixact.c:295">MaxOldestSlot</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactId thisoldest = <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (MultiXactIdIsValid(thisoldest) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(thisoldest, oldestMXact))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestMXact = thisoldest;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L300" title="access/transam/multixact.c:300">OldestVisibleMXactId</a>[<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>] = oldestMXact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L335" title="access/transam/multixact.c:335">debug_elog4</a>(DEBUG2, <span class="Constant">&quot;MultiXact: setting OldestVisible[</span><span class="Special">%d</span><span class="Constant">] = </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>, oldestMXact);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L729" title="access/transam/multixact.c:729">ReadNextMultiXactId</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> MultiXactId to be assigned, but don't allocate it<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MultiXactId<br/></li>
<li><a id="L729">&#x200c;</a><span class="linkable">ReadNextMultiXactId</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactId mxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> we could presumably do this without a lock. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactGenLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; mxid = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mxid &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mxid = FirstMultiXactId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> mxid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L749" title="access/transam/multixact.c:749">ReadMultiXactIdRange</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of IDs that may still be referenced by a relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L749">&#x200c;</a></span><span class="linkable">ReadMultiXactIdRange</span>(MultiXactId *oldest, MultiXactId *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactGenLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; *oldest = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestMultiXactId;<br/></li>
<li>&nbsp; &nbsp; *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*oldest &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *oldest = FirstMultiXactId;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = FirstMultiXactId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L773" title="access/transam/multixact.c:773">MultiXactIdCreateFromMembers</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Make a new MultiXactId from the specified set of members<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Make XLOG, SLRU and cache entries for a new MultiXactId, recording the<br/></li>
<li></span><span class="Comment"> * given TransactionIds as members.&nbsp; Returns the newly created MultiXactId.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: the passed members[] array will be sorted in-place.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MultiXactId<br/></li>
<li><a id="L773">&#x200c;</a><span class="linkable">MultiXactIdCreateFromMembers</span>(<span class="Type">int</span> nmembers, MultiXactMember *members)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactId multi;<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset offset;<br/></li>
<li>&nbsp; &nbsp; xl_multixact_create xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L334" title="access/transam/multixact.c:334">debug_elog3</a>(DEBUG2, <span class="Constant">&quot;Create: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1728" title="access/transam/multixact.c:1728">mxid_to_string</a>(InvalidMultiXactId, nmembers, members));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if the same set of members already exists in our cache; if so, just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-use that MultiXactId.&nbsp; (Note: it might seem that looking in our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cache is insufficient, and we ought to search disk to see if a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * duplicate definition already exists.&nbsp; But since we only ever create<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MultiXacts containing our own XID, in most cases <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such MultiXacts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * were in fact created by us, and so will be in our cache.&nbsp; There are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corner cases where someone else added us to a MultiXact without our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * knowledge, but it's not worth checking for.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; multi = <a href="#L1570" title="access/transam/multixact.c:1570">mXactCacheGetBySet</a>(nmembers, members);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultiXactIdIsValid(multi))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L333" title="access/transam/multixact.c:333">debug_elog2</a>(DEBUG2, <span class="Constant">&quot;Create: in cache!&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> multi;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Verify that there is a single update Xid among the given members. */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_update = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nmembers; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ISUPDATE_from_mxstatus(members[i].status))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (has_update)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;new multixact has more than one updating member: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1728" title="access/transam/multixact.c:1728">mxid_to_string</a>(InvalidMultiXactId, nmembers, members));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_update = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assign the MXID and offsets <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> to use, and make sure there is space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the OFFSETs and MEMBERs files.&nbsp; NB: this routine does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * START_CRIT_SECTION().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: unlike <a href="#L392" title="access/transam/multixact.c:392">MultiXactIdCreate</a> and <a href="#L445" title="access/transam/multixact.c:445">MultiXactIdExpand</a>, we do not check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we've called <a href="#L631" title="access/transam/multixact.c:631">MultiXactIdSetOldestMember</a> here.&nbsp; This is because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this routine is used in some places to create new MultiXactIds of which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the current backend is not a member, notably during freezing of multis<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.&nbsp; During <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>, in particular, it would be unacceptable to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keep OldestMulti set, in case it runs for long.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; multi = <a href="#L985" title="access/transam/multixact.c:985">GetNewMultiXactId</a>(nmembers, &amp;offset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make an XLOG entry describing the new MXID. */<br/></li>
<li></span>&nbsp; &nbsp; xlrec.mid = multi;<br/></li>
<li>&nbsp; &nbsp; xlrec.moff = offset;<br/></li>
<li>&nbsp; &nbsp; xlrec.nmembers = nmembers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Note: there's a lot of padding space in MultiXactMember.&nbsp; We could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a more <a href="../../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a> representation of this Xlog record -- perhaps all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the status flags in one XLogRecData, then all the xids in another one?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Not clear that it's worth the trouble though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xlrec), SizeOfMultiXactCreate);<br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) members, nmembers * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MultiXactMember));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_MULTIXACT_ID, XLOG_MULTIXACT_CREATE_ID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now enter the information into the OFFSETs and MEMBERs logs */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L869" title="access/transam/multixact.c:869">RecordNewMultiXact</a>(multi, offset, nmembers, members);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done with critical section */<br/></li>
<li></span>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store the new MultiXactId in the local cache, too */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1660" title="access/transam/multixact.c:1660">mXactCachePut</a>(multi, nmembers, members);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L333" title="access/transam/multixact.c:333">debug_elog2</a>(DEBUG2, <span class="Constant">&quot;Create: all done&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> multi;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L869" title="access/transam/multixact.c:869">RecordNewMultiXact</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Write info about a new multixact into the offsets and members files<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is broken out of <a href="#L773" title="access/transam/multixact.c:773">MultiXactIdCreateFromMembers</a> so that xlog replay can<br/></li>
<li></span><span class="Comment"> * use it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L869">&#x200c;</a></span><span class="linkable">RecordNewMultiXact</span>(MultiXactId multi, MultiXactOffset offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nmembers, MultiXactMember *members)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; prev_pageno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entryno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset *offptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *prevlock = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pageno = <a href="#L111" title="access/transam/multixact.c:111">MultiXactIdToOffsetPage</a>(multi);<br/></li>
<li>&nbsp; &nbsp; entryno = <a href="#L113" title="access/transam/multixact.c:113">MultiXactIdToOffsetEntry</a>(multi);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lock = SimpleLruGetBankLock(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, pageno);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we pass the MultiXactId to <a href="slru.c.html#L488" title="access/transam/slru.c:488">SimpleLruReadPage</a> as the &quot;transaction&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to complain about if there's <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> I/O error.&nbsp; This is kinda bogus, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since the errors will always give the full pathname, it should be clear<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enough that a MultiXactId is really involved.&nbsp; Perhaps someday we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * take the trouble to generalize the slru.c error reporting code.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; slotno = <a href="slru.c.html#L488" title="access/transam/slru.c:488">SimpleLruReadPage</a>(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, pageno, <span class="Constant">true</span>, multi);<br/></li>
<li>&nbsp; &nbsp; offptr = (MultiXactOffset *) <a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>-&gt;shared-&gt;page_buffer[slotno];<br/></li>
<li>&nbsp; &nbsp; offptr += entryno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *offptr = offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>-&gt;shared-&gt;page_dirty[slotno] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release MultiXactOffset SLRU lock. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If anybody was <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> to know the offset of this multixact ID we just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wrote, they can read it <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, so wake them up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(&amp;<a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextoff_cv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; prev_pageno = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nmembers; i++, offset++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId *memberptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp;&nbsp; *flagsptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; flagsval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bshift;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flagsoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memberoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(members[i].status &lt;= MultiXactStatusUpdate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageno = <a href="#L159" title="access/transam/multixact.c:159">MXOffsetToMemberPage</a>(offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memberoff = <a href="#L172" title="access/transam/multixact.c:172">MXOffsetToMemberOffset</a>(offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flagsoff = <a href="#L163" title="access/transam/multixact.c:163">MXOffsetToFlagsOffset</a>(offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bshift = <a href="#L167" title="access/transam/multixact.c:167">MXOffsetToFlagsBitShift</a>(offset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pageno != prev_pageno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * MultiXactMember SLRU page is changed so check if this new page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fall into the different SLRU bank then release the old bank's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock and acquire lock on the new bank.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock = SimpleLruGetBankLock(<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>, pageno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lock != prevlock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prevlock != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(prevlock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevlock = lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno = <a href="slru.c.html#L488" title="access/transam/slru.c:488">SimpleLruReadPage</a>(<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>, pageno, <span class="Constant">true</span>, multi);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_pageno = pageno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memberptr = (TransactionId *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>-&gt;shared-&gt;page_buffer[slotno] + memberoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *memberptr = members[i].xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flagsptr = (uint32 *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>-&gt;shared-&gt;page_buffer[slotno] + flagsoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flagsval = *flagsptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flagsval &amp;= ~(((<span class="Constant">1</span> &lt;&lt; <a href="#L130" title="access/transam/multixact.c:130">MXACT_MEMBER_BITS_PER_XACT</a>) - <span class="Constant">1</span>) &lt;&lt; bshift);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flagsval |= (members[i].status &lt;&lt; bshift);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *flagsptr = flagsval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>-&gt;shared-&gt;page_dirty[slotno] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prevlock != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(prevlock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L985" title="access/transam/multixact.c:985">GetNewMultiXactId</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Get the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> MultiXactId.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also, reserve the needed amount of space in the &quot;members&quot; area.&nbsp; The<br/></li>
<li></span><span class="Comment"> * starting offset of the reserved space is returned in *offset.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This may generate XLOG <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> for expansion of the offsets and/or members<br/></li>
<li></span><span class="Comment"> * files.&nbsp; Unfortunately, we have to do that while holding MultiXactGenLock<br/></li>
<li></span><span class="Comment"> * to avoid race conditions --- the XLOG record for zeroing a page must appear<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backend can possibly try to store data in that page!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We start a critical section <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> advancing the shared counters.&nbsp; The<br/></li>
<li></span><span class="Comment"> * caller must end the critical section after writing SLRU data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> MultiXactId<br/></li>
<li><a id="L985">&#x200c;</a><span class="linkable">GetNewMultiXactId</span>(<span class="Type">int</span> nmembers, MultiXactOffset *offset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactId result;<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset nextOffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L334" title="access/transam/multixact.c:334">debug_elog3</a>(DEBUG2, <span class="Constant">&quot;GetNew: for </span><span class="Special">%d</span><span class="Constant"> xids&quot;</span>, nmembers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* safety check, we should never get this far in a HS standby */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot assign MultiXactIds during recovery&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactGenLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle wraparound of the nextMXact counter */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact = FirstMultiXactId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assign the MXID */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check to see if it's safe to assign another MultiXactId.&nbsp; This protects<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * against catastrophic data loss due to multixact wraparound.&nbsp; The basic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rules are:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're past multiVacLimit or the safe threshold for member storage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space, or we don't know what the safe threshold for member storage is,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * start trying to force autovacuum cycles.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're past multiWarnLimit, start issuing warnings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're past multiStopLimit, refuse to create new MultiXactIds.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note these are pretty much the same protections in <a href="varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(result, <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;multiVacLimit))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For safety's sake, we release MultiXactGenLock while sending<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * signals, warnings, etc.&nbsp; This is not so much because we care about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * preserving concurrency in this situation, as to avoid <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possibility of deadlock while doing <a href="../../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a>(). First,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * copy all the shared <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> we'll need in this path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactId multiWarnLimit = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;multiWarnLimit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactId multiStopLimit = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;multiStopLimit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactId multiWrapLimit = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;multiWrapLimit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldest_datoid = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestMultiXactDB;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(result, multiStopLimit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *oldest_datname = <a href="../../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a>(oldest_datoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Immediately kick autovacuum into action as we're already in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ERROR territory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/pmsignal.c.html#L181" title="storage/ipc/pmsignal.c:181">SendPostmasterSignal</a>(PMSIGNAL_START_AUTOVAC_LAUNCHER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* complain even if that DB has disappeared */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldest_datname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database is not accepting commands that assign new MultiXactIds to avoid wraparound data loss in database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldest_datname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Execute a database-wide VACUUM in that database.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;You might also need to commit or roll back old prepared transactions, or drop stale replication slots.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database is not accepting commands that assign new MultiXactIds to avoid wraparound data loss in database with OID </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldest_datoid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Execute a database-wide VACUUM in that database.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;You might also need to commit or roll back old prepared transactions, or drop stale replication slots.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To avoid swamping the postmaster with signals, we issue the autovac<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * request only once per 64K multis generated.&nbsp; This still gives<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * plenty of chances <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we get into real trouble.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> &amp;&amp; (result % <span class="Constant">65536</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/pmsignal.c.html#L181" title="storage/ipc/pmsignal.c:181">SendPostmasterSignal</a>(PMSIGNAL_START_AUTOVAC_LAUNCHER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(result, multiWarnLimit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *oldest_datname = <a href="../../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a>(oldest_datoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* complain even if that DB has disappeared */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldest_datname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1182" title="utils/error/elog.c:1182">errmsg_plural</a>(<span class="Constant">&quot;database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be vacuumed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> </span><span class="Special">%u</span><span class="Constant"> more MultiXactId is used&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be vacuumed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> </span><span class="Special">%u</span><span class="Constant"> more MultiXactIds are used&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; multiWrapLimit - result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldest_datname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; multiWrapLimit - result),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Execute a database-wide VACUUM in that database.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;You might also need to commit or roll back old prepared transactions, or drop stale replication slots.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1182" title="utils/error/elog.c:1182">errmsg_plural</a>(<span class="Constant">&quot;database with OID </span><span class="Special">%u</span><span class="Constant"> must be vacuumed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> </span><span class="Special">%u</span><span class="Constant"> more MultiXactId is used&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;database with OID </span><span class="Special">%u</span><span class="Constant"> must be vacuumed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> </span><span class="Special">%u</span><span class="Constant"> more MultiXactIds are used&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; multiWrapLimit - result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldest_datoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; multiWrapLimit - result),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Execute a database-wide VACUUM in that database.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;You might also need to commit or roll back old prepared transactions, or drop stale replication slots.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Re-acquire lock and start over */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactGenLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = FirstMultiXactId;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure there is room for the MXID in the file.&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2504" title="access/transam/multixact.c:2504">ExtendMultiXactOffset</a>(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reserve the members space, similarly to above.&nbsp; Also, be careful not to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return zero as the starting offset for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> multixact. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1252" title="access/transam/multixact.c:1252">GetMultiXactIdMembers</a>() for motivation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nextOffset = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextOffset;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nextOffset == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *offset = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nmembers++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocate member slot 0 too */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *offset = nextOffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Protect against overrun of the members space as well, with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * following rules:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're past offsetStopLimit, refuse to generate more multis.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're close to offsetStopLimit, emit a warning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Arbitrarily, we start emitting warnings when we're 20 segments or less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from offsetStopLimit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note we haven't updated the shared state yet, so if we fail at this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point, the multixact ID we grabbed can still be used by the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> guy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that there is no point in forcing autovacuum runs here: the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multixact freeze settings would have to be reduced for that to have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * effect.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li><a id="L1138">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">OFFSET_WARN_SEGMENTS</span>&nbsp; &nbsp; </span><span class="Constant">20<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestOffsetKnown &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2791" title="access/transam/multixact.c:2791">MultiXactOffsetWouldWrap</a>(<a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;offsetStopLimit, nextOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nmembers))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see comment in the corresponding offsets wraparound case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/pmsignal.c.html#L181" title="storage/ipc/pmsignal.c:181">SendPostmasterSignal</a>(PMSIGNAL_START_AUTOVAC_LAUNCHER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;multixact </span><span class="Special">\&quot;</span><span class="Constant">members</span><span class="Special">\&quot;</span><span class="Constant"> limit exceeded&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1297" title="utils/error/elog.c:1297">errdetail_plural</a>(<span class="Constant">&quot;This command would create a multixact with </span><span class="Special">%u</span><span class="Constant"> members, but the remaining space is only enough for </span><span class="Special">%u</span><span class="Constant"> member.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;This command would create a multixact with </span><span class="Special">%u</span><span class="Constant"> members, but the remaining space is only enough for </span><span class="Special">%u</span><span class="Constant"> members.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;offsetStopLimit - nextOffset - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmembers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;offsetStopLimit - nextOffset - <span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Execute a database-wide VACUUM in database with OID </span><span class="Special">%u</span><span class="Constant"> with reduced <a href="../../commands/vacuum.c.html#L69" title="commands/vacuum.c:69">vacuum_multixact_freeze_min_age</a> and <a href="../../commands/vacuum.c.html#L70" title="commands/vacuum.c:70">vacuum_multixact_freeze_table_age</a> settings.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestMultiXactDB)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check whether we should kick autovacuum into action, to prevent members<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wraparound. NB we use a much larger window to <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> autovacuum than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just the warning limit. The warning is just a measure of last resort -<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this is in line with <a href="varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a>'s behaviour.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestOffsetKnown ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextOffset - <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestOffset<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &gt; <a href="#L177" title="access/transam/multixact.c:177">MULTIXACT_MEMBER_SAFE_THRESHOLD</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To avoid swamping the postmaster with signals, we issue the autovac<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * request only when crossing a segment boundary. With default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * compilation settings that's roughly after 50k members.&nbsp; This still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * gives plenty of chances <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we get into real trouble.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((<a href="#L159" title="access/transam/multixact.c:159">MXOffsetToMemberPage</a>(nextOffset) / SLRU_PAGES_PER_SEGMENT) !=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L159" title="access/transam/multixact.c:159">MXOffsetToMemberPage</a>(nextOffset + nmembers) / SLRU_PAGES_PER_SEGMENT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/pmsignal.c.html#L181" title="storage/ipc/pmsignal.c:181">SendPostmasterSignal</a>(PMSIGNAL_START_AUTOVAC_LAUNCHER);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestOffsetKnown &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2791" title="access/transam/multixact.c:2791">MultiXactOffsetWouldWrap</a>(<a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;offsetStopLimit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nextOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nmembers + <a href="#L142" title="access/transam/multixact.c:142">MULTIXACT_MEMBERS_PER_PAGE</a> * SLRU_PAGES_PER_SEGMENT * <a href="#L1138" title="access/transam/multixact.c:1138">OFFSET_WARN_SEGMENTS</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1182" title="utils/error/elog.c:1182">errmsg_plural</a>(<span class="Constant">&quot;database with OID </span><span class="Special">%u</span><span class="Constant"> must be vacuumed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> </span><span class="Special">%d</span><span class="Constant"> more multixact member is used&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;database with OID </span><span class="Special">%u</span><span class="Constant"> must be vacuumed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> </span><span class="Special">%d</span><span class="Constant"> more multixact members are used&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;offsetStopLimit - nextOffset + nmembers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestMultiXactDB,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;offsetStopLimit - nextOffset + nmembers),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Execute a database-wide VACUUM in that database with reduced <a href="../../commands/vacuum.c.html#L69" title="commands/vacuum.c:69">vacuum_multixact_freeze_min_age</a> and <a href="../../commands/vacuum.c.html#L70" title="commands/vacuum.c:70">vacuum_multixact_freeze_table_age</a> settings.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2536" title="access/transam/multixact.c:2536">ExtendMultiXactMember</a>(nextOffset, nmembers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Critical section from here until caller has written the data into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just-reserved SLRU space; we don't want to error out with a partly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * written MultiXact structure.&nbsp; (In particular, failing to write our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * start offset after advancing nextMXact would effectively corrupt the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previous MultiXact.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advance counters.&nbsp; As in <a href="varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a>(), this must not happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until after file extension has succeeded!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't care about MultiXactId wraparound here; it will be handled by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iteration.&nbsp; But note that nextMXact may be InvalidMultiXactId<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or the first value on a segment-beginning page after this routine<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exits, so anyone else looking at the variable must be prepared to deal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with either case.&nbsp; Similarly, nextOffset may be zero, but we won't use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that as the actual start offset of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> multixact.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (<a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact)++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextOffset += nmembers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L335" title="access/transam/multixact.c:335">debug_elog4</a>(DEBUG2, <span class="Constant">&quot;GetNew: returning </span><span class="Special">%u</span><span class="Constant"> offset </span><span class="Special">%u</span><span class="Constant">&quot;</span>, result, *offset);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1252" title="access/transam/multixact.c:1252">GetMultiXactIdMembers</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return the set of MultiXactMembers that make up a MultiXactId<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is the number of members found, or -1 if there are <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>,<br/></li>
<li></span><span class="Comment"> * and *members is set to a newly <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'ed array of members.&nbsp; It's the<br/></li>
<li></span><span class="Comment"> * caller's responsibility to free it when done with it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * from_pgupgrade must be passed as true if and only if only the multixact<br/></li>
<li></span><span class="Comment"> * corresponds to a value from a tuple that was locked in a 9.2-or-older<br/></li>
<li></span><span class="Comment"> * installation and later pg_upgrade'd (that is, the infomask is<br/></li>
<li></span><span class="Comment"> * HEAP_LOCKED_UPGRADED).&nbsp; In this case, we know for certain that no members<br/></li>
<li></span><span class="Comment"> * can still be running, so we return -1 just like for an empty multixact<br/></li>
<li></span><span class="Comment"> * without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further checking.&nbsp; It would be wrong to try to resolve such a<br/></li>
<li></span><span class="Comment"> * multixact: either the multixact is within the current valid multixact<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, in which case the returned result would be bogus, or outside that<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, in which case an error would be raised.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In all other cases, the passed multixact must be within the known valid<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, that is, greater to or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> than oldestMultiXactId, and less than<br/></li>
<li></span><span class="Comment"> * nextMXact.&nbsp; Otherwise, an error is raised.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * isLockOnly must be set to true if caller is certain that the given multi<br/></li>
<li></span><span class="Comment"> * is used only to lock tuples; can be false without loss of correctness,<br/></li>
<li></span><span class="Comment"> * but passing a true means we can return quickly without checking for<br/></li>
<li></span><span class="Comment"> * old updates.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1252">&#x200c;</a></span><span class="linkable">GetMultiXactIdMembers</span>(MultiXactId multi, MultiXactMember **members,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> from_pgupgrade, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isLockOnly)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; prev_pageno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entryno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset *offptr;<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; length;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; truelength;<br/></li>
<li>&nbsp; &nbsp; MultiXactId oldestMXact;<br/></li>
<li>&nbsp; &nbsp; MultiXactId nextMXact;<br/></li>
<li>&nbsp; &nbsp; MultiXactId tmpMXact;<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset nextOffset;<br/></li>
<li>&nbsp; &nbsp; MultiXactMember *ptr;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; slept = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L334" title="access/transam/multixact.c:334">debug_elog3</a>(DEBUG2, <span class="Constant">&quot;GetMembers: asked for </span><span class="Special">%u</span><span class="Constant">&quot;</span>, multi);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!MultiXactIdIsValid(multi) || from_pgupgrade)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *members = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See if the MultiXactId is in the local cache */<br/></li>
<li></span>&nbsp; &nbsp; length = <a href="#L1613" title="access/transam/multixact.c:1613">mXactCacheGetById</a>(multi, members);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (length &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L334" title="access/transam/multixact.c:334">debug_elog3</a>(DEBUG2, <span class="Constant">&quot;GetMembers: found </span><span class="Special">%s</span><span class="Constant"> in the cache&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1728" title="access/transam/multixact.c:1728">mxid_to_string</a>(multi, length, *members));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> length;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set our <a href="#L300" title="access/transam/multixact.c:300">OldestVisibleMXactId</a>[] entry if we didn't already */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L688" title="access/transam/multixact.c:688">MultiXactIdSetOldestVisible</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we know the multi is used only for locking and not for updates, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> checking if the value is older than our oldest visible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multi.&nbsp; It cannot possibly still be running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isLockOnly &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(multi, <a href="#L300" title="access/transam/multixact.c:300">OldestVisibleMXactId</a>[<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>]))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L333" title="access/transam/multixact.c:333">debug_elog2</a>(DEBUG2, <span class="Constant">&quot;GetMembers: a locker-only multi is too old&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *members = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We check known limits on MultiXact <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> resorting to the SLRU area.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * An ID older than <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestMultiXactId cannot possibly be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * useful; it has already been removed, or will be removed shortly, by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * truncation.&nbsp; If one is passed, an error is raised.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, an ID &gt;= nextMXact shouldn't ever be seen here; if it is seen, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implies undetected ID wraparound has occurred.&nbsp; This raises a hard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Shared lock is enough here since we aren't modifying <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> global state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Acquire it just long enough to grab the current counter <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; We may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need both nextMXact and nextOffset; see below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactGenLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldestMXact = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestMultiXactId;<br/></li>
<li>&nbsp; &nbsp; nextMXact = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact;<br/></li>
<li>&nbsp; &nbsp; nextOffset = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextOffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(multi, oldestMXact))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERNAL_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;MultiXactId </span><span class="Special">%u</span><span class="Constant"> does no longer exist -- apparent wraparound&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multi)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(multi, nextMXact))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERNAL_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;MultiXactId </span><span class="Special">%u</span><span class="Constant"> has not been created yet -- apparent wraparound&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multi)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find out the offset at which we need to start reading MultiXactMembers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and the number of members in the multixact.&nbsp; We determine the latter as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the difference between this multixact's starting offset and the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one's.&nbsp; However, there are some corner cases to worry about:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 1. This multixact may be the latest one created, in which case there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one to look at.&nbsp; In this case the nextOffset value we just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * saved is the correct endpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 2. The <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> multixact may still be in process of being filled in: that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is, another process may have done <a href="#L985" title="access/transam/multixact.c:985">GetNewMultiXactId</a> but not yet written<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the offset entry for that ID.&nbsp; In that scenario, it is guaranteed that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the offset entry for that multixact exists (because <a href="#L985" title="access/transam/multixact.c:985">GetNewMultiXactId</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * won't release MultiXactGenLock until it does) but contains zero<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (because we are careful to pre-zero offset pages). Because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L985" title="access/transam/multixact.c:985">GetNewMultiXactId</a> will never return zero as the starting offset for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multixact, when we read zero as the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> multixact's offset, we know we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have this case.&nbsp; We handle this by sleeping on the condition variable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we have just for this; the process in <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> will signal the CV as soon<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as it has finished writing the multixact offset.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 3. Because <a href="#L985" title="access/transam/multixact.c:985">GetNewMultiXactId</a> increments offset zero to offset one to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handle case #2, there is an ambiguity near the point of offset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wraparound.&nbsp; If we see <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> multixact's offset is one, is that our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multixact's actual endpoint, or did it end at zero with a subsequent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * increment?&nbsp; We handle this using the knowledge that if the zero'th<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * member slot wasn't filled, it'll contain zero, and zero isn't a valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction ID so it can't be a multixact member.&nbsp; Therefore, if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read a zero from the members array, just ignore it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is all pretty messy, but the mess occurs only in infrequent corner<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases, so it seems better than holding the MultiXactGenLock for a long<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * time on every multixact creation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Statement">retry</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; pageno = <a href="#L111" title="access/transam/multixact.c:111">MultiXactIdToOffsetPage</a>(multi);<br/></li>
<li>&nbsp; &nbsp; entryno = <a href="#L113" title="access/transam/multixact.c:113">MultiXactIdToOffsetEntry</a>(multi);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Acquire the bank lock for the page we need. */<br/></li>
<li></span>&nbsp; &nbsp; lock = SimpleLruGetBankLock(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, pageno);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slotno = <a href="slru.c.html#L488" title="access/transam/slru.c:488">SimpleLruReadPage</a>(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, pageno, <span class="Constant">true</span>, multi);<br/></li>
<li>&nbsp; &nbsp; offptr = (MultiXactOffset *) <a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>-&gt;shared-&gt;page_buffer[slotno];<br/></li>
<li>&nbsp; &nbsp; offptr += entryno;<br/></li>
<li>&nbsp; &nbsp; offset = *offptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(offset != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use the same increment rule as <a href="#L985" title="access/transam/multixact.c:985">GetNewMultiXactId</a>(), that is, don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handle wraparound explicitly until needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tmpMXact = multi + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nextMXact == tmpMXact)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Corner case 1: there is no <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> multixact */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; length = nextOffset - offset;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactOffset nextMXOffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* handle wraparound if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tmpMXact &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmpMXact = FirstMultiXactId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prev_pageno = pageno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageno = <a href="#L111" title="access/transam/multixact.c:111">MultiXactIdToOffsetPage</a>(tmpMXact);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entryno = <a href="#L113" title="access/transam/multixact.c:113">MultiXactIdToOffsetEntry</a>(tmpMXact);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pageno != prev_pageno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *newlock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we're going to access a different SLRU page, if this page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * falls under a different bank, release the old bank's lock and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * acquire the lock of the new bank.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlock = SimpleLruGetBankLock(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, pageno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newlock != lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(newlock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock = newlock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno = <a href="slru.c.html#L488" title="access/transam/slru.c:488">SimpleLruReadPage</a>(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, pageno, <span class="Constant">true</span>, tmpMXact);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offptr = (MultiXactOffset *) <a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>-&gt;shared-&gt;page_buffer[slotno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offptr += entryno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nextMXOffset = *offptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nextMXOffset == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Corner case 2: <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> multixact is still being filled in */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L96" title="storage/lmgr/condition_variable.c:96">ConditionVariableSleep</a>(&amp;<a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextoff_cv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_MULTIXACT_CREATION);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slept = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> retry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; length = nextMXOffset - offset;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>&nbsp; &nbsp; lock = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we slept above, clean up state; it's no longer needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (slept)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ptr = (MultiXactMember *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(length * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MultiXactMember));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; truelength = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; prev_pageno = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; length; i++, offset++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId *xactptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp;&nbsp; *flagsptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flagsoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bshift;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memberoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageno = <a href="#L159" title="access/transam/multixact.c:159">MXOffsetToMemberPage</a>(offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memberoff = <a href="#L172" title="access/transam/multixact.c:172">MXOffsetToMemberOffset</a>(offset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pageno != prev_pageno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *newlock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we're going to access a different SLRU page, if this page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * falls under a different bank, release the old bank's lock and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * acquire the lock of the new bank.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlock = SimpleLruGetBankLock(<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>, pageno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newlock != lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(newlock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock = newlock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno = <a href="slru.c.html#L488" title="access/transam/slru.c:488">SimpleLruReadPage</a>(<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>, pageno, <span class="Constant">true</span>, multi);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_pageno = pageno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xactptr = (TransactionId *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>-&gt;shared-&gt;page_buffer[slotno] + memberoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(*xactptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Corner case 3: we must be looking at unused slot zero */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(offset == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flagsoff = <a href="#L163" title="access/transam/multixact.c:163">MXOffsetToFlagsOffset</a>(offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bshift = <a href="#L167" title="access/transam/multixact.c:167">MXOffsetToFlagsBitShift</a>(offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flagsptr = (uint32 *) (<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>-&gt;shared-&gt;page_buffer[slotno] + flagsoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr[truelength].xid = *xactptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr[truelength].status = (*flagsptr &gt;&gt; bshift) &amp; <a href="#L132" title="access/transam/multixact.c:132">MXACT_MEMBER_XACT_BITMASK</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; truelength++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* A multixid with zero members should not happen */<br/></li>
<li></span>&nbsp; &nbsp; Assert(truelength &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the result into the local cache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1660" title="access/transam/multixact.c:1660">mXactCachePut</a>(multi, truelength, ptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L334" title="access/transam/multixact.c:334">debug_elog3</a>(DEBUG2, <span class="Constant">&quot;GetMembers: no cache for </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1728" title="access/transam/multixact.c:1728">mxid_to_string</a>(multi, truelength, ptr));<br/></li>
<li>&nbsp; &nbsp; *members = ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> truelength;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1540" title="access/transam/multixact.c:1540">mxactMemberComparator</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; qsort comparison function for MultiXactMember<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can't use wraparound comparison for XIDs because that does not respect<br/></li>
<li></span><span class="Comment"> * the triangle inequality!&nbsp; Any old sort order will do.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1540">&#x200c;</a></span><span class="linkable">mxactMemberComparator</span>(<span class="Type">const</span> <span class="Type">void</span> *arg1, <span class="Type">const</span> <span class="Type">void</span> *arg2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactMember member1 = *(<span class="Type">const</span> MultiXactMember *) arg1;<br/></li>
<li>&nbsp; &nbsp; MultiXactMember member2 = *(<span class="Type">const</span> MultiXactMember *) arg2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (member1.xid &gt; member2.xid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (member1.xid &lt; member2.xid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (member1.status &gt; member2.status)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (member1.status &lt; member2.status)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1570" title="access/transam/multixact.c:1570">mXactCacheGetBySet</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returns a MultiXactId from the cache based on the set of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; TransactionIds that compose it, or InvalidMultiXactId if<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> matches.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is helpful, for example, if two transactions want to lock a huge<br/></li>
<li></span><span class="Comment"> * table.&nbsp; By using the cache, the second will use the same MultiXactId<br/></li>
<li></span><span class="Comment"> * for the majority of tuples, thus keeping MultiXactId usage low (saving<br/></li>
<li></span><span class="Comment"> * both I/O and wraparound issues).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: the passed members array will be sorted in-place.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> MultiXactId<br/></li>
<li><a id="L1570">&#x200c;</a><span class="linkable">mXactCacheGetBySet</span>(<span class="Type">int</span> nmembers, MultiXactMember *members)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L334" title="access/transam/multixact.c:334">debug_elog3</a>(DEBUG2, <span class="Constant">&quot;CacheGet: looking for </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1728" title="access/transam/multixact.c:1728">mxid_to_string</a>(InvalidMultiXactId, nmembers, members));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sort the array so comparison is easy */<br/></li>
<li></span>&nbsp; &nbsp; qsort(members, nmembers, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MultiXactMember), <a href="#L1540" title="access/transam/multixact.c:1540">mxactMemberComparator</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dclist_foreach(iter, &amp;<a href="#L329" title="access/transam/multixact.c:329">MXactCache</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L320" title="access/transam/multixact.c:320">mXactCacheEnt</a> *entry = dclist_container(<a href="#L320" title="access/transam/multixact.c:320">mXactCacheEnt</a>, node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;nmembers != nmembers)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We assume the cache entries are sorted, and that the unused bits in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;status&quot; are zeroed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (memcmp(members, entry-&gt;members, nmembers * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MultiXactMember)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L334" title="access/transam/multixact.c:334">debug_elog3</a>(DEBUG2, <span class="Constant">&quot;CacheGet: found </span><span class="Special">%u</span><span class="Constant">&quot;</span>, entry-&gt;multi);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dclist_move_head(&amp;<a href="#L329" title="access/transam/multixact.c:329">MXactCache</a>, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> entry-&gt;multi;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L333" title="access/transam/multixact.c:333">debug_elog2</a>(DEBUG2, <span class="Constant">&quot;CacheGet: not found :-(&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidMultiXactId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1613" title="access/transam/multixact.c:1613">mXactCacheGetById</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returns the composing MultiXactMember set from the cache for a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; given MultiXactId, if present.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If successful, *xids is set to the address of a <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d copy of the<br/></li>
<li></span><span class="Comment"> * MultiXactMember set.&nbsp; Return value is number of members, or -1 on failure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1613">&#x200c;</a></span><span class="linkable">mXactCacheGetById</span>(MultiXactId multi, MultiXactMember **members)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L334" title="access/transam/multixact.c:334">debug_elog3</a>(DEBUG2, <span class="Constant">&quot;CacheGet: looking for </span><span class="Special">%u</span><span class="Constant">&quot;</span>, multi);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dclist_foreach(iter, &amp;<a href="#L329" title="access/transam/multixact.c:329">MXactCache</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L320" title="access/transam/multixact.c:320">mXactCacheEnt</a> *entry = dclist_container(<a href="#L320" title="access/transam/multixact.c:320">mXactCacheEnt</a>, node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry-&gt;multi == multi)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactMember *ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MultiXactMember) * entry-&gt;nmembers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = (MultiXactMember *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, entry-&gt;members, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L334" title="access/transam/multixact.c:334">debug_elog3</a>(DEBUG2, <span class="Constant">&quot;CacheGet: found </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1728" title="access/transam/multixact.c:1728">mxid_to_string</a>(multi,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; entry-&gt;nmembers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; entry-&gt;members));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note we modify the list while not using a modifiable iterator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is acceptable only because we exit the iteration<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * immediately afterwards.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dclist_move_head(&amp;<a href="#L329" title="access/transam/multixact.c:329">MXactCache</a>, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *members = ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> entry-&gt;nmembers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L333" title="access/transam/multixact.c:333">debug_elog2</a>(DEBUG2, <span class="Constant">&quot;CacheGet: not found&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1660" title="access/transam/multixact.c:1660">mXactCachePut</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Add a new MultiXactId and its composing set into the local cache.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1660">&#x200c;</a></span><span class="linkable">mXactCachePut</span>(MultiXactId multi, <span class="Type">int</span> nmembers, MultiXactMember *members)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L320" title="access/transam/multixact.c:320">mXactCacheEnt</a> *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L334" title="access/transam/multixact.c:334">debug_elog3</a>(DEBUG2, <span class="Constant">&quot;CachePut: storing </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1728" title="access/transam/multixact.c:1728">mxid_to_string</a>(multi, nmembers, members));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L330" title="access/transam/multixact.c:330">MXactContext</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The cache only lives as long as the current transaction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L333" title="access/transam/multixact.c:333">debug_elog2</a>(DEBUG2, <span class="Constant">&quot;CachePut: initializing memory context&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L330" title="access/transam/multixact.c:330">MXactContext</a> = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;MultiXact cache context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry = (<a href="#L320" title="access/transam/multixact.c:320">mXactCacheEnt</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="#L330" title="access/transam/multixact.c:330">MXactContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetof(<a href="#L320" title="access/transam/multixact.c:320">mXactCacheEnt</a>, members) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nmembers * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MultiXactMember));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry-&gt;multi = multi;<br/></li>
<li>&nbsp; &nbsp; entry-&gt;nmembers = nmembers;<br/></li>
<li>&nbsp; &nbsp; memcpy(entry-&gt;members, members, nmembers * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MultiXactMember));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L1570" title="access/transam/multixact.c:1570">mXactCacheGetBySet</a> assumes the entries are sorted, so sort them */<br/></li>
<li></span>&nbsp; &nbsp; qsort(entry-&gt;members, nmembers, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MultiXactMember), <a href="#L1540" title="access/transam/multixact.c:1540">mxactMemberComparator</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dclist_push_head(&amp;<a href="#L329" title="access/transam/multixact.c:329">MXactCache</a>, &amp;entry-&gt;node);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dclist_count(&amp;<a href="#L329" title="access/transam/multixact.c:329">MXactCache</a>) &gt; <a href="#L328" title="access/transam/multixact.c:328">MAX_CACHE_ENTRIES</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_node *node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node = dclist_tail_node(&amp;<a href="#L329" title="access/transam/multixact.c:329">MXactCache</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dclist_delete_from(&amp;<a href="#L329" title="access/transam/multixact.c:329">MXactCache</a>, node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry = dclist_container(<a href="#L320" title="access/transam/multixact.c:320">mXactCacheEnt</a>, node, node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L334" title="access/transam/multixact.c:334">debug_elog3</a>(DEBUG2, <span class="Constant">&quot;CachePut: pruning cached multi </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;multi);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(entry);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1705">&#x200c;</a><span class="linkable">mxstatus_to_string</span>(MultiXactStatus status)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (status)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MultiXactStatusForKeyShare:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;keysh&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MultiXactStatusForShare:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;sh&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MultiXactStatusForNoKeyUpdate:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;fornokeyupd&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MultiXactStatusForUpdate:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;forupd&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MultiXactStatusNoKeyUpdate:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;nokeyupd&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MultiXactStatusUpdate:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;upd&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized multixact status </span><span class="Special">%d</span><span class="Constant">&quot;</span>, status);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">char</span> *<br/></li>
<li><a id="L1728">&#x200c;</a><span class="linkable">mxid_to_string</span>(MultiXactId multi, <span class="Type">int</span> nmembers, MultiXactMember *members)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> *str = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (str != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">[</span><span class="Special">%u</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>, multi, nmembers, members[<span class="Constant">0</span>].xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1705" title="access/transam/multixact.c:1705">mxstatus_to_string</a>(members[<span class="Constant">0</span>].status));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; nmembers; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;, </span><span class="Special">%u</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>, members[i].xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1705" title="access/transam/multixact.c:1705">mxstatus_to_string</a>(members[i].status));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;buf, <span class="Constant">']'</span>);<br/></li>
<li>&nbsp; &nbsp; str = <a href="../../utils/mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, buf.data);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> str;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1759" title="access/transam/multixact.c:1759">AtEOXact_MultiXact</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Handle transaction end for MultiXact<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called at top transaction commit or abort (we don't care which).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1759">&#x200c;</a></span><span class="linkable">AtEOXact_MultiXact</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset our <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a> and <a href="#L300" title="access/transam/multixact.c:300">OldestVisibleMXactId</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, both of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which should only be valid while within a transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We assume that storing a MultiXactId is atomic and so we need not take<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MultiXactGenLock to do this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a>[<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>] = InvalidMultiXactId;<br/></li>
<li>&nbsp; &nbsp; <a href="#L300" title="access/transam/multixact.c:300">OldestVisibleMXactId</a>[<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>] = InvalidMultiXactId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Discard the local MultiXactId cache.&nbsp; Since <a href="#L330" title="access/transam/multixact.c:330">MXactContext</a> was created as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a child of <a href="../../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>, we needn't delete it explicitly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L330" title="access/transam/multixact.c:330">MXactContext</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; dclist_init(&amp;<a href="#L329" title="access/transam/multixact.c:329">MXactCache</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1787" title="access/transam/multixact.c:1787">AtPrepare_MultiXact</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Save multixact state at 2PC transaction prepare<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In this phase, we only store our <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a> value in the two-phase<br/></li>
<li></span><span class="Comment"> * state file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1787">&#x200c;</a></span><span class="linkable">AtPrepare_MultiXact</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactId myOldestMember = <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a>[<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultiXactIdIsValid(myOldestMember))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="twophase.c.html#L1280" title="access/transam/twophase.c:1280">RegisterTwoPhaseRecord</a>(TWOPHASE_RM_MULTIXACT_ID, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;myOldestMember, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MultiXactId));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1801" title="access/transam/multixact.c:1801">PostPrepare_MultiXact</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Clean up after successful PREPARE TRANSACTION<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1801">&#x200c;</a></span><span class="linkable">PostPrepare_MultiXact</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactId myOldestMember;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Transfer our <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a> value to the slot reserved for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prepared transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; myOldestMember = <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a>[<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (MultiXactIdIsValid(myOldestMember))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ProcNumber&nbsp; &nbsp; dummyProcNumber = <a href="twophase.c.html#L903" title="access/transam/twophase.c:903">TwoPhaseGetDummyProcNumber</a>(xid, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Even though storing MultiXactId is atomic, acquire lock to make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sure others see both changes, not just the reset of the slot of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current backend. Using a volatile pointer might suffice, but this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * isn't a hot spot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactGenLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a>[dummyProcNumber] = myOldestMember;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a>[<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>] = InvalidMultiXactId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactGenLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't need to transfer <a href="#L300" title="access/transam/multixact.c:300">OldestVisibleMXactId</a> value, because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction is not going to be looking at <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more multixacts once it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prepared.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We assume that storing a MultiXactId is atomic and so we need not take<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MultiXactGenLock to do this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L300" title="access/transam/multixact.c:300">OldestVisibleMXactId</a>[<a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>] = InvalidMultiXactId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Discard the local MultiXactId cache like in <a href="#L1759" title="access/transam/multixact.c:1759">AtEOXact_MultiXact</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L330" title="access/transam/multixact.c:330">MXactContext</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; dclist_init(&amp;<a href="#L329" title="access/transam/multixact.c:329">MXactCache</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1850" title="access/transam/multixact.c:1850">multixact_twophase_recover</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Recover the state of a prepared transaction at startup<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1850">&#x200c;</a></span><span class="linkable">multixact_twophase_recover</span>(TransactionId xid, uint16 info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *recdata, uint32 len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ProcNumber&nbsp; &nbsp; dummyProcNumber = <a href="twophase.c.html#L903" title="access/transam/twophase.c:903">TwoPhaseGetDummyProcNumber</a>(xid, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; MultiXactId oldestMember;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the oldest member XID from the state file record, and set it in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a> slot reserved for this prepared transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(len == <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MultiXactId));<br/></li>
<li>&nbsp; &nbsp; oldestMember = *((MultiXactId *) recdata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a>[dummyProcNumber] = oldestMember;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1871" title="access/transam/multixact.c:1871">multixact_twophase_postcommit</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Similar to <a href="#L1759" title="access/transam/multixact.c:1759">AtEOXact_MultiXact</a> but for COMMIT PREPARED<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1871">&#x200c;</a></span><span class="linkable">multixact_twophase_postcommit</span>(TransactionId xid, uint16 info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *recdata, uint32 len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ProcNumber&nbsp; &nbsp; dummyProcNumber = <a href="twophase.c.html#L903" title="access/transam/twophase.c:903">TwoPhaseGetDummyProcNumber</a>(xid, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(len == <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MultiXactId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a>[dummyProcNumber] = InvalidMultiXactId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1886" title="access/transam/multixact.c:1886">multixact_twophase_postabort</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is actually just the same as the COMMIT case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1886">&#x200c;</a></span><span class="linkable">multixact_twophase_postabort</span>(TransactionId xid, uint16 info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *recdata, uint32 len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1871" title="access/transam/multixact.c:1871">multixact_twophase_postcommit</a>(xid, info, recdata, len);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialization of shared memory for MultiXact.&nbsp; We use two SLRU areas,<br/></li>
<li></span><span class="Comment"> * thus double memory.&nbsp; Also, reserve space for the shared <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a><br/></li>
<li></span><span class="Comment"> * struct and the per-backend MultiXactId arrays (two of those, too).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L1898">&#x200c;</a><span class="linkable">MultiXactShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need 2*<a href="#L295" title="access/transam/multixact.c:295">MaxOldestSlot</a> perBackendXactIds[] entries */<br/></li>
<li><a id="L1903">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SHARED_MULTIXACT_STATE_SIZE</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(offsetof(<a href="#L200" title="access/transam/multixact.c:200">MultiXactStateData</a>, perBackendXactIds), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(</span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(MultiXactId) * </span><span class="Constant">2</span><span class="PreProc">, <a href="#L295" title="access/transam/multixact.c:295">MaxOldestSlot</a>))<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; size = <a href="#L1903" title="access/transam/multixact.c:1903">SHARED_MULTIXACT_STATE_SIZE</a>;<br/></li>
<li>&nbsp; &nbsp; size = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="slru.c.html#L184" title="access/transam/slru.c:184">SimpleLruShmemSize</a>(<a href="../../utils/init/globals.c.html#L164" title="utils/init/globals.c:164">multixact_offset_buffers</a>, <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; size = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="slru.c.html#L184" title="access/transam/slru.c:184">SimpleLruShmemSize</a>(<a href="../../utils/init/globals.c.html#L163" title="utils/init/globals.c:163">multixact_member_buffers</a>, <span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1915">&#x200c;</a></span><span class="linkable">MultiXactShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L333" title="access/transam/multixact.c:333">debug_elog2</a>(DEBUG2, <span class="Constant">&quot;Shared Memory Init for MultiXact&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>-&gt;PagePrecedes = <a href="#L3220" title="access/transam/multixact.c:3220">MultiXactOffsetPagePrecedes</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>-&gt;PagePrecedes = <a href="#L3240" title="access/transam/multixact.c:3240">MultiXactMemberPagePrecedes</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="slru.c.html#L238" title="access/transam/slru.c:238">SimpleLruInit</a>(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;multixact_offset&quot;</span>, <a href="../../utils/init/globals.c.html#L164" title="utils/init/globals.c:164">multixact_offset_buffers</a>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;pg_multixact/offsets&quot;</span>, LWTRANCHE_MULTIXACTOFFSET_BUFFER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LWTRANCHE_MULTIXACTOFFSET_SLRU,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_HANDLER_MULTIXACT_OFFSET,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="slru.c.html#L1680" title="access/transam/slru.c:1680">SlruPagePrecedesUnitTests</a>(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, <a href="#L109" title="access/transam/multixact.c:109">MULTIXACT_OFFSETS_PER_PAGE</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="slru.c.html#L238" title="access/transam/slru.c:238">SimpleLruInit</a>(<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;multixact_member&quot;</span>, <a href="../../utils/init/globals.c.html#L163" title="utils/init/globals.c:163">multixact_member_buffers</a>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;pg_multixact/members&quot;</span>, LWTRANCHE_MULTIXACTMEMBER_BUFFER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LWTRANCHE_MULTIXACTMEMBER_SLRU,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SYNC_HANDLER_MULTIXACT_MEMBER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* doesn't call <a href="slru.c.html#L1391" title="access/transam/slru.c:1391">SimpleLruTruncate</a>() or meet criteria for unit tests */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize our shared state struct */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a> = <a href="../../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;Shared MultiXact State&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1903" title="access/transam/multixact.c:1903">SHARED_MULTIXACT_STATE_SIZE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure we zero out the per-backend state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(<a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>, <span class="Constant">0</span>, <a href="#L1903" title="access/transam/multixact.c:1903">SHARED_MULTIXACT_STATE_SIZE</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L35" title="storage/lmgr/condition_variable.c:35">ConditionVariableInit</a>(&amp;<a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextoff_cv);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up array pointers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a> = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;perBackendXactIds;<br/></li>
<li>&nbsp; &nbsp; <a href="#L300" title="access/transam/multixact.c:300">OldestVisibleMXactId</a> = <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a> + <a href="#L295" title="access/transam/multixact.c:295">MaxOldestSlot</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for <a href="../../utils/init/globals.c.html#L164" title="utils/init/globals.c:164">multixact_offset_buffers</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1965">&#x200c;</a></span><span class="linkable">check_multixact_offset_buffers</span>(<span class="Type">int</span> *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="slru.c.html#L341" title="access/transam/slru.c:341">check_slru_buffers</a>(<span class="Constant">&quot;<a href="../../utils/init/globals.c.html#L164" title="utils/init/globals.c:164">multixact_offset_buffers</a>&quot;</span>, <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for multixact_member_buffer<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1974">&#x200c;</a></span><span class="linkable">check_multixact_member_buffers</span>(<span class="Type">int</span> *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="slru.c.html#L341" title="access/transam/slru.c:341">check_slru_buffers</a>(<span class="Constant">&quot;<a href="../../utils/init/globals.c.html#L163" title="utils/init/globals.c:163">multixact_member_buffers</a>&quot;</span>, <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This func must be called ONCE on system install.&nbsp; It creates the initial<br/></li>
<li></span><span class="Comment"> * MultiXact segments.&nbsp; (The MultiXacts directories are assumed to have been<br/></li>
<li></span><span class="Comment"> * created by initdb, and <a href="#L1915" title="access/transam/multixact.c:1915">MultiXactShmemInit</a> must have been called already.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1985">&#x200c;</a></span><span class="linkable">BootStrapMultiXact</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lock = SimpleLruGetBankLock(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create and zero the first page of the offsets log */<br/></li>
<li></span>&nbsp; &nbsp; slotno = <a href="#L2025" title="access/transam/multixact.c:2025">ZeroMultiXactOffsetPage</a>(<span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure it's written out */<br/></li>
<li></span>&nbsp; &nbsp; <a href="slru.c.html#L715" title="access/transam/slru.c:715">SimpleLruWritePage</a>(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, slotno);<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>-&gt;shared-&gt;page_dirty[slotno]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lock = SimpleLruGetBankLock(<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create and zero the first page of the members log */<br/></li>
<li></span>&nbsp; &nbsp; slotno = <a href="#L2041" title="access/transam/multixact.c:2041">ZeroMultiXactMemberPage</a>(<span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure it's written out */<br/></li>
<li></span>&nbsp; &nbsp; <a href="slru.c.html#L715" title="access/transam/slru.c:715">SimpleLruWritePage</a>(<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>, slotno);<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>-&gt;shared-&gt;page_dirty[slotno]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize (or reinitialize) a page of MultiXactOffset to zeroes.<br/></li>
<li></span><span class="Comment"> * If writeXlog is true, also emit an XLOG record saying we did this.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The page is not actually written, just set up in shared memory.<br/></li>
<li></span><span class="Comment"> * The slot number of the new page is returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Control lock must be held at entry, and will be held at exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2025">&#x200c;</a></span><span class="linkable">ZeroMultiXactOffsetPage</span>(int64 pageno, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> writeXlog)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slotno = <a href="slru.c.html#L361" title="access/transam/slru.c:361">SimpleLruZeroPage</a>(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (writeXlog)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3298" title="access/transam/multixact.c:3298">WriteMZeroPageXlogRec</a>(pageno, XLOG_MULTIXACT_ZERO_OFF_PAGE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> slotno;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Ditto, for MultiXactMember<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2041">&#x200c;</a></span><span class="linkable">ZeroMultiXactMemberPage</span>(int64 pageno, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> writeXlog)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slotno = <a href="slru.c.html#L361" title="access/transam/slru.c:361">SimpleLruZeroPage</a>(<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>, pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (writeXlog)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3298" title="access/transam/multixact.c:3298">WriteMZeroPageXlogRec</a>(pageno, XLOG_MULTIXACT_ZERO_MEM_PAGE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> slotno;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2069" title="access/transam/multixact.c:2069">MaybeExtendOffsetSlru</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Extend the offsets SLRU area, if necessary<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * After a binary upgrade from &lt;= 9.2, the pg_multixact/offsets SLRU area might<br/></li>
<li></span><span class="Comment"> * contain files that are shorter than necessary; this would occur if the old<br/></li>
<li></span><span class="Comment"> * installation had used multixacts beyond the first page (files cannot be<br/></li>
<li></span><span class="Comment"> * copied, because the on-disk representation is different).&nbsp; pg_upgrade would<br/></li>
<li></span><span class="Comment"> * update pg_control to set the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> offset value to be at that position, so<br/></li>
<li></span><span class="Comment"> * that tuples marked as locked by such MultiXacts would be seen as visible<br/></li>
<li></span><span class="Comment"> * without having to consult multixact.&nbsp; However, trying to create and use a<br/></li>
<li></span><span class="Comment"> * new MultiXactId would result in an error because the page on which the new<br/></li>
<li></span><span class="Comment"> * value would reside does not exist.&nbsp; This routine is in <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> of creating<br/></li>
<li></span><span class="Comment"> * such pages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2069">&#x200c;</a></span><span class="linkable">MaybeExtendOffsetSlru</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pageno = <a href="#L111" title="access/transam/multixact.c:111">MultiXactIdToOffsetPage</a>(<a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact);<br/></li>
<li>&nbsp; &nbsp; lock = SimpleLruGetBankLock(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="slru.c.html#L729" title="access/transam/slru.c:729">SimpleLruDoesPhysicalPageExist</a>(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, pageno))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fortunately for us, <a href="slru.c.html#L715" title="access/transam/slru.c:715">SimpleLruWritePage</a> is already prepared to deal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with creating a new segment file even if the page we're writing is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not the first in it, so this is enough.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; slotno = <a href="#L2025" title="access/transam/multixact.c:2025">ZeroMultiXactOffsetPage</a>(pageno, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slru.c.html#L715" title="access/transam/slru.c:715">SimpleLruWritePage</a>(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, slotno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This must be called ONCE during postmaster or standalone-backend startup.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="xlog.c.html#L5388" title="access/transam/xlog.c:5388">StartupXLOG</a> has already established nextMXact/nextOffset by calling<br/></li>
<li></span><span class="Comment"> * <a href="#L2279" title="access/transam/multixact.c:2279">MultiXactSetNextMXact</a> and/or <a href="#L2462" title="access/transam/multixact.c:2462">MultiXactAdvanceNextMXact</a>, and the oldestMulti<br/></li>
<li></span><span class="Comment"> * info from pg_control and/or <a href="#L2487" title="access/transam/multixact.c:2487">MultiXactAdvanceOldest</a>, but we haven't yet<br/></li>
<li></span><span class="Comment"> * replayed WAL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2104">&#x200c;</a></span><span class="linkable">StartupMultiXact</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactId multi = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact;<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset offset = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextOffset;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize offset's idea of the latest page number.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pageno = <a href="#L111" title="access/transam/multixact.c:111">MultiXactIdToOffsetPage</a>(multi);<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>-&gt;shared-&gt;latest_page_number,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize member's idea of the latest page number.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pageno = <a href="#L159" title="access/transam/multixact.c:159">MXOffsetToMemberPage</a>(offset);<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>-&gt;shared-&gt;latest_page_number,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageno);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This must be called ONCE at the end of startup/recovery.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2129">&#x200c;</a></span><span class="linkable">TrimMultiXact</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactId nextMXact;<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset offset;<br/></li>
<li>&nbsp; &nbsp; MultiXactId oldestMXact;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestMXactDB;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entryno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flagsoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactGenLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; nextMXact = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact;<br/></li>
<li>&nbsp; &nbsp; offset = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextOffset;<br/></li>
<li>&nbsp; &nbsp; oldestMXact = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestMultiXactId;<br/></li>
<li>&nbsp; &nbsp; oldestMXactDB = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestMultiXactDB;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up offsets state */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Re-)Initialize our idea of the latest page number for offsets.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pageno = <a href="#L111" title="access/transam/multixact.c:111">MultiXactIdToOffsetPage</a>(nextMXact);<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>-&gt;shared-&gt;latest_page_number,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Zero out the remainder of the current offsets page.&nbsp; See notes in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="clog.c.html#L892" title="access/transam/clog.c:892">TrimCLOG</a>() for background.&nbsp; Unlike CLOG, some WAL record covers every<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_multixact SLRU mutation.&nbsp; Since, also unlike CLOG, we ignore the WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rule &quot;write xlog <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> data,&quot; nextMXact successors may carry obsolete,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nonzero offset <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; Zero those so case 2 of <a href="#L1252" title="access/transam/multixact.c:1252">GetMultiXactIdMembers</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operates normally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; entryno = <a href="#L113" title="access/transam/multixact.c:113">MultiXactIdToOffsetEntry</a>(nextMXact);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (entryno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactOffset *offptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock = SimpleLruGetBankLock(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slotno = <a href="slru.c.html#L488" title="access/transam/slru.c:488">SimpleLruReadPage</a>(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, pageno, <span class="Constant">true</span>, nextMXact);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offptr = (MultiXactOffset *) <a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>-&gt;shared-&gt;page_buffer[slotno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offptr += entryno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(offptr, <span class="Constant">0</span>, BLCKSZ - (entryno * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MultiXactOffset)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>-&gt;shared-&gt;page_dirty[slotno] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And the same for members.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Re-)Initialize our idea of the latest page number for members.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pageno = <a href="#L159" title="access/transam/multixact.c:159">MXOffsetToMemberPage</a>(offset);<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>-&gt;shared-&gt;latest_page_number,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Zero out the remainder of the current members page.&nbsp; See notes in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="clog.c.html#L892" title="access/transam/clog.c:892">TrimCLOG</a>() for motivation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; flagsoff = <a href="#L163" title="access/transam/multixact.c:163">MXOffsetToFlagsOffset</a>(offset);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flagsoff != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId *xidptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memberoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock = SimpleLruGetBankLock(<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>, pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memberoff = <a href="#L172" title="access/transam/multixact.c:172">MXOffsetToMemberOffset</a>(offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slotno = <a href="slru.c.html#L488" title="access/transam/slru.c:488">SimpleLruReadPage</a>(<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>, pageno, <span class="Constant">true</span>, offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xidptr = (TransactionId *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>-&gt;shared-&gt;page_buffer[slotno] + memberoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(xidptr, <span class="Constant">0</span>, BLCKSZ - memberoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we don't need to zero out the flag bits in the remaining<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * members of the current group, because they are always reset <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * writing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>-&gt;shared-&gt;page_dirty[slotno] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* signal that we're officially up */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactGenLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;finishedStartup = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now compute how far away the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> members wraparound is. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2313" title="access/transam/multixact.c:2313">SetMultiXactIdLimit</a>(oldestMXact, oldestMXactDB, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the MultiXact data to save in a checkpoint record<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2233">&#x200c;</a></span><span class="linkable">MultiXactGetCheckptMulti</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_shutdown,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MultiXactId *nextMulti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MultiXactOffset *nextMultiOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MultiXactId *oldestMulti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *oldestMultiDB)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactGenLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; *nextMulti = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact;<br/></li>
<li>&nbsp; &nbsp; *nextMultiOffset = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextOffset;<br/></li>
<li>&nbsp; &nbsp; *oldestMulti = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestMultiXactId;<br/></li>
<li>&nbsp; &nbsp; *oldestMultiDB = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestMultiXactDB;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L337" title="access/transam/multixact.c:337">debug_elog6</a>(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;MultiXact: checkpoint is nextMulti </span><span class="Special">%u</span><span class="Constant">, nextOffset </span><span class="Special">%u</span><span class="Constant">, oldestMulti </span><span class="Special">%u</span><span class="Constant"> in DB </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *nextMulti, *nextMultiOffset, *oldestMulti, *oldestMultiDB);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform a checkpoint --- either during shutdown, or on-the-fly<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2255">&#x200c;</a></span><span class="linkable">CheckPointMultiXact</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_MULTIXACT_CHECKPOINT_START(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write dirty MultiXact pages to disk.&nbsp; This may result in sync requests<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * queued for later handling by <a href="../../storage/sync/sync.c.html#L286" title="storage/sync/sync.c:286">ProcessSyncRequests</a>(), as part of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="slru.c.html#L1305" title="access/transam/slru.c:1305">SimpleLruWriteAll</a>(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="slru.c.html#L1305" title="access/transam/slru.c:1305">SimpleLruWriteAll</a>(<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_MULTIXACT_CHECKPOINT_DONE(<span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-to-be-assigned MultiXactId and offset<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used when we can determine the correct <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> ID/offset exactly<br/></li>
<li></span><span class="Comment"> * from a checkpoint record.&nbsp; Although this is only called during bootstrap<br/></li>
<li></span><span class="Comment"> * and XLog replay, we take the lock in case <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> hot-standby backends are<br/></li>
<li></span><span class="Comment"> * examining the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2279">&#x200c;</a></span><span class="linkable">MultiXactSetNextMXact</span>(MultiXactId nextMulti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactOffset nextMultiOffset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L335" title="access/transam/multixact.c:335">debug_elog4</a>(DEBUG2, <span class="Constant">&quot;MultiXact: setting <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> multi to </span><span class="Special">%u</span><span class="Constant"> offset </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextMulti, nextMultiOffset);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactGenLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact = nextMulti;<br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextOffset = nextMultiOffset;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During a binary upgrade, make sure that the offsets SLRU is large<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enough to contain the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> value that would be created.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to do this pretty early during the first startup in binary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * upgrade mode: <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="#L2104" title="access/transam/multixact.c:2104">StartupMultiXact</a>() in fact, because this routine<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is called even <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> that by <a href="xlog.c.html#L5388" title="access/transam/xlog.c:5388">StartupXLOG</a>().&nbsp; And we can't do it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * earlier than at this point, because during that first call of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * routine we determine the <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact value that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2069" title="access/transam/multixact.c:2069">MaybeExtendOffsetSlru</a> needs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L118" title="utils/init/globals.c:118">IsBinaryUpgrade</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2069" title="access/transam/multixact.c:2069">MaybeExtendOffsetSlru</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine the last safe MultiXactId to allocate given the currently oldest<br/></li>
<li></span><span class="Comment"> * datminmxid (ie, the oldest MultiXactId that might exist in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> database<br/></li>
<li></span><span class="Comment"> * of our <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>), and the OID of the (or a) database with that value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * is_startup is true when we are just starting the <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>, false when we<br/></li>
<li></span><span class="Comment"> * are updating state in a running <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>.&nbsp; This only affects log messages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2313">&#x200c;</a></span><span class="linkable">SetMultiXactIdLimit</span>(MultiXactId oldest_datminmxid, Oid oldest_datoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_startup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactId multiVacLimit;<br/></li>
<li>&nbsp; &nbsp; MultiXactId multiWarnLimit;<br/></li>
<li>&nbsp; &nbsp; MultiXactId multiStopLimit;<br/></li>
<li>&nbsp; &nbsp; MultiXactId multiWrapLimit;<br/></li>
<li>&nbsp; &nbsp; MultiXactId curMulti;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needs_offset_vacuum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(MultiXactIdIsValid(oldest_datminmxid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We pretend that a wrap will happen halfway through the multixact ID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space, but that's not really true, because multixacts wrap differently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from transaction IDs.&nbsp; Note that, separately from <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> concern about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multixact IDs wrapping, we must ensure that multixact members do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wrap.&nbsp; Limits for that are set in <a href="#L2664" title="access/transam/multixact.c:2664">SetOffsetVacuumLimit</a>, not here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; multiWrapLimit = oldest_datminmxid + (MaxMultiXactId &gt;&gt; <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (multiWrapLimit &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; multiWrapLimit += FirstMultiXactId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We'll refuse to continue assigning MultiXactIds once we get within 3M<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multi of data loss.&nbsp; See <a href="varsup.c.html#L372" title="access/transam/varsup.c:372">SetTransactionIdLimit</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; multiStopLimit = multiWrapLimit - <span class="Constant">3000000</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (multiStopLimit &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; multiStopLimit -= FirstMultiXactId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We'll start complaining loudly when we get within 40M multis of data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loss.&nbsp; This is kind of arbitrary, but if you let your gas gauge get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * down to 2% of full, would you be looking for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> gas station?&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to be fairly liberal about this number because there are lots of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scenarios where most transactions are done by automatic clients that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * won't pay attention to warnings.&nbsp; (No, we're not gonna make this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * configurable.&nbsp; If you know enough to configure it, you know enough to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not get in this kind of trouble in the first place.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; multiWarnLimit = multiWrapLimit - <span class="Constant">40000000</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (multiWarnLimit &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; multiWarnLimit -= FirstMultiXactId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We'll start trying to force autovacuums when oldest_datminmxid gets to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be more than <a href="../../postmaster/autovacuum.c.html#L127" title="postmaster/autovacuum.c:127">autovacuum_multixact_freeze_max_age</a> mxids old.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: <a href="../../postmaster/autovacuum.c.html#L127" title="postmaster/autovacuum.c:127">autovacuum_multixact_freeze_max_age</a> is a PGC_POSTMASTER parameter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so that we don't have to worry about dealing with on-the-fly changes in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its value.&nbsp; See <a href="varsup.c.html#L372" title="access/transam/varsup.c:372">SetTransactionIdLimit</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; multiVacLimit = oldest_datminmxid + <a href="../../postmaster/autovacuum.c.html#L127" title="postmaster/autovacuum.c:127">autovacuum_multixact_freeze_max_age</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (multiVacLimit &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; multiVacLimit += FirstMultiXactId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Grab lock for just long enough to set the new limit <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactGenLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestMultiXactId = oldest_datminmxid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestMultiXactDB = oldest_datoid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;multiVacLimit = multiVacLimit;<br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;multiWarnLimit = multiWarnLimit;<br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;multiStopLimit = multiStopLimit;<br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;multiWrapLimit = multiWrapLimit;<br/></li>
<li>&nbsp; &nbsp; curMulti = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Log the info */<br/></li>
<li></span>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;MultiXactId wrap limit is </span><span class="Special">%u</span><span class="Constant">, limited by database with OID </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; multiWrapLimit, oldest_datoid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Computing the actual limits is only possible once the data directory is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in a consistent state. There's no need to compute the limits while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still replaying WAL - no decisions about new multis are made even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * though multixact creations might be replayed. So we'll only do further<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checks after <a href="#L2129" title="access/transam/multixact.c:2129">TrimMultiXact</a>() has been called.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;finishedStartup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set limits for offset <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>. */<br/></li>
<li></span>&nbsp; &nbsp; needs_offset_vacuum = <a href="#L2664" title="access/transam/multixact.c:2664">SetOffsetVacuumLimit</a>(is_startup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If past the autovacuum force point, immediately signal an autovac<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * request.&nbsp; The reason for this is that autovac only processes one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database per invocation.&nbsp; Once it's finished cleaning up the oldest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database, it'll call here, and we'll signal the postmaster to start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another iteration immediately if there are still <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> old databases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((<a href="#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(multiVacLimit, curMulti) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; needs_offset_vacuum) &amp;&amp; <a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/pmsignal.c.html#L181" title="storage/ipc/pmsignal.c:181">SendPostmasterSignal</a>(PMSIGNAL_START_AUTOVAC_LAUNCHER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Give an immediate warning if past the wrap warn point */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(multiWarnLimit, curMulti))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *oldest_datname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can be called when not inside a transaction, for example during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="xlog.c.html#L5388" title="access/transam/xlog.c:5388">StartupXLOG</a>().&nbsp; In such a case we cannot do database access, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must just report the oldest DB's OID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: it's also possible that <a href="../../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a> fails and returns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL, for example because the database just got dropped.&nbsp; We'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still warn, even though the warning might <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be unnecessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldest_datname = <a href="../../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a>(oldest_datoid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldest_datname = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldest_datname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1182" title="utils/error/elog.c:1182">errmsg_plural</a>(<span class="Constant">&quot;database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be vacuumed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> </span><span class="Special">%u</span><span class="Constant"> more MultiXactId is used&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be vacuumed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> </span><span class="Special">%u</span><span class="Constant"> more MultiXactIds are used&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; multiWrapLimit - curMulti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldest_datname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; multiWrapLimit - curMulti),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;To avoid MultiXactId assignment failures, execute a database-wide VACUUM in that database.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;You might also need to commit or roll back old prepared transactions, or drop stale replication slots.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1182" title="utils/error/elog.c:1182">errmsg_plural</a>(<span class="Constant">&quot;database with OID </span><span class="Special">%u</span><span class="Constant"> must be vacuumed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> </span><span class="Special">%u</span><span class="Constant"> more MultiXactId is used&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;database with OID </span><span class="Special">%u</span><span class="Constant"> must be vacuumed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> </span><span class="Special">%u</span><span class="Constant"> more MultiXactIds are used&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; multiWrapLimit - curMulti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldest_datoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; multiWrapLimit - curMulti),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;To avoid MultiXactId assignment failures, execute a database-wide VACUUM in that database.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;You might also need to commit or roll back old prepared transactions, or drop stale replication slots.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Ensure the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-to-be-assigned MultiXactId is at least minMulti,<br/></li>
<li></span><span class="Comment"> * and similarly nextOffset is at least minMultiOffset.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used when we can determine minimum safe <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> from an XLog<br/></li>
<li></span><span class="Comment"> * record (either an on-line checkpoint or an mxact creation log entry).<br/></li>
<li></span><span class="Comment"> * Although this is only called during XLog replay, we take the lock in case<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> hot-standby backends are examining the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2462">&#x200c;</a></span><span class="linkable">MultiXactAdvanceNextMXact</span>(MultiXactId minMulti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactOffset minMultiOffset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactGenLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(<a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact, minMulti))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L334" title="access/transam/multixact.c:334">debug_elog3</a>(DEBUG2, <span class="Constant">&quot;MultiXact: setting <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> multi to </span><span class="Special">%u</span><span class="Constant">&quot;</span>, minMulti);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact = minMulti;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3286" title="access/transam/multixact.c:3286">MultiXactOffsetPrecedes</a>(<a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextOffset, minMultiOffset))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L334" title="access/transam/multixact.c:334">debug_elog3</a>(DEBUG2, <span class="Constant">&quot;MultiXact: setting <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> offset to </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minMultiOffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextOffset = minMultiOffset;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactGenLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update our oldestMultiXactId value, but only if it's more recent than what<br/></li>
<li></span><span class="Comment"> * we had.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This may only be called during WAL replay.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2487">&#x200c;</a></span><span class="linkable">MultiXactAdvanceOldest</span>(MultiXactId oldestMulti, Oid oldestMultiDB)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(<a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestMultiXactId, oldestMulti))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2313" title="access/transam/multixact.c:2313">SetMultiXactIdLimit</a>(oldestMulti, oldestMultiDB, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make sure that MultiXactOffset has room for a newly-allocated MultiXactId.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: this is called while holding MultiXactGenLock.&nbsp; We want it to be very<br/></li>
<li></span><span class="Comment"> * fast most of the time; even when it's not so fast, no actual I/O need<br/></li>
<li></span><span class="Comment"> * happen unless we're forced to write out a dirty log or xlog page to make<br/></li>
<li></span><span class="Comment"> * room in shared memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2504">&#x200c;</a></span><span class="linkable">ExtendMultiXactOffset</span>(MultiXactId multi)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No work except at first MultiXactId of a page.&nbsp; But beware: just after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wraparound, the first MultiXactId of page zero is FirstMultiXactId.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L113" title="access/transam/multixact.c:113">MultiXactIdToOffsetEntry</a>(multi) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; multi != FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pageno = <a href="#L111" title="access/transam/multixact.c:111">MultiXactIdToOffsetPage</a>(multi);<br/></li>
<li>&nbsp; &nbsp; lock = SimpleLruGetBankLock(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Zero the page and make an XLOG entry about it */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2025" title="access/transam/multixact.c:2025">ZeroMultiXactOffsetPage</a>(pageno, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make sure that MultiXactMember has room for the members of a newly-<br/></li>
<li></span><span class="Comment"> * allocated MultiXactId.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Like the above routine, this is called while holding MultiXactGenLock;<br/></li>
<li></span><span class="Comment"> * same comments apply.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2536">&#x200c;</a></span><span class="linkable">ExtendMultiXactMember</span>(MultiXactOffset offset, <span class="Type">int</span> nmembers)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's possible that the members span more than one page of the members<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * file, so we loop to ensure we consider each page.&nbsp; The coding is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * optimal if the members span several pages, but that seems unusual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enough to not worry much about.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (nmembers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flagsoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flagsbit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; difference;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only zero when at first entry of a page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; flagsoff = <a href="#L163" title="access/transam/multixact.c:163">MXOffsetToFlagsOffset</a>(offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flagsbit = <a href="#L167" title="access/transam/multixact.c:167">MXOffsetToFlagsBitShift</a>(offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flagsoff == <span class="Constant">0</span> &amp;&amp; flagsbit == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageno = <a href="#L159" title="access/transam/multixact.c:159">MXOffsetToMemberPage</a>(offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock = SimpleLruGetBankLock(<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>, pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Zero the page and make an XLOG entry about it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2041" title="access/transam/multixact.c:2041">ZeroMultiXactMemberPage</a>(pageno, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compute the number of items till end of current page.&nbsp; Careful: if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * addition of unsigned ints wraps around, we're at the last page of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the last segment; since that page holds a different number of items<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than other pages, we need to do it differently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offset + <a href="#L155" title="access/transam/multixact.c:155">MAX_MEMBERS_IN_LAST_MEMBERS_PAGE</a> &lt; offset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is the last page of the last segment; we can compute the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * number of items left to allocate in it without modulo<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * arithmetic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; difference = MaxMultiXactOffset - offset + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; difference = <a href="#L142" title="access/transam/multixact.c:142">MULTIXACT_MEMBERS_PER_PAGE</a> - offset % <a href="#L142" title="access/transam/multixact.c:142">MULTIXACT_MEMBERS_PER_PAGE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page, taking care to properly handle the wraparound<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case.&nbsp; OK if nmembers goes negative.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nmembers -= difference;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset += difference;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2611" title="access/transam/multixact.c:2611">GetOldestMultiXactId</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the oldest MultiXactId that's still possibly still seen as live by<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> running transaction.&nbsp; Older ones might still exist on disk, but they no<br/></li>
<li></span><span class="Comment"> * longer have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> running member transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's not safe to truncate MultiXact SLRU segments on the value returned by<br/></li>
<li></span><span class="Comment"> * this function; however, it can be set as the new relminmxid for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> table<br/></li>
<li></span><span class="Comment"> * that VACUUM knows has no remaining MXIDs &lt; the same value.&nbsp; It is only safe<br/></li>
<li></span><span class="Comment"> * to truncate SLRUs when no table can possibly still have a referencing MXID.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>MultiXactId<br/></li>
<li><a id="L2611">&#x200c;</a><span class="linkable">GetOldestMultiXactId</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactId oldestMXact;<br/></li>
<li>&nbsp; &nbsp; MultiXactId nextMXact;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is the oldest valid value among all the <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a>[] and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L300" title="access/transam/multixact.c:300">OldestVisibleMXactId</a>[] entries, or nextMXact if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> are valid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactGenLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to beware of the possibility that nextMXact is in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wrapped-around state.&nbsp; We don't fix the counter itself here, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must be sure to use a valid value in our calculation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nextMXact = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nextMXact &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nextMXact = FirstMultiXactId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldestMXact = nextMXact;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L295" title="access/transam/multixact.c:295">MaxOldestSlot</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactId thisoldest;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; thisoldest = <a href="#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (MultiXactIdIsValid(thisoldest) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(thisoldest, oldestMXact))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestMXact = thisoldest;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; thisoldest = <a href="#L300" title="access/transam/multixact.c:300">OldestVisibleMXactId</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (MultiXactIdIsValid(thisoldest) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(thisoldest, oldestMXact))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestMXact = thisoldest;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> oldestMXact;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine how aggressively we need to <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> in order to prevent member<br/></li>
<li></span><span class="Comment"> * wraparound.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To do so determine what's the oldest member offset and install the limit<br/></li>
<li></span><span class="Comment"> * info in <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>, where it can be used to prevent overrun of old data<br/></li>
<li></span><span class="Comment"> * in the members SLRU area.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The return value is true if emergency autovacuum is required and false<br/></li>
<li></span><span class="Comment"> * otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2664">&#x200c;</a></span><span class="linkable">SetOffsetVacuumLimit</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_startup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactId oldestMultiXactId;<br/></li>
<li>&nbsp; &nbsp; MultiXactId nextMXact;<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset oldestOffset = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* placate compiler */<br/></li>
<li></span>&nbsp; &nbsp; MultiXactOffset prevOldestOffset;<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset nextOffset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; oldestOffsetKnown = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; prevOldestOffsetKnown;<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset offsetStopLimit = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset prevOffsetStopLimit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: Have to prevent concurrent truncation, we might otherwise try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lookup an oldestMulti that's concurrently getting truncated away.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactTruncationLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Read relevant fields from shared memory. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactGenLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; oldestMultiXactId = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestMultiXactId;<br/></li>
<li>&nbsp; &nbsp; nextMXact = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact;<br/></li>
<li>&nbsp; &nbsp; nextOffset = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextOffset;<br/></li>
<li>&nbsp; &nbsp; prevOldestOffsetKnown = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestOffsetKnown;<br/></li>
<li>&nbsp; &nbsp; prevOldestOffset = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestOffset;<br/></li>
<li>&nbsp; &nbsp; prevOffsetStopLimit = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;offsetStopLimit;<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;finishedStartup);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the offset of the oldest multixact.&nbsp; Normally, we can read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the offset from the multixact itself, but there's an important special<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case: if there are no multixacts in existence at all, oldestMXact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * obviously can't point to one.&nbsp; It will instead point to the multixact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ID that will be assigned the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time one is needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (oldestMultiXactId == nextMXact)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> multixact gets created, it will be stored at the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * offset.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldestOffset = nextOffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldestOffsetKnown = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Figure out where the oldest existing multixact's offsets are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stored. Due to bugs in early release of PostgreSQL 9.3.X and 9.4.X,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the supposedly-earliest multixact might not really exist.&nbsp; We are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * careful not to fail in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldestOffsetKnown =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2839" title="access/transam/multixact.c:2839">find_multixact_start</a>(oldestMultiXactId, &amp;oldestOffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldestOffsetKnown)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;oldest MultiXactId member is at offset </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldestOffset)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;MultiXact member wraparound protections are disabled because oldest checkpointed MultiXact </span><span class="Special">%u</span><span class="Constant"> does not exist on disk&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestMultiXactId)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactTruncationLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we can, compute limits (and install them <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>) to prevent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overrun of old data in the members SLRU area. We can only do so if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * oldest offset is known though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (oldestOffsetKnown)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* move back to start of the corresponding segment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; offsetStopLimit = oldestOffset - (oldestOffset %<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L142" title="access/transam/multixact.c:142">MULTIXACT_MEMBERS_PER_PAGE</a> * SLRU_PAGES_PER_SEGMENT));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* always leave one segment <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the wraparound point */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; offsetStopLimit -= (<a href="#L142" title="access/transam/multixact.c:142">MULTIXACT_MEMBERS_PER_PAGE</a> * SLRU_PAGES_PER_SEGMENT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!prevOldestOffsetKnown &amp;&amp; !is_startup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;MultiXact member wraparound protections are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> enabled&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;MultiXact member stop limit is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> </span><span class="Special">%u</span><span class="Constant"> based on MultiXact </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetStopLimit, oldestMultiXactId)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (prevOldestOffsetKnown)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we failed to get the oldest offset this time, but we have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value from a previous pass through this function, use the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> rather than automatically forcing an emergency autovacuum<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cycle again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldestOffset = prevOldestOffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldestOffsetKnown = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offsetStopLimit = prevOffsetStopLimit;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Install the computed <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactGenLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestOffset = oldestOffset;<br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestOffsetKnown = oldestOffsetKnown;<br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;offsetStopLimit = offsetStopLimit;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do we need an emergency autovacuum?&nbsp; &nbsp; If we're not sure, assume yes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> !oldestOffsetKnown ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (nextOffset - oldestOffset &gt; <a href="#L177" title="access/transam/multixact.c:177">MULTIXACT_MEMBER_SAFE_THRESHOLD</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return whether adding &quot;distance&quot; to &quot;start&quot; would move past &quot;boundary&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use this to determine whether the addition is &quot;wrapping around&quot; the<br/></li>
<li></span><span class="Comment"> * boundary point, hence the name.&nbsp; The reason we don't want to use the regular<br/></li>
<li></span><span class="Comment"> * 2^31-modulo arithmetic here is that we want to be able to use the whole of<br/></li>
<li></span><span class="Comment"> * the 2^32-1 space here, allowing for more multixacts than would fit<br/></li>
<li></span><span class="Comment"> * otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2791">&#x200c;</a></span><span class="linkable">MultiXactOffsetWouldWrap</span>(MultiXactOffset boundary, MultiXactOffset start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 distance)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset finish;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that offset number 0 is not used (see <a href="#L1252" title="access/transam/multixact.c:1252">GetMultiXactIdMembers</a>), so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the addition wraps around the UINT_MAX boundary, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> that value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; finish = start + distance;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (finish &lt; start)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; finish++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*-----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When the boundary is numerically greater than the starting point, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value numerically between the two is not wrapped:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &lt;----S----B----&gt;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; [---)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = F wrapped past B (and UINT_MAX)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [---)&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = F not wrapped<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [----] = F wrapped past B<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When the boundary is numerically less than the starting point (i.e. the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * UINT_MAX wraparound occurs somewhere in between) then all <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * between are wrapped:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &lt;----B----S----&gt;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; [---)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = F not wrapped past B (but wrapped past UINT_MAX)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; [---)&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; = F wrapped past B (and UINT_MAX)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [----] = F not wrapped<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *-----------------------------------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (start &lt; boundary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> finish &gt;= boundary || finish &lt; start;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> finish &gt;= boundary &amp;&amp; finish &lt; start;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find the starting offset of the given MultiXactId.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false if the file containing the multi does not exist on disk.<br/></li>
<li></span><span class="Comment"> * Otherwise, returns true and sets *result to the starting member offset.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function does not prevent concurrent truncation, so if that's<br/></li>
<li></span><span class="Comment"> * required, the caller has to protect against that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2839">&#x200c;</a></span><span class="linkable">find_multixact_start</span>(MultiXactId multi, MultiXactOffset *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset offset;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entryno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset *offptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;finishedStartup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pageno = <a href="#L111" title="access/transam/multixact.c:111">MultiXactIdToOffsetPage</a>(multi);<br/></li>
<li>&nbsp; &nbsp; entryno = <a href="#L113" title="access/transam/multixact.c:113">MultiXactIdToOffsetEntry</a>(multi);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write out dirty data, so PhysicalPageExists can work correctly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="slru.c.html#L1305" title="access/transam/slru.c:1305">SimpleLruWriteAll</a>(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="slru.c.html#L1305" title="access/transam/slru.c:1305">SimpleLruWriteAll</a>(<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="slru.c.html#L729" title="access/transam/slru.c:729">SimpleLruDoesPhysicalPageExist</a>(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, pageno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* lock is acquired by <a href="slru.c.html#L591" title="access/transam/slru.c:591">SimpleLruReadPage_ReadOnly</a> */<br/></li>
<li></span>&nbsp; &nbsp; slotno = <a href="slru.c.html#L591" title="access/transam/slru.c:591">SimpleLruReadPage_ReadOnly</a>(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, pageno, multi);<br/></li>
<li>&nbsp; &nbsp; offptr = (MultiXactOffset *) <a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>-&gt;shared-&gt;page_buffer[slotno];<br/></li>
<li>&nbsp; &nbsp; offptr += entryno;<br/></li>
<li>&nbsp; &nbsp; offset = *offptr;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(SimpleLruGetBankLock(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, pageno));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *result = offset;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine how many multixacts, and how many multixact members, currently<br/></li>
<li></span><span class="Comment"> * exist.&nbsp; Return false if unable to determine.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2877">&#x200c;</a></span><span class="linkable">ReadMultiXactCounts</span>(uint32 *multixacts, MultiXactOffset *members)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset nextOffset;<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset oldestOffset;<br/></li>
<li>&nbsp; &nbsp; MultiXactId oldestMultiXactId;<br/></li>
<li>&nbsp; &nbsp; MultiXactId nextMultiXactId;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; oldestOffsetKnown;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactGenLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; nextOffset = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextOffset;<br/></li>
<li>&nbsp; &nbsp; oldestMultiXactId = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestMultiXactId;<br/></li>
<li>&nbsp; &nbsp; nextMultiXactId = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact;<br/></li>
<li>&nbsp; &nbsp; oldestOffset = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestOffset;<br/></li>
<li>&nbsp; &nbsp; oldestOffsetKnown = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestOffsetKnown;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!oldestOffsetKnown)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *members = nextOffset - oldestOffset;<br/></li>
<li>&nbsp; &nbsp; *multixacts = nextMultiXactId - oldestMultiXactId;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Multixact members can be removed once the multixacts that refer to them<br/></li>
<li></span><span class="Comment"> * are older than every datminmxid.&nbsp; <a href="../../postmaster/autovacuum.c.html#L127" title="postmaster/autovacuum.c:127">autovacuum_multixact_freeze_max_age</a> and<br/></li>
<li></span><span class="Comment"> * <a href="../../commands/vacuum.c.html#L70" title="commands/vacuum.c:70">vacuum_multixact_freeze_table_age</a> work together to make sure we never have<br/></li>
<li></span><span class="Comment"> * too many multixacts; we hope that, at least under normal circumstances,<br/></li>
<li></span><span class="Comment"> * this will also be sufficient to keep us from using too many offsets.<br/></li>
<li></span><span class="Comment"> * However, if the average multixact has many members, we might exhaust the<br/></li>
<li></span><span class="Comment"> * members space while still using few enough members that these limits fail<br/></li>
<li></span><span class="Comment"> * to <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> relminmxid advancement by VACUUM.&nbsp; At that point, we'd have no<br/></li>
<li></span><span class="Comment"> * choice but to start failing multixact-creating operations with an error.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To prevent that, if more than a threshold portion of the members space is<br/></li>
<li></span><span class="Comment"> * used, we effectively reduce <a href="../../postmaster/autovacuum.c.html#L127" title="postmaster/autovacuum.c:127">autovacuum_multixact_freeze_max_age</a> and<br/></li>
<li></span><span class="Comment"> * to a value just less than the number of multixacts in use.&nbsp; We hope that<br/></li>
<li></span><span class="Comment"> * this will quickly <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> autovacuuming on the table or tables with the<br/></li>
<li></span><span class="Comment"> * oldest relminmxid, thus allowing datminmxid <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to advance and removing<br/></li>
<li></span><span class="Comment"> * some members.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As the fraction of the member space currently in use grows, we become<br/></li>
<li></span><span class="Comment"> * more aggressive in clamping this value.&nbsp; That not only causes autovacuum<br/></li>
<li></span><span class="Comment"> * to ramp up, but also makes <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> manual vacuums the user issues more<br/></li>
<li></span><span class="Comment"> * aggressive.&nbsp; This happens because <a href="../../commands/vacuum.c.html#L1072" title="commands/vacuum.c:1072">vacuum_get_cutoffs</a>() will clamp the<br/></li>
<li></span><span class="Comment"> * freeze table and the minimum freeze age cutoffs based on the effective<br/></li>
<li></span><span class="Comment"> * <a href="../../postmaster/autovacuum.c.html#L127" title="postmaster/autovacuum.c:127">autovacuum_multixact_freeze_max_age</a> this function returns.&nbsp; In the worst<br/></li>
<li></span><span class="Comment"> * case, we'll claim the freeze_max_age to zero, and every <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * table will freeze every multixact.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2929">&#x200c;</a></span><span class="linkable">MultiXactMemberFreezeThreshold</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset members;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; multixacts;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; victim_multixacts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; fraction;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we can't determine member space utilization, assume the worst. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2877" title="access/transam/multixact.c:2877">ReadMultiXactCounts</a>(&amp;multixacts, &amp;members))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If member space utilization is low, no special action is required. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (members &lt;= <a href="#L177" title="access/transam/multixact.c:177">MULTIXACT_MEMBER_SAFE_THRESHOLD</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../postmaster/autovacuum.c.html#L127" title="postmaster/autovacuum.c:127">autovacuum_multixact_freeze_max_age</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute a target for relminmxid advancement.&nbsp; The number of multixacts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we try to eliminate from the system is based on how far we are past<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L177" title="access/transam/multixact.c:177">MULTIXACT_MEMBER_SAFE_THRESHOLD</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fraction = (<span class="Type">double</span>) (members - <a href="#L177" title="access/transam/multixact.c:177">MULTIXACT_MEMBER_SAFE_THRESHOLD</a>) /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L178" title="access/transam/multixact.c:178">MULTIXACT_MEMBER_DANGER_THRESHOLD</a> - <a href="#L177" title="access/transam/multixact.c:177">MULTIXACT_MEMBER_SAFE_THRESHOLD</a>);<br/></li>
<li>&nbsp; &nbsp; victim_multixacts = multixacts * fraction;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fraction could be &gt; 1.0, but lowest possible freeze age is zero */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (victim_multixacts &gt; multixacts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> multixacts - victim_multixacts;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L2959">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">mxtruncinfo</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; earliestExistingPage;<br/></li>
<li><a id="L2962">&#x200c;</a>} <span class="linkable">mxtruncinfo</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="slru.c.html#L1774" title="access/transam/slru.c:1774">SlruScanDirectory</a> callback<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This callback determines the earliest existing page number.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2969">&#x200c;</a></span><span class="linkable">SlruScanDirCbFindEarliest</span>(SlruCtl ctl, <span class="Type">char</span> *filename, int64 segpage, <span class="Type">void</span> *data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L2959" title="access/transam/multixact.c:2959">mxtruncinfo</a> *trunc = (<a href="#L2959" title="access/transam/multixact.c:2959">mxtruncinfo</a> *) data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (trunc-&gt;earliestExistingPage == -<span class="Constant">1</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl-&gt;PagePrecedes(segpage, trunc-&gt;earliestExistingPage))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trunc-&gt;earliestExistingPage = segpage;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep going */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> members segments [oldest, newOldest)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The members SLRU can, in contrast to the offsets one, be filled to almost<br/></li>
<li></span><span class="Comment"> * the full <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> at once. This means <a href="slru.c.html#L1391" title="access/transam/slru.c:1391">SimpleLruTruncate</a>() can't trivially be<br/></li>
<li></span><span class="Comment"> * used - instead the to-be-deleted <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is computed using the offsets<br/></li>
<li></span><span class="Comment"> * SLRU. C.f. <a href="#L3045" title="access/transam/multixact.c:3045">TruncateMultiXact</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2992">&#x200c;</a></span><span class="linkable">PerformMembersTruncation</span>(MultiXactOffset oldestOffset, MultiXactOffset newOldestOffset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">int</span>&nbsp; &nbsp; maxsegment = <a href="#L160" title="access/transam/multixact.c:160">MXOffsetToMemberSegment</a>(MaxMultiXactOffset);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startsegment = <a href="#L160" title="access/transam/multixact.c:160">MXOffsetToMemberSegment</a>(oldestOffset);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endsegment = <a href="#L160" title="access/transam/multixact.c:160">MXOffsetToMemberSegment</a>(newOldestOffset);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment = startsegment;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> all the segments but the last one. The last segment can still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contain, possibly partially, valid data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (segment != endsegment)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;truncating multixact members segment </span><span class="Special">%x</span><span class="Constant">&quot;</span>, segment);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slru.c.html#L1509" title="access/transam/slru.c:1509">SlruDeleteSegment</a>(<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>, segment);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* move to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> segment, handling wraparound correctly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (segment == maxsegment)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segment += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> offsets segments [oldest, newOldest)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3020">&#x200c;</a></span><span class="linkable">PerformOffsetsTruncation</span>(MultiXactId oldestMulti, MultiXactId newOldestMulti)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We step back one multixact to avoid passing a cutoff page that hasn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been created yet in the rare case that oldestMulti would be the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * item on a page and oldestMulti == nextMulti.&nbsp; In that case, if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * didn't subtract one, we'd <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> <a href="slru.c.html#L1391" title="access/transam/slru.c:1391">SimpleLruTruncate</a>'s wraparound<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * detection.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="slru.c.html#L1391" title="access/transam/slru.c:1391">SimpleLruTruncate</a>(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L111" title="access/transam/multixact.c:111">MultiXactIdToOffsetPage</a>(<a href="#L181" title="access/transam/multixact.c:181">PreviousMultiXactId</a>(newOldestMulti)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove all MultiXactOffset and MultiXactMember segments <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the oldest<br/></li>
<li></span><span class="Comment"> * ones still of interest.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is only called on a primary as part of <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> (via<br/></li>
<li></span><span class="Comment"> * <a href="../../commands/vacuum.c.html#L1779" title="commands/vacuum.c:1779">vac_truncate_clog</a>()). During recovery truncation is done by replaying<br/></li>
<li></span><span class="Comment"> * truncation WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> logged here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * newOldestMulti is the oldest currently required multixact, newOldestMultiDB<br/></li>
<li></span><span class="Comment"> * is one of the databases preventing newOldestMulti from increasing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3045">&#x200c;</a></span><span class="linkable">TruncateMultiXact</span>(MultiXactId newOldestMulti, Oid newOldestMultiDB)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactId oldestMulti;<br/></li>
<li>&nbsp; &nbsp; MultiXactId nextMulti;<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset newOldestOffset;<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset oldestOffset;<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset nextOffset;<br/></li>
<li>&nbsp; &nbsp; <a href="#L2959" title="access/transam/multixact.c:2959">mxtruncinfo</a> trunc;<br/></li>
<li>&nbsp; &nbsp; MultiXactId earliest;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>());<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;finishedStartup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can only allow one truncation to happen at once. Otherwise parts of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * members might vanish while we're doing lookups or similar. There's no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to have an interlock with creating new multis or such, since those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are constrained by the limits (which only grow, never shrink).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactTruncationLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactGenLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; nextMulti = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextMXact;<br/></li>
<li>&nbsp; &nbsp; nextOffset = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;nextOffset;<br/></li>
<li>&nbsp; &nbsp; oldestMulti = <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestMultiXactId;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactGenLock);<br/></li>
<li>&nbsp; &nbsp; Assert(MultiXactIdIsValid(oldestMulti));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure to only attempt truncation if there's <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to truncate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * away. In normal processing <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> shouldn't go backwards, but there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some corner cases (due to bugs) where that's possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3274" title="access/transam/multixact.c:3274">MultiXactIdPrecedesOrEquals</a>(newOldestMulti, oldestMulti))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactTruncationLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note we can't just plow ahead with the truncation; it's possible that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there are no segments to truncate, which is a problem because we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * going to attempt to read the offsets page to determine where to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * truncate the members SLRU.&nbsp; So we first scan the directory to determine<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the earliest offsets page number that we can read without error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When nextMXact is less than one segment away from multiWrapLimit,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2969" title="access/transam/multixact.c:2969">SlruScanDirCbFindEarliest</a> can <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> some early segment other than the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actual earliest.&nbsp; (<a href="#L3220" title="access/transam/multixact.c:3220">MultiXactOffsetPagePrecedes</a>(EARLIEST, LATEST)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * returns false, because not all pairs of entries have the same answer.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * That can also arise when an earlier truncation attempt failed unlink()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or returned early from this function.&nbsp; The only consequence is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * returning early, which wastes space that we could have liberated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: It's also possible that the page that oldestMulti is on has already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been truncated away, and we crashed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> updating oldestMulti.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; trunc.earliestExistingPage = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="slru.c.html#L1774" title="access/transam/slru.c:1774">SlruScanDirectory</a>(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, <a href="#L2969" title="access/transam/multixact.c:2969">SlruScanDirCbFindEarliest</a>, &amp;trunc);<br/></li>
<li>&nbsp; &nbsp; earliest = trunc.earliestExistingPage * <a href="#L109" title="access/transam/multixact.c:109">MULTIXACT_OFFSETS_PER_PAGE</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (earliest &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; earliest = FirstMultiXactId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there's nothing to remove, we can bail out early. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(oldestMulti, earliest))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactTruncationLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, compute the safe truncation point for MultiXactMember. This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the starting offset of the oldest multixact.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Hopefully, <a href="#L2839" title="access/transam/multixact.c:2839">find_multixact_start</a> will always work here, because we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already checked that it doesn't precede the earliest MultiXact on disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * But if it fails, don't truncate anything, and log a message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (oldestMulti == nextMulti)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there are NO MultiXacts */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldestOffset = nextOffset;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="#L2839" title="access/transam/multixact.c:2839">find_multixact_start</a>(oldestMulti, &amp;oldestOffset))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;oldest MultiXact </span><span class="Special">%u</span><span class="Constant"> not found, earliest MultiXact </span><span class="Special">%u</span><span class="Constant">, skipping truncation&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestMulti, earliest)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactTruncationLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Secondly compute up to where to truncate. Lookup the corresponding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * member offset for newOldestMulti for that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newOldestMulti == nextMulti)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there are NO MultiXacts */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newOldestOffset = nextOffset;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="#L2839" title="access/transam/multixact.c:2839">find_multixact_start</a>(newOldestMulti, &amp;newOldestOffset))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot truncate up to MultiXact </span><span class="Special">%u</span><span class="Constant"> because it does not exist on disk, skipping truncation&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newOldestMulti)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactTruncationLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;performing multixact truncation: &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;offsets [</span><span class="Special">%u</span><span class="Constant">, </span><span class="Special">%u</span><span class="Constant">), offsets segments [</span><span class="Special">%x</span><span class="Constant">, </span><span class="Special">%x</span><span class="Constant">), &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;members [</span><span class="Special">%u</span><span class="Constant">, </span><span class="Special">%u</span><span class="Constant">), members segments [</span><span class="Special">%x</span><span class="Constant">, </span><span class="Special">%x</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldestMulti, newOldestMulti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L115" title="access/transam/multixact.c:115">MultiXactIdToOffsetSegment</a>(oldestMulti),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L115" title="access/transam/multixact.c:115">MultiXactIdToOffsetSegment</a>(newOldestMulti),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldestOffset, newOldestOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L160" title="access/transam/multixact.c:160">MXOffsetToMemberSegment</a>(oldestOffset),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L160" title="access/transam/multixact.c:160">MXOffsetToMemberSegment</a>(newOldestOffset));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do truncation, and the WAL logging of the truncation, in a critical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * section. That way offsets/members cannot get out of sync anymore, i.e.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * once consistent the newOldestMulti will always exist in members, even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we crashed in the wrong moment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prevent checkpoints from being scheduled concurrently. This is critical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because otherwise a truncation record might not be replayed after a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * crash/basebackup, even though the state of the data directory would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * require it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert((<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags &amp; DELAY_CHKPT_START) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags |= DELAY_CHKPT_START;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* WAL log truncation */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3312" title="access/transam/multixact.c:3312">WriteMTruncateXlogRec</a>(newOldestMultiDB,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestMulti, newOldestMulti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestOffset, newOldestOffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update in-memory limits <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> performing the truncation, while inside<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the critical section: Have to do it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> truncation, to prevent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrent lookups of those <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. Has to be inside the critical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * section as otherwise a future call to this function would error out,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * while looking up the oldest member in offsets, if our caller crashes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> updating the limits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactGenLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestMultiXactId = newOldestMulti;<br/></li>
<li>&nbsp; &nbsp; <a href="#L298" title="access/transam/multixact.c:298">MultiXactState</a>-&gt;oldestMultiXactDB = newOldestMultiDB;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First truncate members */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2992" title="access/transam/multixact.c:2992">PerformMembersTruncation</a>(oldestOffset, newOldestOffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Then offsets */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3020" title="access/transam/multixact.c:3020">PerformOffsetsTruncation</a>(oldestMulti, newOldestMulti);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags &amp;= ~DELAY_CHKPT_START;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactTruncationLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Decide whether a MultiXactOffset page number is &quot;older&quot; for truncation<br/></li>
<li></span><span class="Comment"> * purposes.&nbsp; Analogous to <a href="clog.c.html#L1055" title="access/transam/clog.c:1055">CLOGPagePrecedes</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Offsetting the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> is optional, because <a href="#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>() has<br/></li>
<li></span><span class="Comment"> * translational symmetry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3220">&#x200c;</a></span><span class="linkable">MultiXactOffsetPagePrecedes</span>(int64 page1, int64 page2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactId multi1;<br/></li>
<li>&nbsp; &nbsp; MultiXactId multi2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; multi1 = ((MultiXactId) page1) * <a href="#L109" title="access/transam/multixact.c:109">MULTIXACT_OFFSETS_PER_PAGE</a>;<br/></li>
<li>&nbsp; &nbsp; multi1 += FirstMultiXactId + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; multi2 = ((MultiXactId) page2) * <a href="#L109" title="access/transam/multixact.c:109">MULTIXACT_OFFSETS_PER_PAGE</a>;<br/></li>
<li>&nbsp; &nbsp; multi2 += FirstMultiXactId + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(multi1, multi2) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(multi1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multi2 + <a href="#L109" title="access/transam/multixact.c:109">MULTIXACT_OFFSETS_PER_PAGE</a> - <span class="Constant">1</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Decide whether a MultiXactMember page number is &quot;older&quot; for truncation<br/></li>
<li></span><span class="Comment"> * purposes.&nbsp; There is no &quot;invalid offset number&quot; so use the numbers verbatim.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3240">&#x200c;</a></span><span class="linkable">MultiXactMemberPagePrecedes</span>(int64 page1, int64 page2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset offset1;<br/></li>
<li>&nbsp; &nbsp; MultiXactOffset offset2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; offset1 = ((MultiXactOffset) page1) * <a href="#L142" title="access/transam/multixact.c:142">MULTIXACT_MEMBERS_PER_PAGE</a>;<br/></li>
<li>&nbsp; &nbsp; offset2 = ((MultiXactOffset) page2) * <a href="#L142" title="access/transam/multixact.c:142">MULTIXACT_MEMBERS_PER_PAGE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L3286" title="access/transam/multixact.c:3286">MultiXactOffsetPrecedes</a>(offset1, offset2) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3286" title="access/transam/multixact.c:3286">MultiXactOffsetPrecedes</a>(offset1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset2 + <a href="#L142" title="access/transam/multixact.c:142">MULTIXACT_MEMBERS_PER_PAGE</a> - <span class="Constant">1</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Decide which of two MultiXactIds is earlier.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> do we need to do something special for InvalidMultiXactId?<br/></li>
<li></span><span class="Comment"> * (Doesn't look like it.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3260">&#x200c;</a></span><span class="linkable">MultiXactIdPrecedes</span>(MultiXactId multi1, MultiXactId multi2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; diff = (int32) (multi1 - multi2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (diff &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3274" title="access/transam/multixact.c:3274">MultiXactIdPrecedesOrEquals</a> -- is multi1 logically &lt;= multi2?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> do we need to do something special for InvalidMultiXactId?<br/></li>
<li></span><span class="Comment"> * (Doesn't look like it.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3274">&#x200c;</a></span><span class="linkable">MultiXactIdPrecedesOrEquals</span>(MultiXactId multi1, MultiXactId multi2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; diff = (int32) (multi1 - multi2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (diff &lt;= <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Decide which of two offsets is earlier.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3286">&#x200c;</a></span><span class="linkable">MultiXactOffsetPrecedes</span>(MultiXactOffset offset1, MultiXactOffset offset2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; diff = (int32) (offset1 - offset2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (diff &lt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write an xlog record reflecting the zeroing of either a MEMBERs or<br/></li>
<li></span><span class="Comment"> * OFFSETs page (info shows which)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3298">&#x200c;</a></span><span class="linkable">WriteMZeroPageXlogRec</span>(int64 pageno, uint8 info)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;pageno), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pageno));<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_MULTIXACT_ID, info);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write a TRUNCATE xlog record<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We must flush the xlog record to disk <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning --- see notes in<br/></li>
<li></span><span class="Comment"> * <a href="clog.c.html#L1000" title="access/transam/clog.c:1000">TruncateCLOG</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3312">&#x200c;</a></span><span class="linkable">WriteMTruncateXlogRec</span>(Oid oldestMultiDB,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactId startTruncOff, MultiXactId endTruncOff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactOffset startTruncMemb, MultiXactOffset endTruncMemb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; xl_multixact_truncate xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec.oldestMultiDB = oldestMultiDB;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec.startTruncOff = startTruncOff;<br/></li>
<li>&nbsp; &nbsp; xlrec.endTruncOff = endTruncOff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec.startTruncMemb = startTruncMemb;<br/></li>
<li>&nbsp; &nbsp; xlrec.endTruncMemb = endTruncMemb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xlrec), SizeOfMultiXactTruncate);<br/></li>
<li>&nbsp; &nbsp; recptr = <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_MULTIXACT_ID, XLOG_MULTIXACT_TRUNCATE_ID);<br/></li>
<li>&nbsp; &nbsp; <a href="xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(recptr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * MULTIXACT resource manager's routines<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3337">&#x200c;</a></span><span class="linkable">multixact_redo</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(record) &amp; ~XLR_INFO_MASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Backup blocks are not used in multixact <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!XLogRecHasAnyBlockRefs(record));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (info == XLOG_MULTIXACT_ZERO_OFF_PAGE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;pageno, XLogRecGetData(record), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pageno));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock = SimpleLruGetBankLock(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, pageno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slotno = <a href="#L2025" title="access/transam/multixact.c:2025">ZeroMultiXactOffsetPage</a>(pageno, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slru.c.html#L715" title="access/transam/slru.c:715">SimpleLruWritePage</a>(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, slotno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>-&gt;shared-&gt;page_dirty[slotno]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_MULTIXACT_ZERO_MEM_PAGE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;pageno, XLogRecGetData(record), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pageno));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock = SimpleLruGetBankLock(<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>, pageno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slotno = <a href="#L2041" title="access/transam/multixact.c:2041">ZeroMultiXactMemberPage</a>(pageno, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="slru.c.html#L715" title="access/transam/slru.c:715">SimpleLruWritePage</a>(<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>, slotno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>-&gt;shared-&gt;page_dirty[slotno]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(lock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_MULTIXACT_CREATE_ID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_multixact_create *xlrec =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (xl_multixact_create *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId max_xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Store the data back into the SLRU files */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L869" title="access/transam/multixact.c:869">RecordNewMultiXact</a>(xlrec-&gt;mid, xlrec-&gt;moff, xlrec-&gt;nmembers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;members);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure nextMXact/nextOffset are beyond what this record has */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2462" title="access/transam/multixact.c:2462">MultiXactAdvanceNextMXact</a>(xlrec-&gt;mid + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec-&gt;moff + xlrec-&gt;nmembers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure nextXid is beyond <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> XID mentioned in the record. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should be unnecessary, since <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> XID found here ought to have other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * evidence in the XLOG, but let's be safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; max_xid = XLogRecGetXid(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; xlrec-&gt;nmembers; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(max_xid, xlrec-&gt;members[i].xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_xid = xlrec-&gt;members[i].xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="varsup.c.html#L304" title="access/transam/varsup.c:304">AdvanceNextFullTransactionIdPastXid</a>(max_xid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_MULTIXACT_TRUNCATE_ID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_multixact_truncate xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;xlrec, XLogRecGetData(record),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SizeOfMultiXactTruncate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;replaying multixact truncation: &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;offsets [</span><span class="Special">%u</span><span class="Constant">, </span><span class="Special">%u</span><span class="Constant">), offsets segments [</span><span class="Special">%x</span><span class="Constant">, </span><span class="Special">%x</span><span class="Constant">), &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;members [</span><span class="Special">%u</span><span class="Constant">, </span><span class="Special">%u</span><span class="Constant">), members segments [</span><span class="Special">%x</span><span class="Constant">, </span><span class="Special">%x</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec.startTruncOff, xlrec.endTruncOff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L115" title="access/transam/multixact.c:115">MultiXactIdToOffsetSegment</a>(xlrec.startTruncOff),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L115" title="access/transam/multixact.c:115">MultiXactIdToOffsetSegment</a>(xlrec.endTruncOff),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec.startTruncMemb, xlrec.endTruncMemb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L160" title="access/transam/multixact.c:160">MXOffsetToMemberSegment</a>(xlrec.startTruncMemb),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L160" title="access/transam/multixact.c:160">MXOffsetToMemberSegment</a>(xlrec.endTruncMemb));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should not be required, but more than cheap enough */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(MultiXactTruncationLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Advance the horizon <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, so they're current at the end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2313" title="access/transam/multixact.c:2313">SetMultiXactIdLimit</a>(xlrec.endTruncOff, xlrec.oldestMultiDB, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2992" title="access/transam/multixact.c:2992">PerformMembersTruncation</a>(xlrec.startTruncMemb, xlrec.endTruncMemb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * During XLOG replay, latest_page_number isn't necessarily set up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * yet; insert a suitable value to bypass the sanity test in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="slru.c.html#L1391" title="access/transam/slru.c:1391">SimpleLruTruncate</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pageno = <a href="#L111" title="access/transam/multixact.c:111">MultiXactIdToOffsetPage</a>(xlrec.endTruncOff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>-&gt;shared-&gt;latest_page_number,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3020" title="access/transam/multixact.c:3020">PerformOffsetsTruncation</a>(xlrec.startTruncOff, xlrec.endTruncOff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(MultiXactTruncationLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;<a href="#L3337" title="access/transam/multixact.c:3337">multixact_redo</a>: unknown op code </span><span class="Special">%u</span><span class="Constant">&quot;</span>, info);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L3453">&#x200c;</a><span class="linkable">pg_get_multixact_members</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactMember *members;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmembers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; } mxact;<br/></li>
<li>&nbsp; &nbsp; MultiXactId mxid = PG_GETARG_TRANSACTIONID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; mxact&nbsp; &nbsp; &nbsp;&nbsp; *multi;<br/></li>
<li>&nbsp; &nbsp; FuncCallContext *funccxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mxid &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid MultiXactId: </span><span class="Special">%u</span><span class="Constant">&quot;</span>, mxid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (SRF_IS_FIRSTCALL())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funccxt = SRF_FIRSTCALL_INIT();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(funccxt-&gt;multi_call_memory_ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; multi = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(mxact));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no need to allow for old <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; multi-&gt;nmembers = <a href="#L1252" title="access/transam/multixact.c:1252">GetMultiXactIdMembers</a>(mxid, &amp;multi-&gt;members, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; multi-&gt;iter = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/fmgr/funcapi.c.html#L276" title="utils/fmgr/funcapi.c:276">get_call_result_type</a>(fcinfo, <span class="Constant">NULL</span>, &amp;tupdesc) != TYPEFUNC_COMPOSITE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;return type must be a row type&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funccxt-&gt;tuple_desc = tupdesc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funccxt-&gt;attinmeta = <a href="../../executor/execTuples.c.html#L2173" title="executor/execTuples.c:2173">TupleDescGetAttInMetadata</a>(tupdesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funccxt-&gt;user_fctx = multi;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; funccxt = SRF_PERCALL_SETUP();<br/></li>
<li>&nbsp; &nbsp; multi = (mxact *) funccxt-&gt;user_fctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (multi-&gt;iter &lt; multi-&gt;nmembers)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = psprintf(<span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant">&quot;</span>, multi-&gt;members[multi-&gt;iter].xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = <a href="#L1705" title="access/transam/multixact.c:1705">mxstatus_to_string</a>(multi-&gt;members[multi-&gt;iter].status);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../../executor/execTuples.c.html#L2222" title="executor/execTuples.c:2222">BuildTupleFromCStrings</a>(funccxt-&gt;attinmeta, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; multi-&gt;iter++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SRF_RETURN_NEXT(funccxt, HeapTupleGetDatum(tuple));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SRF_RETURN_DONE(funccxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Entrypoint for sync.c to sync offsets files.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3518">&#x200c;</a></span><span class="linkable">multixactoffsetssyncfiletag</span>(<span class="Type">const</span> FileTag *ftag, <span class="Type">char</span> *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="slru.c.html#L1814" title="access/transam/slru.c:1814">SlruSyncFileTag</a>(<a href="#L190" title="access/transam/multixact.c:190">MultiXactOffsetCtl</a>, ftag, path);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Entrypoint for sync.c to sync members files.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3527">&#x200c;</a></span><span class="linkable">multixactmemberssyncfiletag</span>(<span class="Type">const</span> FileTag *ftag, <span class="Type">char</span> *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="slru.c.html#L1814" title="access/transam/slru.c:1814">SlruSyncFileTag</a>(<a href="#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a>, ftag, path);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
