<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/transam/slru.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/transam/slru.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L160">slru_errcause</a></li>
<li><a href="#L161">slru_errno</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L158">SlruErrorCause</a></li>
<li><a href="#L118">SlruWriteAll</a></li>
<li><a href="#L111">SlruWriteAllData</a></li>
<li><a href="#L116">SlruWriteAllData</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L217">SimpleLruAutotuneBuffers</a></li>
<li><a href="#L729">SimpleLruDoesPhysicalPageExist</a></li>
<li><a href="#L238">SimpleLruInit</a></li>
<li><a href="#L488">SimpleLruReadPage</a></li>
<li><a href="#L591">SimpleLruReadPage_ReadOnly</a></li>
<li><a href="#L184">SimpleLruShmemSize</a></li>
<li><a href="#L1391">SimpleLruTruncate</a></li>
<li><a href="#L431">SimpleLruWaitIO</a></li>
<li><a href="#L1305">SimpleLruWriteAll</a></li>
<li><a href="#L715">SimpleLruWritePage</a></li>
<li><a href="#L414">SimpleLruZeroLSNs</a></li>
<li><a href="#L361">SimpleLruZeroPage</a></li>
<li><a href="#L1741">SlruCorrectSegmentFilenameLength</a></li>
<li><a href="#L1509">SlruDeleteSegment</a></li>
<li><a href="#L76">SlruFileName</a></li>
<li><a href="#L1486">SlruInternalDeleteSegment</a></li>
<li><a href="#L638">SlruInternalWritePage</a></li>
<li><a href="#L1586">SlruMayDeleteSegment</a></li>
<li><a href="#L1598">SlruPagePrecedesTestOffset</a></li>
<li><a href="#L1680">SlruPagePrecedesUnitTests</a></li>
<li><a href="#L787">SlruPhysicalReadPage</a></li>
<li><a href="#L859">SlruPhysicalWritePage</a></li>
<li><a href="#L1106">SlruRecentlyUsed</a></li>
<li><a href="#L1031">SlruReportIOError</a></li>
<li><a href="#L1727">SlruScanDirCbDeleteAll</a></li>
<li><a href="#L1711">SlruScanDirCbDeleteCutoff</a></li>
<li><a href="#L1695">SlruScanDirCbReportPresence</a></li>
<li><a href="#L1774">SlruScanDirectory</a></li>
<li><a href="#L1152">SlruSelectLRUPage</a></li>
<li><a href="#L1814">SlruSyncFileTag</a></li>
<li><a href="#L341">check_slru_buffers</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L142">INIT_SLRUFILETAG</a></li>
<li><a href="#L109">MAX_WRITEALL_BUFFERS</a></li>
<li><a href="#L128">SLRU_BANK_BITSHIFT</a></li>
<li><a href="#L129">SLRU_BANK_SIZE</a></li>
<li><a href="#L134">SlotGetBankNumber</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * slru.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Simple LRU buffering for wrap-around-able permanent metadata<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module is used to maintain various pieces of transaction status<br/></li>
<li></span><span class="Comment"> * indexed by TransactionId (such as commit status, parent transaction ID,<br/></li>
<li></span><span class="Comment"> * commit timestamp), as well as storage for multixacts, serializable<br/></li>
<li></span><span class="Comment"> * isolation locks and NOTIFY traffic.&nbsp; Extensions can define their own<br/></li>
<li></span><span class="Comment"> * SLRUs, too.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Under ordinary circumstances we expect that write traffic will occur<br/></li>
<li></span><span class="Comment"> * mostly to the latest page (and to the just-prior page, soon after a<br/></li>
<li></span><span class="Comment"> * page transition).&nbsp; Read traffic will probably touch a larger span of<br/></li>
<li></span><span class="Comment"> * pages, but a relatively small number of buffers should be sufficient.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use a simple least-recently-used scheme to manage a pool of shared<br/></li>
<li></span><span class="Comment"> * page buffers, split in banks by the lowest bits of the page number, and<br/></li>
<li></span><span class="Comment"> * the management algorithm only processes the bank to which the desired<br/></li>
<li></span><span class="Comment"> * page belongs, so a linear search is sufficient; there's no need for a<br/></li>
<li></span><span class="Comment"> * hashtable or anything fancy.&nbsp; The algorithm is straight LRU except that<br/></li>
<li></span><span class="Comment"> * we will never swap out the latest page (since we know it's going to be<br/></li>
<li></span><span class="Comment"> * hit again eventually).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use per-bank control LWLocks to protect the shared data structures,<br/></li>
<li></span><span class="Comment"> * plus per-buffer LWLocks that synchronize I/O for each buffer.&nbsp; The<br/></li>
<li></span><span class="Comment"> * bank's control lock must be held to examine or modify <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the bank's<br/></li>
<li></span><span class="Comment"> * shared state.&nbsp; A process that is reading in or writing out a page<br/></li>
<li></span><span class="Comment"> * buffer does not hold the control lock, only the per-buffer lock for the<br/></li>
<li></span><span class="Comment"> * buffer it is working on.&nbsp; One exception is latest_page_number, which is<br/></li>
<li></span><span class="Comment"> * read and written using atomic ops.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;Holding the bank control lock&quot; means exclusive lock in all cases<br/></li>
<li></span><span class="Comment"> * except for <a href="#L591" title="access/transam/slru.c:591">SimpleLruReadPage_ReadOnly</a>(); see comments for<br/></li>
<li></span><span class="Comment"> * <a href="#L1106" title="access/transam/slru.c:1106">SlruRecentlyUsed</a>() for the implications of that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When initiating I/O on a buffer, we acquire the per-buffer lock exclusively<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing the control lock.&nbsp; The per-buffer lock is released after<br/></li>
<li></span><span class="Comment"> * completing the I/O, re-acquiring the control lock, and updating the shared<br/></li>
<li></span><span class="Comment"> * state.&nbsp; (Deadlock is not possible here, because we never try to initiate<br/></li>
<li></span><span class="Comment"> * I/O when someone else is already doing I/O on the same buffer.)<br/></li>
<li></span><span class="Comment"> * To wait for I/O to complete, release the control lock, acquire the<br/></li>
<li></span><span class="Comment"> * per-buffer lock in shared mode, immediately release the per-buffer lock,<br/></li>
<li></span><span class="Comment"> * reacquire the control lock, and then recheck state (since arbitrary things<br/></li>
<li></span><span class="Comment"> * could have happened while we didn't have the lock).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As with the regular buffer manager, it is possible for another process<br/></li>
<li></span><span class="Comment"> * to re-dirty a page that is currently being written out.&nbsp; This is handled<br/></li>
<li></span><span class="Comment"> * by re-setting the page's page_dirty flag.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * src/backend/access/transam/slru.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/slru.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L76">&#x200c;</a></span><span class="linkable">SlruFileName</span>(SlruCtl ctl, <span class="Type">char</span> *path, int64 segno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ctl-&gt;long_segment_names)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could use 16 characters here but the disadvantage would be that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the SLRU segments will be hard to distinguish from WAL segments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For this reason we use 15 characters. It is enough but also means<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that in the future we can't decrease SLRU_PAGES_PER_SEGMENT easily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(segno &gt;= <span class="Constant">0</span> &amp;&amp; segno &lt;= INT64CONST(<span class="Constant">0xFFFFFFFFFFFFFFF</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> snprintf(path, MAXPGPATH, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%015llX</span><span class="Constant">&quot;</span>, ctl-&gt;Dir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) segno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Despite the fact that %04X format string is used up to 24 <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * integers are allowed. See <a href="#L1741" title="access/transam/slru.c:1741">SlruCorrectSegmentFilenameLength</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(segno &gt;= <span class="Constant">0</span> &amp;&amp; segno &lt;= INT64CONST(<span class="Constant">0xFFFFFF</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> snprintf(path, MAXPGPATH, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%04X</span><span class="Constant">&quot;</span>, (ctl)-&gt;Dir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) segno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * During <a href="#L1305" title="access/transam/slru.c:1305">SimpleLruWriteAll</a>(), we will usually not need to write more than one<br/></li>
<li></span><span class="Comment"> * or two physical files, but we may need to write several pages per file.&nbsp; We<br/></li>
<li></span><span class="Comment"> * can consolidate the I/O requests by leaving files open until control returns<br/></li>
<li></span><span class="Comment"> * to <a href="#L1305" title="access/transam/slru.c:1305">SimpleLruWriteAll</a>().&nbsp; This data structure remembers which files are open.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L109">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_WRITEALL_BUFFERS</span>&nbsp; &nbsp; </span><span class="Constant">16<br/></li>
<li></span><br/></li>
<li><a id="L111">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SlruWriteAllData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_files;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* # files actually open */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd[<a href="#L109" title="access/transam/slru.c:109">MAX_WRITEALL_BUFFERS</a>];&nbsp; &nbsp; <span class="Comment">/* their FD's */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; segno[<a href="#L109" title="access/transam/slru.c:109">MAX_WRITEALL_BUFFERS</a>];&nbsp; &nbsp; <span class="Comment">/* their log seg#s */<br/></li>
<li><a id="L116">&#x200c;</a></span>} <span class="linkable">SlruWriteAllData</span>;<br/></li>
<li><br/></li>
<li><a id="L118">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <a href="#L111" title="access/transam/slru.c:111">SlruWriteAllData</a> *<span class="linkable">SlruWriteAll</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Bank size for the slot array.&nbsp; Pages are assigned a bank according to their<br/></li>
<li></span><span class="Comment"> * page number, with each bank being this size.&nbsp; We want a power of 2 so that<br/></li>
<li></span><span class="Comment"> * we can determine the bank number for a page with just <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> shifting; we also<br/></li>
<li></span><span class="Comment"> * want to keep the bank size small so that LRU victim search is fast.&nbsp; 16<br/></li>
<li></span><span class="Comment"> * buffers per bank seems a good number.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L128">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SLRU_BANK_BITSHIFT</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">4<br/></li>
<li><a id="L129">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SLRU_BANK_SIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; <a href="#L128" title="access/transam/slru.c:128">SLRU_BANK_BITSHIFT</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Macro to get the bank number to which the slot belongs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L134">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SlotGetBankNumber</span>(slotno)&nbsp; &nbsp; ((slotno) &gt;&gt; <a href="#L128" title="access/transam/slru.c:128">SLRU_BANK_BITSHIFT</a>)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Populate a file tag describing a segment file.&nbsp; We only use the segment<br/></li>
<li></span><span class="Comment"> * number, since we can derive everything else we need by having separate<br/></li>
<li></span><span class="Comment"> * sync handler <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for clog, multixact etc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L142">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INIT_SLRUFILETAG</span>(a,xx_handler,xx_segno) \<br/></li>
<li></span><span class="PreProc">( \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; memset(&amp;(a), </span><span class="Constant">0</span><span class="PreProc">, </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(FileTag)), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (a).handler = (xx_handler), \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (a).segno = (xx_segno) \<br/></li>
<li></span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Saved info for <a href="#L1031" title="access/transam/slru.c:1031">SlruReportIOError</a> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; SLRU_OPEN_FAILED,<br/></li>
<li>&nbsp; &nbsp; SLRU_SEEK_FAILED,<br/></li>
<li>&nbsp; &nbsp; SLRU_READ_FAILED,<br/></li>
<li>&nbsp; &nbsp; SLRU_WRITE_FAILED,<br/></li>
<li>&nbsp; &nbsp; SLRU_FSYNC_FAILED,<br/></li>
<li>&nbsp; &nbsp; SLRU_CLOSE_FAILED,<br/></li>
<li><a id="L158">&#x200c;</a>} <span class="linkable">SlruErrorCause</span>;<br/></li>
<li><br/></li>
<li><a id="L160">&#x200c;</a><span class="Type">static</span> <a href="#L158" title="access/transam/slru.c:158">SlruErrorCause</a> <span class="linkable">slru_errcause</span>;<br/></li>
<li><a id="L161">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">slru_errno</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L414" title="access/transam/slru.c:414">SimpleLruZeroLSNs</a>(SlruCtl ctl, <span class="Type">int</span> slotno);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L431" title="access/transam/slru.c:431">SimpleLruWaitIO</a>(SlruCtl ctl, <span class="Type">int</span> slotno);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L638" title="access/transam/slru.c:638">SlruInternalWritePage</a>(SlruCtl ctl, <span class="Type">int</span> slotno, <a href="#L118" title="access/transam/slru.c:118">SlruWriteAll</a> fdata);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L787" title="access/transam/slru.c:787">SlruPhysicalReadPage</a>(SlruCtl ctl, int64 pageno, <span class="Type">int</span> slotno);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L859" title="access/transam/slru.c:859">SlruPhysicalWritePage</a>(SlruCtl ctl, int64 pageno, <span class="Type">int</span> slotno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L118" title="access/transam/slru.c:118">SlruWriteAll</a> fdata);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1031" title="access/transam/slru.c:1031">SlruReportIOError</a>(SlruCtl ctl, int64 pageno, TransactionId xid);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1152" title="access/transam/slru.c:1152">SlruSelectLRUPage</a>(SlruCtl ctl, int64 pageno);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1711" title="access/transam/slru.c:1711">SlruScanDirCbDeleteCutoff</a>(SlruCtl ctl, <span class="Type">char</span> *filename,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64 segpage, <span class="Type">void</span> *data);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1486" title="access/transam/slru.c:1486">SlruInternalDeleteSegment</a>(SlruCtl ctl, int64 segno);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L1106" title="access/transam/slru.c:1106">SlruRecentlyUsed</a>(SlruShared shared, <span class="Type">int</span> slotno);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialization of shared memory<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li>Size<br/></li>
<li><a id="L184">&#x200c;</a><span class="linkable">SimpleLruShmemSize</span>(<span class="Type">int</span> nslots, <span class="Type">int</span> nlsns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbanks = nslots / <a href="#L129" title="access/transam/slru.c:129">SLRU_BANK_SIZE</a>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; sz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(nslots &lt;= SLRU_MAX_ALLOWED_BUFFERS);<br/></li>
<li>&nbsp; &nbsp; Assert(nslots % <a href="#L129" title="access/transam/slru.c:129">SLRU_BANK_SIZE</a> == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we assume nslots isn't so large as to risk overflow */<br/></li>
<li></span>&nbsp; &nbsp; sz = MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SlruSharedData));<br/></li>
<li>&nbsp; &nbsp; sz += MAXALIGN(nslots * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span> *));&nbsp; &nbsp; <span class="Comment">/* page_buffer[] */<br/></li>
<li></span>&nbsp; &nbsp; sz += MAXALIGN(nslots * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SlruPageStatus));&nbsp; &nbsp; <span class="Comment">/* page_status[] */<br/></li>
<li></span>&nbsp; &nbsp; sz += MAXALIGN(nslots * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));&nbsp; &nbsp; <span class="Comment">/* page_dirty[] */<br/></li>
<li></span>&nbsp; &nbsp; sz += MAXALIGN(nslots * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64)); <span class="Comment">/* page_number[] */<br/></li>
<li></span>&nbsp; &nbsp; sz += MAXALIGN(nslots * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));&nbsp; &nbsp; <span class="Comment">/* page_lru_count[] */<br/></li>
<li></span>&nbsp; &nbsp; sz += MAXALIGN(nslots * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LWLockPadded));&nbsp; &nbsp; <span class="Comment">/* buffer_locks[] */<br/></li>
<li></span>&nbsp; &nbsp; sz += MAXALIGN(nbanks * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LWLockPadded));&nbsp; &nbsp; <span class="Comment">/* bank_locks[] */<br/></li>
<li></span>&nbsp; &nbsp; sz += MAXALIGN(nbanks * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));&nbsp; &nbsp; <span class="Comment">/* bank_cur_lru_count[] */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nlsns &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sz += MAXALIGN(nslots * nlsns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(XLogRecPtr));&nbsp; &nbsp; <span class="Comment">/* group_lsn[] */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> BUFFERALIGN(sz) + BLCKSZ * nslots;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine a number of SLRU buffers to use.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We simply divide shared_buffers by the divisor given and cap<br/></li>
<li></span><span class="Comment"> * that at the maximum given; but always at least <a href="#L129" title="access/transam/slru.c:129">SLRU_BANK_SIZE</a>.<br/></li>
<li></span><span class="Comment"> * Round down to the nearest multiple of <a href="#L129" title="access/transam/slru.c:129">SLRU_BANK_SIZE</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L217">&#x200c;</a></span><span class="linkable">SimpleLruAutotuneBuffers</span>(<span class="Type">int</span> divisor, <span class="Type">int</span> max)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(max - (max % <a href="#L129" title="access/transam/slru.c:129">SLRU_BANK_SIZE</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Max(<a href="#L129" title="access/transam/slru.c:129">SLRU_BANK_SIZE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> / divisor - (<a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> / divisor) % <a href="#L129" title="access/transam/slru.c:129">SLRU_BANK_SIZE</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize, or attach to, a simple LRU cache in shared memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ctl: address of local (unshared) control structure.<br/></li>
<li></span><span class="Comment"> * name: name of SLRU.&nbsp; (This is user-visible, pick with care!)<br/></li>
<li></span><span class="Comment"> * nslots: number of page slots to use.<br/></li>
<li></span><span class="Comment"> * nlsns: number of LSN groups per page (set to zero if not relevant).<br/></li>
<li></span><span class="Comment"> * ctllock: LWLock to use to control access to the shared control structure.<br/></li>
<li></span><span class="Comment"> * subdir: PGDATA-relative subdirectory that will contain the files.<br/></li>
<li></span><span class="Comment"> * buffer_tranche_id: tranche ID to use for the SLRU's per-buffer LWLocks.<br/></li>
<li></span><span class="Comment"> * bank_tranche_id: tranche ID to use for the bank LWLocks.<br/></li>
<li></span><span class="Comment"> * sync_handler: which set of <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to use to handle sync requests<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L238">&#x200c;</a></span><span class="linkable">SimpleLruInit</span>(SlruCtl ctl, <span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type">int</span> nslots, <span class="Type">int</span> nlsns,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *subdir, <span class="Type">int</span> buffer_tranche_id, <span class="Type">int</span> bank_tranche_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SyncRequestHandler sync_handler, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> long_segment_names)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SlruShared&nbsp; &nbsp; shared;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbanks = nslots / <a href="#L129" title="access/transam/slru.c:129">SLRU_BANK_SIZE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(nslots &lt;= SLRU_MAX_ALLOWED_BUFFERS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; shared = (SlruShared) <a href="../../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L184" title="access/transam/slru.c:184">SimpleLruShmemSize</a>(nslots, nlsns),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize locks and shared memory area */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(shared, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SlruSharedData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;num_slots = nslots;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;lsn_groups_per_page = nlsns;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u64(&amp;shared-&gt;latest_page_number, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;slru_stats_idx = <a href="../../utils/activity/pgstat_slru.c.html#L132" title="utils/activity/pgstat_slru.c:132">pgstat_get_slru_index</a>(name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = (<span class="Type">char</span> *) shared;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset = MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SlruSharedData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_buffer = (<span class="Type">char</span> **) (ptr + offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset += MAXALIGN(nslots * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span> *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_status = (SlruPageStatus *) (ptr + offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset += MAXALIGN(nslots * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SlruPageStatus));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_dirty = (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *) (ptr + offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset += MAXALIGN(nslots * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_number = (int64 *) (ptr + offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset += MAXALIGN(nslots * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_lru_count = (<span class="Type">int</span> *) (ptr + offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset += MAXALIGN(nslots * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize LWLocks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;buffer_locks = (LWLockPadded *) (ptr + offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset += MAXALIGN(nslots * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LWLockPadded));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;bank_locks = (LWLockPadded *) (ptr + offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset += MAXALIGN(nbanks * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LWLockPadded));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;bank_cur_lru_count = (<span class="Type">int</span> *) (ptr + offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offset += MAXALIGN(nbanks * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nlsns &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;group_lsn = (XLogRecPtr *) (ptr + offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset += MAXALIGN(nslots * nlsns * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(XLogRecPtr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += BUFFERALIGN(offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> slotno = <span class="Constant">0</span>; slotno &lt; nslots; slotno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;shared-&gt;buffer_locks[slotno].lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buffer_tranche_id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_buffer[slotno] = ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_status[slotno] = SLRU_PAGE_EMPTY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_dirty[slotno] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_lru_count[slotno] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize the slot banks. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> bankno = <span class="Constant">0</span>; bankno &lt; nbanks; bankno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;shared-&gt;bank_locks[bankno].lock, bank_tranche_id);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;bank_cur_lru_count[bankno] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should fit to estimated shmem size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ptr - (<span class="Type">char</span> *) shared &lt;= <a href="#L184" title="access/transam/slru.c:184">SimpleLruShmemSize</a>(nslots, nlsns));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(shared-&gt;num_slots == nslots);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the unshared control struct, including directory path. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume caller set PagePrecedes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctl-&gt;shared = shared;<br/></li>
<li>&nbsp; &nbsp; ctl-&gt;sync_handler = sync_handler;<br/></li>
<li>&nbsp; &nbsp; ctl-&gt;long_segment_names = long_segment_names;<br/></li>
<li>&nbsp; &nbsp; ctl-&gt;bank_mask = (nslots / <a href="#L129" title="access/transam/slru.c:129">SLRU_BANK_SIZE</a>) - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; strlcpy(ctl-&gt;Dir, subdir, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ctl-&gt;Dir));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for GUC check_hook to check whether slru buffers are in<br/></li>
<li></span><span class="Comment"> * multiples of <a href="#L129" title="access/transam/slru.c:129">SLRU_BANK_SIZE</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L341">&#x200c;</a></span><span class="linkable">check_slru_buffers</span>(<span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type">int</span> *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Valid <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are multiples of <a href="#L129" title="access/transam/slru.c:129">SLRU_BANK_SIZE</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> % <a href="#L129" title="access/transam/slru.c:129">SLRU_BANK_SIZE</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be a multiple of </span><span class="Special">%d</span><span class="Constant">&quot;</span>, name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="access/transam/slru.c:129">SLRU_BANK_SIZE</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize (or reinitialize) a page to zeroes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The page is not actually written, just set up in shared memory.<br/></li>
<li></span><span class="Comment"> * The slot number of the new page is returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Bank lock must be held at entry, and will be held at exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L361">&#x200c;</a></span><span class="linkable">SimpleLruZeroPage</span>(SlruCtl ctl, int64 pageno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SlruShared&nbsp; &nbsp; shared = ctl-&gt;shared;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(SimpleLruGetBankLock(ctl, pageno), LW_EXCLUSIVE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find a suitable buffer slot for the page */<br/></li>
<li></span>&nbsp; &nbsp; slotno = <a href="#L1152" title="access/transam/slru.c:1152">SlruSelectLRUPage</a>(ctl, pageno);<br/></li>
<li>&nbsp; &nbsp; Assert(shared-&gt;page_status[slotno] == SLRU_PAGE_EMPTY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (shared-&gt;page_status[slotno] == SLRU_PAGE_VALID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !shared-&gt;page_dirty[slotno]) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; shared-&gt;page_number[slotno] == pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the slot as containing this page */<br/></li>
<li></span>&nbsp; &nbsp; shared-&gt;page_number[slotno] = pageno;<br/></li>
<li>&nbsp; &nbsp; shared-&gt;page_status[slotno] = SLRU_PAGE_VALID;<br/></li>
<li>&nbsp; &nbsp; shared-&gt;page_dirty[slotno] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1106" title="access/transam/slru.c:1106">SlruRecentlyUsed</a>(shared, slotno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set the buffer to zeroes */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(shared-&gt;page_buffer[slotno], <span class="Constant">0</span>, BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set the LSNs for this new page to zero */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L414" title="access/transam/slru.c:414">SimpleLruZeroLSNs</a>(ctl, slotno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assume this page is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> the latest active page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that because both this routine and <a href="#L1152" title="access/transam/slru.c:1152">SlruSelectLRUPage</a> run with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ControlLock held, it is not possible for this to be zeroing a page that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1152" title="access/transam/slru.c:1152">SlruSelectLRUPage</a> is going to evict simultaneously.&nbsp; Therefore, there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no memory barrier here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_write_u64(&amp;shared-&gt;latest_page_number, pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update the stats counter of zeroed pages */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_slru.c.html#L59" title="utils/activity/pgstat_slru.c:59">pgstat_count_slru_page_zeroed</a>(shared-&gt;slru_stats_idx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> slotno;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Zero all the LSNs we store for this slru page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be called each time we create a new page, and each time we read<br/></li>
<li></span><span class="Comment"> * in a page from disk into an existing buffer.&nbsp; (Such an old page cannot<br/></li>
<li></span><span class="Comment"> * have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> interesting LSNs, since we'd have flushed them <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> writing<br/></li>
<li></span><span class="Comment"> * the page in the first place.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This assumes that InvalidXLogRecPtr is bitwise-all-0.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L414">&#x200c;</a></span><span class="linkable">SimpleLruZeroLSNs</span>(SlruCtl ctl, <span class="Type">int</span> slotno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SlruShared&nbsp; &nbsp; shared = ctl-&gt;shared;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shared-&gt;lsn_groups_per_page &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(&amp;shared-&gt;group_lsn[slotno * shared-&gt;lsn_groups_per_page], <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; shared-&gt;lsn_groups_per_page * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(XLogRecPtr));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> active I/O on a page slot to finish.&nbsp; (This does not<br/></li>
<li></span><span class="Comment"> * guarantee that new I/O hasn't been started <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we return, though.<br/></li>
<li></span><span class="Comment"> * In fact the slot might not even contain the same page anymore.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Bank lock must be held at entry, and will be held at exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L431">&#x200c;</a></span><span class="linkable">SimpleLruWaitIO</span>(SlruCtl ctl, <span class="Type">int</span> slotno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SlruShared&nbsp; &nbsp; shared = ctl-&gt;shared;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bankno = <a href="#L134" title="access/transam/slru.c:134">SlotGetBankNumber</a>(slotno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(shared-&gt;page_status[slotno] != SLRU_PAGE_EMPTY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See notes at top of file */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;shared-&gt;bank_locks[bankno].lock);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;shared-&gt;buffer_locks[slotno].lock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;shared-&gt;buffer_locks[slotno].lock);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;shared-&gt;bank_locks[bankno].lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the slot is still in an io-in-progress state, then either someone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already started a new I/O on the slot, or a previous I/O failed and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * neglected to reset the page state.&nbsp; That shouldn't happen, really, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it seems worth a few extra cycles to check and recover from it. We can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cheaply test for failure by seeing if the buffer lock is still held (we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume that transaction abort would release the lock).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shared-&gt;page_status[slotno] == SLRU_PAGE_READ_IN_PROGRESS ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_status[slotno] == SLRU_PAGE_WRITE_IN_PROGRESS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/lmgr/lwlock.c.html#L1341" title="storage/lmgr/lwlock.c:1341">LWLockConditionalAcquire</a>(&amp;shared-&gt;buffer_locks[slotno].lock, LW_SHARED))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* indeed, the I/O must have failed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shared-&gt;page_status[slotno] == SLRU_PAGE_READ_IN_PROGRESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_status[slotno] = SLRU_PAGE_EMPTY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* write_in_progress */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_status[slotno] = SLRU_PAGE_VALID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_dirty[slotno] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;shared-&gt;buffer_locks[slotno].lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find a page in a shared buffer, reading it in if necessary.<br/></li>
<li></span><span class="Comment"> * The page number must correspond to an already-initialized page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If write_ok is true then it is OK to return a page that is in<br/></li>
<li></span><span class="Comment"> * WRITE_IN_PROGRESS state; it is the caller's responsibility to be sure<br/></li>
<li></span><span class="Comment"> * that modification of the page is safe.&nbsp; If write_ok is false then we<br/></li>
<li></span><span class="Comment"> * will not return the page until it is not undergoing active I/O.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The passed-in xid is used only for error reporting, and may be<br/></li>
<li></span><span class="Comment"> * InvalidTransactionId if no specific xid is associated with the action.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is the shared-buffer slot number <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> holding the page.<br/></li>
<li></span><span class="Comment"> * The buffer's LRU access info is updated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The correct bank lock must be held at entry, and will be held at exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L488">&#x200c;</a></span><span class="linkable">SimpleLruReadPage</span>(SlruCtl ctl, int64 pageno, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> write_ok,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SlruShared&nbsp; &nbsp; shared = ctl-&gt;shared;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *banklock = SimpleLruGetBankLock(ctl, pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(banklock, LW_EXCLUSIVE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Outer loop handles restart if we must wait for someone else's I/O */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ok;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if page already is in memory; if not, pick victim slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; slotno = <a href="#L1152" title="access/transam/slru.c:1152">SlruSelectLRUPage</a>(ctl, pageno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Did we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the page in memory? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shared-&gt;page_status[slotno] != SLRU_PAGE_EMPTY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_number[slotno] == pageno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If page is still being read in, we must wait for I/O.&nbsp; Likewise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if the page is being written and the caller said that's not OK.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shared-&gt;page_status[slotno] == SLRU_PAGE_READ_IN_PROGRESS ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (shared-&gt;page_status[slotno] == SLRU_PAGE_WRITE_IN_PROGRESS &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !write_ok))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L431" title="access/transam/slru.c:431">SimpleLruWaitIO</a>(ctl, slotno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now we must recheck state from the top */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise, it's ready to use */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1106" title="access/transam/slru.c:1106">SlruRecentlyUsed</a>(shared, slotno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update the stats counter of pages found in the SLRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_slru.c.html#L65" title="utils/activity/pgstat_slru.c:65">pgstat_count_slru_page_hit</a>(shared-&gt;slru_stats_idx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> slotno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We found no match; assert we selected a freeable slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(shared-&gt;page_status[slotno] == SLRU_PAGE_EMPTY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (shared-&gt;page_status[slotno] == SLRU_PAGE_VALID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !shared-&gt;page_dirty[slotno]));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark the slot read-busy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_number[slotno] = pageno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_status[slotno] = SLRU_PAGE_READ_IN_PROGRESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_dirty[slotno] = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Acquire per-buffer lock (cannot deadlock, see notes at top) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;shared-&gt;buffer_locks[slotno].lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release bank lock while doing I/O */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(banklock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do the read */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ok = <a href="#L787" title="access/transam/slru.c:787">SlruPhysicalReadPage</a>(ctl, pageno, slotno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set the LSNs for this newly read-in page to zero */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L414" title="access/transam/slru.c:414">SimpleLruZeroLSNs</a>(ctl, slotno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Re-acquire bank control lock and update page state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(banklock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(shared-&gt;page_number[slotno] == pageno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; shared-&gt;page_status[slotno] == SLRU_PAGE_READ_IN_PROGRESS &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !shared-&gt;page_dirty[slotno]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_status[slotno] = ok ? SLRU_PAGE_VALID : SLRU_PAGE_EMPTY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;shared-&gt;buffer_locks[slotno].lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now it's okay to ereport if we failed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1031" title="access/transam/slru.c:1031">SlruReportIOError</a>(ctl, pageno, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1106" title="access/transam/slru.c:1106">SlruRecentlyUsed</a>(shared, slotno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update the stats counter of pages not found in SLRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_slru.c.html#L77" title="utils/activity/pgstat_slru.c:77">pgstat_count_slru_page_read</a>(shared-&gt;slru_stats_idx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> slotno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find a page in a shared buffer, reading it in if necessary.<br/></li>
<li></span><span class="Comment"> * The page number must correspond to an already-initialized page.<br/></li>
<li></span><span class="Comment"> * The caller must intend only read-only access to the page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The passed-in xid is used only for error reporting, and may be<br/></li>
<li></span><span class="Comment"> * InvalidTransactionId if no specific xid is associated with the action.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is the shared-buffer slot number <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> holding the page.<br/></li>
<li></span><span class="Comment"> * The buffer's LRU access info is updated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Bank control lock must NOT be held at entry, but will be held at exit.<br/></li>
<li></span><span class="Comment"> * It is unspecified whether the lock will be shared or exclusive.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L591">&#x200c;</a></span><span class="linkable">SimpleLruReadPage_ReadOnly</span>(SlruCtl ctl, int64 pageno, TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SlruShared&nbsp; &nbsp; shared = ctl-&gt;shared;<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp;&nbsp; *banklock = SimpleLruGetBankLock(ctl, pageno);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bankno = pageno &amp; ctl-&gt;bank_mask;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bankstart = bankno * <a href="#L129" title="access/transam/slru.c:129">SLRU_BANK_SIZE</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bankend = bankstart + <a href="#L129" title="access/transam/slru.c:129">SLRU_BANK_SIZE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the page while holding only shared lock */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(banklock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* See if page is already in a buffer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> slotno = bankstart; slotno &lt; bankend; slotno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shared-&gt;page_status[slotno] != SLRU_PAGE_EMPTY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_number[slotno] == pageno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_status[slotno] != SLRU_PAGE_READ_IN_PROGRESS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See comments for <a href="#L1106" title="access/transam/slru.c:1106">SlruRecentlyUsed</a> macro */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1106" title="access/transam/slru.c:1106">SlruRecentlyUsed</a>(shared, slotno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update the stats counter of pages found in the SLRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_slru.c.html#L65" title="utils/activity/pgstat_slru.c:65">pgstat_count_slru_page_hit</a>(shared-&gt;slru_stats_idx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> slotno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No luck, so switch to normal exclusive lock and do regular read */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(banklock);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(banklock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L488" title="access/transam/slru.c:488">SimpleLruReadPage</a>(ctl, pageno, <span class="Constant">true</span>, xid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write a page from a shared buffer, if necessary.<br/></li>
<li></span><span class="Comment"> * Does nothing if the specified slot is not dirty.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: only one write attempt is made here.&nbsp; Hence, it is possible that<br/></li>
<li></span><span class="Comment"> * the page is still dirty at exit (if someone else re-dirtied it during<br/></li>
<li></span><span class="Comment"> * the write).&nbsp; However, we *do* attempt a fresh write even if the page<br/></li>
<li></span><span class="Comment"> * is already being written; this is for checkpoints.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Bank lock must be held at entry, and will be held at exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L638">&#x200c;</a></span><span class="linkable">SlruInternalWritePage</span>(SlruCtl ctl, <span class="Type">int</span> slotno, <a href="#L118" title="access/transam/slru.c:118">SlruWriteAll</a> fdata)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SlruShared&nbsp; &nbsp; shared = ctl-&gt;shared;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno = shared-&gt;page_number[slotno];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bankno = <a href="#L134" title="access/transam/slru.c:134">SlotGetBankNumber</a>(slotno);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ok;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(shared-&gt;page_status[slotno] != SLRU_PAGE_EMPTY);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(SimpleLruGetBankLock(ctl, pageno), LW_EXCLUSIVE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If a write is in progress, wait for it to finish */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (shared-&gt;page_status[slotno] == SLRU_PAGE_WRITE_IN_PROGRESS &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; shared-&gt;page_number[slotno] == pageno)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L431" title="access/transam/slru.c:431">SimpleLruWaitIO</a>(ctl, slotno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do nothing if page is not dirty, or if buffer no longer contains the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same page we were called for.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!shared-&gt;page_dirty[slotno] ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_status[slotno] != SLRU_PAGE_VALID ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_number[slotno] != pageno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark the slot write-busy, and clear the dirtybit.&nbsp; After this point, a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction status update on this page will mark it dirty again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; shared-&gt;page_status[slotno] = SLRU_PAGE_WRITE_IN_PROGRESS;<br/></li>
<li>&nbsp; &nbsp; shared-&gt;page_dirty[slotno] = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Acquire per-buffer lock (cannot deadlock, see notes at top) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;shared-&gt;buffer_locks[slotno].lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release bank lock while doing I/O */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;shared-&gt;bank_locks[bankno].lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do the write */<br/></li>
<li></span>&nbsp; &nbsp; ok = <a href="#L859" title="access/transam/slru.c:859">SlruPhysicalWritePage</a>(ctl, pageno, slotno, fdata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we failed, and we're in a flush, better close the files */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!ok &amp;&amp; fdata)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; fdata-&gt;num_files; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fdata-&gt;fd[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Re-acquire bank lock and update page state */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;shared-&gt;bank_locks[bankno].lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(shared-&gt;page_number[slotno] == pageno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; shared-&gt;page_status[slotno] == SLRU_PAGE_WRITE_IN_PROGRESS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we failed to write, mark the page dirty again */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_dirty[slotno] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; shared-&gt;page_status[slotno] = SLRU_PAGE_VALID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;shared-&gt;buffer_locks[slotno].lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now it's okay to ereport if we failed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1031" title="access/transam/slru.c:1031">SlruReportIOError</a>(ctl, pageno, InvalidTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If part of a checkpoint, count this as a buffer written. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fdata)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_bufs_written++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wrapper of <a href="#L638" title="access/transam/slru.c:638">SlruInternalWritePage</a>, for external callers.<br/></li>
<li></span><span class="Comment"> * fdata is always passed a NULL here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L715">&#x200c;</a></span><span class="linkable">SimpleLruWritePage</span>(SlruCtl ctl, <span class="Type">int</span> slotno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(ctl-&gt;shared-&gt;page_status[slotno] != SLRU_PAGE_EMPTY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L638" title="access/transam/slru.c:638">SlruInternalWritePage</a>(ctl, slotno, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return whether the given page exists on disk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A false return means that either the file does not exist, or that it's not<br/></li>
<li></span><span class="Comment"> * large enough to contain the given page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L729">&#x200c;</a></span><span class="linkable">SimpleLruDoesPhysicalPageExist</span>(SlruCtl ctl, int64 pageno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; segno = pageno / SLRU_PAGES_PER_SEGMENT;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rpageno = pageno % SLRU_PAGES_PER_SEGMENT;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset = rpageno * BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; endpos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update the stats counter of checked pages */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_slru.c.html#L71" title="utils/activity/pgstat_slru.c:71">pgstat_count_slru_page_exists</a>(ctl-&gt;shared-&gt;slru_stats_idx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="access/transam/slru.c:76">SlruFileName</a>(ctl, path, segno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(path, O_RDONLY | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expected: file doesn't exist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* report error normally */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/transam/slru.c:160">slru_errcause</a> = SLRU_OPEN_FAILED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L161" title="access/transam/slru.c:161">slru_errno</a> = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1031" title="access/transam/slru.c:1031">SlruReportIOError</a>(ctl, pageno, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((endpos = lseek(fd, <span class="Constant">0</span>, <span class="Constant">SEEK_END</span>)) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/transam/slru.c:160">slru_errcause</a> = SLRU_SEEK_FAILED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L161" title="access/transam/slru.c:161">slru_errno</a> = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1031" title="access/transam/slru.c:1031">SlruReportIOError</a>(ctl, pageno, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = endpos &gt;= (<span class="Type">off_t</span>) (offset + BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/transam/slru.c:160">slru_errcause</a> = SLRU_CLOSE_FAILED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L161" title="access/transam/slru.c:161">slru_errno</a> = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Physical read of a (previously existing) page into a buffer slot<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On failure, we cannot just ereport(ERROR) since caller has put state in<br/></li>
<li></span><span class="Comment"> * shared memory that must be undone.&nbsp; So, we return false and save enough<br/></li>
<li></span><span class="Comment"> * info in static variables to let <a href="#L1031" title="access/transam/slru.c:1031">SlruReportIOError</a> make the report.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, assume it's not worth keeping a file pointer open across<br/></li>
<li></span><span class="Comment"> * read/write operations.&nbsp; We could cache one virtual file pointer ...<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L787">&#x200c;</a></span><span class="linkable">SlruPhysicalReadPage</span>(SlruCtl ctl, int64 pageno, <span class="Type">int</span> slotno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SlruShared&nbsp; &nbsp; shared = ctl-&gt;shared;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; segno = pageno / SLRU_PAGES_PER_SEGMENT;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rpageno = pageno % SLRU_PAGES_PER_SEGMENT;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; offset = rpageno * BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="access/transam/slru.c:76">SlruFileName</a>(ctl, path, segno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In a crash-and-restart situation, it's possible for us to receive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commands to set the commit status of transactions whose bits are in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already-truncated segments of the commit log (see notes in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L859" title="access/transam/slru.c:859">SlruPhysicalWritePage</a>).&nbsp; Hence, if we are <a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>, allow the case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where the file doesn't exist, and return zeroes instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(path, O_RDONLY | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">ENOENT</span> || !<a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/transam/slru.c:160">slru_errcause</a> = SLRU_OPEN_FAILED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L161" title="access/transam/slru.c:161">slru_errno</a> = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> doesn't exist, reading as zeroes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(shared-&gt;page_buffer[slotno], <span class="Constant">0</span>, BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_SLRU_READ);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_pread(fd, shared-&gt;page_buffer[slotno], BLCKSZ, offset) != BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/transam/slru.c:160">slru_errcause</a> = SLRU_READ_FAILED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L161" title="access/transam/slru.c:161">slru_errno</a> = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/transam/slru.c:160">slru_errcause</a> = SLRU_CLOSE_FAILED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L161" title="access/transam/slru.c:161">slru_errno</a> = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Physical write of a page from a buffer slot<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On failure, we cannot just ereport(ERROR) since caller has put state in<br/></li>
<li></span><span class="Comment"> * shared memory that must be undone.&nbsp; So, we return false and save enough<br/></li>
<li></span><span class="Comment"> * info in static variables to let <a href="#L1031" title="access/transam/slru.c:1031">SlruReportIOError</a> make the report.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, assume it's not worth keeping a file pointer open across<br/></li>
<li></span><span class="Comment"> * independent read/write operations.&nbsp; We do batch operations during<br/></li>
<li></span><span class="Comment"> * <a href="#L1305" title="access/transam/slru.c:1305">SimpleLruWriteAll</a>, though.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * fdata is NULL for a standalone write, pointer to open-file info during<br/></li>
<li></span><span class="Comment"> * <a href="#L1305" title="access/transam/slru.c:1305">SimpleLruWriteAll</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L859">&#x200c;</a></span><span class="linkable">SlruPhysicalWritePage</span>(SlruCtl ctl, int64 pageno, <span class="Type">int</span> slotno, <a href="#L118" title="access/transam/slru.c:118">SlruWriteAll</a> fdata)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SlruShared&nbsp; &nbsp; shared = ctl-&gt;shared;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; segno = pageno / SLRU_PAGES_PER_SEGMENT;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rpageno = pageno % SLRU_PAGES_PER_SEGMENT;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; offset = rpageno * BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update the stats counter of written pages */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_slru.c.html#L83" title="utils/activity/pgstat_slru.c:83">pgstat_count_slru_page_written</a>(shared-&gt;slru_stats_idx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Honor the write-WAL-<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>-data rule, if appropriate, so that we do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * write out data <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> associated WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.&nbsp; This is the same action<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * performed during <a href="../../storage/buffer/bufmgr.c.html#L3727" title="storage/buffer/bufmgr.c:3727">FlushBuffer</a>() in the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> buffer manager.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shared-&gt;group_lsn != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must determine the largest async-commit LSN for the page. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> tedious, but since this entire function is a slow path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway, it seems better to do this here than to maintain a per-page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LSN variable (which'd need an extra comparison in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction-commit path).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; max_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lsnindex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lsnindex = slotno * shared-&gt;lsn_groups_per_page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; max_lsn = shared-&gt;group_lsn[lsnindex++];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> lsnoff = <span class="Constant">1</span>; lsnoff &lt; shared-&gt;lsn_groups_per_page; lsnoff++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; this_lsn = shared-&gt;group_lsn[lsnindex++];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (max_lsn &lt; this_lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_lsn = this_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(max_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As noted above, elog(ERROR) is not acceptable here, so if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a> were to fail, we must PANIC.&nbsp; This isn't much of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * restriction because <a href="xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a> is just about all critical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * section anyway, but let's make sure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(max_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During a <a href="#L1305" title="access/transam/slru.c:1305">SimpleLruWriteAll</a>, we may already have the desired file open.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fdata)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; fdata-&gt;num_files; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fdata-&gt;segno[i] == segno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd = fdata-&gt;fd[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the file doesn't already exist, we should create it.&nbsp; It is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible for this to need to happen when writing a page that's not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first in its segment; we assume the OS can cope with that. (Note:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it might seem that it'd be okay to create files only when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L361" title="access/transam/slru.c:361">SimpleLruZeroPage</a> is called for the first page of a segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, if after a crash and restart the REDO logic elects to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * replay the log from a checkpoint <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the latest one, then it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible that we will get commands to set transaction status of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions that have already been truncated from the commit log.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Easiest way to deal with that is to <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> references to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nonexistent files here and in <a href="#L787" title="access/transam/slru.c:787">SlruPhysicalReadPage</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: it is possible for more than one backend to be executing this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * code simultaneously for different pages of the same file. Hence,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't use O_EXCL or O_TRUNC or anything like that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L76" title="access/transam/slru.c:76">SlruFileName</a>(ctl, path, segno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(path, O_RDWR | O_CREAT | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/transam/slru.c:160">slru_errcause</a> = SLRU_OPEN_FAILED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L161" title="access/transam/slru.c:161">slru_errno</a> = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fdata)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fdata-&gt;num_files &lt; <a href="#L109" title="access/transam/slru.c:109">MAX_WRITEALL_BUFFERS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdata-&gt;fd[fdata-&gt;num_files] = fd;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdata-&gt;segno[fdata-&gt;num_files] = segno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdata-&gt;num_files++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the unlikely event that we exceed <a href="#L109" title="access/transam/slru.c:109">MAX_WRITEALL_BUFFERS</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fall back to treating it as a standalone write.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdata = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_SLRU_WRITE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_pwrite(fd, shared-&gt;page_buffer[slotno], BLCKSZ, offset) != BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if write didn't set errno, assume problem is no disk space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ENOSPC</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/transam/slru.c:160">slru_errcause</a> = SLRU_WRITE_FAILED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L161" title="access/transam/slru.c:161">slru_errno</a> = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!fdata)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Queue up a sync request for the checkpointer. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ctl-&gt;sync_handler != SYNC_HANDLER_NONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FileTag&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L142" title="access/transam/slru.c:142">INIT_SLRUFILETAG</a>(tag, ctl-&gt;sync_handler, segno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/sync/sync.c.html#L580" title="storage/sync/sync.c:580">RegisterSyncRequest</a>(&amp;tag, SYNC_REQUEST, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No space to enqueue sync request.&nbsp; Do it synchronously. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_SLRU_SYNC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L386" title="storage/file/fd.c:386">pg_fsync</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/transam/slru.c:160">slru_errcause</a> = SLRU_FSYNC_FAILED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L161" title="access/transam/slru.c:161">slru_errno</a> = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close file, unless part of flush request. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!fdata)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/transam/slru.c:160">slru_errcause</a> = SLRU_CLOSE_FAILED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L161" title="access/transam/slru.c:161">slru_errno</a> = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Issue the error message after failure of <a href="#L787" title="access/transam/slru.c:787">SlruPhysicalReadPage</a> or<br/></li>
<li></span><span class="Comment"> * <a href="#L859" title="access/transam/slru.c:859">SlruPhysicalWritePage</a>.&nbsp; Call this after cleaning up shared-memory state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1031">&#x200c;</a></span><span class="linkable">SlruReportIOError</span>(SlruCtl ctl, int64 pageno, TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; segno = pageno / SLRU_PAGES_PER_SEGMENT;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rpageno = pageno % SLRU_PAGES_PER_SEGMENT;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset = rpageno * BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="access/transam/slru.c:76">SlruFileName</a>(ctl, path, segno);<br/></li>
<li>&nbsp; &nbsp; errno = <a href="#L161" title="access/transam/slru.c:161">slru_errno</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L160" title="access/transam/slru.c:160">slru_errcause</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SLRU_OPEN_FAILED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not access status of transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>, xid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m.&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SLRU_SEEK_FAILED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not access status of transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>, xid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Could not seek in file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to offset </span><span class="Special">%d</span><span class="Constant">: %m.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path, offset)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SLRU_READ_FAILED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not access status of transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>, xid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Could not read from file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> at offset </span><span class="Special">%d</span><span class="Constant">: %m.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path, offset)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not access status of transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>, xid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Could not read from file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> at offset </span><span class="Special">%d</span><span class="Constant">: read too few bytes.&quot;</span>, path, offset)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SLRU_WRITE_FAILED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not access status of transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>, xid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Could not write to file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> at offset </span><span class="Special">%d</span><span class="Constant">: %m.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path, offset)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not access status of transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>, xid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Could not write to file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> at offset </span><span class="Special">%d</span><span class="Constant">: wrote too few bytes.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path, offset)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SLRU_FSYNC_FAILED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(<a href="../../storage/file/fd.c.html#L3936" title="storage/file/fd.c:3936">data_sync_elevel</a>(ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not access status of transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>, xid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Could not fsync file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> SLRU_CLOSE_FAILED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not access status of transaction </span><span class="Special">%u</span><span class="Constant">&quot;</span>, xid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't get here, we trust */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized SimpleLru error cause: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) <a href="#L160" title="access/transam/slru.c:160">slru_errcause</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Mark a buffer slot &quot;most recently used&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L1106">&#x200c;</a></span><span class="linkable">SlruRecentlyUsed</span>(SlruShared shared, <span class="Type">int</span> slotno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bankno = <a href="#L134" title="access/transam/slru.c:134">SlotGetBankNumber</a>(slotno);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_lru_count = shared-&gt;bank_cur_lru_count[bankno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(shared-&gt;page_status[slotno] != SLRU_PAGE_EMPTY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The reason for the if-test is that there are often many consecutive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accesses to the same page (particularly the latest page).&nbsp; By<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * suppressing useless increments of bank_cur_lru_count, we reduce the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * probability that old pages' counts will &quot;wrap around&quot; and make them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appear recently used.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We allow this code to be executed concurrently by multiple processes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * within <a href="#L591" title="access/transam/slru.c:591">SimpleLruReadPage_ReadOnly</a>().&nbsp; As long as int reads and writes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are atomic, this should not cause <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> completely-bogus <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to enter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the computation.&nbsp; However, it is possible for either bank_cur_lru_count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or individual page_lru_count entries to be &quot;reset&quot; to <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they should have, in case a process is delayed while it executes this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function.&nbsp; With care in <a href="#L1152" title="access/transam/slru.c:1152">SlruSelectLRUPage</a>(), this does little harm, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case the absolute worst possible consequence is a nonoptimal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * choice of page to evict.&nbsp; The gain from allowing concurrent reads of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SLRU pages seems worth it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (new_lru_count != shared-&gt;page_lru_count[slotno])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;bank_cur_lru_count[bankno] = ++new_lru_count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_lru_count[slotno] = new_lru_count;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Select the slot to re-use when we need a free slot for the given page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The target page number is passed not only because we need to know the<br/></li>
<li></span><span class="Comment"> * correct bank to use, but also because we need to consider the possibility<br/></li>
<li></span><span class="Comment"> * that some other process reads in the target page while we are doing I/O to<br/></li>
<li></span><span class="Comment"> * free a slot.&nbsp; Hence, check or recheck to see if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> slot already holds the<br/></li>
<li></span><span class="Comment"> * target page, and return that slot if so.&nbsp; Thus, the returned slot is<br/></li>
<li></span><span class="Comment"> * *either* a slot already holding the pageno (could be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> state except<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a>), *or* a freeable slot (state <a href="../../regex/regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> or CLEAN).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The correct bank lock must be held at entry, and will be held at exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1152">&#x200c;</a></span><span class="linkable">SlruSelectLRUPage</span>(SlruCtl ctl, int64 pageno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SlruShared&nbsp; &nbsp; shared = ctl-&gt;shared;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Outer loop handles restart after I/O */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bestvalidslot = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_valid_delta = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; best_valid_page_number = <span class="Constant">0</span>; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bestinvalidslot = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_invalid_delta = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; best_invalid_page_number = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bankno = pageno &amp; ctl-&gt;bank_mask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bankstart = bankno * <a href="#L129" title="access/transam/slru.c:129">SLRU_BANK_SIZE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bankend = bankstart + <a href="#L129" title="access/transam/slru.c:129">SLRU_BANK_SIZE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(SimpleLruGetBankLock(ctl, pageno)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if page already has a buffer assigned */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> slotno = <span class="Constant">0</span>; slotno &lt; shared-&gt;num_slots; slotno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shared-&gt;page_status[slotno] != SLRU_PAGE_EMPTY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_number[slotno] == pageno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> slotno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../regex/regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> slot, just <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> that one. Else choose a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * victim page to replace.&nbsp; We normally take the least recently used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * valid page, but we will never take the slot containing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * latest_page_number, even if it appears least recently used.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> a slot that is already I/O busy only if there is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other choice: a read-busy slot will not be least recently used once<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the read finishes, and <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for an I/O on a write-busy slot is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inferior to just picking some other slot.&nbsp; Testing shows the slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we pick instead will often be clean, allowing us to begin a read at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normally the page_lru_count <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> will all be different and so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there will be a well-defined LRU page.&nbsp; But since we allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * concurrent execution of <a href="#L1106" title="access/transam/slru.c:1106">SlruRecentlyUsed</a>() within<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L591" title="access/transam/slru.c:591">SimpleLruReadPage_ReadOnly</a>(), it is possible that multiple pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * acquire the same lru_count <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; In that case we break ties by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * choosing the furthest-back page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Notice that this <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> line forcibly advances cur_lru_count to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value that is certainly beyond <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> value that will be in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page_lru_count array after the loop finishes.&nbsp; This ensures that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> execution of <a href="#L1106" title="access/transam/slru.c:1106">SlruRecentlyUsed</a> will mark the page newly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * used, even if it's for a page that has the current counter value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * That gets us back on the path to having good data when there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple pages with the same lru_count.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cur_count = (shared-&gt;bank_cur_lru_count[bankno])++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> slotno = bankstart; slotno &lt; bankend; slotno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_delta;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; this_page_number;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shared-&gt;page_status[slotno] == SLRU_PAGE_EMPTY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> slotno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_delta = cur_count - shared-&gt;page_lru_count[slotno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (this_delta &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Clean up in case shared updates have caused cur_count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * increments to get &quot;lost&quot;.&nbsp; We back off the page counts,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rather than trying to increase cur_count, to avoid <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * question of infinite loops or failure in the presence of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wrapped-around counts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_lru_count[slotno] = cur_count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_delta = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this page is the one most recently zeroed, don't consider it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an eviction candidate. See comments in <a href="#L361" title="access/transam/slru.c:361">SimpleLruZeroPage</a> for an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * explanation about the lack of a memory barrier here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_page_number = shared-&gt;page_number[slotno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (this_page_number ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_read_u64(&amp;shared-&gt;latest_page_number))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shared-&gt;page_status[slotno] == SLRU_PAGE_VALID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (this_delta &gt; best_valid_delta ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (this_delta == best_valid_delta &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ctl-&gt;PagePrecedes(this_page_number,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_valid_page_number)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bestvalidslot = slotno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_valid_delta = this_delta;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_valid_page_number = this_page_number;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (this_delta &gt; best_invalid_delta ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (this_delta == best_invalid_delta &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ctl-&gt;PagePrecedes(this_page_number,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; best_invalid_page_number)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bestinvalidslot = slotno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_invalid_delta = this_delta;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; best_invalid_page_number = this_page_number;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If all pages (except possibly the latest one) are I/O busy, we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to wait for an I/O to complete and then retry.&nbsp; In that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unhappy case, we choose to wait for the I/O on the least recently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * used slot, on the assumption that it was likely initiated first of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all the I/Os in progress and may therefore finish first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (best_valid_delta &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L431" title="access/transam/slru.c:431">SimpleLruWaitIO</a>(ctl, bestinvalidslot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the selected page is clean, we're set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!shared-&gt;page_dirty[bestvalidslot])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> bestvalidslot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Write the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L638" title="access/transam/slru.c:638">SlruInternalWritePage</a>(ctl, bestvalidslot, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now loop back and try again.&nbsp; This is the easiest way of dealing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with corner cases such as the victim page being re-dirtied while we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wrote it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write dirty pages to disk during checkpoint or database shutdown.&nbsp; Flushing<br/></li>
<li></span><span class="Comment"> * is deferred until the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call to <a href="../../storage/sync/sync.c.html#L286" title="storage/sync/sync.c:286">ProcessSyncRequests</a>(), though we do fsync<br/></li>
<li></span><span class="Comment"> * the containing directory here to make sure that newly created directory<br/></li>
<li></span><span class="Comment"> * entries are on disk.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1305">&#x200c;</a></span><span class="linkable">SimpleLruWriteAll</span>(SlruCtl ctl, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allow_redirtied)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SlruShared&nbsp; &nbsp; shared = ctl-&gt;shared;<br/></li>
<li>&nbsp; &nbsp; <a href="#L111" title="access/transam/slru.c:111">SlruWriteAllData</a> fdata;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; pageno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevbank = <a href="#L134" title="access/transam/slru.c:134">SlotGetBankNumber</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ok;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update the stats counter of flushes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_slru.c.html#L89" title="utils/activity/pgstat_slru.c:89">pgstat_count_slru_flush</a>(shared-&gt;slru_stats_idx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find and write dirty pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fdata.num_files = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;shared-&gt;bank_locks[prevbank].lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> slotno = <span class="Constant">0</span>; slotno &lt; shared-&gt;num_slots; slotno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curbank = <a href="#L134" title="access/transam/slru.c:134">SlotGetBankNumber</a>(slotno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the current bank lock is not same as the previous bank lock then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * release the previous lock and acquire the new lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curbank != prevbank)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;shared-&gt;bank_locks[prevbank].lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;shared-&gt;bank_locks[curbank].lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevbank = curbank;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do nothing if slot is unused */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shared-&gt;page_status[slotno] == SLRU_PAGE_EMPTY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L638" title="access/transam/slru.c:638">SlruInternalWritePage</a>(ctl, slotno, &amp;fdata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In some places (e.g. checkpoints), we cannot assert that the slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is clean <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, since another process might have re-dirtied it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already.&nbsp; That's okay.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(allow_redirtied ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; shared-&gt;page_status[slotno] == SLRU_PAGE_EMPTY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (shared-&gt;page_status[slotno] == SLRU_PAGE_VALID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !shared-&gt;page_dirty[slotno]));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;shared-&gt;bank_locks[prevbank].lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now close <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> files that were open<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ok = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; fdata.num_files; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fdata.fd[i]) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/transam/slru.c:160">slru_errcause</a> = SLRU_CLOSE_FAILED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L161" title="access/transam/slru.c:161">slru_errno</a> = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageno = fdata.segno[i] * SLRU_PAGES_PER_SEGMENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ok = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1031" title="access/transam/slru.c:1031">SlruReportIOError</a>(ctl, pageno, InvalidTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure that directory entries for new files are on disk. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ctl-&gt;sync_handler != SYNC_HANDLER_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L756" title="storage/file/fd.c:756">fsync_fname</a>(ctl-&gt;Dir, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove all segments <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the one holding the passed page number<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All SLRUs prevent concurrent calls to this function, either with an LWLock<br/></li>
<li></span><span class="Comment"> * or by calling it only as part of a checkpoint.&nbsp; Mutual exclusion must begin<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> computing cutoffPage.&nbsp; Mutual exclusion must end after <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> limit<br/></li>
<li></span><span class="Comment"> * update that would permit other backends to write fresh data into the<br/></li>
<li></span><span class="Comment"> * segment immediately preceding the one containing cutoffPage.&nbsp; Otherwise,<br/></li>
<li></span><span class="Comment"> * when the SLRU is quite full, <a href="#L1391" title="access/transam/slru.c:1391">SimpleLruTruncate</a>() might delete that segment<br/></li>
<li></span><span class="Comment"> * after it has accrued freshly-written data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1391">&#x200c;</a></span><span class="linkable">SimpleLruTruncate</span>(SlruCtl ctl, int64 cutoffPage)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SlruShared&nbsp; &nbsp; shared = ctl-&gt;shared;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevbank;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update the stats counter of truncates */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_slru.c.html#L95" title="utils/activity/pgstat_slru.c:95">pgstat_count_slru_truncate</a>(shared-&gt;slru_stats_idx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan shared memory and remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pages preceding the cutoff page, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensure we won't rewrite them later.&nbsp; (Since this is normally called in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or just after a checkpoint, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dirty pages should have been flushed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already ... we're just being extra careful here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="Statement">restart</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * An important safety check: the current endpoint page must not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * eligible for removal.&nbsp; This check is just a backstop against wraparound<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bugs elsewhere in SLRU handling, so we don't care if we read a slightly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outdated value; therefore we don't add a memory barrier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ctl-&gt;PagePrecedes(pg_atomic_read_u64(&amp;shared-&gt;latest_page_number),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cutoffPage))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not truncate directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: apparent wraparound&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctl-&gt;Dir)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; prevbank = <a href="#L134" title="access/transam/slru.c:134">SlotGetBankNumber</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;shared-&gt;bank_locks[prevbank].lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> slotno = <span class="Constant">0</span>; slotno &lt; shared-&gt;num_slots; slotno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curbank = <a href="#L134" title="access/transam/slru.c:134">SlotGetBankNumber</a>(slotno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the current bank lock is not same as the previous bank lock then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * release the previous lock and acquire the new lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curbank != prevbank)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;shared-&gt;bank_locks[prevbank].lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;shared-&gt;bank_locks[curbank].lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevbank = curbank;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shared-&gt;page_status[slotno] == SLRU_PAGE_EMPTY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ctl-&gt;PagePrecedes(shared-&gt;page_number[slotno], cutoffPage))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If page is clean, just change state to <a href="../../regex/regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> (expected case).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shared-&gt;page_status[slotno] == SLRU_PAGE_VALID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !shared-&gt;page_dirty[slotno])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_status[slotno] = SLRU_PAGE_EMPTY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Hmm, we have (or may have) I/O operations acting on the page, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we've got to wait for them to finish and then start again. This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same logic as in <a href="#L1152" title="access/transam/slru.c:1152">SlruSelectLRUPage</a>.&nbsp; (</span><span class="Todo">XXX</span><span class="Comment"> if page is dirty,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wouldn't it be OK to just discard it without writing it?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1586" title="access/transam/slru.c:1586">SlruMayDeleteSegment</a>() uses a stricter qualification, so we might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not delete this page in the end; even if we don't delete it, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * won't have cause to read its data again.&nbsp; For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, keep the logic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same as it was.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shared-&gt;page_status[slotno] == SLRU_PAGE_VALID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L638" title="access/transam/slru.c:638">SlruInternalWritePage</a>(ctl, slotno, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L431" title="access/transam/slru.c:431">SimpleLruWaitIO</a>(ctl, slotno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;shared-&gt;bank_locks[prevbank].lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> restart;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;shared-&gt;bank_locks[prevbank].lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we can remove the old segment(s) */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L1774" title="access/transam/slru.c:1774">SlruScanDirectory</a>(ctl, <a href="#L1711" title="access/transam/slru.c:1711">SlruScanDirCbDeleteCutoff</a>, &amp;cutoffPage);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> an individual SLRU segment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: This does not touch the SLRU buffers themselves, callers have to ensure<br/></li>
<li></span><span class="Comment"> * they either can't yet contain anything, or have already been cleaned out.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1486">&#x200c;</a></span><span class="linkable">SlruInternalDeleteSegment</span>(SlruCtl ctl, int64 segno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Forget <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fsync requests queued for this segment. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ctl-&gt;sync_handler != SYNC_HANDLER_NONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FileTag&nbsp; &nbsp; &nbsp; &nbsp; tag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L142" title="access/transam/slru.c:142">INIT_SLRUFILETAG</a>(tag, ctl-&gt;sync_handler, segno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/sync/sync.c.html#L580" title="storage/sync/sync.c:580">RegisterSyncRequest</a>(&amp;tag, SYNC_FORGET_REQUEST, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unlink the file. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L76" title="access/transam/slru.c:76">SlruFileName</a>(ctl, path, segno);<br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG2, (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;removing file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; unlink(path);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> an individual SLRU segment, identified by the segment number.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1509">&#x200c;</a></span><span class="linkable">SlruDeleteSegment</span>(SlruCtl ctl, int64 segno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SlruShared&nbsp; &nbsp; shared = ctl-&gt;shared;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevbank = <a href="#L134" title="access/transam/slru.c:134">SlotGetBankNumber</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; did_write;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean out <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> possibly existing references to the segment. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;shared-&gt;bank_locks[prevbank].lock, LW_EXCLUSIVE);<br/></li>
<li><span class="Statement">restart</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; did_write = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> slotno = <span class="Constant">0</span>; slotno &lt; shared-&gt;num_slots; slotno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pagesegno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curbank = <a href="#L134" title="access/transam/slru.c:134">SlotGetBankNumber</a>(slotno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the current bank lock is not same as the previous bank lock then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * release the previous lock and acquire the new lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curbank != prevbank)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;shared-&gt;bank_locks[prevbank].lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;shared-&gt;bank_locks[curbank].lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prevbank = curbank;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shared-&gt;page_status[slotno] == SLRU_PAGE_EMPTY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pagesegno = shared-&gt;page_number[slotno] / SLRU_PAGES_PER_SEGMENT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not the segment we're looking for */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pagesegno != segno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If page is clean, just change state to <a href="../../regex/regcomp.c.html#L328" title="regex/regcomp.c:328">EMPTY</a> (expected case). */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shared-&gt;page_status[slotno] == SLRU_PAGE_VALID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !shared-&gt;page_dirty[slotno])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shared-&gt;page_status[slotno] = SLRU_PAGE_EMPTY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Same logic as <a href="#L1391" title="access/transam/slru.c:1391">SimpleLruTruncate</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (shared-&gt;page_status[slotno] == SLRU_PAGE_VALID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L638" title="access/transam/slru.c:638">SlruInternalWritePage</a>(ctl, slotno, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L431" title="access/transam/slru.c:431">SimpleLruWaitIO</a>(ctl, slotno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; did_write = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Be extra careful and re-check. The IO <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> release the control<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock, so new pages could have been read in.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (did_write)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> restart;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1486" title="access/transam/slru.c:1486">SlruInternalDeleteSegment</a>(ctl, segno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;shared-&gt;bank_locks[prevbank].lock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine whether a segment is okay to delete.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * segpage is the first page of the segment, and cutoffPage is the oldest (in<br/></li>
<li></span><span class="Comment"> * PagePrecedes order) page in the SLRU containing still-useful data.&nbsp; Since<br/></li>
<li></span><span class="Comment"> * every core PagePrecedes callback implements &quot;wrap around&quot;, check the<br/></li>
<li></span><span class="Comment"> * segment's first and last pages:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * first&lt;cutoff&nbsp; &amp;&amp; last&lt;cutoff:&nbsp; yes<br/></li>
<li></span><span class="Comment"> * first&lt;cutoff&nbsp; &amp;&amp; last&gt;=cutoff: no; cutoff falls inside this segment<br/></li>
<li></span><span class="Comment"> * first&gt;=cutoff &amp;&amp; last&lt;cutoff:&nbsp; no; wrap point falls inside this segment<br/></li>
<li></span><span class="Comment"> * first&gt;=cutoff &amp;&amp; last&gt;=cutoff: no; every page of this segment is too young<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1586">&#x200c;</a></span><span class="linkable">SlruMayDeleteSegment</span>(SlruCtl ctl, int64 segpage, int64 cutoffPage)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; seg_last_page = segpage + SLRU_PAGES_PER_SEGMENT - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(segpage % SLRU_PAGES_PER_SEGMENT == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (ctl-&gt;PagePrecedes(segpage, cutoffPage) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctl-&gt;PagePrecedes(seg_last_page, cutoffPage));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1598">&#x200c;</a></span><span class="linkable">SlruPagePrecedesTestOffset</span>(SlruCtl ctl, <span class="Type">int</span> per_page, uint32 offset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId lhs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rhs;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; newestPage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestPage;<br/></li>
<li>&nbsp; &nbsp; TransactionId newestXact,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestXact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compare an XID pair having undefined order (see RFC 1982), a pair at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;opposite ends&quot; of the XID space.&nbsp; <a href="transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>() treats each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as preceding the other.&nbsp; If RHS is oldestXact, LHS is the first XID we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must not assign.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lhs = per_page + offset;&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> first page to avoid non-normal XIDs */<br/></li>
<li></span>&nbsp; &nbsp; rhs = lhs + (<span class="Constant">1U</span> &lt;&lt; <span class="Constant">31</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(lhs, rhs));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(rhs, lhs));<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(lhs - <span class="Constant">1</span>, rhs));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(rhs, lhs - <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(lhs + <span class="Constant">1</span>, rhs));<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(rhs, lhs + <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(lhs, rhs));<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(rhs, lhs));<br/></li>
<li>&nbsp; &nbsp; Assert(!ctl-&gt;PagePrecedes(lhs / per_page, lhs / per_page));<br/></li>
<li>&nbsp; &nbsp; Assert(!ctl-&gt;PagePrecedes(lhs / per_page, rhs / per_page));<br/></li>
<li>&nbsp; &nbsp; Assert(!ctl-&gt;PagePrecedes(rhs / per_page, lhs / per_page));<br/></li>
<li>&nbsp; &nbsp; Assert(!ctl-&gt;PagePrecedes((lhs - per_page) / per_page, rhs / per_page));<br/></li>
<li>&nbsp; &nbsp; Assert(ctl-&gt;PagePrecedes(rhs / per_page, (lhs - <span class="Constant">3</span> * per_page) / per_page));<br/></li>
<li>&nbsp; &nbsp; Assert(ctl-&gt;PagePrecedes(rhs / per_page, (lhs - <span class="Constant">2</span> * per_page) / per_page));<br/></li>
<li>&nbsp; &nbsp; Assert(ctl-&gt;PagePrecedes(rhs / per_page, (lhs - <span class="Constant">1</span> * per_page) / per_page)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; || (<span class="Constant">1U</span> &lt;&lt; <span class="Constant">31</span>) % per_page != <span class="Constant">0</span>);&nbsp; &nbsp; <span class="Comment">/* See <a href="commit_ts.c.html#L970" title="access/transam/commit_ts.c:970">CommitTsPagePrecedes</a>() */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ctl-&gt;PagePrecedes((lhs + <span class="Constant">1</span> * per_page) / per_page, rhs / per_page)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; || (<span class="Constant">1U</span> &lt;&lt; <span class="Constant">31</span>) % per_page != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(ctl-&gt;PagePrecedes((lhs + <span class="Constant">2</span> * per_page) / per_page, rhs / per_page));<br/></li>
<li>&nbsp; &nbsp; Assert(ctl-&gt;PagePrecedes((lhs + <span class="Constant">3</span> * per_page) / per_page, rhs / per_page));<br/></li>
<li>&nbsp; &nbsp; Assert(!ctl-&gt;PagePrecedes(rhs / per_page, (lhs + per_page) / per_page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a>() has assigned the last XID it can safely use, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that XID is in the *LAST* page of the second segment.&nbsp; We must not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * delete that segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newestPage = <span class="Constant">2</span> * SLRU_PAGES_PER_SEGMENT - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; newestXact = newestPage * per_page + offset;<br/></li>
<li>&nbsp; &nbsp; Assert(newestXact / per_page == newestPage);<br/></li>
<li>&nbsp; &nbsp; oldestXact = newestXact + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; oldestXact -= <span class="Constant">1U</span> &lt;&lt; <span class="Constant">31</span>;<br/></li>
<li>&nbsp; &nbsp; oldestPage = oldestXact / per_page;<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L1586" title="access/transam/slru.c:1586">SlruMayDeleteSegment</a>(ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (newestPage -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newestPage % SLRU_PAGES_PER_SEGMENT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldestPage));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="varsup.c.html#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a>() has assigned the last XID it can safely use, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that XID is in the *FIRST* page of the second segment.&nbsp; We must not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * delete that segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newestPage = SLRU_PAGES_PER_SEGMENT;<br/></li>
<li>&nbsp; &nbsp; newestXact = newestPage * per_page + offset;<br/></li>
<li>&nbsp; &nbsp; Assert(newestXact / per_page == newestPage);<br/></li>
<li>&nbsp; &nbsp; oldestXact = newestXact + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; oldestXact -= <span class="Constant">1U</span> &lt;&lt; <span class="Constant">31</span>;<br/></li>
<li>&nbsp; &nbsp; oldestPage = oldestXact / per_page;<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="#L1586" title="access/transam/slru.c:1586">SlruMayDeleteSegment</a>(ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (newestPage -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newestPage % SLRU_PAGES_PER_SEGMENT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; oldestPage));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Unit-test a PagePrecedes function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This assumes every uint32 &gt;= FirstNormalTransactionId is a valid key.&nbsp; It<br/></li>
<li></span><span class="Comment"> * assumes each value occupies a contiguous, fixed-size region of SLRU bytes.<br/></li>
<li></span><span class="Comment"> * (<a href="multixact.c.html#L191" title="access/transam/multixact.c:191">MultiXactMemberCtl</a> separates flags from XIDs.&nbsp; <a href="../../commands/async.c.html#L310" title="commands/async.c:310">NotifyCtl</a> has<br/></li>
<li></span><span class="Comment"> * variable-length entries, no keys, and no random access.&nbsp; These unit tests<br/></li>
<li></span><span class="Comment"> * do not apply to them.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1680">&#x200c;</a></span><span class="linkable">SlruPagePrecedesUnitTests</span>(SlruCtl ctl, <span class="Type">int</span> per_page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Test first, middle and last entries of a page. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1598" title="access/transam/slru.c:1598">SlruPagePrecedesTestOffset</a>(ctl, per_page, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1598" title="access/transam/slru.c:1598">SlruPagePrecedesTestOffset</a>(ctl, per_page, per_page / <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1598" title="access/transam/slru.c:1598">SlruPagePrecedesTestOffset</a>(ctl, per_page, per_page - <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1774" title="access/transam/slru.c:1774">SlruScanDirectory</a> callback<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This callback reports true if there's <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> segment wholly prior to the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; one containing the page passed as &quot;data&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1695">&#x200c;</a></span><span class="linkable">SlruScanDirCbReportPresence</span>(SlruCtl ctl, <span class="Type">char</span> *filename, int64 segpage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; cutoffPage = *(int64 *) data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1586" title="access/transam/slru.c:1586">SlruMayDeleteSegment</a>(ctl, segpage, cutoffPage))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found one; don't iterate <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep going */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1774" title="access/transam/slru.c:1774">SlruScanDirectory</a> callback.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This callback deletes segments prior to the one passed in as &quot;data&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1711">&#x200c;</a></span><span class="linkable">SlruScanDirCbDeleteCutoff</span>(SlruCtl ctl, <span class="Type">char</span> *filename, int64 segpage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; cutoffPage = *(int64 *) data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1586" title="access/transam/slru.c:1586">SlruMayDeleteSegment</a>(ctl, segpage, cutoffPage))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1486" title="access/transam/slru.c:1486">SlruInternalDeleteSegment</a>(ctl, segpage / SLRU_PAGES_PER_SEGMENT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep going */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1774" title="access/transam/slru.c:1774">SlruScanDirectory</a> callback.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This callback deletes all segments.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1727">&#x200c;</a></span><span class="linkable">SlruScanDirCbDeleteAll</span>(SlruCtl ctl, <span class="Type">char</span> *filename, int64 segpage, <span class="Type">void</span> *data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1486" title="access/transam/slru.c:1486">SlruInternalDeleteSegment</a>(ctl, segpage / SLRU_PAGES_PER_SEGMENT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep going */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * An <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> function used by <a href="#L1774" title="access/transam/slru.c:1774">SlruScanDirectory</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if a file with a name of a given length may be a correct<br/></li>
<li></span><span class="Comment"> * SLRU segment.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1741">&#x200c;</a></span><span class="linkable">SlruCorrectSegmentFilenameLength</span>(SlruCtl ctl, <span class="Type">size_t</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ctl-&gt;long_segment_names)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (len == <span class="Constant">15</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see <a href="#L76" title="access/transam/slru.c:76">SlruFileName</a>() */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Commit 638cf09e76d allowed 5-character lengths. Later commit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 73c986adde5 allowed 6-character length.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: There is an ongoing plan to migrate all SLRUs to 64-<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * numbers, and the corresponding 15-character file names, which may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * eventually deprecate the support for 4, 5, and 6-character names.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (len == <span class="Constant">4</span> || len == <span class="Constant">5</span> || len == <span class="Constant">6</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Scan the SimpleLru directory and apply a callback to each file found in it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the callback returns true, the scan is stopped.&nbsp; The last return value<br/></li>
<li></span><span class="Comment"> * from the callback is returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The callback receives the following arguments: 1. the SlruCtl struct for the<br/></li>
<li></span><span class="Comment"> * slru being truncated; 2. the filename being considered; 3. the page number<br/></li>
<li></span><span class="Comment"> * for the first page of that file; 4. a pointer to the opaque data given to us<br/></li>
<li></span><span class="Comment"> * by the caller.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the ordering in which the directory is scanned is not guaranteed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that no locking is applied.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1774">&#x200c;</a></span><span class="linkable">SlruScanDirectory</span>(SlruCtl ctl, SlruScanCallback callback, <span class="Type">void</span> *data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; retval = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *cldir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *clde;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; segno;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; segpage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cldir = <a href="../../storage/file/fd.c.html#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(ctl-&gt;Dir);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((clde = <a href="../../storage/file/fd.c.html#L2909" title="storage/file/fd.c:2909">ReadDir</a>(cldir, ctl-&gt;Dir)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = strlen(clde-&gt;d_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1741" title="access/transam/slru.c:1741">SlruCorrectSegmentFilenameLength</a>(ctl, len) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strspn(clde-&gt;d_name, <span class="Constant">&quot;0123456789ABCDEF&quot;</span>) == len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segno = strtoi64(clde-&gt;d_name, <span class="Constant">NULL</span>, <span class="Constant">16</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segpage = segno * SLRU_PAGES_PER_SEGMENT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;<a href="#L1774" title="access/transam/slru.c:1774">SlruScanDirectory</a> invoking callback on </span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ctl-&gt;Dir, clde-&gt;d_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = callback(ctl, clde-&gt;d_name, segpage, data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2961" title="storage/file/fd.c:2961">FreeDir</a>(cldir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Individual SLRUs (clog, ...) have to provide a sync.c handler function so<br/></li>
<li></span><span class="Comment"> * that they can provide the correct &quot;SlruCtl&quot; (otherwise we don't know how to<br/></li>
<li></span><span class="Comment"> * build the path), but they just forward to this common implementation that<br/></li>
<li></span><span class="Comment"> * performs the fsync.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L1814">&#x200c;</a></span><span class="linkable">SlruSyncFileTag</span>(SlruCtl ctl, <span class="Type">const</span> FileTag *ftag, <span class="Type">char</span> *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="access/transam/slru.c:76">SlruFileName</a>(ctl, path, ftag-&gt;segno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(path, O_RDWR | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_SLRU_FLUSH_SYNC);<br/></li>
<li>&nbsp; &nbsp; result = <a href="../../storage/file/fd.c.html#L386" title="storage/file/fd.c:386">pg_fsync</a>(fd);<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
