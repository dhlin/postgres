<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/transam/xlog.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/transam/xlog.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L159">CheckPointDistanceEstimate</a></li>
<li><a href="#L156">CheckPointSegments</a></li>
<li><a href="#L209">CheckpointStats</a></li>
<li><a href="#L132">CommitDelay</a></li>
<li><a href="#L133">CommitSiblings</a></li>
<li><a href="#L569">ControlFile</a></li>
<li><a href="#L121">EnableHotStandby</a></li>
<li><a href="#L641">LocalMinRecoveryPoint</a></li>
<li><a href="#L642">LocalMinRecoveryPointTLI</a></li>
<li><a href="#L224">LocalRecoveryInProgress</a></li>
<li><a href="#L236">LocalXLogInsertAllowed</a></li>
<li><a href="#L607">LogwrtResult</a></li>
<li><a href="#L646">MyLockNo</a></li>
<li><a href="#L160">PrevCheckPointDistance</a></li>
<li><a href="#L253">ProcLastRecPtr</a></li>
<li><a href="#L273">RedoRecPtr</a></li>
<li><a href="#L601">UsableBytesInSegment</a></li>
<li><a href="#L564">WALInsertLocks</a></li>
<li><a href="#L140">XLOG_DEBUG</a></li>
<li><a href="#L117">XLOGbuffers</a></li>
<li><a href="#L120">XLogArchiveCommand</a></li>
<li><a href="#L119">XLogArchiveMode</a></li>
<li><a href="#L118">XLogArchiveTimeout</a></li>
<li><a href="#L561">XLogCtl</a></li>
<li><a href="#L255">XactLastCommitEnd</a></li>
<li><a href="#L254">XactLastRecEnd</a></li>
<li><a href="#L191">archive_mode_options</a></li>
<li><a href="#L166">check_wal_consistency_checking_deferred</a></li>
<li><a href="#L286">doPageWrites</a></li>
<li><a href="#L122">fullPageWrites</a></li>
<li><a href="#L647">holdingAllLocks</a></li>
<li><a href="#L217">lastFullPageWrites</a></li>
<li><a href="#L129">log_checkpoints</a></li>
<li><a href="#L135">max_slot_wal_keep_size_mb</a></li>
<li><a href="#L114">max_wal_size_mb</a></li>
<li><a href="#L115">min_wal_size_mb</a></li>
<li><a href="#L630">openLogFile</a></li>
<li><a href="#L631">openLogSegNo</a></li>
<li><a href="#L632">openLogTLI</a></li>
<li><a href="#L391">sessionBackupState</a></li>
<li><a href="#L137">track_wal_io_timing</a></li>
<li><a href="#L643">updateMinRecoveryPoint</a></li>
<li><a href="#L650">walDebugCxt</a></li>
<li><a href="#L124">wal_compression</a></li>
<li><a href="#L126">wal_consistency_checking</a></li>
<li><a href="#L125">wal_consistency_checking_string</a></li>
<li><a href="#L136">wal_decode_buffer_size</a></li>
<li><a href="#L127">wal_init_zero</a></li>
<li><a href="#L116">wal_keep_size_mb</a></li>
<li><a href="#L131">wal_level</a></li>
<li><a href="#L123">wal_log_hints</a></li>
<li><a href="#L128">wal_recycle</a></li>
<li><a href="#L134">wal_retrieve_retry_interval</a></li>
<li><a href="#L143">wal_segment_size</a></li>
<li><a href="#L130">wal_sync_method</a></li>
<li><a href="#L171">wal_sync_method_options</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L372">WALInsertLock</a></li>
<li><a href="#L381">WALInsertLockPadded</a></li>
<li><a href="#L385">WALInsertLockPadded</a></li>
<li><a href="#L559">WalInsertClass</a></li>
<li><a href="#L450">XLogCtlData</a></li>
<li><a href="#L549">XLogCtlData</a></li>
<li><a href="#L396">XLogCtlInsert</a></li>
<li><a href="#L445">XLogCtlInsert</a></li>
<li><a href="#L325">XLogwrtResult</a></li>
<li><a href="#L329">XLogwrtResult</a></li>
<li><a href="#L319">XLogwrtRqst</a></li>
<li><a href="#L323">XLogwrtRqst</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1980">AdvanceXLInsertBuffer</a></li>
<li><a href="#L5000">BootStrapXLOG</a></li>
<li><a href="#L2157">CalculateCheckpointSegments</a></li>
<li><a href="#L7431">CheckPointGuts</a></li>
<li><a href="#L5344">CheckRequiredParameterValues</a></li>
<li><a href="#L3716">CheckXLogRemoved</a></li>
<li><a href="#L5255">CleanupAfterArchiveRecovery</a></li>
<li><a href="#L4150">CleanupBackupHistory</a></li>
<li><a href="#L1220">CopyXLogRecordToWAL</a></li>
<li><a href="#L6821">CreateCheckPoint</a></li>
<li><a href="#L7297">CreateEndOfRecoveryRecord</a></li>
<li><a href="#L7361">CreateOverwriteContrecordRecord</a></li>
<li><a href="#L7512">CreateRestartPoint</a></li>
<li><a href="#L4555">DataChecksumsEnabled</a></li>
<li><a href="#L4826">GetActiveWalLevelOnStandby</a></li>
<li><a href="#L4571">GetFakeLSNForUnloggedRel</a></li>
<li><a href="#L6455">GetFlushRecPtr</a></li>
<li><a href="#L6423">GetFullPageWriteInfo</a></li>
<li><a href="#L6438">GetInsertRecPtr</a></li>
<li><a href="#L6493">GetLastImportantRecPtr</a></li>
<li><a href="#L6522">GetLastSegSwitchData</a></li>
<li><a href="#L4545">GetMockAuthenticationNonce</a></li>
<li><a href="#L9383">GetOldestRestartPoint</a></li>
<li><a href="#L6326">GetRecoveryState</a></li>
<li><a href="#L6393">GetRedoRecPtr</a></li>
<li><a href="#L4535">GetSystemIdentifier</a></li>
<li><a href="#L7790">GetWALAvailability</a></li>
<li><a href="#L6476">GetWALInsertionTimeLine</a></li>
<li><a href="#L1627">GetXLogBuffer</a></li>
<li><a href="#L9355">GetXLogInsertRecPtr</a></li>
<li><a href="#L9371">GetXLogWriteRecPtr</a></li>
<li><a href="#L4193">InitControlFile</a></li>
<li><a href="#L4751">InitializeWalConsistencyChecking</a></li>
<li><a href="#L3552">InstallXLogFileSegment</a></li>
<li><a href="#L9412">IsInstallXLogFileSegmentActive</a></li>
<li><a href="#L7874">KeepLogSeg</a></li>
<li><a href="#L4813">LocalProcessControlFile</a></li>
<li><a href="#L6378">LocalSetXLogInsertAllowed</a></li>
<li><a href="#L6618">LogCheckpointEnd</a></li>
<li><a href="#L6586">LogCheckpointStart</a></li>
<li><a href="#L6240">PerformRecoveryXLogAction</a></li>
<li><a href="#L3679">PreallocXlogFiles</a></li>
<li><a href="#L6203">ReachedEndOfBackup</a></li>
<li><a href="#L4310">ReadControlFile</a></li>
<li><a href="#L6290">RecoveryInProgress</a></li>
<li><a href="#L7471">RecoveryRestartPoint</a></li>
<li><a href="#L3929">RemoveNonParentXlogFiles</a></li>
<li><a href="#L3854">RemoveOldXlogFiles</a></li>
<li><a href="#L3821">RemoveTempXlogFiles</a></li>
<li><a href="#L3998">RemoveXlogFile</a></li>
<li><a href="#L7981">RequestXLogSwitch</a></li>
<li><a href="#L1103">ReserveXLogInsertLocation</a></li>
<li><a href="#L1159">ReserveXLogSwitch</a></li>
<li><a href="#L9404">SetInstallXLogFileSegmentActive</a></li>
<li><a href="#L9427">SetWalWriterSleeping</a></li>
<li><a href="#L6539">ShutdownXLOG</a></li>
<li><a href="#L5388">StartupXLOG</a></li>
<li><a href="#L6165">SwitchIntoArchiveRecovery</a></li>
<li><a href="#L6721">UpdateCheckPointDistanceEstimate</a></li>
<li><a href="#L4526">UpdateControlFile</a></li>
<li><a href="#L8087">UpdateFullPageWrites</a></li>
<li><a href="#L3801">UpdateLastRemovedPtr</a></li>
<li><a href="#L2711">UpdateMinRecoveryPoint</a></li>
<li><a href="#L4088">ValidateXLOGDirectoryStructure</a></li>
<li><a href="#L1366">WALInsertLockAcquire</a></li>
<li><a href="#L1411">WALInsertLockAcquireExclusive</a></li>
<li><a href="#L1440">WALInsertLockRelease</a></li>
<li><a href="#L1466">WALInsertLockUpdateInsertingAt</a></li>
<li><a href="#L1743">WALReadFromBuffers</a></li>
<li><a href="#L1499">WaitXLogInsertionsToFinish</a></li>
<li><a href="#L4228">WriteControlFile</a></li>
<li><a href="#L4588">XLOGChooseNumBuffers</a></li>
<li><a href="#L4885">XLOGShmemInit</a></li>
<li><a href="#L4835">XLOGShmemSize</a></li>
<li><a href="#L2235">XLOGfileslop</a></li>
<li><a href="#L2979">XLogBackgroundFlush</a></li>
<li><a href="#L1893">XLogBytePosToEndRecPtr</a></li>
<li><a href="#L1853">XLogBytePosToRecPtr</a></li>
<li><a href="#L2285">XLogCheckpointNeeded</a></li>
<li><a href="#L3628">XLogFileClose</a></li>
<li><a href="#L3407">XLogFileCopy</a></li>
<li><a href="#L3369">XLogFileInit</a></li>
<li><a href="#L3199">XLogFileInitInternal</a></li>
<li><a href="#L3607">XLogFileOpen</a></li>
<li><a href="#L2791">XLogFlush</a></li>
<li><a href="#L3747">XLogGetLastRemovedSegno</a></li>
<li><a href="#L3763">XLogGetOldestSegno</a></li>
<li><a href="#L2690">XLogGetReplicationSlotMinimumLSN</a></li>
<li><a href="#L5180">XLogInitNewTimeline</a></li>
<li><a href="#L6345">XLogInsertAllowed</a></li>
<li><a href="#L743">XLogInsertRecord</a></li>
<li><a href="#L3122">XLogNeedsFlush</a></li>
<li><a href="#L7944">XLogPutNextOid</a></li>
<li><a href="#L1936">XLogRecPtrToBytePos</a></li>
<li><a href="#L8024">XLogReportParameters</a></li>
<li><a href="#L7999">XLogRestorePoint</a></li>
<li><a href="#L2626">XLogSetAsyncXactLSN</a></li>
<li><a href="#L2677">XLogSetReplicationSlotMinimumLSN</a></li>
<li><a href="#L9393">XLogShutdownWalRcv</a></li>
<li><a href="#L2309">XLogWrite</a></li>
<li><a href="#L2193">assign_checkpoint_completion_target</a></li>
<li><a href="#L2186">assign_max_wal_size</a></li>
<li><a href="#L4724">assign_wal_consistency_checking</a></li>
<li><a href="#L8561">assign_wal_sync_method</a></li>
<li><a href="#L2218">check_max_slot_wal_keep_size</a></li>
<li><a href="#L4604">check_wal_buffers</a></li>
<li><a href="#L4639">check_wal_consistency_checking</a></li>
<li><a href="#L2200">check_wal_segment_size</a></li>
<li><a href="#L9314">do_pg_abort_backup</a></li>
<li><a href="#L8712">do_pg_backup_start</a></li>
<li><a href="#L9040">do_pg_backup_stop</a></li>
<li><a href="#L9021">get_backup_status</a></li>
<li><a href="#L8513">get_sync_bit</a></li>
<li><a href="#L8603">issue_xlog_fsync</a></li>
<li><a href="#L9341">register_persistent_abort_backup_handler</a></li>
<li><a href="#L4777">show_archive_command</a></li>
<li><a href="#L4789">show_in_hot_standby</a></li>
<li><a href="#L5165">str_time</a></li>
<li><a href="#L6759">update_checkpoint_display</a></li>
<li><a href="#L8156">xlog_redo</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L111">BootstrapTimeLineID</a></li>
<li><a href="#L598">ConvertToXSegs</a></li>
<li><a href="#L575">INSERT_FREESPACE</a></li>
<li><a href="#L150">NUM_XLOGINSERT_LOCKS</a></li>
<li><a href="#L579">NextBufIdx</a></li>
<li><a href="#L615">RefreshXLogWriteResult</a></li>
<li><a href="#L592">UsableBytesInPage</a></li>
<li><a href="#L586">XLogRecPtrToBufIdx</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * xlog.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PostgreSQL write-ahead log manager<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The Write-Ahead Log (WAL) functionality is split into several source<br/></li>
<li></span><span class="Comment"> * files, in addition to this one:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * xloginsert.c - Functions for constructing WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a><br/></li>
<li></span><span class="Comment"> * xlogrecovery.c - WAL recovery and standby code<br/></li>
<li></span><span class="Comment"> * <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>.c - Facility for reading WAL files and parsing WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a><br/></li>
<li></span><span class="Comment"> * xlogutils.c - Helper <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for WAL redo routines<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This file contains <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for coordinating database startup and<br/></li>
<li></span><span class="Comment"> * checkpointing, and managing the write-ahead log buffers when the<br/></li>
<li></span><span class="Comment"> * system is running.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L5388" title="access/transam/xlog.c:5388">StartupXLOG</a>() is the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> entry point of the startup process.&nbsp; It<br/></li>
<li></span><span class="Comment"> * coordinates database startup, performing WAL recovery, and the<br/></li>
<li></span><span class="Comment"> * transition from WAL recovery into normal operations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L743" title="access/transam/xlog.c:743">XLogInsertRecord</a>() inserts a WAL record into the WAL buffers.&nbsp; Most<br/></li>
<li></span><span class="Comment"> * callers should not call this directly, but use the <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in<br/></li>
<li></span><span class="Comment"> * xloginsert.c to construct the WAL record.&nbsp; <a href="#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>() can be used<br/></li>
<li></span><span class="Comment"> * to force the WAL to disk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition to those, there are many other <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for interrogating<br/></li>
<li></span><span class="Comment"> * the current system state, and for starting/stopping backups.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * src/backend/access/transam/xlog.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;time.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/time.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/clog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/commit_ts.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heaptoast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/multixact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/rewriteheap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/subtrans.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/timeline.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/twophase.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogarchive.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogrecovery.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;backup/basebackup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/catversion.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_control.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_database.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/controldata_utils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/file_utils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/instrument.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pg_trace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/atomics.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_iovec.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/bgwriter.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/startup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/walsummarizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/walwriter.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/origin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/slot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/snapbuild.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walreceiver.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walsender.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/large_object.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/latch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/reinit.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/spin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/sync.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_tables.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/injection_point.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ps_status.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/relmapper.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timeout.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/varlena.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">extern</span> uint32 <a href="../../bootstrap/bootstrap.c.html#L44" title="bootstrap/bootstrap.c:44">bootstrap_data_checksum_version</a>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* timeline ID to be used when bootstrapping */<br/></li>
<li><a id="L111">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BootstrapTimeLineID</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* User-settable parameters */<br/></li>
<li><a id="L114">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">max_wal_size_mb</span> = <span class="Constant">1024</span>; <span class="Comment">/* 1 GB */<br/></li>
<li><a id="L115">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">min_wal_size_mb</span> = <span class="Constant">80</span>;&nbsp; &nbsp; <span class="Comment">/* 80 MB */<br/></li>
<li><a id="L116">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">wal_keep_size_mb</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L117">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">XLOGbuffers</span> = -<span class="Constant">1</span>;<br/></li>
<li><a id="L118">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">XLogArchiveTimeout</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L119">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">XLogArchiveMode</span> = ARCHIVE_MODE_OFF;<br/></li>
<li><a id="L120">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">XLogArchiveCommand</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L121">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">EnableHotStandby</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L122">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">fullPageWrites</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L123">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">wal_log_hints</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L124">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">wal_compression</span> = WAL_COMPRESSION_NONE;<br/></li>
<li><a id="L125">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">wal_consistency_checking_string</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L126">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">wal_consistency_checking</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L127">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">wal_init_zero</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L128">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">wal_recycle</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L129">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">log_checkpoints</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L130">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">wal_sync_method</span> = DEFAULT_WAL_SYNC_METHOD;<br/></li>
<li><a id="L131">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">wal_level</span> = WAL_LEVEL_REPLICA;<br/></li>
<li><a id="L132">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">CommitDelay</span> = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* precommit delay in microseconds */<br/></li>
<li><a id="L133">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">CommitSiblings</span> = <span class="Constant">5</span>; <span class="Comment">/* # concurrent xacts needed to sleep */<br/></li>
<li><a id="L134">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">wal_retrieve_retry_interval</span> = <span class="Constant">5000</span>;<br/></li>
<li><a id="L135">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">max_slot_wal_keep_size_mb</span> = -<span class="Constant">1</span>;<br/></li>
<li><a id="L136">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">wal_decode_buffer_size</span> = <span class="Constant">512</span> * <span class="Constant">1024</span>;<br/></li>
<li><a id="L137">&#x200c;</a><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">track_wal_io_timing</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WAL_DEBUG<br/></li>
<li><a id="L140">&#x200c;</a></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">XLOG_DEBUG</span> = <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L143">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">wal_segment_size</span> = DEFAULT_XLOG_SEG_SIZE;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Number of WAL insertion locks to use. A higher value allows more insertions<br/></li>
<li></span><span class="Comment"> * to happen concurrently, but adds some CPU overhead to flushing the WAL,<br/></li>
<li></span><span class="Comment"> * which needs to iterate all the locks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L150">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUM_XLOGINSERT_LOCKS</span>&nbsp; </span><span class="Constant">8<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Max distance from last checkpoint, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> triggering a new xlog-based<br/></li>
<li></span><span class="Comment"> * checkpoint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L156">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">CheckPointSegments</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Estimated distance between checkpoints, in bytes */<br/></li>
<li><a id="L159">&#x200c;</a></span><span class="Type">static</span> <span class="Type">double</span> <span class="linkable">CheckPointDistanceEstimate</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L160">&#x200c;</a><span class="Type">static</span> <span class="Type">double</span> <span class="linkable">PrevCheckPointDistance</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Track whether there were <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> deferred checks for custom resource managers<br/></li>
<li></span><span class="Comment"> * specified in <a href="#L126" title="access/transam/xlog.c:126">wal_consistency_checking</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L166">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">check_wal_consistency_checking_deferred</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC support<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L171">&#x200c;</a></span><span class="Type">const</span> <span class="Type">struct</span> config_enum_entry <span class="linkable">wal_sync_method_options</span>[] = {<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;fsync&quot;</span>, WAL_SYNC_METHOD_FSYNC, <span class="Constant">false</span>},<br/></li>
<li><span class="PreProc">#ifdef HAVE_FSYNC_WRITETHROUGH<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;fsync_writethrough&quot;</span>, WAL_SYNC_METHOD_FSYNC_WRITETHROUGH, <span class="Constant">false</span>},<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;fdatasync&quot;</span>, WAL_SYNC_METHOD_FDATASYNC, <span class="Constant">false</span>},<br/></li>
<li><span class="PreProc">#ifdef O_SYNC<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;open_sync&quot;</span>, WAL_SYNC_METHOD_OPEN, <span class="Constant">false</span>},<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef O_DSYNC<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">&quot;open_datasync&quot;</span>, WAL_SYNC_METHOD_OPEN_DSYNC, <span class="Constant">false</span>},<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">false</span>}<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Although only &quot;on&quot;, &quot;off&quot;, and &quot;always&quot; are documented,<br/></li>
<li></span><span class="Comment"> * we <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> all the likely variants of &quot;on&quot; and &quot;off&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L191">&#x200c;</a></span><span class="Type">const</span> <span class="Type">struct</span> config_enum_entry <span class="linkable">archive_mode_options</span>[] = {<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;always&quot;</span>, ARCHIVE_MODE_ALWAYS, <span class="Constant">false</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;on&quot;</span>, ARCHIVE_MODE_ON, <span class="Constant">false</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;off&quot;</span>, ARCHIVE_MODE_OFF, <span class="Constant">false</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;true&quot;</span>, ARCHIVE_MODE_ON, <span class="Constant">true</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;false&quot;</span>, ARCHIVE_MODE_OFF, <span class="Constant">true</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;yes&quot;</span>, ARCHIVE_MODE_ON, <span class="Constant">true</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;no&quot;</span>, ARCHIVE_MODE_OFF, <span class="Constant">true</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;1&quot;</span>, ARCHIVE_MODE_ON, <span class="Constant">true</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">&quot;0&quot;</span>, ARCHIVE_MODE_OFF, <span class="Constant">true</span>},<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">false</span>}<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Statistics for current checkpoint are collected in this global struct.<br/></li>
<li></span><span class="Comment"> * Because only the checkpointer or a stand-alone backend can perform<br/></li>
<li></span><span class="Comment"> * checkpoints, this will be unused in normal backends.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L209">&#x200c;</a></span>CheckpointStatsData <span class="linkable">CheckpointStats</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * During recovery, <a href="#L217" title="access/transam/xlog.c:217">lastFullPageWrites</a> keeps track of full_page_writes that<br/></li>
<li></span><span class="Comment"> * the replayed WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> indicate. It's initialized with full_page_writes<br/></li>
<li></span><span class="Comment"> * that the recovery starting checkpoint record indicates, and then updated<br/></li>
<li></span><span class="Comment"> * each time XLOG_FPW_CHANGE record is replayed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L217">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">lastFullPageWrites</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Local copy of the state tracked by SharedRecoveryState in shared memory,<br/></li>
<li></span><span class="Comment"> * It is false if SharedRecoveryState is RECOVERY_STATE_DONE.&nbsp; True actually<br/></li>
<li></span><span class="Comment"> * means &quot;not known, need to check the shared state&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L224">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">LocalRecoveryInProgress</span> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Local state for <a href="#L6345" title="access/transam/xlog.c:6345">XLogInsertAllowed</a>():<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 1: unconditionally allowed to insert XLOG<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 0: unconditionally not allowed to insert XLOG<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; -1: must check <a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>(); disallow until it is false<br/></li>
<li></span><span class="Comment"> * Most processes start with -1 and transition to 1 after seeing that recovery<br/></li>
<li></span><span class="Comment"> * is not in progress.&nbsp; But we can also force the value for special cases.<br/></li>
<li></span><span class="Comment"> * The coding in <a href="#L6345" title="access/transam/xlog.c:6345">XLogInsertAllowed</a>() depends on the first two of these states<br/></li>
<li></span><span class="Comment"> * being numerically the same as <a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> true and false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L236">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">LocalXLogInsertAllowed</span> = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L253" title="access/transam/xlog.c:253">ProcLastRecPtr</a> points to the start of the last XLOG record inserted by the<br/></li>
<li></span><span class="Comment"> * current backend.&nbsp; It is updated for all inserts.&nbsp; <a href="#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a> points to<br/></li>
<li></span><span class="Comment"> * end+1 of the last record, and is reset when we end a top-level transaction,<br/></li>
<li></span><span class="Comment"> * or start a new one; so it can be used to tell if the current transaction has<br/></li>
<li></span><span class="Comment"> * created <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> XLOG <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * While in parallel mode, this may not be fully up to date.&nbsp; When committing,<br/></li>
<li></span><span class="Comment"> * a transaction can assume this covers all xlog <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> written either by the<br/></li>
<li></span><span class="Comment"> * user backend or by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parallel worker which was present at <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> point during<br/></li>
<li></span><span class="Comment"> * the transaction.&nbsp; But when aborting, or when still in parallel mode, other<br/></li>
<li></span><span class="Comment"> * parallel backends may have written WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> at later LSNs than the value<br/></li>
<li></span><span class="Comment"> * stored here.&nbsp; The parallel leader advances its own copy, when necessary,<br/></li>
<li></span><span class="Comment"> * in <a href="parallel.c.html#L775" title="access/transam/parallel.c:775">WaitForParallelWorkersToFinish</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L253">&#x200c;</a></span>XLogRecPtr&nbsp; &nbsp; <span class="linkable">ProcLastRecPtr</span> = InvalidXLogRecPtr;<br/></li>
<li><a id="L254">&#x200c;</a>XLogRecPtr&nbsp; &nbsp; <span class="linkable">XactLastRecEnd</span> = InvalidXLogRecPtr;<br/></li>
<li><a id="L255">&#x200c;</a>XLogRecPtr&nbsp; &nbsp; <span class="linkable">XactLastCommitEnd</span> = InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> is this backend's local copy of the REDO record pointer<br/></li>
<li></span><span class="Comment"> * (which is almost but not quite the same as a pointer to the most recent<br/></li>
<li></span><span class="Comment"> * CHECKPOINT record).&nbsp; We update this from the shared-memory copy,<br/></li>
<li></span><span class="Comment"> * <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>.<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>, whenever we can safely do so (ie, when we<br/></li>
<li></span><span class="Comment"> * hold an insertion lock).&nbsp; See <a href="#L743" title="access/transam/xlog.c:743">XLogInsertRecord</a> for details.&nbsp; We are also<br/></li>
<li></span><span class="Comment"> * allowed to update from <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> if we hold the info_lck;<br/></li>
<li></span><span class="Comment"> * see <a href="#L6393" title="access/transam/xlog.c:6393">GetRedoRecPtr</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: Code that uses this variable must be prepared not only for the<br/></li>
<li></span><span class="Comment"> * possibility that it may be arbitrarily out of date, but also for the<br/></li>
<li></span><span class="Comment"> * possibility that it might be set to InvalidXLogRecPtr. We used to<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it as a side effect of the first call to <a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>(),<br/></li>
<li></span><span class="Comment"> * which meant that most code that might use it could assume that it had a<br/></li>
<li></span><span class="Comment"> * real if perhaps stale value. That's no longer the case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L273">&#x200c;</a></span><span class="Type">static</span> XLogRecPtr <span class="linkable">RedoRecPtr</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L286" title="access/transam/xlog.c:286">doPageWrites</a> is this backend's local copy of (<a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a> ||<br/></li>
<li></span><span class="Comment"> * runningBackups &gt; 0).&nbsp; It is used together with <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> to decide whether<br/></li>
<li></span><span class="Comment"> * a full-page image of a page need to be taken.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: Initially this is false, and there's no guarantee that it will be<br/></li>
<li></span><span class="Comment"> * initialized to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other value <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it is first used. Any code that<br/></li>
<li></span><span class="Comment"> * makes use of it must recheck the value after obtaining a <a href="#L372" title="access/transam/xlog.c:372">WALInsertLock</a>,<br/></li>
<li></span><span class="Comment"> * and respond appropriately if it turns out that the previous value wasn't<br/></li>
<li></span><span class="Comment"> * accurate.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L286">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">doPageWrites</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*----------<br/></li>
<li></span><span class="Comment"> * Shared-memory data structures for XLOG control<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * LogwrtRqst indicates a byte position that we need to write and/or fsync<br/></li>
<li></span><span class="Comment"> * the log up to (all <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> that point must be written or fsynced).<br/></li>
<li></span><span class="Comment"> * The positions already written/fsynced are maintained in logWriteResult<br/></li>
<li></span><span class="Comment"> * and logFlushResult using atomic access.<br/></li>
<li></span><span class="Comment"> * In addition to the shared variable, each backend has a private copy of<br/></li>
<li></span><span class="Comment"> * both in <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>, which is updated when convenient.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The request bookkeeping is simpler: there is a shared <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;LogwrtRqst<br/></li>
<li></span><span class="Comment"> * (protected by info_lck), but we don't need to cache <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> copies of it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * info_lck is only held long enough to read/update the protected variables,<br/></li>
<li></span><span class="Comment"> * so it's a plain spinlock.&nbsp; The other locks are held longer (potentially<br/></li>
<li></span><span class="Comment"> * over I/O operations), so we use LWLocks for them.&nbsp; These locks are:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * WALBufMappingLock: must be held to replace a page in the WAL buffer cache.<br/></li>
<li></span><span class="Comment"> * It is only held while initializing and changing the mapping.&nbsp; If the<br/></li>
<li></span><span class="Comment"> * contents of the buffer being replaced haven't been written yet, the mapping<br/></li>
<li></span><span class="Comment"> * lock is released while the write is done, and reacquired afterwards.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * WALWriteLock: must be held to write WAL buffers to disk (<a href="#L2309" title="access/transam/xlog.c:2309">XLogWrite</a> or<br/></li>
<li></span><span class="Comment"> * <a href="#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ControlFileLock: must be held to read/update control file or create<br/></li>
<li></span><span class="Comment"> * new log file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L319">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">XLogwrtRqst</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; Write;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* last byte + 1 to write out */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; Flush;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* last byte + 1 to flush */<br/></li>
<li><a id="L323">&#x200c;</a></span>} <span class="linkable">XLogwrtRqst</span>;<br/></li>
<li><br/></li>
<li><a id="L325">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">XLogwrtResult</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; Write;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* last byte + 1 written out */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; Flush;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* last byte + 1 flushed */<br/></li>
<li><a id="L329">&#x200c;</a></span>} <span class="linkable">XLogwrtResult</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Inserting to WAL is protected by a small fixed number of WAL insertion<br/></li>
<li></span><span class="Comment"> * locks. To insert to the WAL, you must hold one of the locks - it doesn't<br/></li>
<li></span><span class="Comment"> * matter which one. To lock out other concurrent insertions, you must hold<br/></li>
<li></span><span class="Comment"> * of them. Each WAL insertion lock consists of a lightweight lock, plus an<br/></li>
<li></span><span class="Comment"> * indicator of how far the insertion has progressed (insertingAt).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The insertingAt <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are read when a process wants to flush WAL from<br/></li>
<li></span><span class="Comment"> * the in-memory buffers to disk, to check that all the insertions to the<br/></li>
<li></span><span class="Comment"> * region the process is about to write out have finished. You could simply<br/></li>
<li></span><span class="Comment"> * wait for all currently in-progress insertions to finish, but the<br/></li>
<li></span><span class="Comment"> * insertingAt indicator allows you to ignore insertions to later in the WAL,<br/></li>
<li></span><span class="Comment"> * so that you only wait for the insertions that are modifying the buffers<br/></li>
<li></span><span class="Comment"> * you're about to write out.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This isn't just an optimization. If all the WAL buffers are dirty, an<br/></li>
<li></span><span class="Comment"> * inserter that's holding a WAL insert lock might need to evict an old WAL<br/></li>
<li></span><span class="Comment"> * buffer, which requires flushing the WAL. If it's possible for an inserter<br/></li>
<li></span><span class="Comment"> * to block on another inserter unnecessarily, deadlock can arise when two<br/></li>
<li></span><span class="Comment"> * inserters holding a WAL insert lock wait for each other to finish their<br/></li>
<li></span><span class="Comment"> * insertion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Small WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> that don't cross a page boundary never update the value,<br/></li>
<li></span><span class="Comment"> * the WAL record is just copied to the page and the lock is released. But<br/></li>
<li></span><span class="Comment"> * to avoid the deadlock-scenario explained above, the indicator is always<br/></li>
<li></span><span class="Comment"> * updated <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> sleeping while holding an insertion lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * lastImportantAt contains the LSN of the last important WAL record inserted<br/></li>
<li></span><span class="Comment"> * using a given lock. This value is used to detect if there has been<br/></li>
<li></span><span class="Comment"> * important WAL activity since the last time some action, like a checkpoint,<br/></li>
<li></span><span class="Comment"> * was performed - allowing to not <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> the action if not. The LSN is<br/></li>
<li></span><span class="Comment"> * updated for all insertions, unless the XLOG_MARK_UNIMPORTANT flag was<br/></li>
<li></span><span class="Comment"> * set. lastImportantAt is never cleared, only overwritten by the LSN of newer<br/></li>
<li></span><span class="Comment"> * <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.&nbsp; Tracking the WAL activity directly in <a href="#L372" title="access/transam/xlog.c:372">WALInsertLock</a> has the<br/></li>
<li></span><span class="Comment"> * advantage of not needing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> additional locks to update the value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp; &nbsp; lock;<br/></li>
<li>&nbsp; &nbsp; pg_atomic_uint64 insertingAt;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lastImportantAt;<br/></li>
<li><a id="L372">&#x200c;</a>} <span class="linkable">WALInsertLock</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * All the WAL insertion locks are allocated as an array in shared memory. We<br/></li>
<li></span><span class="Comment"> * force the array stride to be a power of 2, which saves a few cycles in<br/></li>
<li></span><span class="Comment"> * indexing, but more importantly also ensures that individual slots don't<br/></li>
<li></span><span class="Comment"> * cross cache line boundaries. (Of course, we have to also ensure that the<br/></li>
<li></span><span class="Comment"> * array start address is suitably aligned.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L381">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">union</span> <span class="linkable">WALInsertLockPadded</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L372" title="access/transam/xlog.c:372">WALInsertLock</a> l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; pad[PG_CACHE_LINE_SIZE];<br/></li>
<li><a id="L385">&#x200c;</a>} <span class="linkable">WALInsertLockPadded</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Session status of running backup, used for sanity checks in SQL-callable<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to start and stop backups.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L391">&#x200c;</a></span><span class="Type">static</span> SessionBackupState <span class="linkable">sessionBackupState</span> = SESSION_BACKUP_NONE;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Shared state data for WAL insertion.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L396">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">XLogCtlInsert</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; slock_t&nbsp; &nbsp; &nbsp; &nbsp; insertpos_lck;&nbsp; &nbsp; <span class="Comment">/* protects CurrBytePos and PrevBytePos */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CurrBytePos is the end of reserved WAL. The <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> record will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inserted at that position. PrevBytePos is the start position of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previously inserted (or rather, reserved) record - it is copied to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prev-link of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> record. These are stored as &quot;usable byte<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * positions&quot; rather than XLogRecPtrs (see <a href="#L1853" title="access/transam/xlog.c:1853">XLogBytePosToRecPtr</a>()).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; CurrBytePos;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; PrevBytePos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure the above heavily-contended spinlock and byte positions are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on their own cache line. In particular, the <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> and full page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * write variables below should be on a different cache line. They are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read on every WAL insertion, but updated rarely, and we don't want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those reads to steal the cache line containing Curr/PrevBytePos.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; pad[PG_CACHE_LINE_SIZE];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a> is the authoritative value used by all backends to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * determine whether to write full-page image to WAL. This shared value,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instead of the process-local <a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a>, is required because, when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * full_page_writes is changed by SIGHUP, we must WAL-log it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actually affects WAL-logging by backends.&nbsp; Checkpointer sets at startup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or after SIGHUP.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To read these fields, you must hold an insertion lock. To modify them,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * you must hold ALL the locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current redo point for insertions */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * runningBackups is a counter indicating the number of backups currently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in progress. lastBackupStart is the latest checkpoint redo location<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used as a starting point for an online backup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; runningBackups;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lastBackupStart;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WAL insertion locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L381" title="access/transam/xlog.c:381">WALInsertLockPadded</a> *<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>;<br/></li>
<li><a id="L445">&#x200c;</a>} <span class="linkable">XLogCtlInsert</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Total shared-memory state for XLOG.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L450">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">XLogCtlData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L396" title="access/transam/xlog.c:396">XLogCtlInsert</a> <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Protected by info_lck: */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L319" title="access/transam/xlog.c:319">XLogwrtRqst</a> LogwrtRqst;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* a recent copy of <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> */<br/></li>
<li></span>&nbsp; &nbsp; FullTransactionId ckptFullXid;&nbsp; &nbsp; <span class="Comment">/* nextXid of latest checkpoint */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; asyncXactLSN;&nbsp; &nbsp; <span class="Comment">/* LSN of newest async commit/abort */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; replicationSlotMinLSN;&nbsp; &nbsp; <span class="Comment">/* oldest LSN needed by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> slot */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; lastRemovedSegNo;&nbsp; &nbsp; <span class="Comment">/* latest removed/recycled XLOG segment */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fake LSN counter, for unlogged relations. */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_uint64 unloggedLSN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Time and LSN of last xlog segment switch. Protected by WALWriteLock. */<br/></li>
<li></span>&nbsp; &nbsp; pg_time_t&nbsp; &nbsp; lastSegSwitchTime;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lastSegSwitchLSN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* These are accessed using atomics -- info_lck not needed */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_uint64 logInsertResult;&nbsp; &nbsp; <span class="Comment">/* last byte + 1 inserted to buffers */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_uint64 logWriteResult;&nbsp; &nbsp; <span class="Comment">/* last byte + 1 written out */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_uint64 logFlushResult;&nbsp; &nbsp; <span class="Comment">/* last byte + 1 flushed */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Latest initialized page in the cache (last byte position + 1).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To change the identity of a buffer (and InitializedUpTo), you need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hold WALBufMappingLock.&nbsp; To change the identity of a buffer that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still dirty, the old page needs to be written out first, and for that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * you need WALWriteLock, and you need to ensure that there are no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in-progress insertions to the page by calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1499" title="access/transam/xlog.c:1499">WaitXLogInsertionsToFinish</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; InitializedUpTo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> do not change after startup, although the pointed-to pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and xlblocks <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> certainly do.&nbsp; xlblocks <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are protected by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WALBufMappingLock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pages;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* buffers for unwritten XLOG pages */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_uint64 *xlblocks; <span class="Comment">/* 1st byte ptr-s + XLOG_BLCKSZ */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogCacheBlck;&nbsp; &nbsp; <span class="Comment">/* highest allocated xlog buffer index */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * InsertTimeLineID is the timeline into which new WAL is being inserted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and flushed. It is zero during recovery, and does not change once set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we create a new timeline when the system was started up,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PrevTimeLineID is the old timeline's ID that we forked off from.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise it's <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to InsertTimeLineID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; InsertTimeLineID;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; PrevTimeLineID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SharedRecoveryState indicates if we're still in crash or archive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery.&nbsp; Protected by info_lck.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; RecoveryState SharedRecoveryState;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * InstallXLogFileSegmentActive indicates whether the checkpointer should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arrange for future segments by recycling and/or <a href="#L3679" title="access/transam/xlog.c:3679">PreallocXlogFiles</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Protected by ControlFileLock.&nbsp; Only the startup process changes it.&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * true, anyone can use <a href="#L3552" title="access/transam/xlog.c:3552">InstallXLogFileSegment</a>().&nbsp; If false, the startup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process owns the exclusive right to install segments, by reading from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the archive and possibly replacing existing files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; InstallXLogFileSegmentActive;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WalWriterSleeping indicates whether the WAL writer is currently in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * low-power mode (and hence should be nudged if an async commit occurs).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Protected by info_lck.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; WalWriterSleeping;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During recovery, we keep a copy of the latest checkpoint record here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lastCheckPointRecPtr points to start of checkpoint record and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lastCheckPointEndPtr points to end+1 of checkpoint record.&nbsp; Used by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpointer when it wants to create a restartpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Protected by info_lck.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lastCheckPointRecPtr;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lastCheckPointEndPtr;<br/></li>
<li>&nbsp; &nbsp; CheckPoint&nbsp; &nbsp; lastCheckPoint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lastFpwDisableRecPtr points to the start of the last replayed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLOG_FPW_CHANGE record that instructs full_page_writes is disabled.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lastFpwDisableRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slock_t&nbsp; &nbsp; &nbsp; &nbsp; info_lck;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* locks shared variables shown above */<br/></li>
<li><a id="L549">&#x200c;</a></span>} <span class="linkable">XLogCtlData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Classification of XLogRecordInsert operations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; WALINSERT_NORMAL,<br/></li>
<li>&nbsp; &nbsp; WALINSERT_SPECIAL_SWITCH,<br/></li>
<li>&nbsp; &nbsp; WALINSERT_SPECIAL_CHECKPOINT<br/></li>
<li><a id="L559">&#x200c;</a>} <span class="linkable">WalInsertClass</span>;<br/></li>
<li><br/></li>
<li><a id="L561">&#x200c;</a><span class="Type">static</span> <a href="#L450" title="access/transam/xlog.c:450">XLogCtlData</a> *<span class="linkable">XLogCtl</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* a private copy of <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>.<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>, for convenience */<br/></li>
<li><a id="L564">&#x200c;</a></span><span class="Type">static</span> <a href="#L381" title="access/transam/xlog.c:381">WALInsertLockPadded</a> *<span class="linkable">WALInsertLocks</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We maintain an image of pg_control in shared memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L569">&#x200c;</a></span><span class="Type">static</span> ControlFileData *<span class="linkable">ControlFile</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Calculate the amount of space left on the page after 'endptr'. Beware<br/></li>
<li></span><span class="Comment"> * multiple evaluation!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L575">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INSERT_FREESPACE</span>(endptr)&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (((endptr) % XLOG_BLCKSZ == </span><span class="Constant">0</span><span class="PreProc">) ? </span><span class="Constant">0</span><span class="PreProc"> : (XLOG_BLCKSZ - (endptr) % XLOG_BLCKSZ))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Macro to advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> buffer index. */<br/></li>
<li><a id="L579">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NextBufIdx</span>(idx)&nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; (((idx) == <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;XLogCacheBlck) ? </span><span class="Constant">0</span><span class="PreProc"> : ((idx) + </span><span class="Constant">1</span><span class="PreProc">))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L586" title="access/transam/xlog.c:586">XLogRecPtrToBufIdx</a> returns the index of the WAL buffer that holds, or<br/></li>
<li></span><span class="Comment"> * would hold if it was in cache, the page containing 'recptr'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L586">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">XLogRecPtrToBufIdx</span>(recptr)&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (((recptr) / XLOG_BLCKSZ) % (<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;XLogCacheBlck + </span><span class="Constant">1</span><span class="PreProc">))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These are the number of bytes in a WAL page usable for WAL data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L592">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">UsableBytesInPage</span> (XLOG_BLCKSZ - SizeOfXLogShortPHD)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of GUCs measured in megabytes to equiv. segment count.<br/></li>
<li></span><span class="Comment"> * Rounds down.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L598">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ConvertToXSegs</span>(x, segsize)&nbsp; &nbsp; XLogMBVarToSegs((x), (segsize))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* The number of bytes in a WAL segment usable for WAL data. */<br/></li>
<li><a id="L601">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">UsableBytesInSegment</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Private, possibly out-of-date copy of shared <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.<br/></li>
<li></span><span class="Comment"> * See discussion above.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L607">&#x200c;</a></span><span class="Type">static</span> <a href="#L325" title="access/transam/xlog.c:325">XLogwrtResult</a> <span class="linkable">LogwrtResult</span> = {<span class="Constant">0</span>, <span class="Constant">0</span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update local copy of shared <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;log{Write,Flush}Result<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's critical that Flush always trails Write, so the order of the reads is<br/></li>
<li></span><span class="Comment"> * important, as is the barrier.&nbsp; See also <a href="#L2309" title="access/transam/xlog.c:2309">XLogWrite</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L615">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RefreshXLogWriteResult</span>(_target) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> { \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; _target.Flush = pg_atomic_read_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;logFlushResult); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; pg_read_barrier(); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; _target.Write = pg_atomic_read_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;logWriteResult); \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc"> (</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L630" title="access/transam/xlog.c:630">openLogFile</a> is -1 or a kernel FD for an open log file segment.<br/></li>
<li></span><span class="Comment"> * <a href="#L631" title="access/transam/xlog.c:631">openLogSegNo</a> identifies the segment, and <a href="#L632" title="access/transam/xlog.c:632">openLogTLI</a> the corresponding TLI.<br/></li>
<li></span><span class="Comment"> * These variables are only used to write the XLOG, and so will normally refer<br/></li>
<li></span><span class="Comment"> * to the active segment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: call Reserve/<a href="../../storage/file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a> to track consumption of this FD.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L630">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">openLogFile</span> = -<span class="Constant">1</span>;<br/></li>
<li><a id="L631">&#x200c;</a><span class="Type">static</span> XLogSegNo <span class="linkable">openLogSegNo</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L632">&#x200c;</a><span class="Type">static</span> TimeLineID <span class="linkable">openLogTLI</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Local copies of equivalent fields in the control file.&nbsp; When running<br/></li>
<li></span><span class="Comment"> * crash recovery, <a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a> is set to InvalidXLogRecPtr as we<br/></li>
<li></span><span class="Comment"> * expect to replay all the WAL available, and <a href="#L643" title="access/transam/xlog.c:643">updateMinRecoveryPoint</a> is<br/></li>
<li></span><span class="Comment"> * switched to false to prevent <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> updates while replaying <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment"> * Those <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are kept consistent as long as crash recovery runs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L641">&#x200c;</a></span><span class="Type">static</span> XLogRecPtr <span class="linkable">LocalMinRecoveryPoint</span>;<br/></li>
<li><a id="L642">&#x200c;</a><span class="Type">static</span> TimeLineID <span class="linkable">LocalMinRecoveryPointTLI</span>;<br/></li>
<li><a id="L643">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">updateMinRecoveryPoint</span> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* For <a href="#L1366" title="access/transam/xlog.c:1366">WALInsertLockAcquire</a>/Release <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li><a id="L646">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">MyLockNo</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L647">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">holdingAllLocks</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WAL_DEBUG<br/></li>
<li><a id="L650">&#x200c;</a></span><span class="Type">static</span> MemoryContext <span class="linkable">walDebugCxt</span> = <span class="Constant">NULL</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5255" title="access/transam/xlog.c:5255">CleanupAfterArchiveRecovery</a>(TimeLineID EndOfLogTLI,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr EndOfLog,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID newTLI);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5344" title="access/transam/xlog.c:5344">CheckRequiredParameterValues</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L8024" title="access/transam/xlog.c:8024">XLogReportParameters</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L6378" title="access/transam/xlog.c:6378">LocalSetXLogInsertAllowed</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L7297" title="access/transam/xlog.c:7297">CreateEndOfRecoveryRecord</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> XLogRecPtr <a href="#L7361" title="access/transam/xlog.c:7361">CreateOverwriteContrecordRecord</a>(XLogRecPtr aborted_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr pagePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID newTLI);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L7431" title="access/transam/xlog.c:7431">CheckPointGuts</a>(XLogRecPtr checkPointRedo, <span class="Type">int</span> flags);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L7874" title="access/transam/xlog.c:7874">KeepLogSeg</a>(XLogRecPtr recptr, XLogSegNo *logSegNo);<br/></li>
<li><span class="Type">static</span> XLogRecPtr <a href="#L2690" title="access/transam/xlog.c:2690">XLogGetReplicationSlotMinimumLSN</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1980" title="access/transam/xlog.c:1980">AdvanceXLInsertBuffer</a>(XLogRecPtr upto, TimeLineID tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> opportunistic);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2309" title="access/transam/xlog.c:2309">XLogWrite</a>(<a href="#L319" title="access/transam/xlog.c:319">XLogwrtRqst</a> WriteRqst, TimeLineID tli, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> flexible);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3552" title="access/transam/xlog.c:3552">InstallXLogFileSegment</a>(XLogSegNo *segno, <span class="Type">char</span> *tmppath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> find_free, XLogSegNo max_segno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimeLineID tli);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3628" title="access/transam/xlog.c:3628">XLogFileClose</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3679" title="access/transam/xlog.c:3679">PreallocXlogFiles</a>(XLogRecPtr endptr, TimeLineID tli);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3821" title="access/transam/xlog.c:3821">RemoveTempXlogFiles</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3854" title="access/transam/xlog.c:3854">RemoveOldXlogFiles</a>(XLogSegNo segno, XLogRecPtr lastredoptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr endptr, TimeLineID insertTLI);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3998" title="access/transam/xlog.c:3998">RemoveXlogFile</a>(<span class="Type">const</span> <span class="Type">struct</span> dirent *segment_de,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogSegNo recycleSegNo, XLogSegNo *endlogSegNo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimeLineID insertTLI);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3801" title="access/transam/xlog.c:3801">UpdateLastRemovedPtr</a>(<span class="Type">char</span> *filename);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4088" title="access/transam/xlog.c:4088">ValidateXLOGDirectoryStructure</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4150" title="access/transam/xlog.c:4150">CleanupBackupHistory</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2711" title="access/transam/xlog.c:2711">UpdateMinRecoveryPoint</a>(XLogRecPtr lsn, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> force);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L6240" title="access/transam/xlog.c:6240">PerformRecoveryXLogAction</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4193" title="access/transam/xlog.c:4193">InitControlFile</a>(uint64 sysidentifier);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4228" title="access/transam/xlog.c:4228">WriteControlFile</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4310" title="access/transam/xlog.c:4310">ReadControlFile</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4526" title="access/transam/xlog.c:4526">UpdateControlFile</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L5165" title="access/transam/xlog.c:5165">str_time</a>(pg_time_t tnow);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L8513" title="access/transam/xlog.c:8513">get_sync_bit</a>(<span class="Type">int</span> method);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1220" title="access/transam/xlog.c:1220">CopyXLogRecordToWAL</a>(<span class="Type">int</span> write_len, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isLogSwitch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecData *rdata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr StartPos, XLogRecPtr EndPos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID tli);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1103" title="access/transam/xlog.c:1103">ReserveXLogInsertLocation</a>(<span class="Type">int</span> size, XLogRecPtr *StartPos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr *EndPos, XLogRecPtr *PrevPtr);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1159" title="access/transam/xlog.c:1159">ReserveXLogSwitch</a>(XLogRecPtr *StartPos, XLogRecPtr *EndPos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr *PrevPtr);<br/></li>
<li><span class="Type">static</span> XLogRecPtr <a href="#L1499" title="access/transam/xlog.c:1499">WaitXLogInsertionsToFinish</a>(XLogRecPtr upto);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L1627" title="access/transam/xlog.c:1627">GetXLogBuffer</a>(XLogRecPtr ptr, TimeLineID tli);<br/></li>
<li><span class="Type">static</span> XLogRecPtr <a href="#L1853" title="access/transam/xlog.c:1853">XLogBytePosToRecPtr</a>(uint64 bytepos);<br/></li>
<li><span class="Type">static</span> XLogRecPtr <a href="#L1893" title="access/transam/xlog.c:1893">XLogBytePosToEndRecPtr</a>(uint64 bytepos);<br/></li>
<li><span class="Type">static</span> uint64 <a href="#L1936" title="access/transam/xlog.c:1936">XLogRecPtrToBytePos</a>(XLogRecPtr ptr);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1366" title="access/transam/xlog.c:1366">WALInsertLockAcquire</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1411" title="access/transam/xlog.c:1411">WALInsertLockAcquireExclusive</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1440" title="access/transam/xlog.c:1440">WALInsertLockRelease</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1466" title="access/transam/xlog.c:1466">WALInsertLockUpdateInsertingAt</a>(XLogRecPtr insertingAt);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> an XLOG record represented by an already-constructed chain of data<br/></li>
<li></span><span class="Comment"> * chunks.&nbsp; This is a low-level routine; to construct the WAL record header<br/></li>
<li></span><span class="Comment"> * and data, use the higher-level routines in xloginsert.c.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If 'fpw_lsn' is valid, it is the oldest LSN among the pages that this<br/></li>
<li></span><span class="Comment"> * WAL record applies to, that were not included in the record as full page<br/></li>
<li></span><span class="Comment"> * images.&nbsp; If fpw_lsn &lt;= <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>, the function does not perform the<br/></li>
<li></span><span class="Comment"> * insertion and returns InvalidXLogRecPtr.&nbsp; The caller can then recalculate<br/></li>
<li></span><span class="Comment"> * which pages need a full-page image, and retry.&nbsp; If fpw_lsn is invalid, the<br/></li>
<li></span><span class="Comment"> * record is always inserted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'flags' gives more in-depth control on the record being inserted. See<br/></li>
<li></span><span class="Comment"> * <a href="xloginsert.c.html#L456" title="access/transam/xloginsert.c:456">XLogSetRecordFlags</a>() for details.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'topxid_included' tells whether the top-transaction id is logged along with<br/></li>
<li></span><span class="Comment"> * current subtransaction. See <a href="xloginsert.c.html#L548" title="access/transam/xloginsert.c:548">XLogRecordAssemble</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The first XLogRecData in the chain must be for the record header, and its<br/></li>
<li></span><span class="Comment"> * data must be MAXALIGNed.&nbsp; <a href="#L743" title="access/transam/xlog.c:743">XLogInsertRecord</a> fills in the xl_prev and<br/></li>
<li></span><span class="Comment"> * xl_crc fields in the header, the rest of the header must already be filled<br/></li>
<li></span><span class="Comment"> * by the caller.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns XLOG pointer to end of record (beginning of <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> record).<br/></li>
<li></span><span class="Comment"> * This can be used as LSN for data pages affected by the logged action.<br/></li>
<li></span><span class="Comment"> * (LSN is the XLOG point up to which the XLOG must be flushed to disk<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the data page can be written out.&nbsp; This implements the basic<br/></li>
<li></span><span class="Comment"> * WAL rule &quot;write the log <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the data&quot;.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L743">&#x200c;</a><span class="linkable">XLogInsertRecord</span>(XLogRecData *rdata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr fpw_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint8 flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> num_fpi,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> topxid_included)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L396" title="access/transam/xlog.c:396">XLogCtlInsert</a> *<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> = &amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>;<br/></li>
<li>&nbsp; &nbsp; pg_crc32c&nbsp; &nbsp; rdata_crc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; inserted;<br/></li>
<li>&nbsp; &nbsp; XLogRecord *rechdr = (XLogRecord *) rdata-&gt;data;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = rechdr-&gt;xl_info &amp; ~XLR_INFO_MASK;<br/></li>
<li>&nbsp; &nbsp; <a href="#L559" title="access/transam/xlog.c:559">WalInsertClass</a> class = WALINSERT_NORMAL;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; StartPos;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; EndPos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; prevDoPageWrites = <a href="#L286" title="access/transam/xlog.c:286">doPageWrites</a>;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; insertTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Does this record type require special handling? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(rechdr-&gt;xl_rmid == RM_XLOG_ID))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (info == XLOG_SWITCH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; class = WALINSERT_SPECIAL_SWITCH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_CHECKPOINT_REDO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; class = WALINSERT_SPECIAL_CHECKPOINT;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we assume that all of the record header is in the first chunk */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rdata-&gt;len &gt;= SizeOfXLogRecord);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cross-check on whether we should be here or not */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L6345" title="access/transam/xlog.c:6345">XLogInsertAllowed</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot make new WAL entries during recovery&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Given that we're not in recovery, InsertTimeLineID is set and can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * change, so we can read it without a lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; insertTLI = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InsertTimeLineID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> done all the preparatory work we can without holding a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock or modifying shared state. From here on, inserting the new WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record to the shared WAL buffer cache is a two-step process:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 1. Reserve the right amount of space from the WAL. The current head of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; reserved space is kept in <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;CurrBytePos, and is protected by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; insertpos_lck.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 2. Copy the record to the reserved WAL space. This involves finding the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; correct WAL buffer containing the reserved space, and copying the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; record in place. This can be done concurrently in multiple processes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To keep track of which insertions are still in-progress, each concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inserter acquires an insertion lock. In addition to just indicating that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an insertion is in progress, the lock tells others how far the inserter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has progressed. There is a small fixed number of insertion locks,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * determined by <a href="#L150" title="access/transam/xlog.c:150">NUM_XLOGINSERT_LOCKS</a>. When an inserter crosses a page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * boundary, it updates the value stored in the lock to the how far it has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inserted, to allow the previous buffer to be flushed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Holding onto an insertion lock also protects <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a> from changing until the insertion is finished.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Step 2 can usually be done completely in parallel. If the required WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page is not initialized yet, you have to grab WALBufMappingLock to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it, but the WAL writer tries to do that ahead of insertions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to avoid that from happening in the critical path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (likely(class == WALINSERT_NORMAL))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1366" title="access/transam/xlog.c:1366">WALInsertLockAcquire</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check to see if my copy of <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> is out of date. If so, may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to go back and have the caller recompute everything. This can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only happen just after a checkpoint, so it's better to be slow in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this case and fast otherwise.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also check to see if <a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a> was just turned on or there's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * running backup (which forces full-page writes); if we weren't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already doing full-page writes then go back and recompute.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we aren't doing full-page writes then <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actually affect the contents of the XLOG record, so we'll update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * our local copy but not force a recomputation.&nbsp; (If <a href="#L286" title="access/transam/xlog.c:286">doPageWrites</a> was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just turned off, we could recompute the record without full pages,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but we choose not to bother.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> != <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> &lt; <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> = <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L286" title="access/transam/xlog.c:286">doPageWrites</a> = (<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;<a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a> || <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;runningBackups &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L286" title="access/transam/xlog.c:286">doPageWrites</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (!prevDoPageWrites ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (fpw_lsn != InvalidXLogRecPtr &amp;&amp; fpw_lsn &lt;= <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Oops, some buffer <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> needs to be backed up that the caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * didn't back up.&nbsp; Start over.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1440" title="access/transam/xlog.c:1440">WALInsertLockRelease</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reserve space for the record in the WAL. This also sets the xl_prev<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1103" title="access/transam/xlog.c:1103">ReserveXLogInsertLocation</a>(rechdr-&gt;xl_tot_len, &amp;StartPos, &amp;EndPos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;rechdr-&gt;xl_prev);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Normal <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> are always inserted. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; inserted = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (class == WALINSERT_SPECIAL_SWITCH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In order to insert an XLOG_SWITCH record, we need to hold all of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the WAL insertion locks, not just one, so that no one else can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * begin inserting a record until we've figured out how much space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remains in the current WAL segment and claimed all of it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Nonetheless, this case is simpler than the normal cases handled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * below, which must check for changes in <a href="#L286" title="access/transam/xlog.c:286">doPageWrites</a> and <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Those checks are only needed for <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> that can contain buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * references, and an XLOG_SWITCH record never does.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(fpw_lsn == InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1411" title="access/transam/xlog.c:1411">WALInsertLockAcquireExclusive</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inserted = <a href="#L1159" title="access/transam/xlog.c:1159">ReserveXLogSwitch</a>(&amp;StartPos, &amp;EndPos, &amp;rechdr-&gt;xl_prev);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(class == WALINSERT_SPECIAL_CHECKPOINT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to update both the local and shared copies of <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which means that we need to hold all the WAL insertion locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, there can't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> buffer references, so as above, we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not check <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> inserting the record; we just need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * update it afterwards.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(fpw_lsn == InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1411" title="access/transam/xlog.c:1411">WALInsertLockAcquireExclusive</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1103" title="access/transam/xlog.c:1103">ReserveXLogInsertLocation</a>(rechdr-&gt;xl_tot_len, &amp;StartPos, &amp;EndPos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;rechdr-&gt;xl_prev);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> = <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> = StartPos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inserted = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (inserted)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now that xl_prev has been filled in, calculate CRC of the record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * header.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rdata_crc = rechdr-&gt;xl_crc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; COMP_CRC32C(rdata_crc, rechdr, offsetof(XLogRecord, xl_crc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FIN_CRC32C(rdata_crc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rechdr-&gt;xl_crc = rdata_crc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All the record data, including the header, is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> ready to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inserted. Copy the record in the space reserved.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1220" title="access/transam/xlog.c:1220">CopyXLogRecordToWAL</a>(rechdr-&gt;xl_tot_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; class == WALINSERT_SPECIAL_SWITCH, rdata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StartPos, EndPos, insertTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unless record is flagged as not important, update LSN of last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * important record in the current slot. When holding all locks, just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * update the first one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; XLOG_MARK_UNIMPORTANT) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockno = <a href="#L647" title="access/transam/xlog.c:647">holdingAllLocks</a> ? <span class="Constant">0</span> : <a href="#L646" title="access/transam/xlog.c:646">MyLockNo</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[lockno].l.lastImportantAt = StartPos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This was an xlog-switch record, but the current insert location was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already exactly at the beginning of a segment, so there was no need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to do anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Done! Let others know that we're finished.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1440" title="access/transam/xlog.c:1440">WALInsertLockRelease</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="xact.c.html#L538" title="access/transam/xact.c:538">MarkCurrentTransactionIdLoggedIfAny</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark top transaction id is logged (if needed) so that we should not try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to log it again with the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> WAL record in the current subtransaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (topxid_included)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xact.c.html#L588" title="access/transam/xact.c:588">MarkSubxactTopXidLogged</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update shared LogwrtRqst.Write, if we crossed page boundary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (StartPos / XLOG_BLCKSZ != EndPos / XLOG_BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* advance global request to include new block(s) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;LogwrtRqst.Write &lt; EndPos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;LogwrtRqst.Write = EndPos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L615" title="access/transam/xlog.c:615">RefreshXLogWriteResult</a>(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this was an XLOG_SWITCH record, flush the record and the empty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * padding space that fills the rest of the segment, and perform<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end-of-segment actions (eg, notifying archiver).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (class == WALINSERT_SPECIAL_SWITCH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_WAL_SWITCH();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(EndPos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Even though we reserved the rest of the segment for us, which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reflected in EndPos, we return a pointer to just the end of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xlog-switch record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (inserted)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EndPos = StartPos + SizeOfXLogRecord;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (StartPos / XLOG_BLCKSZ != EndPos / XLOG_BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; offset = XLogSegmentOffset(EndPos, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offset == EndPos % XLOG_BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EndPos += SizeOfXLogLongPHD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EndPos += SizeOfXLogShortPHD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WAL_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L140" title="access/transam/xlog.c:140">XLOG_DEBUG</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">static</span> XLogReaderState *debug_reader = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecord *record;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DecodedXLogRecord *decoded;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData recordBuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *errormsg = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldCxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldCxt = MemoryContextSwitchTo(<a href="#L650" title="access/transam/xlog.c:650">walDebugCxt</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;INSERT @ </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">: &quot;</span>, LSN_FORMAT_ARGS(EndPos));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to piece together the WAL record data from the XLogRecData<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entries, so that we can pass it to the rm_desc function as one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contiguous chunk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;recordBuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; rdata != <span class="Constant">NULL</span>; rdata = rdata-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(&amp;recordBuf, rdata-&gt;data, rdata-&gt;len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We also need temporary space to decode the record. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; record = (XLogRecord *) recordBuf.data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; decoded = (DecodedXLogRecord *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="xlogreader.c.html#L1629" title="access/transam/xlogreader.c:1629">DecodeXLogRecordRequiredSpace</a>(record-&gt;xl_tot_len));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!debug_reader)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; debug_reader = <a href="xlogreader.c.html#L106" title="access/transam/xlogreader.c:106">XLogReaderAllocate</a>(<a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XL_ROUTINE(.page_read = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; .segment_open = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; .segment_close = <span class="Constant">NULL</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!debug_reader)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot;error decoding record: out of memory while allocating a WAL reading processor&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="xlogreader.c.html#L1662" title="access/transam/xlogreader.c:1662">DecodeXLogRecord</a>(debug_reader,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; decoded,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; record,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EndPos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;errormsg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;error decoding record: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errormsg ? errormsg : <span class="Constant">&quot;no error message&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <span class="Constant">&quot; - &quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; debug_reader-&gt;record = decoded;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogrecovery.c.html#L2297" title="access/transam/xlogrecovery.c:2297">xlog_outdesc</a>(&amp;buf, debug_reader);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; debug_reader-&gt;record = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, buf.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(decoded);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(recordBuf.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldCxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update our global variables<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L253" title="access/transam/xlog.c:253">ProcLastRecPtr</a> = StartPos;<br/></li>
<li>&nbsp; &nbsp; <a href="#L254" title="access/transam/xlog.c:254">XactLastRecEnd</a> = EndPos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report WAL traffic to the instrumentation. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (inserted)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/instrument.c.html#L22" title="executor/instrument.c:22">pgWalUsage</a>.wal_bytes += rechdr-&gt;xl_tot_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/instrument.c.html#L22" title="executor/instrument.c:22">pgWalUsage</a>.wal_records++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/instrument.c.html#L22" title="executor/instrument.c:22">pgWalUsage</a>.wal_fpi += num_fpi;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> EndPos;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reserves the right amount of space for a record of given size from the WAL.<br/></li>
<li></span><span class="Comment"> * *StartPos is set to the beginning of the reserved section, *EndPos to<br/></li>
<li></span><span class="Comment"> * its end+1. *PrevPtr is set to the beginning of the previous record; it is<br/></li>
<li></span><span class="Comment"> * used to set the xl_prev of this record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is the performance critical part of <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a> that must be serialized<br/></li>
<li></span><span class="Comment"> * across backends. The rest can happen mostly in parallel. Try to keep this<br/></li>
<li></span><span class="Comment"> * section as short as possible, insertpos_lck can be heavily contended on a<br/></li>
<li></span><span class="Comment"> * busy system.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: The space calculation here must match the code in <a href="#L1220" title="access/transam/xlog.c:1220">CopyXLogRecordToWAL</a>,<br/></li>
<li></span><span class="Comment"> * where we actually copy the record to the reserved space.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: Testing shows that <a href="#L743" title="access/transam/xlog.c:743">XLogInsertRecord</a> runs faster if this code is inlined;<br/></li>
<li></span><span class="Comment"> * however, because there are two call sites, the compiler is reluctant to<br/></li>
<li></span><span class="Comment"> * inline. We use pg_attribute_always_inline here to try to convince it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> pg_attribute_always_inline <span class="Type">void<br/></li>
<li><a id="L1103">&#x200c;</a></span><span class="linkable">ReserveXLogInsertLocation</span>(<span class="Type">int</span> size, XLogRecPtr *StartPos, XLogRecPtr *EndPos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr *PrevPtr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L396" title="access/transam/xlog.c:396">XLogCtlInsert</a> *<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> = &amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; startbytepos;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; endbytepos;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; prevbytepos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = MAXALIGN(size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All (non xlog-switch) <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> should contain data. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(size &gt; SizeOfXLogRecord);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The duration the spinlock needs to be held is minimized by minimizing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the calculations that have to be done while holding the lock. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current tip of reserved WAL is kept in CurrBytePos, as a byte position<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that only counts &quot;usable&quot; bytes in WAL, that is, it excludes all WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page headers. The mapping between &quot;usable&quot; byte positions and physical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * positions (XLogRecPtrs) can be done outside the locked region, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because the usable byte position doesn't include <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> headers, reserving<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * X bytes from WAL is almost as simple as &quot;CurrBytePos += X&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;insertpos_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; startbytepos = <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;CurrBytePos;<br/></li>
<li>&nbsp; &nbsp; endbytepos = startbytepos + size;<br/></li>
<li>&nbsp; &nbsp; prevbytepos = <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;PrevBytePos;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;CurrBytePos = endbytepos;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;PrevBytePos = startbytepos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;insertpos_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *StartPos = <a href="#L1853" title="access/transam/xlog.c:1853">XLogBytePosToRecPtr</a>(startbytepos);<br/></li>
<li>&nbsp; &nbsp; *EndPos = <a href="#L1893" title="access/transam/xlog.c:1893">XLogBytePosToEndRecPtr</a>(endbytepos);<br/></li>
<li>&nbsp; &nbsp; *PrevPtr = <a href="#L1853" title="access/transam/xlog.c:1853">XLogBytePosToRecPtr</a>(prevbytepos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that the conversions between &quot;usable byte positions&quot; and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLogRecPtrs work consistently in both directions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L1936" title="access/transam/xlog.c:1936">XLogRecPtrToBytePos</a>(*StartPos) == startbytepos);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L1936" title="access/transam/xlog.c:1936">XLogRecPtrToBytePos</a>(*EndPos) == endbytepos);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L1936" title="access/transam/xlog.c:1936">XLogRecPtrToBytePos</a>(*PrevPtr) == prevbytepos);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Like <a href="#L1103" title="access/transam/xlog.c:1103">ReserveXLogInsertLocation</a>(), but for an xlog-switch record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A log-switch record is handled slightly differently. The rest of the<br/></li>
<li></span><span class="Comment"> * segment will be reserved for this insertion, as indicated by the returned<br/></li>
<li></span><span class="Comment"> * *EndPos value. However, if we are already at the beginning of the current<br/></li>
<li></span><span class="Comment"> * segment, *StartPos and *EndPos are set to the current location without<br/></li>
<li></span><span class="Comment"> * reserving <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> space, and the function returns false.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1159">&#x200c;</a></span><span class="linkable">ReserveXLogSwitch</span>(XLogRecPtr *StartPos, XLogRecPtr *EndPos, XLogRecPtr *PrevPtr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L396" title="access/transam/xlog.c:396">XLogCtlInsert</a> *<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> = &amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; startbytepos;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; endbytepos;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; prevbytepos;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; size = MAXALIGN(SizeOfXLogRecord);<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; ptr;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; segleft;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These calculations are a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> heavy-weight to be done while holding a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * spinlock, but since we're holding all the WAL insertion locks, there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are no other inserters competing for it. <a href="#L9355" title="access/transam/xlog.c:9355">GetXLogInsertRecPtr</a>() does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compete for it, but that's not called very frequently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;insertpos_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; startbytepos = <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;CurrBytePos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ptr = <a href="#L1893" title="access/transam/xlog.c:1893">XLogBytePosToEndRecPtr</a>(startbytepos);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (XLogSegmentOffset(ptr, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;insertpos_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *EndPos = *StartPos = ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; endbytepos = startbytepos + size;<br/></li>
<li>&nbsp; &nbsp; prevbytepos = <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;PrevBytePos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *StartPos = <a href="#L1853" title="access/transam/xlog.c:1853">XLogBytePosToRecPtr</a>(startbytepos);<br/></li>
<li>&nbsp; &nbsp; *EndPos = <a href="#L1893" title="access/transam/xlog.c:1893">XLogBytePosToEndRecPtr</a>(endbytepos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; segleft = <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a> - XLogSegmentOffset(*EndPos, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (segleft != <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* consume the rest of the segment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *EndPos += segleft;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; endbytepos = <a href="#L1936" title="access/transam/xlog.c:1936">XLogRecPtrToBytePos</a>(*EndPos);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;CurrBytePos = endbytepos;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;PrevBytePos = startbytepos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;insertpos_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *PrevPtr = <a href="#L1853" title="access/transam/xlog.c:1853">XLogBytePosToRecPtr</a>(prevbytepos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(XLogSegmentOffset(*EndPos, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L1936" title="access/transam/xlog.c:1936">XLogRecPtrToBytePos</a>(*EndPos) == endbytepos);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L1936" title="access/transam/xlog.c:1936">XLogRecPtrToBytePos</a>(*StartPos) == startbytepos);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L1936" title="access/transam/xlog.c:1936">XLogRecPtrToBytePos</a>(*PrevPtr) == prevbytepos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine of <a href="#L743" title="access/transam/xlog.c:743">XLogInsertRecord</a>.&nbsp; Copies a WAL record to an already-reserved<br/></li>
<li></span><span class="Comment"> * area in the WAL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1220">&#x200c;</a></span><span class="linkable">CopyXLogRecordToWAL</span>(<span class="Type">int</span> write_len, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isLogSwitch, XLogRecData *rdata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr StartPos, XLogRecPtr EndPos, TimeLineID tli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *currpos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freespace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; written;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; CurrPos;<br/></li>
<li>&nbsp; &nbsp; XLogPageHeader pagehdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get a pointer to the right place in the right WAL buffer to start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inserting to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; CurrPos = StartPos;<br/></li>
<li>&nbsp; &nbsp; currpos = <a href="#L1627" title="access/transam/xlog.c:1627">GetXLogBuffer</a>(CurrPos, tli);<br/></li>
<li>&nbsp; &nbsp; freespace = <a href="#L575" title="access/transam/xlog.c:575">INSERT_FREESPACE</a>(CurrPos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there should be enough space for at least the first field (xl_tot_len)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on this page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(freespace &gt;= <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy record data */<br/></li>
<li></span>&nbsp; &nbsp; written = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (rdata != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *rdata_data = rdata-&gt;data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdata_len = rdata-&gt;len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (rdata_len &gt; freespace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Write what fits on this page, and continue on the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(CurrPos % XLOG_BLCKSZ &gt;= SizeOfXLogShortPHD || freespace == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(currpos, rdata_data, freespace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdata_data += freespace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rdata_len -= freespace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; written += freespace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CurrPos += freespace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get pointer to beginning of <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page, and set the xlp_rem_len<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the page header. Set XLP_FIRST_IS_CONTRECORD.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's safe to set the contrecord flag and xlp_rem_len without a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock on the page. All the other flags were already set when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page was initialized, in <a href="#L1980" title="access/transam/xlog.c:1980">AdvanceXLInsertBuffer</a>, and we're the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only backend that needs to set the contrecord flag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currpos = <a href="#L1627" title="access/transam/xlog.c:1627">GetXLogBuffer</a>(CurrPos, tli);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pagehdr = (XLogPageHeader) currpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pagehdr-&gt;xlp_rem_len = write_len - written;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pagehdr-&gt;xlp_info |= XLP_FIRST_IS_CONTRECORD;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over the page header */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogSegmentOffset(CurrPos, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CurrPos += SizeOfXLogLongPHD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currpos += SizeOfXLogLongPHD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CurrPos += SizeOfXLogShortPHD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currpos += SizeOfXLogShortPHD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freespace = <a href="#L575" title="access/transam/xlog.c:575">INSERT_FREESPACE</a>(CurrPos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(CurrPos % XLOG_BLCKSZ &gt;= SizeOfXLogShortPHD || rdata_len == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(currpos, rdata_data, rdata_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; currpos += rdata_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CurrPos += rdata_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freespace -= rdata_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; written += rdata_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rdata = rdata-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(written == write_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this was an xlog-switch, it's not enough to write the switch record,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we also have to consume all the remaining space in the WAL segment.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have already reserved that space, but we need to actually fill it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isLogSwitch &amp;&amp; XLogSegmentOffset(CurrPos, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* An xlog-switch record doesn't contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data besides the header */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(write_len == SizeOfXLogRecord);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assert that we did reserve the right amount of space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(XLogSegmentOffset(EndPos, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use up all the remaining space on the current page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CurrPos += freespace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Cause all remaining pages in the segment to be flushed, leaving the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * XLog position where it should be, at the start of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We do this one page at a time, to make sure we don't deadlock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * against ourselves if wal_buffers &lt; <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (CurrPos &lt; EndPos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The minimal action to flush the page would be to call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1466" title="access/transam/xlog.c:1466">WALInsertLockUpdateInsertingAt</a>(CurrPos) followed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1980" title="access/transam/xlog.c:1980">AdvanceXLInsertBuffer</a>(...).&nbsp; The page would be left initialized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mostly to zeros, except for the page header (always the short<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * variant, as this is never a segment's first page).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The large vistas of zeros are good for compressibility, but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * headers interrupting them every XLOG_BLCKSZ (with <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * differ from page to page) are not.&nbsp; The effect varies with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * compression tool, but bzip2 for instance compresses about an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * order of magnitude worse if those headers are left in place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Rather than complicating <a href="#L1980" title="access/transam/xlog.c:1980">AdvanceXLInsertBuffer</a> itself (which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * called in heavily-loaded circumstances as well as this lightly-<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loaded one) with variant behavior, we just use <a href="#L1627" title="access/transam/xlog.c:1627">GetXLogBuffer</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (which itself calls the two methods we need) to get the pointer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and zero most of the page.&nbsp; Then we just zero the page header.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currpos = <a href="#L1627" title="access/transam/xlog.c:1627">GetXLogBuffer</a>(CurrPos, tli);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemSet(currpos, <span class="Constant">0</span>, SizeOfXLogShortPHD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CurrPos += XLOG_BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Align the end position, so that the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> record starts aligned */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CurrPos = MAXALIGN64(CurrPos);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (CurrPos != EndPos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;space reserved for WAL record does not match what was written&quot;</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Acquire a WAL insertion lock, for inserting to WAL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1366">&#x200c;</a></span><span class="linkable">WALInsertLockAcquire</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; immed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It doesn't matter which of the WAL insertion locks we acquire, so try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the one we used last time.&nbsp; If the system isn't particularly busy, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a good bet that it's still available, and it's good to have some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * affinity to a particular lock so that you don't unnecessarily bounce<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cache lines between processes when there's no contention.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is the first time through in this backend, pick a lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (semi-)randomly.&nbsp; This allows the locks to be used evenly if you have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lot of very short connections.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; lockToTry = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lockToTry == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lockToTry = <a href="../../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a> % <a href="#L150" title="access/transam/xlog.c:150">NUM_XLOGINSERT_LOCKS</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L646" title="access/transam/xlog.c:646">MyLockNo</a> = lockToTry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The insertingAt value is initially set to 0, as we don't know our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * insert location yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; immed = <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[<a href="#L646" title="access/transam/xlog.c:646">MyLockNo</a>].l.lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!immed)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we couldn't get the lock immediately, try another lock <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time.&nbsp; On a system with more insertion locks than concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inserters, this causes all the inserters to eventually migrate to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock that no-one else is using.&nbsp; On a system with more inserters<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than locks, it still helps to distribute the inserters evenly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * across the locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lockToTry = (lockToTry + <span class="Constant">1</span>) % <a href="#L150" title="access/transam/xlog.c:150">NUM_XLOGINSERT_LOCKS</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Acquire all WAL insertion locks, to prevent other backends from inserting<br/></li>
<li></span><span class="Comment"> * to WAL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1411">&#x200c;</a></span><span class="linkable">WALInsertLockAcquireExclusive</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When holding all the locks, all but the last lock's insertingAt<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indicator is set to 0xFFFFFFFFFFFFFFFF, which is higher than <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> real<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLogRecPtr value, to make sure that no-one blocks <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> on those.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L150" title="access/transam/xlog.c:150">NUM_XLOGINSERT_LOCKS</a> - <span class="Constant">1</span>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[i].l.lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1722" title="storage/lmgr/lwlock.c:1722">LWLockUpdateVar</a>(&amp;<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[i].l.lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[i].l.insertingAt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_UINT64_MAX);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Variable value reset to 0 at release */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[i].l.lock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L647" title="access/transam/xlog.c:647">holdingAllLocks</a> = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release our insertion lock (or locks, if we're holding them all).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: Reset all variables to 0, so they cause <a href="../../storage/lmgr/lwlock.c.html#L1586" title="storage/lmgr/lwlock.c:1586">LWLockWaitForVar</a> to block the<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time the lock is acquired.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1440">&#x200c;</a></span><span class="linkable">WALInsertLockRelease</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L647" title="access/transam/xlog.c:647">holdingAllLocks</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L150" title="access/transam/xlog.c:150">NUM_XLOGINSERT_LOCKS</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1856" title="storage/lmgr/lwlock.c:1856">LWLockReleaseClearVar</a>(&amp;<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[i].l.lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[i].l.insertingAt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L647" title="access/transam/xlog.c:647">holdingAllLocks</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1856" title="storage/lmgr/lwlock.c:1856">LWLockReleaseClearVar</a>(&amp;<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[<a href="#L646" title="access/transam/xlog.c:646">MyLockNo</a>].l.lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[<a href="#L646" title="access/transam/xlog.c:646">MyLockNo</a>].l.insertingAt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update our insertingAt value, to let others know that we've finished<br/></li>
<li></span><span class="Comment"> * inserting up to that point.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1466">&#x200c;</a></span><span class="linkable">WALInsertLockUpdateInsertingAt</span>(XLogRecPtr insertingAt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L647" title="access/transam/xlog.c:647">holdingAllLocks</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We use the last lock to mark our actual position, see comments in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1411" title="access/transam/xlog.c:1411">WALInsertLockAcquireExclusive</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1722" title="storage/lmgr/lwlock.c:1722">LWLockUpdateVar</a>(&amp;<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[<a href="#L150" title="access/transam/xlog.c:150">NUM_XLOGINSERT_LOCKS</a> - <span class="Constant">1</span>].l.lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[<a href="#L150" title="access/transam/xlog.c:150">NUM_XLOGINSERT_LOCKS</a> - <span class="Constant">1</span>].l.insertingAt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertingAt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1722" title="storage/lmgr/lwlock.c:1722">LWLockUpdateVar</a>(&amp;<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[<a href="#L646" title="access/transam/xlog.c:646">MyLockNo</a>].l.lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[<a href="#L646" title="access/transam/xlog.c:646">MyLockNo</a>].l.insertingAt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertingAt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WAL insertions &lt; upto to finish.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the location of the oldest insertion that is still in-progress.<br/></li>
<li></span><span class="Comment"> * Any WAL prior to that point has been fully copied into WAL buffers, and<br/></li>
<li></span><span class="Comment"> * can be flushed out to disk. Because this waits for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> insertions older<br/></li>
<li></span><span class="Comment"> * than 'upto' to finish, the return value is always &gt;= 'upto'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: When you are about to write out WAL, you must call this function<br/></li>
<li></span><span class="Comment"> * *<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>* acquiring WALWriteLock, to avoid deadlocks. This function might<br/></li>
<li></span><span class="Comment"> * need to wait for an insertion to finish (or at least advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment"> * uninitialized page), and the inserter might need to evict an old WAL buffer<br/></li>
<li></span><span class="Comment"> * to make room for a new one, which in turn requires WALWriteLock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> XLogRecPtr<br/></li>
<li><a id="L1499">&#x200c;</a><span class="linkable">WaitXLogInsertionsToFinish</span>(XLogRecPtr upto)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; bytepos;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; inserted;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; reservedUpto;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; finishedUpto;<br/></li>
<li>&nbsp; &nbsp; <a href="#L396" title="access/transam/xlog.c:396">XLogCtlInsert</a> *<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> = &amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;cannot wait without a PGPROC structure&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if there's <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> work to do.&nbsp; Use a barrier to ensure we get the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * freshest value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; inserted = pg_atomic_read_membarrier_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;logInsertResult);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (upto &lt;= inserted)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> inserted;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Read the current insert position */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;insertpos_lck);<br/></li>
<li>&nbsp; &nbsp; bytepos = <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;CurrBytePos;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;insertpos_lck);<br/></li>
<li>&nbsp; &nbsp; reservedUpto = <a href="#L1893" title="access/transam/xlog.c:1893">XLogBytePosToEndRecPtr</a>(bytepos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No-one should request to flush a piece of WAL that hasn't even been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reserved yet. However, it can happen if there is a block with a bogus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LSN on disk, for example. <a href="#L2791" title="access/transam/xlog.c:2791">XLogFlush</a> checks for that situation and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * complains, but only after the flush. Here we just assume that to mean<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that all WAL that has been reserved needs to be finished. In this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corner-case, the return value can be smaller than 'upto' argument.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (upto &gt; reservedUpto)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;request to flush past end of generated WAL; request </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, current position </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(upto), LSN_FORMAT_ARGS(reservedUpto))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; upto = reservedUpto;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop through all the locks, sleeping on <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> in-progress insert older<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than 'upto'.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * finishedUpto is our return value, indicating the point upto which all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the WAL insertions have been finished. Initialize it to the head of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reserved WAL, and as we iterate through the insertion locks, back it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> insertion that's still in progress.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; finishedUpto = reservedUpto;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L150" title="access/transam/xlog.c:150">NUM_XLOGINSERT_LOCKS</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; insertingat = InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See if this insertion is in progress.&nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1586" title="storage/lmgr/lwlock.c:1586">LWLockWaitForVar</a> will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wait for the lock to be released, or for the 'value' to be set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by a <a href="../../storage/lmgr/lwlock.c.html#L1722" title="storage/lmgr/lwlock.c:1722">LWLockUpdateVar</a> call.&nbsp; When a lock is initially acquired,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its value is 0 (InvalidXLogRecPtr), which means that we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * know where it's inserting yet.&nbsp; We will have to wait for it. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's a small insertion, the record will most likely fit on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same page and the inserter will release the lock without ever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * calling <a href="../../storage/lmgr/lwlock.c.html#L1722" title="storage/lmgr/lwlock.c:1722">LWLockUpdateVar</a>.&nbsp; But if it has to sleep, it will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * advertise the insertion point with <a href="../../storage/lmgr/lwlock.c.html#L1722" title="storage/lmgr/lwlock.c:1722">LWLockUpdateVar</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sleeping.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In this loop we are only <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for insertions that started<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="#L1499" title="access/transam/xlog.c:1499">WaitXLogInsertionsToFinish</a> was called.&nbsp; The lack of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memory barriers in the loop means that we might see locks as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;unused&quot; that have since become used.&nbsp; This is fine because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they only can be used for later insertions that we would not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * want to wait on anyway.&nbsp; Not taking a lock to acquire the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current insertingAt value means that we might see older<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * insertingAt <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; This is also fine, because if we read a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value too old, we will add ourselves to the wait queue, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contains atomic operations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/lmgr/lwlock.c.html#L1586" title="storage/lmgr/lwlock.c:1586">LWLockWaitForVar</a>(&amp;<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[i].l.lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[i].l.insertingAt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; insertingat, &amp;insertingat))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the lock was free, so no insertion in progress */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertingat = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This insertion is still in progress. Have to wait, unless the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inserter has proceeded past 'upto'.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (insertingat &lt; upto);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (insertingat != InvalidXLogRecPtr &amp;&amp; insertingat &lt; finishedUpto)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finishedUpto = insertingat;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advance the limit we know to have been inserted and return the freshest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value we know of, which might be beyond what we requested if somebody<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is concurrently doing this with an 'upto' pointer ahead of us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; finishedUpto = pg_atomic_monotonic_advance_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;logInsertResult,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; finishedUpto);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> finishedUpto;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get a pointer to the right location in the WAL buffer containing the<br/></li>
<li></span><span class="Comment"> * given XLogRecPtr.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the page is not initialized yet, it is initialized. That might require<br/></li>
<li></span><span class="Comment"> * evicting an old dirty buffer from the buffer cache, which means I/O.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must ensure that the page containing the requested location<br/></li>
<li></span><span class="Comment"> * isn't evicted yet, and won't be evicted. The way to ensure that is to<br/></li>
<li></span><span class="Comment"> * hold onto a WAL insertion lock with the insertingAt position set to<br/></li>
<li></span><span class="Comment"> * something &lt;= ptr. <a href="#L1627" title="access/transam/xlog.c:1627">GetXLogBuffer</a>() will update insertingAt if it needs<br/></li>
<li></span><span class="Comment"> * to evict an old page from the buffer. (This means that once you call<br/></li>
<li></span><span class="Comment"> * <a href="#L1627" title="access/transam/xlog.c:1627">GetXLogBuffer</a>() with a given 'ptr', you must not access anything <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * that point anymore, and must not call <a href="#L1627" title="access/transam/xlog.c:1627">GetXLogBuffer</a>() with an older 'ptr'<br/></li>
<li></span><span class="Comment"> * later, because older buffers might be recycled already)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1627">&#x200c;</a><span class="linkable">GetXLogBuffer</span>(XLogRecPtr ptr, TimeLineID tli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; endptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> uint64 cachedPage = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> *cachedPos = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; expectedEndPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fast path for the common case that we need to access again the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page as last time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ptr / XLOG_BLCKSZ == cachedPage)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(((XLogPageHeader) cachedPos)-&gt;xlp_magic == XLOG_PAGE_MAGIC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(((XLogPageHeader) cachedPos)-&gt;xlp_pageaddr == ptr - (ptr % XLOG_BLCKSZ));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> cachedPos + ptr % XLOG_BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The XLog buffer cache is organized so that a page is always loaded to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * particular buffer.&nbsp; That way we can easily calculate the buffer a given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page must be loaded into, from the XLogRecPtr alone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; idx = <a href="#L586" title="access/transam/xlog.c:586">XLogRecPtrToBufIdx</a>(ptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See what page is loaded in the buffer at the moment. It could be the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page we're looking for, or something older. It can't be anything newer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - that would imply the page we're looking for has already been written<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out to disk and evicted, and the caller is responsible for making sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that doesn't happen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't hold a lock while we read the value. If someone is just about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> or has just initialized the page, it's possible that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get InvalidXLogRecPtr. That's ok, we'll grab the mapping lock (in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1980" title="access/transam/xlog.c:1980">AdvanceXLInsertBuffer</a>) and retry if we see anything other than the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're looking for.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; expectedEndPtr = ptr;<br/></li>
<li>&nbsp; &nbsp; expectedEndPtr += XLOG_BLCKSZ - ptr % XLOG_BLCKSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; endptr = pg_atomic_read_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;xlblocks[idx]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (expectedEndPtr != endptr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; initializedUpto;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before calling <a href="#L1980" title="access/transam/xlog.c:1980">AdvanceXLInsertBuffer</a>(), which can block, let others<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * know how far we're finished with inserting the record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB: If 'ptr' points to just after the page header, advertise a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * position at the beginning of the page rather than 'ptr' itself. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there are no other insertions running, someone might try to flush<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up to our advertised location. If we advertised a position after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the page header, someone might try to flush the page header, even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * though page might actually not be initialized yet. As the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inserter on the page, we are effectively responsible for making<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sure that it's initialized, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we let insertingAt to move past<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the page header.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptr % XLOG_BLCKSZ == SizeOfXLogShortPHD &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogSegmentOffset(ptr, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>) &gt; XLOG_BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initializedUpto = ptr - SizeOfXLogShortPHD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ptr % XLOG_BLCKSZ == SizeOfXLogLongPHD &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogSegmentOffset(ptr, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>) &lt; XLOG_BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initializedUpto = ptr - SizeOfXLogLongPHD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initializedUpto = ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1466" title="access/transam/xlog.c:1466">WALInsertLockUpdateInsertingAt</a>(initializedUpto);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1980" title="access/transam/xlog.c:1980">AdvanceXLInsertBuffer</a>(ptr, tli, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; endptr = pg_atomic_read_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;xlblocks[idx]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expectedEndPtr != endptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> WAL buffer for </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(ptr));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure the initialization of the page is visible to us, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * won't arrive later to overwrite the WAL data we write on the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_memory_barrier();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Found the buffer holding this page. Return a pointer to the right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * offset within the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cachedPage = ptr / XLOG_BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; cachedPos = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;pages + idx * (Size) XLOG_BLCKSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(((XLogPageHeader) cachedPos)-&gt;xlp_magic == XLOG_PAGE_MAGIC);<br/></li>
<li>&nbsp; &nbsp; Assert(((XLogPageHeader) cachedPos)-&gt;xlp_pageaddr == ptr - (ptr % XLOG_BLCKSZ));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cachedPos + ptr % XLOG_BLCKSZ;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read WAL data directly from WAL buffers, if available. Returns the number<br/></li>
<li></span><span class="Comment"> * of bytes read successfully.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Fewer than 'count' bytes may be read if some of the requested WAL data has<br/></li>
<li></span><span class="Comment"> * already been evicted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * No locks are taken.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller should ensure that it reads no further than <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write<br/></li>
<li></span><span class="Comment"> * (which should have been updated by the caller when determining how far to<br/></li>
<li></span><span class="Comment"> * read). The 'tli' argument is only used as a convenient safety check so that<br/></li>
<li></span><span class="Comment"> * callers do not read from WAL buffers on a historical timeline.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L1743">&#x200c;</a><span class="linkable">WALReadFromBuffers</span>(<span class="Type">char</span> *dstbuf, XLogRecPtr startptr, Size count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimeLineID tli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pdst = dstbuf;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr = startptr;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; inserted;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nbytes = count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>() || tli != <a href="#L6476" title="access/transam/xlog.c:6476">GetWALInsertionTimeLine</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!XLogRecPtrIsInvalid(startptr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Caller should ensure that the requested data has been inserted into WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffers <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we try to read it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; inserted = pg_atomic_read_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;logInsertResult);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (startptr + count &gt; inserted)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot read past end of generated WAL: requested </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, current position </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(startptr + count),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(inserted)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop through the buffers without a lock. For each buffer, atomically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read and verify the end pointer, then copy the data out, and finally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-read and re-verify the end pointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Once a page is evicted, it never returns to the WAL buffers, so if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end pointer matches the expected end pointer <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> and after we copy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the data, then the right page must have been present during the data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copy. Read barriers are necessary to ensure that the data copy actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happens between the two verification steps.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If either verification fails, we simply terminate the loop and return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with the data that had been already copied out successfully.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (nbytes &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; offset = recptr % XLOG_BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = <a href="#L586" title="access/transam/xlog.c:586">XLogRecPtrToBufIdx</a>(recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; expectedEndPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; endptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *psrc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; npagebytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Calculate the end pointer we expect in the xlblocks array if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * correct page is present.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; expectedEndPtr = recptr + (XLOG_BLCKSZ - offset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First verification step: check that the correct page is present in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the WAL buffers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; endptr = pg_atomic_read_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;xlblocks[idx]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expectedEndPtr != endptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The correct page is present (or was at the time the endptr was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * read; must re-verify later). Calculate pointer to source data and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * determine how much data to read from this page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; page = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;pages + idx * (Size) XLOG_BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; psrc = page + offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; npagebytes = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(nbytes, XLOG_BLCKSZ - offset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ensure that the data copy and the first verification step are not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reordered.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_read_barrier();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* data copy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(pdst, psrc, npagebytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ensure that the data copy and the second verification step are not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reordered.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_read_barrier();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Second verification step: check that the page we read from wasn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * evicted while we were copying the data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; endptr = pg_atomic_read_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;xlblocks[idx]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (expectedEndPtr != endptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pdst += npagebytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr += npagebytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbytes -= npagebytes;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(pdst - dstbuf &lt;= count);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pdst - dstbuf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Converts a &quot;usable byte position&quot; to XLogRecPtr. A usable byte position<br/></li>
<li></span><span class="Comment"> * is the position starting from the beginning of WAL, excluding all WAL<br/></li>
<li></span><span class="Comment"> * page headers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> XLogRecPtr<br/></li>
<li><a id="L1853">&#x200c;</a><span class="linkable">XLogBytePosToRecPtr</span>(uint64 bytepos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; fullsegs;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; fullpages;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; bytesleft;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; seg_offset;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fullsegs = bytepos / <a href="#L601" title="access/transam/xlog.c:601">UsableBytesInSegment</a>;<br/></li>
<li>&nbsp; &nbsp; bytesleft = bytepos % <a href="#L601" title="access/transam/xlog.c:601">UsableBytesInSegment</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bytesleft &lt; XLOG_BLCKSZ - SizeOfXLogLongPHD)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fits on first page of segment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; seg_offset = bytesleft + SizeOfXLogLongPHD;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* account for the first page on segment with long header */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; seg_offset = XLOG_BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bytesleft -= XLOG_BLCKSZ - SizeOfXLogLongPHD;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fullpages = bytesleft / <a href="#L592" title="access/transam/xlog.c:592">UsableBytesInPage</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bytesleft = bytesleft % <a href="#L592" title="access/transam/xlog.c:592">UsableBytesInPage</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seg_offset += fullpages * XLOG_BLCKSZ + bytesleft + SizeOfXLogShortPHD;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLogSegNoOffsetToRecPtr(fullsegs, seg_offset, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Like <a href="#L1853" title="access/transam/xlog.c:1853">XLogBytePosToRecPtr</a>, but if the position is at a page boundary,<br/></li>
<li></span><span class="Comment"> * returns a pointer to the beginning of the page (ie. <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> page header),<br/></li>
<li></span><span class="Comment"> * not to where the first xlog record on that page would go to. This is used<br/></li>
<li></span><span class="Comment"> * when converting a pointer to the end of a record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> XLogRecPtr<br/></li>
<li><a id="L1893">&#x200c;</a><span class="linkable">XLogBytePosToEndRecPtr</span>(uint64 bytepos)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; fullsegs;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; fullpages;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; bytesleft;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; seg_offset;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fullsegs = bytepos / <a href="#L601" title="access/transam/xlog.c:601">UsableBytesInSegment</a>;<br/></li>
<li>&nbsp; &nbsp; bytesleft = bytepos % <a href="#L601" title="access/transam/xlog.c:601">UsableBytesInSegment</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bytesleft &lt; XLOG_BLCKSZ - SizeOfXLogLongPHD)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fits on first page of segment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bytesleft == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seg_offset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seg_offset = bytesleft + SizeOfXLogLongPHD;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* account for the first page on segment with long header */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; seg_offset = XLOG_BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bytesleft -= XLOG_BLCKSZ - SizeOfXLogLongPHD;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fullpages = bytesleft / <a href="#L592" title="access/transam/xlog.c:592">UsableBytesInPage</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bytesleft = bytesleft % <a href="#L592" title="access/transam/xlog.c:592">UsableBytesInPage</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bytesleft == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seg_offset += fullpages * XLOG_BLCKSZ + bytesleft;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seg_offset += fullpages * XLOG_BLCKSZ + bytesleft + SizeOfXLogShortPHD;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLogSegNoOffsetToRecPtr(fullsegs, seg_offset, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convert an XLogRecPtr to a &quot;usable byte position&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint64<br/></li>
<li><a id="L1936">&#x200c;</a><span class="linkable">XLogRecPtrToBytePos</span>(XLogRecPtr ptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; fullsegs;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; fullpages;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLByteToSeg(ptr, fullsegs, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fullpages = (XLogSegmentOffset(ptr, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>)) / XLOG_BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; offset = ptr % XLOG_BLCKSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fullpages == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = fullsegs * <a href="#L601" title="access/transam/xlog.c:601">UsableBytesInSegment</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offset &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(offset &gt;= SizeOfXLogLongPHD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result += offset - SizeOfXLogLongPHD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = fullsegs * <a href="#L601" title="access/transam/xlog.c:601">UsableBytesInSegment</a> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (XLOG_BLCKSZ - SizeOfXLogLongPHD) + <span class="Comment">/* account for first page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fullpages - <span class="Constant">1</span>) * <a href="#L592" title="access/transam/xlog.c:592">UsableBytesInPage</a>;&nbsp; &nbsp; <span class="Comment">/* full pages */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offset &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(offset &gt;= SizeOfXLogShortPHD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result += offset - SizeOfXLogShortPHD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize XLOG buffers, writing out old buffers if they still contain<br/></li>
<li></span><span class="Comment"> * unwritten data, upto the page containing 'upto'. Or if 'opportunistic' is<br/></li>
<li></span><span class="Comment"> * true, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> as many pages as we can without having to write out<br/></li>
<li></span><span class="Comment"> * unwritten data. Any new pages are initialized to zeros, with pages headers<br/></li>
<li></span><span class="Comment"> * initialized properly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1980">&#x200c;</a></span><span class="linkable">AdvanceXLInsertBuffer</span>(XLogRecPtr upto, TimeLineID tli, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> opportunistic)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L396" title="access/transam/xlog.c:396">XLogCtlInsert</a> *<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> = &amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextidx;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; OldPageRqstPtr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L319" title="access/transam/xlog.c:319">XLogwrtRqst</a> WriteRqst;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; NewPageEndPtr = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; NewPageBeginPtr;<br/></li>
<li>&nbsp; &nbsp; XLogPageHeader NewPage;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npages pg_attribute_unused() = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(WALBufMappingLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we have the lock, check if someone initialized the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (upto &gt;= <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InitializedUpTo || opportunistic)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nextidx = <a href="#L586" title="access/transam/xlog.c:586">XLogRecPtrToBufIdx</a>(<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InitializedUpTo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get ending-offset of the buffer page we need to replace (this may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be zero if the buffer hasn't been used yet).&nbsp; Fall through if it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already written out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; OldPageRqstPtr = pg_atomic_read_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;xlblocks[nextidx]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write &lt; OldPageRqstPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Nope, got work to do. If we just want to pre-<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> as much<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as we can without flushing, give up <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opportunistic)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance shared memory write request position */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;LogwrtRqst.Write &lt; OldPageRqstPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;LogwrtRqst.Write = OldPageRqstPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Acquire an up-to-date <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a> value and see if we still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to write it or if someone else already did.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L615" title="access/transam/xlog.c:615">RefreshXLogWriteResult</a>(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write &lt; OldPageRqstPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Must acquire write lock. Release WALBufMappingLock first,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to make sure that all insertions that we need to wait for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can finish (up to this same position). Otherwise we risk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deadlock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WALBufMappingLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1499" title="access/transam/xlog.c:1499">WaitXLogInsertionsToFinish</a>(OldPageRqstPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(WALWriteLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L615" title="access/transam/xlog.c:615">RefreshXLogWriteResult</a>(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write &gt;= OldPageRqstPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, someone wrote it already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WALWriteLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Have to write it ourselves */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_WAL_BUFFER_WRITE_DIRTY_START();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WriteRqst.Write = OldPageRqstPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WriteRqst.Flush = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2309" title="access/transam/xlog.c:2309">XLogWrite</a>(WriteRqst, tli, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WALWriteLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_wal.c.html#L24" title="utils/activity/pgstat_wal.c:24">PendingWalStats</a>.wal_buffers_full++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_WAL_BUFFER_WRITE_DIRTY_DONE();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Re-acquire WALBufMappingLock and retry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(WALBufMappingLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> buffer slot is free and we can set it up to be the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> output page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; NewPageBeginPtr = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InitializedUpTo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; NewPageEndPtr = NewPageBeginPtr + XLOG_BLCKSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L586" title="access/transam/xlog.c:586">XLogRecPtrToBufIdx</a>(NewPageBeginPtr) == nextidx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; NewPage = (XLogPageHeader) (<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;pages + nextidx * (Size) XLOG_BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mark the xlblock with InvalidXLogRecPtr and issue a write barrier<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> initializing. Otherwise, the old page may be partially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * zeroed but look valid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;xlblocks[nextidx], InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_write_barrier();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Be sure to re-zero the buffer so that bytes beyond what we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * written will look like zeroes and not valid XLOG <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemSet((<span class="Type">char</span> *) NewPage, <span class="Constant">0</span>, XLOG_BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fill the new page's header<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; NewPage-&gt;xlp_magic = XLOG_PAGE_MAGIC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NewPage-&gt;xlp_info = 0; */</span>&nbsp; &nbsp; <span class="Comment">/* done by memset */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; NewPage-&gt;xlp_tli = tli;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; NewPage-&gt;xlp_pageaddr = NewPageBeginPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NewPage-&gt;xlp_rem_len = 0; */</span>&nbsp; &nbsp; <span class="Comment">/* done by memset */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If online backup is not in progress, mark the header to indicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> beginning in this page have removable backup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * blocks.&nbsp; This allows the WAL archiver to know whether it is safe to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * compress archived WAL data by transforming full-block <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the non-full-block format.&nbsp; It is sufficient to record this at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page level because we force a page switch (in fact a segment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * switch) when starting a backup, so the flag will be off <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> can be written during the backup.&nbsp; At the end of a backup,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the last page will be marked as all unsafe when perhaps only part<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is unsafe, but at worst the archiver would <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> the opportunity to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * compress a few <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;runningBackups == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NewPage-&gt;xlp_info |= XLP_BKP_REMOVABLE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If first page of an XLOG segment file, make it a long header.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((XLogSegmentOffset(NewPage-&gt;xlp_pageaddr, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogLongPageHeader NewLongPage = (XLogLongPageHeader) NewPage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NewLongPage-&gt;xlp_sysid = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;system_identifier;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NewLongPage-&gt;xlp_seg_size = <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NewLongPage-&gt;xlp_xlog_blcksz = XLOG_BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NewPage-&gt;xlp_info |= XLP_LONG_HEADER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure the initialization of the page becomes visible to others<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the xlblocks update. <a href="#L1627" title="access/transam/xlog.c:1627">GetXLogBuffer</a>() reads xlblocks without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * holding a lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_write_barrier();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;xlblocks[nextidx], NewPageEndPtr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InitializedUpTo = NewPageEndPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; npages++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WALBufMappingLock);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WAL_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L140" title="access/transam/xlog.c:140">XLOG_DEBUG</a> &amp;&amp; npages &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;initialized </span><span class="Special">%d</span><span class="Constant"> pages, up to </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; npages, LSN_FORMAT_ARGS(NewPageEndPtr));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Calculate <a href="#L156" title="access/transam/xlog.c:156">CheckPointSegments</a> based on <a href="#L114" title="access/transam/xlog.c:114">max_wal_size_mb</a> and<br/></li>
<li></span><span class="Comment"> * checkpoint_completion_target.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2157">&#x200c;</a></span><span class="linkable">CalculateCheckpointSegments</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; target;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*-------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate the distance at which to <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> a checkpoint, to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exceeding <a href="#L114" title="access/transam/xlog.c:114">max_wal_size_mb</a>. This is based on two assumptions:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a) we keep WAL for only one checkpoint cycle (prior to PG11 we kept<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; WAL for two checkpoint cycles to allow us to recover from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; secondary checkpoint if the first checkpoint failed, though we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; only did this on the primary anyway, not on standby. Keeping just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; one checkpoint simplifies processing and reduces disk space in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; many smaller databases.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * b) during checkpoint, we consume checkpoint_completion_target *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; number of segments consumed between checkpoints.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *-------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; target = (<span class="Type">double</span>) <a href="#L598" title="access/transam/xlog.c:598">ConvertToXSegs</a>(<a href="#L114" title="access/transam/xlog.c:114">max_wal_size_mb</a>, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>) /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Constant">1.0</span> + <a href="../../postmaster/checkpointer.c.html#L138" title="postmaster/checkpointer.c:138">CheckPointCompletionTarget</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* round down */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L156" title="access/transam/xlog.c:156">CheckPointSegments</a> = (<span class="Type">int</span>) target;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L156" title="access/transam/xlog.c:156">CheckPointSegments</a> &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L156" title="access/transam/xlog.c:156">CheckPointSegments</a> = <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L2186">&#x200c;</a></span><span class="linkable">assign_max_wal_size</span>(<span class="Type">int</span> <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L114" title="access/transam/xlog.c:114">max_wal_size_mb</a> = <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L2157" title="access/transam/xlog.c:2157">CalculateCheckpointSegments</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L2193">&#x200c;</a></span><span class="linkable">assign_checkpoint_completion_target</span>(<span class="Type">double</span> <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../postmaster/checkpointer.c.html#L138" title="postmaster/checkpointer.c:138">CheckPointCompletionTarget</a> = <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L2157" title="access/transam/xlog.c:2157">CalculateCheckpointSegments</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2200">&#x200c;</a></span><span class="linkable">check_wal_segment_size</span>(<span class="Type">int</span> *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!IsValidWalSegSize(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;The WAL segment size must be a power of two between 1 MB and 1 GB.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for max_slot_wal_keep_size<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't allow the value of max_slot_wal_keep_size other than -1 during the<br/></li>
<li></span><span class="Comment"> * binary upgrade. See start_postmaster() in pg_upgrade for more details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2218">&#x200c;</a></span><span class="linkable">check_max_slot_wal_keep_size</span>(<span class="Type">int</span> *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L118" title="utils/init/globals.c:118">IsBinaryUpgrade</a> &amp;&amp; *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be set to -1 during binary upgrade mode.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;max_slot_wal_keep_size&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * At a checkpoint, how many WAL segments to recycle as preallocated future<br/></li>
<li></span><span class="Comment"> * XLOG segments? Returns the highest segment that should be preallocated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> XLogSegNo<br/></li>
<li><a id="L2235">&#x200c;</a><span class="linkable">XLOGfileslop</span>(XLogRecPtr lastredoptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; minSegNo;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; maxSegNo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; distance;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; recycleSegNo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate the segment numbers that <a href="#L115" title="access/transam/xlog.c:115">min_wal_size_mb</a> and <a href="#L114" title="access/transam/xlog.c:114">max_wal_size_mb</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * correspond to. Always recycle enough segments to meet the minimum, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remove enough segments to stay below the maximum.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; minSegNo = lastredoptr / <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L598" title="access/transam/xlog.c:598">ConvertToXSegs</a>(<a href="#L115" title="access/transam/xlog.c:115">min_wal_size_mb</a>, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>) - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; maxSegNo = lastredoptr / <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L598" title="access/transam/xlog.c:598">ConvertToXSegs</a>(<a href="#L114" title="access/transam/xlog.c:114">max_wal_size_mb</a>, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>) - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Between those limits, recycle enough segments to get us through to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimated end of <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To estimate where the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint will finish, assume that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * system runs steadily consuming <a href="#L159" title="access/transam/xlog.c:159">CheckPointDistanceEstimate</a> bytes between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * every checkpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; distance = (<span class="Constant">1.0</span> + <a href="../../postmaster/checkpointer.c.html#L138" title="postmaster/checkpointer.c:138">CheckPointCompletionTarget</a>) * <a href="#L159" title="access/transam/xlog.c:159">CheckPointDistanceEstimate</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add 10% for good measure. */<br/></li>
<li></span>&nbsp; &nbsp; distance *= <span class="Constant">1.10</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; recycleSegNo = (XLogSegNo) ceil(((<span class="Type">double</span>) lastredoptr + distance) /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (recycleSegNo &lt; minSegNo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recycleSegNo = minSegNo;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (recycleSegNo &gt; maxSegNo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recycleSegNo = maxSegNo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> recycleSegNo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether we've consumed enough xlog space that a checkpoint is needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * new_segno indicates a log file that has just been filled up (or read<br/></li>
<li></span><span class="Comment"> * during recovery). We measure the distance from <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> to new_segno<br/></li>
<li></span><span class="Comment"> * and see if that exceeds <a href="#L156" title="access/transam/xlog.c:156">CheckPointSegments</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: it is caller's responsibility that <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> is up-to-date.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2285">&#x200c;</a></span><span class="linkable">XLogCheckpointNeeded</span>(XLogSegNo new_segno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; old_segno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLByteToSeg(<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>, old_segno, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (new_segno &gt;= old_segno + (uint64) (<a href="#L156" title="access/transam/xlog.c:156">CheckPointSegments</a> - <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write and/or fsync the log at least as far as WriteRqst indicates.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If flexible == true, we don't have to write as far as WriteRqst, but<br/></li>
<li></span><span class="Comment"> * may stop at <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> convenient boundary (such as a cache or logfile boundary).<br/></li>
<li></span><span class="Comment"> * This option allows us to avoid uselessly issuing multiple writes when a<br/></li>
<li></span><span class="Comment"> * single one would do.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Must be called with WALWriteLock held. <a href="#L1499" title="access/transam/xlog.c:1499">WaitXLogInsertionsToFinish</a>(WriteRqst)<br/></li>
<li></span><span class="Comment"> * must be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> grabbing the lock, to make sure the data is ready to<br/></li>
<li></span><span class="Comment"> * write.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2309">&#x200c;</a></span><span class="linkable">XLogWrite</span>(<a href="#L319" title="access/transam/xlog.c:319">XLogwrtRqst</a> WriteRqst, TimeLineID tli, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> flexible)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ispartialpage;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; last_iteration;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; finishing_seg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curridx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npages;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startidx;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; startoffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We should always be inside a critical section here */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../utils/init/globals.c.html#L43" title="utils/init/globals.c:43">CritSectionCount</a> &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update local <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a> (caller probably did this already, but...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L615" title="access/transam/xlog.c:615">RefreshXLogWriteResult</a>(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since successive pages in the xlog cache are consecutively allocated,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can usually gather multiple pages together and issue just one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * write() call.&nbsp; npages is the number of pages we have determined can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * written together; startidx is the cache block index of the first one,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and startoffset is the file offset at which it should go. The latter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * two variables are only valid when npages &gt; 0, but we must <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all of them to keep the compiler quiet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; npages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; startidx = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; startoffset = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Within the loop, curridx is the cache block index of the page to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consider writing.&nbsp; Begin at the buffer containing the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> unwritten<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page, or last partially written page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; curridx = <a href="#L586" title="access/transam/xlog.c:586">XLogRecPtrToBufIdx</a>(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write &lt; WriteRqst.Write)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure we're not ahead of the insert process.&nbsp; This could happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we're passed a bogus WriteRqst.Write that is past the end of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * last page that's been initialized by <a href="#L1980" title="access/transam/xlog.c:1980">AdvanceXLInsertBuffer</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; EndPtr = pg_atomic_read_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;xlblocks[curridx]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write &gt;= EndPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;xlog write request </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> is past end of log </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(EndPtr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write to end of current buffer page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write = EndPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ispartialpage = WriteRqst.Write &lt; <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!XLByteInPrevSeg(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write, <a href="#L631" title="access/transam/xlog.c:631">openLogSegNo</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Switch to new logfile segment.&nbsp; We cannot have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pages here (since we <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> what we have at segment end).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(npages == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L630" title="access/transam/xlog.c:630">openLogFile</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3628" title="access/transam/xlog.c:3628">XLogFileClose</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLByteToPrevSeg(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write, <a href="#L631" title="access/transam/xlog.c:631">openLogSegNo</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L632" title="access/transam/xlog.c:632">openLogTLI</a> = tli;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* create/use new log file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L630" title="access/transam/xlog.c:630">openLogFile</a> = <a href="#L3369" title="access/transam/xlog.c:3369">XLogFileInit</a>(<a href="#L631" title="access/transam/xlog.c:631">openLogSegNo</a>, tli);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1221" title="storage/file/fd.c:1221">ReserveExternalFD</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure we have the current logfile open */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L630" title="access/transam/xlog.c:630">openLogFile</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLByteToPrevSeg(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write, <a href="#L631" title="access/transam/xlog.c:631">openLogSegNo</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L632" title="access/transam/xlog.c:632">openLogTLI</a> = tli;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L630" title="access/transam/xlog.c:630">openLogFile</a> = <a href="#L3607" title="access/transam/xlog.c:3607">XLogFileOpen</a>(<a href="#L631" title="access/transam/xlog.c:631">openLogSegNo</a>, tli);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1221" title="storage/file/fd.c:1221">ReserveExternalFD</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add current page to the set of pending pages-to-<a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (npages == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first of group */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startidx = curridx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startoffset = XLogSegmentOffset(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write - XLOG_BLCKSZ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; npages++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Dump the set if this will be the last loop iteration, or if we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at the last page of the cache area (since the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page won't be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contiguous in memory), or if we are at the end of the logfile<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; last_iteration = WriteRqst.Write &lt;= <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; finishing_seg = !ispartialpage &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (startoffset + npages * XLOG_BLCKSZ) &gt;= <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (last_iteration ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curridx == <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;XLogCacheBlck ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finishing_seg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *from;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nleft;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">ssize_t</span>&nbsp; &nbsp; &nbsp; &nbsp; written;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instr_time&nbsp; &nbsp; start;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK to write the page(s) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; from = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;pages + startidx * (Size) XLOG_BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes = npages * (Size) XLOG_BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nleft = nbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Measure I/O timing to write WAL data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L137" title="access/transam/xlog.c:137">track_wal_io_timing</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(start);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_ZERO(start);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_WAL_WRITE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; written = pg_pwrite(<a href="#L630" title="access/transam/xlog.c:630">openLogFile</a>, from, nleft, startoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Increment the I/O timing and the number of times WAL data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * were written out to disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L137" title="access/transam/xlog.c:137">track_wal_io_timing</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instr_time&nbsp; &nbsp; end;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_ACCUM_DIFF(<a href="../../utils/activity/pgstat_wal.c.html#L24" title="utils/activity/pgstat_wal.c:24">PendingWalStats</a>.wal_write_time, end, start);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_wal.c.html#L24" title="utils/activity/pgstat_wal.c:24">PendingWalStats</a>.wal_write++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (written &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; xlogfname[MAXFNAMELEN];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(xlogfname, tli, <a href="#L631" title="access/transam/xlog.c:631">openLogSegNo</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write to log file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> at offset </span><span class="Special">%u</span><span class="Constant">, length </span><span class="Special">%zu</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlogfname, startoffset, nleft)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nleft -= written;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; from += written;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startoffset += written;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (nleft &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npages = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we just wrote the whole last page of a logfile segment,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fsync the segment immediately.&nbsp; This avoids having to go back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and re-open prior segments when an fsync request comes along<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later. Doing it here ensures that one and only one backend will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * perform this fsync.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is also the right place to notify the Archiver that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * segment is ready to copy to archival storage, and to update the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * timer for archive_timeout, and to signal for a checkpoint if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * too many logfile segments have been used since the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checkpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (finishing_seg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8603" title="access/transam/xlog.c:8603">issue_xlog_fsync</a>(<a href="#L630" title="access/transam/xlog.c:630">openLogFile</a>, <a href="#L631" title="access/transam/xlog.c:631">openLogSegNo</a>, tli);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* signal that we need to <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> walsenders later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WalSndWakeupRequest();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush = <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write;&nbsp; &nbsp; <span class="Comment">/* end of page */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogArchivingActive())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogarchive.c.html#L492" title="access/transam/xlogarchive.c:492">XLogArchiveNotifySeg</a>(<a href="#L631" title="access/transam/xlog.c:631">openLogSegNo</a>, tli);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;lastSegSwitchTime = (pg_time_t) time(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;lastSegSwitchLSN = <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Request a checkpoint if we've consumed too much xlog since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the last one.&nbsp; For speed, we first check using the local<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * copy of <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>, which might be out of date; if it looks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * like a checkpoint is needed, forcibly update <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recheck.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> &amp;&amp; <a href="#L2285" title="access/transam/xlog.c:2285">XLogCheckpointNeeded</a>(<a href="#L631" title="access/transam/xlog.c:631">openLogSegNo</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L6393" title="access/transam/xlog.c:6393">GetRedoRecPtr</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2285" title="access/transam/xlog.c:2285">XLogCheckpointNeeded</a>(<a href="#L631" title="access/transam/xlog.c:631">openLogSegNo</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/checkpointer.c.html#L941" title="postmaster/checkpointer.c:941">RequestCheckpoint</a>(CHECKPOINT_CAUSE_XLOG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ispartialpage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Only asked to write a partial page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write = WriteRqst.Write;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; curridx = <a href="#L579" title="access/transam/xlog.c:579">NextBufIdx</a>(curridx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If flexible, break out of loop as soon as we wrote something */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flexible &amp;&amp; npages == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(npages == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If asked to flush, do so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush &lt; WriteRqst.Flush &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush &lt; <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Could get here without iterating above loop, in which case we might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have no open file or the wrong one.&nbsp; However, we do not need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fsync more than one file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L130" title="access/transam/xlog.c:130">wal_sync_method</a> != WAL_SYNC_METHOD_OPEN &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L130" title="access/transam/xlog.c:130">wal_sync_method</a> != WAL_SYNC_METHOD_OPEN_DSYNC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L630" title="access/transam/xlog.c:630">openLogFile</a> &gt;= <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !XLByteInPrevSeg(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write, <a href="#L631" title="access/transam/xlog.c:631">openLogSegNo</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3628" title="access/transam/xlog.c:3628">XLogFileClose</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L630" title="access/transam/xlog.c:630">openLogFile</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLByteToPrevSeg(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write, <a href="#L631" title="access/transam/xlog.c:631">openLogSegNo</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L632" title="access/transam/xlog.c:632">openLogTLI</a> = tli;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L630" title="access/transam/xlog.c:630">openLogFile</a> = <a href="#L3607" title="access/transam/xlog.c:3607">XLogFileOpen</a>(<a href="#L631" title="access/transam/xlog.c:631">openLogSegNo</a>, tli);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1221" title="storage/file/fd.c:1221">ReserveExternalFD</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8603" title="access/transam/xlog.c:8603">issue_xlog_fsync</a>(<a href="#L630" title="access/transam/xlog.c:630">openLogFile</a>, <a href="#L631" title="access/transam/xlog.c:631">openLogSegNo</a>, tli);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* signal that we need to <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> walsenders later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; WalSndWakeupRequest();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush = <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update shared-memory status<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We make sure that the shared 'request' <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> do not fall behind the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'result' <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; This is not absolutely essential, but it saves some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * code in a couple of places.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;LogwrtRqst.Write &lt; <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;LogwrtRqst.Write = <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;LogwrtRqst.Flush &lt; <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;LogwrtRqst.Flush = <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We write Write first, bar, then Flush.&nbsp; When reading, the opposite must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be done (with a matching barrier in between), so that we always see a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Flush value that trails behind the Write value seen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;logWriteResult, <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write);<br/></li>
<li>&nbsp; &nbsp; pg_write_barrier();<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;logFlushResult, <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; Flush;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; Write;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Flush = pg_atomic_read_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;logFlushResult);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_read_barrier();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Write = pg_atomic_read_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;logWriteResult);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_read_barrier();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> = pg_atomic_read_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;logInsertResult);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WAL written to disk is always ahead of WAL flushed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(Write &gt;= Flush);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WAL inserted to buffers is always ahead of WAL written */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> &gt;= Write);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Record the LSN for an asynchronous transaction commit/abort<br/></li>
<li></span><span class="Comment"> * and nudge the WALWriter if there is work for it to do.<br/></li>
<li></span><span class="Comment"> * (This should not be called for synchronous commits.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2626">&#x200c;</a></span><span class="linkable">XLogSetAsyncXactLSN</span>(XLogRecPtr asyncXactLSN)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; WriteRqstPtr = asyncXactLSN;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; sleeping;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; prevAsyncXactLSN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; sleeping = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;WalWriterSleeping;<br/></li>
<li>&nbsp; &nbsp; prevAsyncXactLSN = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;asyncXactLSN;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;asyncXactLSN &lt; asyncXactLSN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;asyncXactLSN = asyncXactLSN;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If somebody else already called this function with a more aggressive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LSN, they will have done what we needed (and perhaps more).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (asyncXactLSN &lt;= prevAsyncXactLSN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the WALWriter is sleeping, kick it to make it come out of low-power<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mode, so that this async commit will reach disk within the expected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * amount of time.&nbsp; Otherwise, determine whether it has enough WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * available to flush, the same way that <a href="#L2979" title="access/transam/xlog.c:2979">XLogBackgroundFlush</a>() does.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sleeping)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flushblocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L615" title="access/transam/xlog.c:615">RefreshXLogWriteResult</a>(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flushblocks =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WriteRqstPtr / XLOG_BLCKSZ - <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush / XLOG_BLCKSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../postmaster/walwriter.c.html#L72" title="postmaster/walwriter.c:72">WalWriterFlushAfter</a> == <span class="Constant">0</span> || flushblocks &gt;= <a href="../../postmaster/walwriter.c.html#L72" title="postmaster/walwriter.c:72">WalWriterFlushAfter</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> &amp;&amp; <a href="../../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;walwriterLatch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;walwriterLatch);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Record the LSN up to which we can remove WAL because it's not required by<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> replication slot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2677">&#x200c;</a></span><span class="linkable">XLogSetReplicationSlotMinimumLSN</span>(XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;replicationSlotMinLSN = lsn;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the oldest LSN we must retain to satisfy the needs of some<br/></li>
<li></span><span class="Comment"> * replication slot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> XLogRecPtr<br/></li>
<li><a id="L2690">&#x200c;</a><span class="linkable">XLogGetReplicationSlotMinimumLSN</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; retval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; retval = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;replicationSlotMinLSN;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Advance <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> in control file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we crash during recovery, we must reach this point again <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment"> * database is consistent.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If 'force' is true, 'lsn' argument is ignored. Otherwise, <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a><br/></li>
<li></span><span class="Comment"> * is only updated if it's not already greater than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to 'lsn'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2711">&#x200c;</a></span><span class="linkable">UpdateMinRecoveryPoint</span>(XLogRecPtr lsn, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> force)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick check using our local copy of the variable */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L643" title="access/transam/xlog.c:643">updateMinRecoveryPoint</a> || (!force &amp;&amp; lsn &lt;= <a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * An invalid <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> means that we need to recover all the WAL,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * i.e., we're doing crash recovery.&nbsp; We never modify the control file's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value in that case, so we can short-circuit future checks here too. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * local <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> and <a href="xlogrecovery.c.html#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a> should not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * updated until crash recovery finishes.&nbsp; We only do this for the startup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process as it should not update its own reference of <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until it has finished crash recovery to make sure that all WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * available is replayed in this case.&nbsp; This also saves from extra locks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * taken on the control file from the startup process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(<a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a>) &amp;&amp; <a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L643" title="access/transam/xlog.c:643">updateMinRecoveryPoint</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ControlFileLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update local copy */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a> = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L642" title="access/transam/xlog.c:642">LocalMinRecoveryPointTLI</a> = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(<a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L643" title="access/transam/xlog.c:643">updateMinRecoveryPoint</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (force || <a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a> &lt; lsn)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; newMinRecoveryPoint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeLineID&nbsp; &nbsp; newMinRecoveryPointTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To avoid having to update the control file too often, we update it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all the way to the last record being replayed, even though 'lsn'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would suffice for correctness.&nbsp; This also allows the 'force' case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to not need a valid 'lsn' value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Another important reason for doing it this way is that the passed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 'lsn' value could be bogus, i.e., past the end of available WAL, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the caller got it from a corrupted heap page.&nbsp; Accepting such a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value as the min recovery point would prevent us from coming up at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all.&nbsp; Instead, we just log a warning and continue with recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (See also the comments about corrupt LSNs in <a href="#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newMinRecoveryPoint = <a href="xlogrecovery.c.html#L4562" title="access/transam/xlogrecovery.c:4562">GetCurrentReplayRecPtr</a>(&amp;newMinRecoveryPointTLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!force &amp;&amp; newMinRecoveryPoint &lt; lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;xlog min recovery request </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> is past current point </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(lsn), LSN_FORMAT_ARGS(newMinRecoveryPoint));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update control file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> &lt; newMinRecoveryPoint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> = newMinRecoveryPoint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a> = newMinRecoveryPointTLI;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4526" title="access/transam/xlog.c:4526">UpdateControlFile</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a> = newMinRecoveryPoint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L642" title="access/transam/xlog.c:642">LocalMinRecoveryPointTLI</a> = newMinRecoveryPointTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;updated min recovery point to </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> on timeline </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(newMinRecoveryPoint),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newMinRecoveryPointTLI)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Ensure that all XLOG data through the given position is flushed to disk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: this differs from <a href="#L2309" title="access/transam/xlog.c:2309">XLogWrite</a> mainly in that the WALWriteLock is not<br/></li>
<li></span><span class="Comment"> * already held, and we try to avoid acquiring it if possible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2791">&#x200c;</a></span><span class="linkable">XLogFlush</span>(XLogRecPtr record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; WriteRqstPtr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L319" title="access/transam/xlog.c:319">XLogwrtRqst</a> WriteRqst;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; insertTLI = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InsertTimeLineID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During REDO, we are reading not writing WAL.&nbsp; Therefore, instead of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trying to flush the WAL, we should update <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> instead. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * test <a href="#L6345" title="access/transam/xlog.c:6345">XLogInsertAllowed</a>(), not <a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>, because we need checkpointer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to act this way too, and because when it tries to write the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end-of-recovery checkpoint, it should indeed flush.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L6345" title="access/transam/xlog.c:6345">XLogInsertAllowed</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2711" title="access/transam/xlog.c:2711">UpdateMinRecoveryPoint</a>(record, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if already known flushed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (record &lt;= <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WAL_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L140" title="access/transam/xlog.c:140">XLOG_DEBUG</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;xlog flush request </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">; write </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">; flush </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(record),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since fsync is usually a horribly expensive operation, we try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * piggyback as much data as we can on each fsync: if we see <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entered into the xlog buffer, we'll write and fsync that too, so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the final value of <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush is as large as possible. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gives us some chance of avoiding another fsync immediately after.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> to given target; may increase below */<br/></li>
<li></span>&nbsp; &nbsp; WriteRqstPtr = record;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now wait until we get the write lock, or someone else does the flush<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; insertpos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* done already? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L615" title="access/transam/xlog.c:615">RefreshXLogWriteResult</a>(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (record &lt;= <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before actually performing the write, wait for all in-flight<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * insertions to the pages we're about to write to finish.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (WriteRqstPtr &lt; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;LogwrtRqst.Write)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WriteRqstPtr = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;LogwrtRqst.Write;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; insertpos = <a href="#L1499" title="access/transam/xlog.c:1499">WaitXLogInsertionsToFinish</a>(WriteRqstPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to get the write lock. If we can't get it immediately, wait<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * until it's released, and recheck if we still need to do the flush<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or if the backend that held the lock did it for us already. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * helps to maintain a good rate of group committing when the system<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is bottlenecked by the speed of fsyncing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/lmgr/lwlock.c.html#L1398" title="storage/lmgr/lwlock.c:1398">LWLockAcquireOrWait</a>(WALWriteLock, LW_EXCLUSIVE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The lock is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> free, but we didn't acquire it yet. Before we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do, loop back to check if someone else flushed the record for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * us already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Got the lock; recheck whether request is satisfied */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L615" title="access/transam/xlog.c:615">RefreshXLogWriteResult</a>(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (record &lt;= <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WALWriteLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sleep <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> flush! By adding a delay here, we may give further<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backends the opportunity to join the backlog of group commit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * followers; this can significantly improve transaction throughput,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at the risk of increasing transaction latency.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We do not sleep if <a href="../../utils/init/globals.c.html#L126" title="utils/init/globals.c:126">enableFsync</a> is not turned on, nor if there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fewer than <a href="#L133" title="access/transam/xlog.c:133">CommitSiblings</a> other backends with active transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L132" title="access/transam/xlog.c:132">CommitDelay</a> &gt; <span class="Constant">0</span> &amp;&amp; <a href="../../utils/init/globals.c.html#L126" title="utils/init/globals.c:126">enableFsync</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L3533" title="storage/ipc/procarray.c:3533">MinimumActiveBackends</a>(<a href="#L133" title="access/transam/xlog.c:133">CommitSiblings</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<a href="#L132" title="access/transam/xlog.c:132">CommitDelay</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Re-check how far we can <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> flush the WAL. It's generally not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * safe to call <a href="#L1499" title="access/transam/xlog.c:1499">WaitXLogInsertionsToFinish</a> while holding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WALWriteLock, because an in-progress insertion might need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * also grab WALWriteLock to make progress. But we know that all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the insertions up to insertpos have already finished, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that's what the earlier <a href="#L1499" title="access/transam/xlog.c:1499">WaitXLogInsertionsToFinish</a>() returned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're only calling it again to allow insertpos to be moved<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * further forward, not to actually wait for anyone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertpos = <a href="#L1499" title="access/transam/xlog.c:1499">WaitXLogInsertionsToFinish</a>(insertpos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try to write/flush later additions to XLOG as well */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; WriteRqst.Write = insertpos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WriteRqst.Flush = insertpos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2309" title="access/transam/xlog.c:2309">XLogWrite</a>(WriteRqst, insertTLI, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WALWriteLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* wake up walsenders <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that we've released heavily contended locks */<br/></li>
<li></span>&nbsp; &nbsp; WalSndWakeupProcessRequests(<span class="Constant">true</span>, !<a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we still haven't flushed to the request point then we have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * problem; most likely, the requested flush point is past end of XLOG.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This has been seen to occur when a disk page has a corrupted LSN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Formerly we treated this as a PANIC condition, but that hurts the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * system's robustness rather than helping it: we do not want to take down<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the whole system due to corruption on one data page.&nbsp; In particular, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the bad page is encountered again during recovery then we would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unable to restart the database at all!&nbsp; (This scenario actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happened in the field several times with 7.1 releases.)&nbsp; &nbsp; As of 8.4, bad<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LSNs encountered during recovery are <a href="#L2711" title="access/transam/xlog.c:2711">UpdateMinRecoveryPoint</a>'s problem;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the only time we can reach here during recovery is while flushing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end-of-recovery checkpoint record, and we don't expect that to have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bad LSN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that for calls from xact.c, the ERROR will be promoted to PANIC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since xact.c calls this routine inside a critical section.&nbsp; However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls from bufmgr.c are not within critical sections and so we will not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * force a restart for a bad LSN on a data page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush &lt; record)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;xlog flush request </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> is not satisfied --- flushed only to </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(record),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write &amp; flush xlog, but without specifying exactly where to.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We normally write only completed blocks; but if there is nothing to do on<br/></li>
<li></span><span class="Comment"> * that basis, we check for unwritten async commits in the current incomplete<br/></li>
<li></span><span class="Comment"> * block, and write through the latest one of those.&nbsp; Thus, if async commits<br/></li>
<li></span><span class="Comment"> * are not being used, we will write complete blocks only.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If, based on the above, there's anything to write we do so immediately. But<br/></li>
<li></span><span class="Comment"> * to avoid calling fsync, fdatasync et. al. at a rate that'd impact<br/></li>
<li></span><span class="Comment"> * concurrent IO, we only flush WAL every wal_writer_delay ms, or if there's<br/></li>
<li></span><span class="Comment"> * more than wal_writer_flush_after unflushed blocks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can guarantee that async commits reach disk after at most three<br/></li>
<li></span><span class="Comment"> * wal_writer_delay cycles. (When flushing complete blocks, we allow <a href="#L2309" title="access/transam/xlog.c:2309">XLogWrite</a><br/></li>
<li></span><span class="Comment"> * to write &quot;flexibly&quot;, meaning it can stop at the end of the buffer ring;<br/></li>
<li></span><span class="Comment"> * this makes a difference only with very high load or long wal_writer_delay,<br/></li>
<li></span><span class="Comment"> * but imposes one extra cycle for the worst case for async commits.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine is invoked periodically by the background walwriter process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if there was <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> work to do, even if we skipped flushing due<br/></li>
<li></span><span class="Comment"> * to wal_writer_delay/wal_writer_flush_after.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2979">&#x200c;</a></span><span class="linkable">XLogBackgroundFlush</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L319" title="access/transam/xlog.c:319">XLogwrtRqst</a> WriteRqst;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; flexible = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> TimestampTz lastflush;<br/></li>
<li>&nbsp; &nbsp; TimestampTz <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flushblocks;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; insertTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG doesn't need flushing during recovery */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we're not in recovery, InsertTimeLineID is set and can't change,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so we can read it without a lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; insertTLI = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InsertTimeLineID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read updated LogwrtRqst */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; WriteRqst = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;LogwrtRqst;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* back off to last completed page boundary */<br/></li>
<li></span>&nbsp; &nbsp; WriteRqst.Write -= WriteRqst.Write % XLOG_BLCKSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if we have already flushed that far, consider async commit <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L615" title="access/transam/xlog.c:615">RefreshXLogWriteResult</a>(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (WriteRqst.Write &lt;= <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WriteRqst.Write = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;asyncXactLSN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flexible = <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ensure it all gets written */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If already known flushed, we're done. Just need to check if we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * holding an open file handle to a logfile that's no longer in use,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * preventing the file from being deleted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (WriteRqst.Write &lt;= <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L630" title="access/transam/xlog.c:630">openLogFile</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!XLByteInPrevSeg(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write, <a href="#L631" title="access/transam/xlog.c:631">openLogSegNo</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3628" title="access/transam/xlog.c:3628">XLogFileClose</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine how far to flush WAL, based on the wal_writer_delay and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wal_writer_flush_after GUCs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that <a href="#L2626" title="access/transam/xlog.c:2626">XLogSetAsyncXactLSN</a>() performs similar calculation based on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wal_writer_flush_after, to decide when to wake us up.&nbsp; Make sure the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * logic is the same in both places if you change this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; flushblocks =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WriteRqst.Write / XLOG_BLCKSZ - <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush / XLOG_BLCKSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../postmaster/walwriter.c.html#L72" title="postmaster/walwriter.c:72">WalWriterFlushAfter</a> == <span class="Constant">0</span> || lastflush == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first call, or block based limits disabled */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; WriteRqst.Flush = WriteRqst.Write;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lastflush = <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../utils/adt/timestamp.c.html#L1790" title="utils/adt/timestamp.c:1790">TimestampDifferenceExceeds</a>(lastflush, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, <a href="../../postmaster/walwriter.c.html#L71" title="postmaster/walwriter.c:71">WalWriterDelay</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Flush the writes at least every <a href="../../postmaster/walwriter.c.html#L71" title="postmaster/walwriter.c:71">WalWriterDelay</a> ms. This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * important to bound the amount of time it takes for an asynchronous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * commit to hit disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; WriteRqst.Flush = WriteRqst.Write;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lastflush = <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (flushblocks &gt;= <a href="../../postmaster/walwriter.c.html#L72" title="postmaster/walwriter.c:72">WalWriterFlushAfter</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* exceeded wal_writer_flush_after blocks, flush */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; WriteRqst.Flush = WriteRqst.Write;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lastflush = <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no flushing, this time round */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; WriteRqst.Flush = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WAL_DEBUG<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L140" title="access/transam/xlog.c:140">XLOG_DEBUG</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;xlog bg flush request write </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">; flush: </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, current is write </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">; flush </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(WriteRqst.Write),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(WriteRqst.Flush),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> wait for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> in-progress insertions to finish and get write lock */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1499" title="access/transam/xlog.c:1499">WaitXLogInsertionsToFinish</a>(WriteRqst.Write);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(WALWriteLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L615" title="access/transam/xlog.c:615">RefreshXLogWriteResult</a>(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (WriteRqst.Write &gt; <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WriteRqst.Flush &gt; <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2309" title="access/transam/xlog.c:2309">XLogWrite</a>(WriteRqst, insertTLI, flexible);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WALWriteLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* wake up walsenders <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that we've released heavily contended locks */<br/></li>
<li></span>&nbsp; &nbsp; WalSndWakeupProcessRequests(<span class="Constant">true</span>, !<a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Great, done. To take some work off the critical path, try to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as many of the no-longer-needed WAL buffers for future use as we can.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1980" title="access/transam/xlog.c:1980">AdvanceXLInsertBuffer</a>(InvalidXLogRecPtr, insertTLI, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we determined that we need to write data, but somebody else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wrote/flushed already, it should be considered as being active, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid hibernating too early.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test whether XLOG data has been flushed up to (at least) the given position.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if a flush is still needed.&nbsp; (It may be that someone else<br/></li>
<li></span><span class="Comment"> * is already in process of flushing that far, however.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3122">&#x200c;</a></span><span class="linkable">XLogNeedsFlush</span>(XLogRecPtr record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During recovery, we don't flush WAL but update <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instead. So &quot;needs flush&quot; is taken to mean whether <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would need to be updated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * An invalid <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> means that we need to recover all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL, i.e., we're doing crash recovery.&nbsp; We never modify the control<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file's value in that case, so we can short-circuit future checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here too.&nbsp; This triggers a quick exit path for the startup process,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which cannot update its local copy of <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> as long as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it has not replayed all WAL available when doing crash recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(<a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a>) &amp;&amp; <a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L643" title="access/transam/xlog.c:643">updateMinRecoveryPoint</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Quick exit if already known to be updated or cannot be updated */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (record &lt;= <a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a> || !<a href="#L643" title="access/transam/xlog.c:643">updateMinRecoveryPoint</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update local copy of <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>. But if the lock is busy,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just return a conservative guess.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/lmgr/lwlock.c.html#L1341" title="storage/lmgr/lwlock.c:1341">LWLockConditionalAcquire</a>(ControlFileLock, LW_SHARED))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a> = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L642" title="access/transam/xlog.c:642">LocalMinRecoveryPointTLI</a> = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other process than the startup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process doing crash recovery, which should not update the control<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file value if crash recovery is still running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(<a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L643" title="access/transam/xlog.c:643">updateMinRecoveryPoint</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (record &lt;= <a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a> || !<a href="#L643" title="access/transam/xlog.c:643">updateMinRecoveryPoint</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick exit if already known flushed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (record &lt;= <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a> and update local state */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L615" title="access/transam/xlog.c:615">RefreshXLogWriteResult</a>(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check again */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (record &lt;= <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Try to make a given XLOG file segment exist.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * logsegno: identify segment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *added: on return, true if this call raised the number of extant segments.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * path: on return, this char[MAXPGPATH] has the path to the logsegno file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns -1 or FD of opened file.&nbsp; A -1 here is not an error; a caller<br/></li>
<li></span><span class="Comment"> * wanting an open segment should attempt to open &quot;path&quot;, which usually will<br/></li>
<li></span><span class="Comment"> * succeed.&nbsp; (This is weird, but it's efficient for the callers.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L3199">&#x200c;</a></span><span class="linkable">XLogFileInitInternal</span>(XLogSegNo logsegno, TimeLineID logtli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *added, <span class="Type">char</span> *path)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tmppath[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; installed_segno;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; max_segno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; open_flags = O_RDWR | O_CREAT | O_EXCL | PG_BINARY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(logtli != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLogFilePath(path, logtli, logsegno, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to use existent file (checkpoint maker may have created it already)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *added = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L1087" title="storage/file/fd.c:1087">BasicOpenFile</a>(path, O_RDWR | PG_BINARY | O_CLOEXEC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L8513" title="access/transam/xlog.c:8513">get_sync_bit</a>(<a href="#L130" title="access/transam/xlog.c:130">wal_sync_method</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize an empty (all zeroes) segment.&nbsp; <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: it is possible that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another process is doing the same thing.&nbsp; If so, we will end up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pre-creating an extra log segment.&nbsp; That seems OK, and better than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * holding the lock throughout this lengthy process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;creating and filling new WAL file&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(tmppath, MAXPGPATH, XLOGDIR <span class="Constant">&quot;/xlogtemp.</span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) getpid());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; unlink(tmppath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L168" title="storage/file/fd.c:168">io_direct_flags</a> &amp; IO_DIRECT_WAL_INIT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; open_flags |= PG_O_DIRECT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do not use <a href="#L8513" title="access/transam/xlog.c:8513">get_sync_bit</a>() here --- want to fsync only at end of fill */<br/></li>
<li></span>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L1087" title="storage/file/fd.c:1087">BasicOpenFile</a>(tmppath, open_flags);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, tmppath)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_WAL_INIT_WRITE);<br/></li>
<li>&nbsp; &nbsp; save_errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L127" title="access/transam/xlog.c:127">wal_init_zero</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">ssize_t</span>&nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Zero-fill the file.&nbsp; With this setting, we do this the hard way to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ensure that all the file space has really been allocated.&nbsp; On<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * platforms that allow &quot;holes&quot; in files, just seeking to the end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doesn't allocate intermediate space.&nbsp; This way, we know that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have all the space and (after the fsync below) that all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indirect blocks are down on disk.&nbsp; Therefore, fdatasync(2) or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * O_DSYNC will be sufficient to sync future writes to the log file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rc = pg_pwrite_zeros(fd, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, seeking to the end and writing a solitary byte is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enough.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_pwrite(fd, <span class="Constant">&quot;</span><span class="Special">\0</span><span class="Constant">&quot;</span>, <span class="Constant">1</span>, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a> - <span class="Constant">1</span>) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if write didn't set errno, assume no disk space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno ? errno : <span class="Constant">ENOSPC</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (save_errno)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we fail to make the file, delete it to release disk space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; unlink(tmppath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close(fd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write to file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, tmppath)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_WAL_INIT_SYNC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L386" title="storage/file/fd.c:386">pg_fsync</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fsync file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, tmppath)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (close(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, tmppath)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now move the segment into place with its final name.&nbsp; Cope with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibility that someone else has created the file while we were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * filling ours: if so, use ours to pre-create a future log segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; installed_segno = logsegno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: What should we use as max_segno? We used to use <a href="#L2235" title="access/transam/xlog.c:2235">XLOGfileslop</a> when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that was a constant, but that was always a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> dubious: normally, at a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoint, <a href="#L2235" title="access/transam/xlog.c:2235">XLOGfileslop</a> was the offset from the checkpoint record, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here, it was the offset from the insert location. We can't do the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * normal <a href="#L2235" title="access/transam/xlog.c:2235">XLOGfileslop</a> calculation here because we don't have access to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the prior checkpoint's redo location. So somewhat arbitrarily, just use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L156" title="access/transam/xlog.c:156">CheckPointSegments</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; max_segno = logsegno + <a href="#L156" title="access/transam/xlog.c:156">CheckPointSegments</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3552" title="access/transam/xlog.c:3552">InstallXLogFileSegment</a>(&amp;installed_segno, tmppath, <span class="Constant">true</span>, max_segno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; logtli))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *added = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;done creating and filling new WAL file&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No need for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more future segments, or <a href="#L3552" title="access/transam/xlog.c:3552">InstallXLogFileSegment</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * failed to rename the file into place. If the rename failed, a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller opening the file may fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; unlink(tmppath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;abandoned new WAL file&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a new XLOG file segment, or open a pre-existing one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * logsegno: identify segment to be created/opened.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns FD of opened file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: errors here are ERROR not PANIC because we might or might not be<br/></li>
<li></span><span class="Comment"> * inside a critical section (eg, during checkpoint there is no reason to<br/></li>
<li></span><span class="Comment"> * take down the system on failure).&nbsp; They will promote to PANIC if we are<br/></li>
<li></span><span class="Comment"> * in a critical section.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3369">&#x200c;</a></span><span class="linkable">XLogFileInit</span>(XLogSegNo logsegno, TimeLineID logtli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ignore_added;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(logtli != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="#L3199" title="access/transam/xlog.c:3199">XLogFileInitInternal</a>(logsegno, logtli, &amp;ignore_added, path);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now open original target segment (might not be file I just made) */<br/></li>
<li></span>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L1087" title="storage/file/fd.c:1087">BasicOpenFile</a>(path, O_RDWR | PG_BINARY | O_CLOEXEC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L8513" title="access/transam/xlog.c:8513">get_sync_bit</a>(<a href="#L130" title="access/transam/xlog.c:130">wal_sync_method</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> fd;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a new XLOG file segment by copying a pre-existing one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * destsegno: identify segment to be created.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * srcTLI, srcsegno: identify segment to be copied (could be from<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a different timeline)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * upto: how much of the source file to copy (the rest is filled with<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; zeros)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently this is only used during recovery, and so there are no locking<br/></li>
<li></span><span class="Comment"> * considerations.&nbsp; But we should be just as tense as <a href="#L3369" title="access/transam/xlog.c:3369">XLogFileInit</a> to avoid<br/></li>
<li></span><span class="Comment"> * emplacing a bogus file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3407">&#x200c;</a></span><span class="linkable">XLogFileCopy</span>(TimeLineID destTLI, XLogSegNo destsegno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimeLineID srcTLI, XLogSegNo srcsegno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> upto)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; tmppath[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; PGAlignedXLogBlock buffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srcfd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open the source file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLogFilePath(path, srcTLI, srcsegno, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; srcfd = <a href="../../storage/file/fd.c.html#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(path, O_RDONLY | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (srcfd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy into a temp file name.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(tmppath, MAXPGPATH, XLOGDIR <span class="Constant">&quot;/xlogtemp.</span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) getpid());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; unlink(tmppath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do not use <a href="#L8513" title="access/transam/xlog.c:8513">get_sync_bit</a>() here --- want to fsync only at end of fill */<br/></li>
<li></span>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(tmppath, O_RDWR | O_CREAT | O_EXCL | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, tmppath)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do the data copying.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (nbytes = <span class="Constant">0</span>; nbytes &lt; <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>; nbytes += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nread;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nread = upto - nbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The part that is not read from the source file is filled with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * zeros.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nread &lt; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(buffer.data, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nread &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nread &gt; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nread = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_WAL_COPY_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = read(srcfd, buffer.data, nread);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r != nread)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: read </span><span class="Special">%d</span><span class="Constant"> of </span><span class="Special">%zu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path, r, (Size) nread)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_WAL_COPY_WRITE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((<span class="Type">int</span>) write(fd, buffer.data, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buffer)) != (<span class="Type">int</span>) <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we fail to make the file, delete it to release disk space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unlink(tmppath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if write didn't set errno, assume problem is no disk space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno ? save_errno : <span class="Constant">ENOSPC</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write to file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, tmppath)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_WAL_COPY_SYNC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L386" title="storage/file/fd.c:386">pg_fsync</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(<a href="../../storage/file/fd.c.html#L3936" title="storage/file/fd.c:3936">data_sync_elevel</a>(ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fsync file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, tmppath)));<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, tmppath)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(srcfd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now move the segment into place with its final name.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3552" title="access/transam/xlog.c:3552">InstallXLogFileSegment</a>(&amp;destsegno, tmppath, <span class="Constant">false</span>, <span class="Constant">0</span>, destTLI))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L3552" title="access/transam/xlog.c:3552">InstallXLogFileSegment</a> should not have failed&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Install a new XLOG segment file as a current or future log segment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used both to install a newly-created segment (which has a temp<br/></li>
<li></span><span class="Comment"> * filename while it's being created) and to recycle an old segment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *segno: identify segment to install as (or first possible target).<br/></li>
<li></span><span class="Comment"> * When find_free is true, this is modified on return to indicate the<br/></li>
<li></span><span class="Comment"> * actual installation location or last segment searched.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tmppath: initial name of file to install.&nbsp; It will be renamed into place.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * find_free: if true, install the new segment at the first empty segno<br/></li>
<li></span><span class="Comment"> * number at or after the passed numbers.&nbsp; If false, install the new segment<br/></li>
<li></span><span class="Comment"> * exactly where specified, deleting <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing segment file there.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * max_segno: maximum segment number to install the new file as.&nbsp; Fail if no<br/></li>
<li></span><span class="Comment"> * free slot is found between *segno and max_segno. (Ignored when find_free<br/></li>
<li></span><span class="Comment"> * is false.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tli: The timeline on which the new segment should be installed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if the file was installed successfully.&nbsp; false indicates that<br/></li>
<li></span><span class="Comment"> * max_segno limit was exceeded, the startup process has disabled this<br/></li>
<li></span><span class="Comment"> * function for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, or an error occurred while renaming the file into place.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3552">&#x200c;</a></span><span class="linkable">InstallXLogFileSegment</span>(XLogSegNo *segno, <span class="Type">char</span> *tmppath,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> find_free, XLogSegNo max_segno, TimeLineID tli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat stat_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(tli != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLogFilePath(path, tli, *segno, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ControlFileLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InstallXLogFileSegmentActive)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!find_free)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Force installation: get rid of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pre-existing segment file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L872" title="storage/file/fd.c:872">durable_unlink</a>(path, DEBUG1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find a free slot to put it in */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (stat(path, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((*segno) &gt;= max_segno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Failed to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a free slot within specified <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (*segno)++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogFilePath(path, tli, *segno, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(access(path, F_OK) != <span class="Constant">0</span> &amp;&amp; errno == <span class="Constant">ENOENT</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L782" title="storage/file/fd.c:782">durable_rename</a>(tmppath, path, LOG) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L782" title="storage/file/fd.c:782">durable_rename</a> already emitted log message */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Open a pre-existing logfile segment for writing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L3607">&#x200c;</a></span><span class="linkable">XLogFileOpen</span>(XLogSegNo segno, TimeLineID tli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLogFilePath(path, tli, segno, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L1087" title="storage/file/fd.c:1087">BasicOpenFile</a>(path, O_RDWR | PG_BINARY | O_CLOEXEC |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L8513" title="access/transam/xlog.c:8513">get_sync_bit</a>(<a href="#L130" title="access/transam/xlog.c:130">wal_sync_method</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> fd;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Close the current logfile segment for writing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3628">&#x200c;</a></span><span class="linkable">XLogFileClose</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L630" title="access/transam/xlog.c:630">openLogFile</a> &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WAL segment files will not be re-read in normal operation, so we advise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the OS to release <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cached pages.&nbsp; But do not do so if WAL archiving<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or streaming is active, because archiver and walsender process could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use the cache to read the WAL segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#if defined(USE_POSIX_FADVISE) &amp;&amp; defined(POSIX_FADV_DONTNEED)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogIsNeeded() &amp;&amp; (<a href="../../storage/file/fd.c.html#L168" title="storage/file/fd.c:168">io_direct_flags</a> &amp; IO_DIRECT_WAL) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) posix_fadvise(<a href="#L630" title="access/transam/xlog.c:630">openLogFile</a>, <span class="Constant">0</span>, <span class="Constant">0</span>, POSIX_FADV_DONTNEED);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (close(<a href="#L630" title="access/transam/xlog.c:630">openLogFile</a>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; xlogfname[MAXFNAMELEN];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(xlogfname, <a href="#L632" title="access/transam/xlog.c:632">openLogTLI</a>, <a href="#L631" title="access/transam/xlog.c:631">openLogSegNo</a>, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, xlogfname)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L630" title="access/transam/xlog.c:630">openLogFile</a> = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Preallocate log files beyond the specified log endpoint.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> this is currently extremely conservative, since it forces only one<br/></li>
<li></span><span class="Comment"> * future log segment to exist, and even that only if we are 75% done with<br/></li>
<li></span><span class="Comment"> * the current one.&nbsp; This is only appropriate for very low-WAL-volume systems.<br/></li>
<li></span><span class="Comment"> * High-volume systems will be OK once they've built up a sufficient set of<br/></li>
<li></span><span class="Comment"> * recycled log segments, but the startup transient is likely to include<br/></li>
<li></span><span class="Comment"> * a lot of segment creations by foreground processes, which is not so good.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L3199" title="access/transam/xlog.c:3199">XLogFileInitInternal</a>() can ereport(ERROR).&nbsp; All known causes indicate big<br/></li>
<li></span><span class="Comment"> * trouble; for example, a full filesystem is one cause.&nbsp; The checkpoint WAL<br/></li>
<li></span><span class="Comment"> * and/or <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a> updates already completed.&nbsp; If a <a href="../../postmaster/checkpointer.c.html#L941" title="postmaster/checkpointer.c:941">RequestCheckpoint</a>()<br/></li>
<li></span><span class="Comment"> * initiated the present checkpoint and an ERROR ends this function, the<br/></li>
<li></span><span class="Comment"> * command that called <a href="../../postmaster/checkpointer.c.html#L941" title="postmaster/checkpointer.c:941">RequestCheckpoint</a>() fails.&nbsp; That's not ideal, but it's<br/></li>
<li></span><span class="Comment"> * not worth contorting more <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to use caller-specified elevel <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> * (With or without <a href="../../postmaster/checkpointer.c.html#L941" title="postmaster/checkpointer.c:941">RequestCheckpoint</a>(), an ERROR forestalls some inessential<br/></li>
<li></span><span class="Comment"> * reporting and resource reclamation.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3679">&#x200c;</a></span><span class="linkable">PreallocXlogFiles</span>(XLogRecPtr endptr, TimeLineID tli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; _logSegNo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; added;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InstallXLogFileSegmentActive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unlocked check says no */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; XLByteToPrevSeg(endptr, _logSegNo, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; offset = XLogSegmentOffset(endptr - <span class="Constant">1</span>, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (offset &gt;= (uint32) (<span class="Constant">0.75</span> * <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _logSegNo++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lf = <a href="#L3199" title="access/transam/xlog.c:3199">XLogFileInitInternal</a>(_logSegNo, tli, &amp;added, path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lf &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; close(lf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (added)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_segs_added++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Throws an error if the given log segment has already been removed or<br/></li>
<li></span><span class="Comment"> * recycled. The caller should only pass a segment that it knows to have<br/></li>
<li></span><span class="Comment"> * existed while the server has been running, as this function always<br/></li>
<li></span><span class="Comment"> * succeeds if no WAL segments have been removed since startup.<br/></li>
<li></span><span class="Comment"> * 'tli' is only used in the error message.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this function guarantees to keep errno unchanged on return.<br/></li>
<li></span><span class="Comment"> * This supports callers that use this to possibly deliver a better<br/></li>
<li></span><span class="Comment"> * error message about a missing file, while still being able to throw<br/></li>
<li></span><span class="Comment"> * a normal file-access error afterwards, if this does return.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3716">&#x200c;</a></span><span class="linkable">CheckXLogRemoved</span>(XLogSegNo segno, TimeLineID tli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; lastRemovedSegNo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; lastRemovedSegNo = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;lastRemovedSegNo;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (segno &lt;= lastRemovedSegNo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; filename[MAXFNAMELEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(filename, tli, segno, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested WAL segment </span><span class="Special">%s</span><span class="Constant"> has already been removed&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filename)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; errno = save_errno;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the last WAL segment removed, or 0 if no segment has been removed<br/></li>
<li></span><span class="Comment"> * since startup.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: the result can be out of date arbitrarily fast, the caller has to deal<br/></li>
<li></span><span class="Comment"> * with that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogSegNo<br/></li>
<li><a id="L3747">&#x200c;</a><span class="linkable">XLogGetLastRemovedSegno</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; lastRemovedSegNo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; lastRemovedSegNo = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;lastRemovedSegNo;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lastRemovedSegNo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the oldest WAL segment on the given TLI that still exists in<br/></li>
<li></span><span class="Comment"> * XLOGDIR, or 0 if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogSegNo<br/></li>
<li><a id="L3763">&#x200c;</a><span class="linkable">XLogGetOldestSegno</span>(TimeLineID tli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *xldir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *xlde;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; oldest_segno = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xldir = <a href="../../storage/file/fd.c.html#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(XLOGDIR);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((xlde = <a href="../../storage/file/fd.c.html#L2909" title="storage/file/fd.c:2909">ReadDir</a>(xldir, XLOGDIR)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeLineID&nbsp; &nbsp; file_tli;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; file_segno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore files that are not XLOG segments. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsXLogFileName(xlde-&gt;d_name))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parse filename to get TLI and segno. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; XLogFromFileName(xlde-&gt;d_name, &amp;file_tli, &amp;file_segno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore anything that's not from the TLI of interest. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tli != file_tli)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's the oldest so far, update oldest_segno. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldest_segno == <span class="Constant">0</span> || file_segno &lt; oldest_segno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldest_segno = file_segno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2961" title="storage/file/fd.c:2961">FreeDir</a>(xldir);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> oldest_segno;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update the last removed segno pointer in shared memory, to reflect that the<br/></li>
<li></span><span class="Comment"> * given XLOG file has been removed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3801">&#x200c;</a></span><span class="linkable">UpdateLastRemovedPtr</span>(<span class="Type">char</span> *filename)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; tli;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; segno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLogFromFileName(filename, &amp;tli, &amp;segno, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (segno &gt; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;lastRemovedSegNo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;lastRemovedSegNo = segno;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove all temporary log files in pg_wal<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called at the beginning of recovery after a previous crash,<br/></li>
<li></span><span class="Comment"> * at a point where no other processes write fresh WAL data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3821">&#x200c;</a></span><span class="linkable">RemoveTempXlogFiles</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *xldir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *xlde;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;removing all temporary WAL segments&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xldir = <a href="../../storage/file/fd.c.html#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(XLOGDIR);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((xlde = <a href="../../storage/file/fd.c.html#L2909" title="storage/file/fd.c:2909">ReadDir</a>(xldir, XLOGDIR)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strncmp(xlde-&gt;d_name, <span class="Constant">&quot;xlogtemp.&quot;</span>, <span class="Constant">9</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(path, MAXPGPATH, XLOGDIR <span class="Constant">&quot;/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, xlde-&gt;d_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unlink(path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;removed temporary WAL segment </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, path);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2961" title="storage/file/fd.c:2961">FreeDir</a>(xldir);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recycle or remove all log files older or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to passed segno.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * endptr is current (or recent) end of xlog, and lastredoptr is the<br/></li>
<li></span><span class="Comment"> * redo pointer of the last checkpoint. These are used to determine<br/></li>
<li></span><span class="Comment"> * whether we want to recycle rather than delete no-longer-wanted log files.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * insertTLI is the current timeline for XLOG insertion. Any recycled<br/></li>
<li></span><span class="Comment"> * segments should be reused for this timeline.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3854">&#x200c;</a></span><span class="linkable">RemoveOldXlogFiles</span>(XLogSegNo segno, XLogRecPtr lastredoptr, XLogRecPtr endptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimeLineID insertTLI)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *xldir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *xlde;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; lastoff[MAXFNAMELEN];<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; endlogSegNo;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; recycleSegNo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize info about where to try to recycle to */<br/></li>
<li></span>&nbsp; &nbsp; XLByteToSeg(endptr, endlogSegNo, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; recycleSegNo = <a href="#L2235" title="access/transam/xlog.c:2235">XLOGfileslop</a>(lastredoptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct a filename of the last segment to be kept. The timeline ID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't matter, we ignore that in the comparison. (During recovery,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * InsertTimeLineID isn't set, so we can't use that.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLogFileName(lastoff, <span class="Constant">0</span>, segno, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;attempting to remove WAL segments older than log file </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lastoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xldir = <a href="../../storage/file/fd.c.html#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(XLOGDIR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((xlde = <a href="../../storage/file/fd.c.html#L2909" title="storage/file/fd.c:2909">ReadDir</a>(xldir, XLOGDIR)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore files that are not XLOG segments */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsXLogFileName(xlde-&gt;d_name) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !IsPartialXLogFileName(xlde-&gt;d_name))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We ignore the timeline part of the XLOG segment identifiers in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deciding whether a segment is still needed.&nbsp; This ensures that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * won't prematurely remove a segment from a parent timeline. We could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * probably be a little more proactive about removing segments of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-parent timelines, but that would be a whole lot more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * complicated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We use the alphanumeric sorting property of the filenames to decide<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which ones are earlier than the lastoff segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(xlde-&gt;d_name + <span class="Constant">8</span>, lastoff + <span class="Constant">8</span>) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogarchive.c.html#L565" title="access/transam/xlogarchive.c:565">XLogArchiveCheckDone</a>(xlde-&gt;d_name))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update the last removed location in shared memory first */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3801" title="access/transam/xlog.c:3801">UpdateLastRemovedPtr</a>(xlde-&gt;d_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3998" title="access/transam/xlog.c:3998">RemoveXlogFile</a>(xlde, recycleSegNo, &amp;endlogSegNo, insertTLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2961" title="storage/file/fd.c:2961">FreeDir</a>(xldir);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recycle or remove WAL files that are not part of the given timeline's<br/></li>
<li></span><span class="Comment"> * history.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called during recovery, whenever we switch to follow a new<br/></li>
<li></span><span class="Comment"> * timeline, and at the end of recovery when we create a new timeline. We<br/></li>
<li></span><span class="Comment"> * wouldn't otherwise care about extra WAL files lying in pg_wal, but they<br/></li>
<li></span><span class="Comment"> * might be leftover pre-allocated or recycled WAL segments on the old timeline<br/></li>
<li></span><span class="Comment"> * that we haven't used yet, and contain garbage. If we just leave them in<br/></li>
<li></span><span class="Comment"> * pg_wal, they will eventually be archived, and we can't let that happen.<br/></li>
<li></span><span class="Comment"> * Files that belong to our timeline history are valid, because we have<br/></li>
<li></span><span class="Comment"> * successfully replayed them, but from others we can't be sure.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'switchpoint' is the current point in WAL where we switch to new timeline,<br/></li>
<li></span><span class="Comment"> * and 'newTLI' is the new timeline we switch to.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3929">&#x200c;</a></span><span class="linkable">RemoveNonParentXlogFiles</span>(XLogRecPtr switchpoint, TimeLineID newTLI)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *xldir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *xlde;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; switchseg[MAXFNAMELEN];<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; endLogSegNo;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; switchLogSegNo;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; recycleSegNo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize info about where to begin the work.&nbsp; This will recycle,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * somewhat arbitrarily, 10 future segments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLByteToPrevSeg(switchpoint, switchLogSegNo, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; XLByteToSeg(switchpoint, endLogSegNo, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; recycleSegNo = endLogSegNo + <span class="Constant">10</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct a filename of the last segment to be kept.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLogFileName(switchseg, newTLI, switchLogSegNo, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;attempting to remove WAL segments newer than log file </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; switchseg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xldir = <a href="../../storage/file/fd.c.html#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(XLOGDIR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((xlde = <a href="../../storage/file/fd.c.html#L2909" title="storage/file/fd.c:2909">ReadDir</a>(xldir, XLOGDIR)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore files that are not XLOG segments */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsXLogFileName(xlde-&gt;d_name))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remove files that are on a timeline older than the new one we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * switching to, but with a segment number &gt;= the first segment on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strncmp(xlde-&gt;d_name, switchseg, <span class="Constant">8</span>) &lt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(xlde-&gt;d_name + <span class="Constant">8</span>, switchseg + <span class="Constant">8</span>) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the file has already been marked as .ready, however, don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remove it yet. It should be OK to remove it - files that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not part of our timeline history are not required for recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * - but seems safer to let them be archived and removed later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="xlogarchive.c.html#L694" title="access/transam/xlogarchive.c:694">XLogArchiveIsReady</a>(xlde-&gt;d_name))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3998" title="access/transam/xlog.c:3998">RemoveXlogFile</a>(xlde, recycleSegNo, &amp;endLogSegNo, newTLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2961" title="storage/file/fd.c:2961">FreeDir</a>(xldir);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recycle or remove a log file that's no longer needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * segment_de is the dirent structure of the segment to recycle or remove.<br/></li>
<li></span><span class="Comment"> * recycleSegNo is the segment number to recycle up to.&nbsp; endlogSegNo is<br/></li>
<li></span><span class="Comment"> * the segment number of the current (or recent) end of WAL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * endlogSegNo gets incremented if the segment is recycled so as it is not<br/></li>
<li></span><span class="Comment"> * checked again with future callers of this function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * insertTLI is the current timeline for XLOG insertion. Any recycled segments<br/></li>
<li></span><span class="Comment"> * should be used for this timeline.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3998">&#x200c;</a></span><span class="linkable">RemoveXlogFile</span>(<span class="Type">const</span> <span class="Type">struct</span> dirent *segment_de,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogSegNo recycleSegNo, XLogSegNo *endlogSegNo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimeLineID insertTLI)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; newpath[MAXPGPATH];<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *segname = segment_de-&gt;d_name;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(path, MAXPGPATH, XLOGDIR <span class="Constant">&quot;/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, segname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Before deleting the file, see if it can be recycled as a future log<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * segment. Only recycle normal files, because we don't want to recycle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * symbolic links pointing to a separate archive directory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L128" title="access/transam/xlog.c:128">wal_recycle</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *endlogSegNo &lt;= recycleSegNo &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InstallXLogFileSegmentActive &amp;&amp;&nbsp; &nbsp; <span class="Comment">/* callee rechecks this */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; get_dirent_type(path, segment_de, <span class="Constant">false</span>, DEBUG2) == PGFILETYPE_REG &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3552" title="access/transam/xlog.c:3552">InstallXLogFileSegment</a>(endlogSegNo, path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, recycleSegNo, insertTLI))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;recycled write-ahead log file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; segname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_segs_recycled++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Needn't recheck that slot on future iterations */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (*endlogSegNo)++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No need for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more future segments, or recycling failed ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;removing write-ahead log file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; segname)));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On Windows, if another process (e.g another backend) holds the file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * open in FILE_SHARE_DELETE mode, unlink will succeed, but the file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will still show up in directory listing until the last handle is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * closed. To avoid confusing the lingering deleted file for a live<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL file that needs to be archived, rename it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> deleting it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If another process holds the file open without FILE_SHARE_DELETE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * flag, rename will fail. We'll try again at the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(newpath, MAXPGPATH, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.deleted&quot;</span>, path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rename(path, newpath) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not rename file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../../storage/file/fd.c.html#L872" title="storage/file/fd.c:872">durable_unlink</a>(newpath, LOG);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../../storage/file/fd.c.html#L872" title="storage/file/fd.c:872">durable_unlink</a>(path, LOG);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Message already logged by <a href="../../storage/file/fd.c.html#L872" title="storage/file/fd.c:872">durable_unlink</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_segs_removed++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="xlogarchive.c.html#L712" title="access/transam/xlogarchive.c:712">XLogArchiveCleanup</a>(segname);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Verify whether pg_wal, pg_wal/archive_status, and pg_wal/summaries exist.<br/></li>
<li></span><span class="Comment"> * If the latter do not exist, recreate them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is not the goal of this function to verify the contents of these<br/></li>
<li></span><span class="Comment"> * directories, but to <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> in cases where someone has performed a <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a><br/></li>
<li></span><span class="Comment"> * copy for PITR purposes but omitted pg_wal from the copy.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We could also recreate pg_wal if it doesn't exist, but a deliberate<br/></li>
<li></span><span class="Comment"> * policy decision was made not to.&nbsp; It is fairly common for pg_wal to be<br/></li>
<li></span><span class="Comment"> * a symlink, and if that was the DBA's intent then automatically making a<br/></li>
<li></span><span class="Comment"> * plain directory would result in degraded performance with no notice.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4088">&#x200c;</a></span><span class="linkable">ValidateXLOGDirectoryStructure</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat stat_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for pg_wal; if it doesn't exist, error out */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stat(XLOGDIR, &amp;stat_buf) != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !S_ISDIR(stat_buf.st_mode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;required WAL directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLOGDIR)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for archive_status */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(path, MAXPGPATH, XLOGDIR <span class="Constant">&quot;/archive_status&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(path, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for weird cases where it exists but isn't a directory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!S_ISDIR(stat_buf.st_mode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;required WAL directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;creating missing WAL directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L3913" title="storage/file/fd.c:3913">MakePGDirectory</a>(path) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create missing directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for summaries */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(path, MAXPGPATH, XLOGDIR <span class="Constant">&quot;/summaries&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(path, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for weird cases where it exists but isn't a directory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!S_ISDIR(stat_buf.st_mode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;required WAL directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;creating missing WAL directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L3913" title="storage/file/fd.c:3913">MakePGDirectory</a>(path) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create missing directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove previous backup history files.&nbsp; This also retries creation of<br/></li>
<li></span><span class="Comment"> * .ready files for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backup history files for which <a href="xlogarchive.c.html#L444" title="access/transam/xlogarchive.c:444">XLogArchiveNotify</a><br/></li>
<li></span><span class="Comment"> * failed earlier.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4150">&#x200c;</a></span><span class="linkable">CleanupBackupHistory</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *xldir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *xlde;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(XLOGDIR)];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xldir = <a href="../../storage/file/fd.c.html#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(XLOGDIR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((xlde = <a href="../../storage/file/fd.c.html#L2909" title="storage/file/fd.c:2909">ReadDir</a>(xldir, XLOGDIR)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsBackupHistoryFileName(xlde-&gt;d_name))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogarchive.c.html#L565" title="access/transam/xlogarchive.c:565">XLogArchiveCheckDone</a>(xlde-&gt;d_name))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;removing WAL backup history file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlde-&gt;d_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(path, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(path), XLOGDIR <span class="Constant">&quot;/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, xlde-&gt;d_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unlink(path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogarchive.c.html#L712" title="access/transam/xlogarchive.c:712">XLogArchiveCleanup</a>(xlde-&gt;d_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2961" title="storage/file/fd.c:2961">FreeDir</a>(xldir);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * I/O routines for pg_control<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a> is a buffer in shared memory that holds an image of the<br/></li>
<li></span><span class="Comment"> * contents of pg_control.&nbsp; <a href="#L4228" title="access/transam/xlog.c:4228">WriteControlFile</a>() initializes pg_control<br/></li>
<li></span><span class="Comment"> * given a preloaded buffer, <a href="#L4310" title="access/transam/xlog.c:4310">ReadControlFile</a>() loads the buffer from<br/></li>
<li></span><span class="Comment"> * the pg_control file (during postmaster or standalone-backend startup),<br/></li>
<li></span><span class="Comment"> * and <a href="#L4526" title="access/transam/xlog.c:4526">UpdateControlFile</a>() rewrites pg_control after we modify xlog state.<br/></li>
<li></span><span class="Comment"> * <a href="#L4193" title="access/transam/xlog.c:4193">InitControlFile</a>() fills the buffer with initial <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For simplicity, <a href="#L4228" title="access/transam/xlog.c:4228">WriteControlFile</a>() initializes the fields of pg_control<br/></li>
<li></span><span class="Comment"> * that are related to checking backend/database compatibility, and<br/></li>
<li></span><span class="Comment"> * <a href="#L4310" title="access/transam/xlog.c:4310">ReadControlFile</a>() verifies they are correct.&nbsp; We could split out the<br/></li>
<li></span><span class="Comment"> * I/O and compatibility-check <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, but there seems no need currently.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4193">&#x200c;</a></span><span class="linkable">InitControlFile</span>(uint64 sysidentifier)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; mock_auth_nonce[MOCK_AUTH_NONCE_LEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate a random nonce. This is used for authentication requests that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will fail because the user does not exist. The nonce is used to create<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a genuine-looking password challenge for the non-existent user, in lieu<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of an actual stored password.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!pg_strong_random(mock_auth_nonce, MOCK_AUTH_NONCE_LEN))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERNAL_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not generate secret authorization token&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ControlFileData));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize pg_control status fields */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;system_identifier = sysidentifier;<br/></li>
<li>&nbsp; &nbsp; memcpy(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;mock_authentication_nonce, mock_auth_nonce, MOCK_AUTH_NONCE_LEN);<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;state = DB_SHUTDOWNED;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;unloggedLSN = FirstNormalUnloggedLSN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set important parameter <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for use when replaying WAL */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="../../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a> = <a href="../../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="../../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a> = <a href="../../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a> = <a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a> = <a href="twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="../../storage/lmgr/lock.c.html#L53" title="storage/lmgr/lock.c:53">max_locks_per_xact</a> = <a href="../../storage/lmgr/lock.c.html#L53" title="storage/lmgr/lock.c:53">max_locks_per_xact</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L131" title="access/transam/xlog.c:131">wal_level</a> = <a href="#L131" title="access/transam/xlog.c:131">wal_level</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L123" title="access/transam/xlog.c:123">wal_log_hints</a> = <a href="#L123" title="access/transam/xlog.c:123">wal_log_hints</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="commit_ts.c.html#L109" title="access/transam/commit_ts.c:109">track_commit_timestamp</a> = <a href="commit_ts.c.html#L109" title="access/transam/commit_ts.c:109">track_commit_timestamp</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;data_checksum_version = <a href="../../bootstrap/bootstrap.c.html#L44" title="bootstrap/bootstrap.c:44">bootstrap_data_checksum_version</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4228">&#x200c;</a></span><span class="linkable">WriteControlFile</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buffer[PG_CONTROL_FILE_SIZE];&nbsp; &nbsp; <span class="Comment">/* need not be aligned */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize version and compatibility-check fields<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;pg_control_version = PG_CONTROL_VERSION;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;catalog_version_no = CATALOG_VERSION_NO;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;maxAlign = MAXIMUM_ALIGNOF;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;floatFormat = FLOATFORMAT_VALUE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;blcksz = BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;relseg_size = RELSEG_SIZE;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;xlog_blcksz = XLOG_BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;xlog_seg_size = <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;nameDataLen = NAMEDATALEN;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;indexMaxKeys = INDEX_MAX_KEYS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;toast_max_chunk_size = TOAST_MAX_CHUNK_SIZE;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;loblksize = LOBLKSIZE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;float8ByVal = FLOAT8PASSBYVAL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Contents are protected with a CRC */<br/></li>
<li></span>&nbsp; &nbsp; INIT_CRC32C(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;crc);<br/></li>
<li>&nbsp; &nbsp; COMP_CRC32C(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;crc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">char</span> *) <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offsetof(ControlFileData, crc));<br/></li>
<li>&nbsp; &nbsp; FIN_CRC32C(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;crc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We write out PG_CONTROL_FILE_SIZE bytes into pg_control, zero-padding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the excess over <a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a>(ControlFileData).&nbsp; This reduces the odds of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * premature-EOF errors when reading pg_control.&nbsp; We'll still fail when we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check the contents of the file, but hopefully with a more specific<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error than &quot;couldn't read pg_control&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; memset(buffer, <span class="Constant">0</span>, PG_CONTROL_FILE_SIZE);<br/></li>
<li>&nbsp; &nbsp; memcpy(buffer, <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ControlFileData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L1087" title="storage/file/fd.c:1087">BasicOpenFile</a>(XLOG_CONTROL_FILE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; O_RDWR | O_CREAT | O_EXCL | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLOG_CONTROL_FILE)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_CONTROL_FILE_WRITE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (write(fd, buffer, PG_CONTROL_FILE_SIZE) != PG_CONTROL_FILE_SIZE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if write didn't set errno, assume problem is no disk space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ENOSPC</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write to file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLOG_CONTROL_FILE)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_CONTROL_FILE_SYNC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L386" title="storage/file/fd.c:386">pg_fsync</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fsync file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLOG_CONTROL_FILE)));<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (close(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLOG_CONTROL_FILE)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4310">&#x200c;</a></span><span class="linkable">ReadControlFile</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_crc32c&nbsp; &nbsp; crc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> wal_segsz_str[<span class="Constant">20</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read data...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L1087" title="storage/file/fd.c:1087">BasicOpenFile</a>(XLOG_CONTROL_FILE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; O_RDWR | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLOG_CONTROL_FILE)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_CONTROL_FILE_READ);<br/></li>
<li>&nbsp; &nbsp; r = read(fd, <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ControlFileData));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (r != <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ControlFileData))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLOG_CONTROL_FILE)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: read </span><span class="Special">%d</span><span class="Constant"> of </span><span class="Special">%zu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLOG_CONTROL_FILE, r, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ControlFileData))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; close(fd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for expected pg_control format version.&nbsp; If this is wrong, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CRC check will likely fail because we'll be checking the wrong number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of bytes.&nbsp; Complaining about wrong version will probably be more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enlightening than complaining about wrong CRC.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;pg_control_version != PG_CONTROL_VERSION &amp;&amp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;pg_control_version % <span class="Constant">65536</span> == <span class="Constant">0</span> &amp;&amp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;pg_control_version / <span class="Constant">65536</span> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database files are incompatible with server&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The database <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> was initialized with PG_CONTROL_VERSION </span><span class="Special">%d</span><span class="Constant"> (0x</span><span class="Special">%08x</span><span class="Constant">),&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; but the server was compiled with PG_CONTROL_VERSION </span><span class="Special">%d</span><span class="Constant"> (0x</span><span class="Special">%08x</span><span class="Constant">).&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;pg_control_version, <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;pg_control_version,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_CONTROL_VERSION, PG_CONTROL_VERSION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;This could be a problem of mismatched byte ordering.&nbsp; It looks like you need to initdb.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;pg_control_version != PG_CONTROL_VERSION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database files are incompatible with server&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The database <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> was initialized with PG_CONTROL_VERSION </span><span class="Special">%d</span><span class="Constant">,&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; but the server was compiled with PG_CONTROL_VERSION </span><span class="Special">%d</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;pg_control_version, PG_CONTROL_VERSION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;It looks like you need to initdb.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now check the CRC. */<br/></li>
<li></span>&nbsp; &nbsp; INIT_CRC32C(crc);<br/></li>
<li>&nbsp; &nbsp; COMP_CRC32C(crc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">char</span> *) <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offsetof(ControlFileData, crc));<br/></li>
<li>&nbsp; &nbsp; FIN_CRC32C(crc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!EQ_CRC32C(crc, <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;crc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;incorrect checksum in control file&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do compatibility checking immediately.&nbsp; If the database isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compatible with the backend executable, we want to abort <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibly do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> damage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;catalog_version_no != CATALOG_VERSION_NO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database files are incompatible with server&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The database <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> was initialized with CATALOG_VERSION_NO </span><span class="Special">%d</span><span class="Constant">,&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; but the server was compiled with CATALOG_VERSION_NO </span><span class="Special">%d</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;catalog_version_no, CATALOG_VERSION_NO),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;It looks like you need to initdb.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;maxAlign != MAXIMUM_ALIGNOF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database files are incompatible with server&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The database <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> was initialized with MAXALIGN </span><span class="Special">%d</span><span class="Constant">,&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; but the server was compiled with MAXALIGN </span><span class="Special">%d</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;maxAlign, MAXIMUM_ALIGNOF),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;It looks like you need to initdb.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;floatFormat != FLOATFORMAT_VALUE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database files are incompatible with server&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The database <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> appears to use a different floating-point number format than the server executable.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;It looks like you need to initdb.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;blcksz != BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database files are incompatible with server&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The database <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> was initialized with BLCKSZ </span><span class="Special">%d</span><span class="Constant">,&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; but the server was compiled with BLCKSZ </span><span class="Special">%d</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;blcksz, BLCKSZ),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;It looks like you need to recompile or initdb.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;relseg_size != RELSEG_SIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database files are incompatible with server&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The database <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> was initialized with RELSEG_SIZE </span><span class="Special">%d</span><span class="Constant">,&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; but the server was compiled with RELSEG_SIZE </span><span class="Special">%d</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;relseg_size, RELSEG_SIZE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;It looks like you need to recompile or initdb.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;xlog_blcksz != XLOG_BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database files are incompatible with server&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The database <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> was initialized with XLOG_BLCKSZ </span><span class="Special">%d</span><span class="Constant">,&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; but the server was compiled with XLOG_BLCKSZ </span><span class="Special">%d</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;xlog_blcksz, XLOG_BLCKSZ),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;It looks like you need to recompile or initdb.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;nameDataLen != NAMEDATALEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database files are incompatible with server&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The database <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> was initialized with NAMEDATALEN </span><span class="Special">%d</span><span class="Constant">,&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; but the server was compiled with NAMEDATALEN </span><span class="Special">%d</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;nameDataLen, NAMEDATALEN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;It looks like you need to recompile or initdb.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;indexMaxKeys != INDEX_MAX_KEYS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database files are incompatible with server&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The database <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> was initialized with INDEX_MAX_KEYS </span><span class="Special">%d</span><span class="Constant">,&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; but the server was compiled with INDEX_MAX_KEYS </span><span class="Special">%d</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;indexMaxKeys, INDEX_MAX_KEYS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;It looks like you need to recompile or initdb.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;toast_max_chunk_size != TOAST_MAX_CHUNK_SIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database files are incompatible with server&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The database <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> was initialized with TOAST_MAX_CHUNK_SIZE </span><span class="Special">%d</span><span class="Constant">,&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; but the server was compiled with TOAST_MAX_CHUNK_SIZE </span><span class="Special">%d</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;toast_max_chunk_size, (<span class="Type">int</span>) TOAST_MAX_CHUNK_SIZE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;It looks like you need to recompile or initdb.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;loblksize != LOBLKSIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database files are incompatible with server&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The database <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> was initialized with LOBLKSIZE </span><span class="Special">%d</span><span class="Constant">,&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; but the server was compiled with LOBLKSIZE </span><span class="Special">%d</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;loblksize, (<span class="Type">int</span>) LOBLKSIZE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;It looks like you need to recompile or initdb.&quot;</span>)));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_FLOAT8_BYVAL<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;float8ByVal != <span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database files are incompatible with server&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The database <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> was initialized without USE_FLOAT8_BYVAL&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; but the server was compiled with USE_FLOAT8_BYVAL.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;It looks like you need to recompile or initdb.&quot;</span>)));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;float8ByVal != <span class="Constant">false</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database files are incompatible with server&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The database <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> was initialized with USE_FLOAT8_BYVAL&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; but the server was compiled without USE_FLOAT8_BYVAL.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;It looks like you need to recompile or initdb.&quot;</span>)));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a> = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;xlog_seg_size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!IsValidWalSegSize(<a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR, (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1182" title="utils/error/elog.c:1182">errmsg_plural</a>(<span class="Constant">&quot;invalid WAL segment size in control file (</span><span class="Special">%d</span><span class="Constant"> byte)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;invalid WAL segment size in control file (</span><span class="Special">%d</span><span class="Constant"> bytes)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The WAL segment size must be a power of two between 1 MB and 1 GB.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(wal_segsz_str, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(wal_segsz_str), <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>&quot;</span>, wal_segsz_str, PGC_INTERNAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_S_DYNAMIC_DEFAULT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check and update variables dependent on <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L598" title="access/transam/xlog.c:598">ConvertToXSegs</a>(<a href="#L115" title="access/transam/xlog.c:115">min_wal_size_mb</a>, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>) &lt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR, (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;min_wal_size must be at least twice <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L598" title="access/transam/xlog.c:598">ConvertToXSegs</a>(<a href="#L114" title="access/transam/xlog.c:114">max_wal_size_mb</a>, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>) &lt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR, (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;max_wal_size must be at least twice <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L601" title="access/transam/xlog.c:601">UsableBytesInSegment</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a> / XLOG_BLCKSZ * <a href="#L592" title="access/transam/xlog.c:592">UsableBytesInPage</a>) -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (SizeOfXLogLongPHD - SizeOfXLogShortPHD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2157" title="access/transam/xlog.c:2157">CalculateCheckpointSegments</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make the initdb settings visible as GUC variables, too */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../../utils/misc/guc_tables.c.html#L603" title="utils/misc/guc_tables.c:603">data_checksums</a>&quot;</span>, <a href="#L4555" title="access/transam/xlog.c:4555">DataChecksumsEnabled</a>() ? <span class="Constant">&quot;yes&quot;</span> : <span class="Constant">&quot;no&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_INTERNAL, PGC_S_DYNAMIC_DEFAULT);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Utility wrapper to update the control file.&nbsp; Note that the control<br/></li>
<li></span><span class="Comment"> * file gets flushed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4526">&#x200c;</a></span><span class="linkable">UpdateControlFile</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; update_controlfile(<a href="../../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns the unique system identifier from control file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint64<br/></li>
<li><a id="L4535">&#x200c;</a><span class="linkable">GetSystemIdentifier</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;system_identifier;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns the random nonce from control file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L4545">&#x200c;</a><span class="linkable">GetMockAuthenticationNonce</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;mock_authentication_nonce;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Are checksums enabled for data pages?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4555">&#x200c;</a></span><span class="linkable">DataChecksumsEnabled</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;data_checksum_version &gt; <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns a fake LSN for unlogged relations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Each call generates an LSN that is greater than <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> previous value<br/></li>
<li></span><span class="Comment"> * returned. The current counter value is saved and restored across clean<br/></li>
<li></span><span class="Comment"> * shutdowns, but like unlogged relations, does not survive a crash. This can<br/></li>
<li></span><span class="Comment"> * be used in lieu of real LSN <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> returned by <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>, if you need an<br/></li>
<li></span><span class="Comment"> * LSN-like increasing sequence of numbers without writing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WAL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L4571">&#x200c;</a><span class="linkable">GetFakeLSNForUnloggedRel</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_atomic_fetch_add_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;unloggedLSN, <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Auto-tune the number of XLOG buffers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The preferred setting for wal_buffers is about 3% of shared_buffers, with<br/></li>
<li></span><span class="Comment"> * a maximum of one XLOG segment (there is little reason to think that more<br/></li>
<li></span><span class="Comment"> * is helpful, at least so long as we force an fsync when switching log files)<br/></li>
<li></span><span class="Comment"> * and a minimum of 8 blocks (which was the default value prior to PostgreSQL<br/></li>
<li></span><span class="Comment"> * 9.1, when auto-tuning was added).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should not be called until <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> has received its final value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L4588">&#x200c;</a></span><span class="linkable">XLOGChooseNumBuffers</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xbuffers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xbuffers = <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> / <span class="Constant">32</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xbuffers &gt; (<a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a> / XLOG_BLCKSZ))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xbuffers = (<a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a> / XLOG_BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xbuffers &lt; <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xbuffers = <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> xbuffers;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for wal_buffers<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4604">&#x200c;</a></span><span class="linkable">check_wal_buffers</span>(<span class="Type">int</span> *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * -1 indicates a request for auto-tune.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we haven't yet changed the boot_val default of -1, just let it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be.&nbsp; We'll fix it when <a href="#L4835" title="access/transam/xlog.c:4835">XLOGShmemSize</a> is called.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L117" title="access/transam/xlog.c:117">XLOGbuffers</a> == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise, substitute the auto-tune value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = <a href="#L4588" title="access/transam/xlog.c:4588">XLOGChooseNumBuffers</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We clamp manually-set <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to at least 4 blocks.&nbsp; Prior to PostgreSQL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 9.1, a minimum of 4 was enforced by guc.c, but since that is no longer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the case, we just silently treat such <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> as a request for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * minimum.&nbsp; (We could throw an error instead, but that doesn't seem very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * helpful.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> &lt; <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = <span class="Constant">4</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for <a href="#L126" title="access/transam/xlog.c:126">wal_consistency_checking</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4639">&#x200c;</a></span><span class="linkable">check_wal_consistency_checking</span>(<span class="Type">char</span> **<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *rawstring;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *elemlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; newwalconsistency[RM_MAX_ID + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the array */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(newwalconsistency, <span class="Constant">0</span>, (RM_MAX_ID + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need a modifiable copy of string */<br/></li>
<li></span>&nbsp; &nbsp; rawstring = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(*<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Parse string into list of identifiers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/adt/varlena.c.html#L3457" title="utils/adt/varlena.c:3457">SplitIdentifierString</a>(rawstring, <span class="Constant">','</span>, &amp;elemlist))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* syntax error in list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;List syntax is invalid.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rawstring);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(elemlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, elemlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tok = (<span class="Type">char</span> *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rmid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for 'all'. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_strcasecmp(tok, <span class="Constant">&quot;all&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (rmid = <span class="Constant">0</span>; rmid &lt;= RM_MAX_ID; rmid++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RmgrIdExists(rmid) &amp;&amp; GetRmgr(rmid).rm_mask != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newwalconsistency[rmid] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if the token matches <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> known resource manager. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (rmid = <span class="Constant">0</span>; rmid &lt;= RM_MAX_ID; rmid++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RmgrIdExists(rmid) &amp;&amp; GetRmgr(rmid).rm_mask != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_strcasecmp(tok, GetRmgr(rmid).rm_name) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newwalconsistency[rmid] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * During startup, it might be a not-yet-loaded custom<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * resource manager.&nbsp; Defer checking until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L4751" title="access/transam/xlog.c:4751">InitializeWalConsistencyChecking</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/init/miscinit.c.html#L1779" title="utils/init/miscinit.c:1779">process_shared_preload_libraries_done</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="access/transam/xlog.c:166">check_wal_consistency_checking_deferred</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;Unrecognized key <a href="../../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>, tok);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rawstring);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(elemlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rawstring);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(elemlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* assign new value */<br/></li>
<li></span>&nbsp; &nbsp; *extra = <a href="../../utils/misc/guc.c.html#L640" title="utils/misc/guc.c:640">guc_malloc</a>(ERROR, (RM_MAX_ID + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; memcpy(*extra, newwalconsistency, (RM_MAX_ID + <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC assign_hook for <a href="#L126" title="access/transam/xlog.c:126">wal_consistency_checking</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4724">&#x200c;</a></span><span class="linkable">assign_wal_consistency_checking</span>(<span class="Type">const</span> <span class="Type">char</span> *<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If some checks were deferred, it's possible that the checks will fail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * later during <a href="#L4751" title="access/transam/xlog.c:4751">InitializeWalConsistencyChecking</a>(). But in that case, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * postmaster will exit anyway, so it's safe to proceed with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assignment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Any built-in resource managers specified are assigned immediately,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which affects WAL created <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> shared_preload_libraries are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processed. Any custom resource managers specified won't be assigned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until after shared_preload_libraries are processed, but that's OK<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because WAL for a custom resource manager can't be written <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * module is loaded anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L126" title="access/transam/xlog.c:126">wal_consistency_checking</a> = extra;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4751" title="access/transam/xlog.c:4751">InitializeWalConsistencyChecking</a>: run after loading custom resource managers<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unknown resource managers were specified in the<br/></li>
<li></span><span class="Comment"> * <a href="#L126" title="access/transam/xlog.c:126">wal_consistency_checking</a> GUC, processing was deferred.&nbsp; Now that<br/></li>
<li></span><span class="Comment"> * shared_preload_libraries have been loaded, process <a href="#L126" title="access/transam/xlog.c:126">wal_consistency_checking</a><br/></li>
<li></span><span class="Comment"> * again.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4751">&#x200c;</a></span><span class="linkable">InitializeWalConsistencyChecking</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../utils/init/miscinit.c.html#L1779" title="utils/init/miscinit.c:1779">process_shared_preload_libraries_done</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L166" title="access/transam/xlog.c:166">check_wal_consistency_checking_deferred</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> config_generic *guc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; guc = <a href="../../utils/misc/guc.c.html#L1237" title="utils/misc/guc.c:1237">find_option</a>(<span class="Constant">&quot;<a href="#L126" title="access/transam/xlog.c:126">wal_consistency_checking</a>&quot;</span>, <span class="Constant">false</span>, <span class="Constant">false</span>, ERROR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="access/transam/xlog.c:166">check_wal_consistency_checking_deferred</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L3383" title="utils/misc/guc.c:3383">set_config_option_ext</a>(<span class="Constant">&quot;<a href="#L126" title="access/transam/xlog.c:126">wal_consistency_checking</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L125" title="access/transam/xlog.c:125">wal_consistency_checking_string</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; guc-&gt;scontext, guc-&gt;source, guc-&gt;srole,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GUC_ACTION_SET, <span class="Constant">true</span>, ERROR, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* checking should not be deferred again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="#L166" title="access/transam/xlog.c:166">check_wal_consistency_checking_deferred</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC show_hook for archive_command<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L4777">&#x200c;</a><span class="linkable">show_archive_command</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (XLogArchivingActive())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L120" title="access/transam/xlog.c:120">XLogArchiveCommand</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;(disabled)&quot;</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC show_hook for in_hot_standby<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L4789">&#x200c;</a><span class="linkable">show_in_hot_standby</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We display the actual state based on shared memory, so that this GUC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reports up-to-date state if examined intra-query.&nbsp; The underlying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * variable (<a href="../../utils/misc/guc_tables.c.html#L623" title="utils/misc/guc_tables.c:623">in_hot_standby_guc</a>) changes only when we transmit a new value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the client.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>() ? <span class="Constant">&quot;on&quot;</span> : <span class="Constant">&quot;off&quot;</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read the control file, set respective GUCs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is to be called during startup, including a crash recovery cycle,<br/></li>
<li></span><span class="Comment"> * unless in bootstrap mode, where no control file yet exists.&nbsp; As there's no<br/></li>
<li></span><span class="Comment"> * usable shared memory yet (its sizing can depend on the contents of the<br/></li>
<li></span><span class="Comment"> * control file!), first store the contents in local memory. <a href="#L4885" title="access/transam/xlog.c:4885">XLOGShmemInit</a>()<br/></li>
<li></span><span class="Comment"> * will then copy it to shared memory later.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * reset just controls whether previous contents are to be expected (in the<br/></li>
<li></span><span class="Comment"> * reset case, there's a dangling pointer into old shared memory), or not.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4813">&#x200c;</a></span><span class="linkable">LocalProcessControlFile</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> reset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(reset || <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a> == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a> = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ControlFileData));<br/></li>
<li>&nbsp; &nbsp; <a href="#L4310" title="access/transam/xlog.c:4310">ReadControlFile</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the <a href="#L131" title="access/transam/xlog.c:131">wal_level</a> from the control file. For a standby, this value should be<br/></li>
<li></span><span class="Comment"> * considered as its active <a href="#L131" title="access/transam/xlog.c:131">wal_level</a>, because it may be different from what<br/></li>
<li></span><span class="Comment"> * was originally configured on standby.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>WalLevel<br/></li>
<li><a id="L4826">&#x200c;</a><span class="linkable">GetActiveWalLevelOnStandby</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L131" title="access/transam/xlog.c:131">wal_level</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialization of shared memory for XLOG<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L4835">&#x200c;</a><span class="linkable">XLOGShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the value of wal_buffers is -1, use the preferred auto-tune value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This isn't an amazingly clean place to do this, but we must wait till<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> has received its final value, and must do it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> using the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value of <a href="#L117" title="access/transam/xlog.c:117">XLOGbuffers</a> to do anything important.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We prefer to report this value's source as PGC_S_DYNAMIC_DEFAULT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, if the DBA explicitly set wal_buffers = -1 in the config file,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then PGC_S_DYNAMIC_DEFAULT will fail to override that and we must force<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the matter with PGC_S_OVERRIDE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L117" title="access/transam/xlog.c:117">XLOGbuffers</a> == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buf[<span class="Constant">32</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buf), <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="#L4588" title="access/transam/xlog.c:4588">XLOGChooseNumBuffers</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;wal_buffers&quot;</span>, buf, PGC_POSTMASTER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_S_DYNAMIC_DEFAULT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L117" title="access/transam/xlog.c:117">XLOGbuffers</a> == -<span class="Constant">1</span>)&nbsp; &nbsp; <span class="Comment">/* failed to apply it? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;wal_buffers&quot;</span>, buf, PGC_POSTMASTER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_S_OVERRIDE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L117" title="access/transam/xlog.c:117">XLOGbuffers</a> &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a> */<br/></li>
<li></span>&nbsp; &nbsp; size = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L450" title="access/transam/xlog.c:450">XLogCtlData</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* WAL insertion locks, plus alignment */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L381" title="access/transam/xlog.c:381">WALInsertLockPadded</a>), <a href="#L150" title="access/transam/xlog.c:150">NUM_XLOGINSERT_LOCKS</a> + <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* xlblocks array */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pg_atomic_uint64), <a href="#L117" title="access/transam/xlog.c:117">XLOGbuffers</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* extra alignment padding for XLOG I/O buffers */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, Max(XLOG_BLCKSZ, PG_IO_ALIGN_SIZE));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and the buffers themselves */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(XLOG_BLCKSZ, <a href="#L117" title="access/transam/xlog.c:117">XLOGbuffers</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we don't count ControlFileData, it comes out of the &quot;slop factor&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * added by <a href="../../storage/ipc/ipci.c.html#L199" title="storage/ipc/ipci.c:199">CreateSharedMemoryAndSemaphores</a>.&nbsp; This lets us use this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * routine again below to compute the actual allocation size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L4885">&#x200c;</a></span><span class="linkable">XLOGShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; foundCFile,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foundXLog;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *allocptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; ControlFileData *localControlFile;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WAL_DEBUG<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a memory context for WAL debugging that's exempt from the normal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;no pallocs in critical section&quot; rule. Yes, that can lead to a PANIC if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an allocation fails, but wal_debug is not for production use anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L650" title="access/transam/xlog.c:650">walDebugCxt</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L650" title="access/transam/xlog.c:650">walDebugCxt</a> = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;WAL Debug&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L694" title="utils/mmgr/mcxt.c:694">MemoryContextAllowInCriticalSection</a>(<a href="#L650" title="access/transam/xlog.c:650">walDebugCxt</a>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a> = (<a href="#L450" title="access/transam/xlog.c:450">XLogCtlData</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;XLOG Ctl&quot;</span>, <a href="#L4835" title="access/transam/xlog.c:4835">XLOGShmemSize</a>(), &amp;foundXLog);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; localControlFile = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a> = (ControlFileData *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;Control File&quot;</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ControlFileData), &amp;foundCFile);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (foundCFile || foundXLog)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* both should be present or neither */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(foundCFile &amp;&amp; foundXLog);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize local copy of <a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a> = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>.<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (localControlFile)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(localControlFile);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; memset(<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L450" title="access/transam/xlog.c:450">XLogCtlData</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Already have read control file locally, unless in bootstrap mode. Move<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contents into shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (localControlFile)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>, localControlFile, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ControlFileData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(localControlFile);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since <a href="#L450" title="access/transam/xlog.c:450">XLogCtlData</a> contains XLogRecPtr fields, its <a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a> should be a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multiple of the alignment for same, so no extra alignment padding is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needed here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; allocptr = ((<span class="Type">char</span> *) <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L450" title="access/transam/xlog.c:450">XLogCtlData</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;xlblocks = (pg_atomic_uint64 *) allocptr;<br/></li>
<li>&nbsp; &nbsp; allocptr += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pg_atomic_uint64) * <a href="#L117" title="access/transam/xlog.c:117">XLOGbuffers</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L117" title="access/transam/xlog.c:117">XLOGbuffers</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;xlblocks[i], InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* WAL insertion locks. Ensure they're aligned to the full padded size */<br/></li>
<li></span>&nbsp; &nbsp; allocptr += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L381" title="access/transam/xlog.c:381">WALInsertLockPadded</a>) -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">uintptr_t</span>) allocptr) % <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L381" title="access/transam/xlog.c:381">WALInsertLockPadded</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a> = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>.<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L381" title="access/transam/xlog.c:381">WALInsertLockPadded</a> *) allocptr;<br/></li>
<li>&nbsp; &nbsp; allocptr += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L381" title="access/transam/xlog.c:381">WALInsertLockPadded</a>) * <a href="#L150" title="access/transam/xlog.c:150">NUM_XLOGINSERT_LOCKS</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L150" title="access/transam/xlog.c:150">NUM_XLOGINSERT_LOCKS</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[i].l.lock, LWTRANCHE_WAL_INSERT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u64(&amp;<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[i].l.insertingAt, InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[i].l.lastImportantAt = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Align the start of the page buffers to a full xlog block size boundary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This simplifies some calculations in XLOG insertion. It is also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * required for O_DIRECT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; allocptr = (<span class="Type">char</span> *) TYPEALIGN(XLOG_BLCKSZ, allocptr);<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;pages = allocptr;<br/></li>
<li>&nbsp; &nbsp; memset(<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;pages, <span class="Constant">0</span>, (Size) XLOG_BLCKSZ * <a href="#L117" title="access/transam/xlog.c:117">XLOGbuffers</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do basic initialization of <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a> shared data. (<a href="#L5388" title="access/transam/xlog.c:5388">StartupXLOG</a> will fill<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in additional info.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;XLogCacheBlck = <a href="#L117" title="access/transam/xlog.c:117">XLOGbuffers</a> - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;SharedRecoveryState = RECOVERY_STATE_CRASH;<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InstallXLogFileSegmentActive = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;WalWriterSleeping = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockInit(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>.insertpos_lck);<br/></li>
<li>&nbsp; &nbsp; SpinLockInit(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; pg_atomic_init_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;logInsertResult, InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; pg_atomic_init_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;logWriteResult, InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; pg_atomic_init_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;logFlushResult, InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; pg_atomic_init_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;unloggedLSN, InvalidXLogRecPtr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This func must be called ONCE on system install.&nbsp; It creates pg_control<br/></li>
<li></span><span class="Comment"> * and the initial XLOG segment.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5000">&#x200c;</a></span><span class="linkable">BootStrapXLOG</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CheckPoint&nbsp; &nbsp; checkPoint;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buffer;<br/></li>
<li>&nbsp; &nbsp; XLogPageHeader page;<br/></li>
<li>&nbsp; &nbsp; XLogLongPageHeader longpage;<br/></li>
<li>&nbsp; &nbsp; XLogRecord *record;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *recptr;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; sysidentifier;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> timeval tv;<br/></li>
<li>&nbsp; &nbsp; pg_crc32c&nbsp; &nbsp; crc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allow ordinary WAL segment creation, like <a href="#L5388" title="access/transam/xlog.c:5388">StartupXLOG</a>() would */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L9404" title="access/transam/xlog.c:9404">SetInstallXLogFileSegmentActive</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Select a hopefully-unique system identifier code for this installation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the result of gettimeofday(), including the fractional seconds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * field, as being about as unique as we can easily get.&nbsp; (Think not to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use random(), since it hasn't been seeded and there's no portable way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to seed it other than the system clock value...)&nbsp; The <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> half of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * uint64 value is just the tv_sec part, while the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> half contains the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tv_usec part (which must fit in 20 bits), plus 12 bits from our current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PID for a little extra uniqueness.&nbsp; A person knowing this encoding can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * determine the initialization time of the installation, which could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * perhaps be useful sometimes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; gettimeofday(&amp;tv, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; sysidentifier = ((uint64) tv.tv_sec) &lt;&lt; <span class="Constant">32</span>;<br/></li>
<li>&nbsp; &nbsp; sysidentifier |= ((uint64) tv.tv_usec) &lt;&lt; <span class="Constant">12</span>;<br/></li>
<li>&nbsp; &nbsp; sysidentifier |= getpid() &amp; <span class="Constant">0xFFF</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* page buffer must be aligned suitably for O_DIRECT */<br/></li>
<li></span>&nbsp; &nbsp; buffer = (<span class="Type">char</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(XLOG_BLCKSZ + XLOG_BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; page = (XLogPageHeader) TYPEALIGN(XLOG_BLCKSZ, buffer);<br/></li>
<li>&nbsp; &nbsp; memset(page, <span class="Constant">0</span>, XLOG_BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up information for the initial checkpoint record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The initial checkpoint record is written to the beginning of the WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * segment with logid=0 logseg=1. The very first WAL segment, 0/0, is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used, so that we can use 0/0 to mean &quot;<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> valid WAL segment&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; checkPoint.redo = <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a> + SizeOfXLogLongPHD;<br/></li>
<li>&nbsp; &nbsp; checkPoint.ThisTimeLineID = <a href="#L111" title="access/transam/xlog.c:111">BootstrapTimeLineID</a>;<br/></li>
<li>&nbsp; &nbsp; checkPoint.PrevTimeLineID = <a href="#L111" title="access/transam/xlog.c:111">BootstrapTimeLineID</a>;<br/></li>
<li>&nbsp; &nbsp; checkPoint.<a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a> = <a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a>;<br/></li>
<li>&nbsp; &nbsp; checkPoint.nextXid =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FullTransactionIdFromEpochAndXid(<span class="Constant">0</span>, FirstNormalTransactionId);<br/></li>
<li>&nbsp; &nbsp; checkPoint.nextOid = FirstGenbkiObjectId;<br/></li>
<li>&nbsp; &nbsp; checkPoint.nextMulti = FirstMultiXactId;<br/></li>
<li>&nbsp; &nbsp; checkPoint.nextMultiOffset = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; checkPoint.oldestXid = FirstNormalTransactionId;<br/></li>
<li>&nbsp; &nbsp; checkPoint.oldestXidDB = Template1DbOid;<br/></li>
<li>&nbsp; &nbsp; checkPoint.oldestMulti = FirstMultiXactId;<br/></li>
<li>&nbsp; &nbsp; checkPoint.oldestMultiDB = Template1DbOid;<br/></li>
<li>&nbsp; &nbsp; checkPoint.oldestCommitTsXid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; checkPoint.newestCommitTsXid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; checkPoint.time = (pg_time_t) time(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; checkPoint.oldestActiveXid = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid = checkPoint.nextXid;<br/></li>
<li>&nbsp; &nbsp; <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextOid = checkPoint.nextOid;<br/></li>
<li>&nbsp; &nbsp; <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oidCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="multixact.c.html#L2279" title="access/transam/multixact.c:2279">MultiXactSetNextMXact</a>(checkPoint.nextMulti, checkPoint.nextMultiOffset);<br/></li>
<li>&nbsp; &nbsp; <a href="varsup.c.html#L355" title="access/transam/varsup.c:355">AdvanceOldestClogXid</a>(checkPoint.oldestXid);<br/></li>
<li>&nbsp; &nbsp; <a href="varsup.c.html#L372" title="access/transam/varsup.c:372">SetTransactionIdLimit</a>(checkPoint.oldestXid, checkPoint.oldestXidDB);<br/></li>
<li>&nbsp; &nbsp; <a href="multixact.c.html#L2313" title="access/transam/multixact.c:2313">SetMultiXactIdLimit</a>(checkPoint.oldestMulti, checkPoint.oldestMultiDB, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="commit_ts.c.html#L909" title="access/transam/commit_ts.c:909">SetCommitTsLimit</a>(InvalidTransactionId, InvalidTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up the XLOG page header */<br/></li>
<li></span>&nbsp; &nbsp; page-&gt;xlp_magic = XLOG_PAGE_MAGIC;<br/></li>
<li>&nbsp; &nbsp; page-&gt;xlp_info = XLP_LONG_HEADER;<br/></li>
<li>&nbsp; &nbsp; page-&gt;xlp_tli = <a href="#L111" title="access/transam/xlog.c:111">BootstrapTimeLineID</a>;<br/></li>
<li>&nbsp; &nbsp; page-&gt;xlp_pageaddr = <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>;<br/></li>
<li>&nbsp; &nbsp; longpage = (XLogLongPageHeader) page;<br/></li>
<li>&nbsp; &nbsp; longpage-&gt;xlp_sysid = sysidentifier;<br/></li>
<li>&nbsp; &nbsp; longpage-&gt;xlp_seg_size = <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>;<br/></li>
<li>&nbsp; &nbsp; longpage-&gt;xlp_xlog_blcksz = XLOG_BLCKSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> the initial checkpoint record */<br/></li>
<li></span>&nbsp; &nbsp; recptr = ((<span class="Type">char</span> *) page + SizeOfXLogLongPHD);<br/></li>
<li>&nbsp; &nbsp; record = (XLogRecord *) recptr;<br/></li>
<li>&nbsp; &nbsp; record-&gt;xl_prev = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; record-&gt;xl_xid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; record-&gt;xl_tot_len = SizeOfXLogRecord + SizeOfXLogRecordDataHeaderShort + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(checkPoint);<br/></li>
<li>&nbsp; &nbsp; record-&gt;xl_info = XLOG_CHECKPOINT_SHUTDOWN;<br/></li>
<li>&nbsp; &nbsp; record-&gt;xl_rmid = RM_XLOG_ID;<br/></li>
<li>&nbsp; &nbsp; recptr += SizeOfXLogRecord;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fill the XLogRecordDataHeaderShort struct */<br/></li>
<li></span>&nbsp; &nbsp; *(recptr++) = (<span class="Type">char</span>) XLR_BLOCK_ID_DATA_SHORT;<br/></li>
<li>&nbsp; &nbsp; *(recptr++) = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(checkPoint);<br/></li>
<li>&nbsp; &nbsp; memcpy(recptr, &amp;checkPoint, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(checkPoint));<br/></li>
<li>&nbsp; &nbsp; recptr += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(checkPoint);<br/></li>
<li>&nbsp; &nbsp; Assert(recptr - (<span class="Type">char</span> *) record == record-&gt;xl_tot_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; INIT_CRC32C(crc);<br/></li>
<li>&nbsp; &nbsp; COMP_CRC32C(crc, ((<span class="Type">char</span> *) record) + SizeOfXLogRecord, record-&gt;xl_tot_len - SizeOfXLogRecord);<br/></li>
<li>&nbsp; &nbsp; COMP_CRC32C(crc, (<span class="Type">char</span> *) record, offsetof(XLogRecord, xl_crc));<br/></li>
<li>&nbsp; &nbsp; FIN_CRC32C(crc);<br/></li>
<li>&nbsp; &nbsp; record-&gt;xl_crc = crc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create first XLOG segment file */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L632" title="access/transam/xlog.c:632">openLogTLI</a> = <a href="#L111" title="access/transam/xlog.c:111">BootstrapTimeLineID</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L630" title="access/transam/xlog.c:630">openLogFile</a> = <a href="#L3369" title="access/transam/xlog.c:3369">XLogFileInit</a>(<span class="Constant">1</span>, <a href="#L111" title="access/transam/xlog.c:111">BootstrapTimeLineID</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We needn't bother with Reserve/<a href="../../storage/file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a> here, since we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * close the file again in a moment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write the first page with the initial record */<br/></li>
<li></span>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_WAL_BOOTSTRAP_WRITE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (write(<a href="#L630" title="access/transam/xlog.c:630">openLogFile</a>, page, XLOG_BLCKSZ) != XLOG_BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if write didn't set errno, assume problem is no disk space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ENOSPC</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write bootstrap write-ahead log file: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_WAL_BOOTSTRAP_SYNC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L386" title="storage/file/fd.c:386">pg_fsync</a>(<a href="#L630" title="access/transam/xlog.c:630">openLogFile</a>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fsync bootstrap write-ahead log file: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (close(<a href="#L630" title="access/transam/xlog.c:630">openLogFile</a>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close bootstrap write-ahead log file: %m&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L630" title="access/transam/xlog.c:630">openLogFile</a> = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now create pg_control */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4193" title="access/transam/xlog.c:4193">InitControlFile</a>(sysidentifier);<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;time = checkPoint.time;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPoint = checkPoint.redo;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy = checkPoint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* some additional <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a> fields are set in <a href="#L4228" title="access/transam/xlog.c:4228">WriteControlFile</a>() */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4228" title="access/transam/xlog.c:4228">WriteControlFile</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Bootstrap the commit log, too */<br/></li>
<li></span>&nbsp; &nbsp; <a href="clog.c.html#L833" title="access/transam/clog.c:833">BootStrapCLOG</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="commit_ts.c.html#L596" title="access/transam/commit_ts.c:596">BootStrapCommitTs</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="subtrans.c.html#L270" title="access/transam/subtrans.c:270">BootStrapSUBTRANS</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="multixact.c.html#L1985" title="access/transam/multixact.c:1985">BootStrapMultiXact</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Force control file to be read - in contrast to normal processing we'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise never run the checks and GUC related initializations therein.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4310" title="access/transam/xlog.c:4310">ReadControlFile</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L5165">&#x200c;</a><span class="linkable">str_time</span>(pg_time_t tnow)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> buf[<span class="Constant">128</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_strftime(buf, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buf),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;%Y-%m-</span><span class="Special">%d</span><span class="Constant"> %H:%M:</span><span class="Special">%S</span><span class="Constant"> %Z&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_localtime(&amp;tnow, log_timezone));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the first WAL segment on new timeline.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5180">&#x200c;</a></span><span class="linkable">XLogInitNewTimeline</span>(TimeLineID endTLI, XLogRecPtr endOfLog, TimeLineID newTLI)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; xlogfname[MAXFNAMELEN];<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; endLogSegNo;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; startLogSegNo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we always switch to a new timeline after archive recovery */<br/></li>
<li></span>&nbsp; &nbsp; Assert(endTLI != newTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update min recovery point one last time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2711" title="access/transam/xlog.c:2711">UpdateMinRecoveryPoint</a>(InvalidXLogRecPtr, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate the last segment on the old timeline, and the first segment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the new timeline. If the switch happens in the middle of a segment,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they are the same, but if the switch happens exactly at a segment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * boundary, startLogSegNo will be endLogSegNo + 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLByteToPrevSeg(endOfLog, endLogSegNo, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; XLByteToSeg(endOfLog, startLogSegNo, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the starting WAL segment for the new timeline. If the switch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happens in the middle of a segment, copy data from the last WAL segment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the old timeline up to the switch point, to the starting WAL segment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the new timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (endLogSegNo == startLogSegNo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make a copy of the file on the new timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Writing WAL isn't allowed yet, so there are no locking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * considerations. But we should be just as tense as <a href="#L3369" title="access/transam/xlog.c:3369">XLogFileInit</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * avoid emplacing a bogus file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3407" title="access/transam/xlog.c:3407">XLogFileCopy</a>(newTLI, endLogSegNo, endTLI, endLogSegNo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogSegmentOffset(endOfLog, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The switch happened at a segment boundary, so just create the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * segment on the new timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fd = <a href="#L3369" title="access/transam/xlog.c:3369">XLogFileInit</a>(startLogSegNo, newTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (close(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(xlogfname, newTLI, startLogSegNo, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, xlogfname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Let's just make real sure there are not .ready or .done flags posted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the new segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLogFileName(xlogfname, newTLI, startLogSegNo, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="xlogarchive.c.html#L712" title="access/transam/xlogarchive.c:712">XLogArchiveCleanup</a>(xlogfname);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> actions at the conclusion of archive recovery.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5255">&#x200c;</a></span><span class="linkable">CleanupAfterArchiveRecovery</span>(TimeLineID EndOfLogTLI, XLogRecPtr EndOfLog,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID newTLI)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Execute the recovery_end_command, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L83" title="access/transam/xlogrecovery.c:83">recoveryEndCommand</a> &amp;&amp; strcmp(<a href="xlogrecovery.c.html#L83" title="access/transam/xlogrecovery.c:83">recoveryEndCommand</a>, <span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogarchive.c.html#L295" title="access/transam/xlogarchive.c:295">ExecuteRecoveryCommand</a>(<a href="xlogrecovery.c.html#L83" title="access/transam/xlogrecovery.c:83">recoveryEndCommand</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;recovery_end_command&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_RECOVERY_END_COMMAND);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We switched to a new timeline. Clean up segments on the old timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> higher-numbered segments on the old timeline, remove<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them. They might contain valid WAL, but they might also be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pre-allocated files containing garbage. In <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, they are not part<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the new timeline's history so we don't need them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3929" title="access/transam/xlog.c:3929">RemoveNonParentXlogFiles</a>(EndOfLog, newTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the switch happened in the middle of a segment, what to do with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * last, partial segment on the old timeline? If we don't archive it, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the server that created the WAL never archives it either (e.g. because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it was hit by a meteor), it will never make it to the archive. That's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK from our point of view, because the new segment that we created with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the new TLI contains all the WAL from the old timeline up to the switch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point. But if you later try to do PITR to the &quot;missing&quot; WAL on the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timeline, recovery won't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it in the archive. It's physically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * present in the new file with new TLI, but recovery won't look there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when it's recovering to the older timeline. On the other hand, if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * archive the partial segment, and the original server on that timeline<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is still running and archives the completed version of the same segment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * later, it will fail. (We used to do that in 9.4 and below, and it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caused such problems).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As a compromise, we rename the last segment with the .partial suffix,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and archive it. Archive recovery will never try to read .partial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * segments, so they will normally go unused. But in the odd PITR case,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the administrator can copy them manually to the pg_wal directory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (removing the suffix). They can be useful in debugging, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a .done or .ready file already exists for the old timeline, however,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we had already determined that the segment is complete, so we can let<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it be archived normally. (In particular, if it was restored from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * archive to begin with, it's expected to have a .done file).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (XLogSegmentOffset(EndOfLog, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogArchivingActive())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; origfname[MAXFNAMELEN];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; endLogSegNo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLByteToPrevSeg(EndOfLog, endLogSegNo, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(origfname, EndOfLogTLI, endLogSegNo, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="xlogarchive.c.html#L664" title="access/transam/xlogarchive.c:664">XLogArchiveIsReadyOrDone</a>(origfname))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; origpath[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; partialfname[MAXFNAMELEN];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; partialpath[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogFilePath(origpath, EndOfLogTLI, endLogSegNo, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(partialfname, MAXFNAMELEN, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.partial&quot;</span>, origfname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(partialpath, MAXPGPATH, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.partial&quot;</span>, origpath);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure there's no .done or .ready file for the .partial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogarchive.c.html#L712" title="access/transam/xlogarchive.c:712">XLogArchiveCleanup</a>(partialfname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L782" title="storage/file/fd.c:782">durable_rename</a>(origpath, partialpath, ERROR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogarchive.c.html#L444" title="access/transam/xlogarchive.c:444">XLogArchiveNotify</a>(partialfname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check to see if required parameters are set high enough on this server<br/></li>
<li></span><span class="Comment"> * for various aspects of recovery operation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that all the parameters which this function tests need to be<br/></li>
<li></span><span class="Comment"> * listed in Administrator's Overview section in high-availability.sgml.<br/></li>
<li></span><span class="Comment"> * If you change them, don't forget to update the list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5344">&#x200c;</a></span><span class="linkable">CheckRequiredParameterValues</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For archive recovery, the WAL must be generated with at least 'replica'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L131" title="access/transam/xlog.c:131">wal_level</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a> &amp;&amp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L131" title="access/transam/xlog.c:131">wal_level</a> == WAL_LEVEL_MINIMAL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;WAL was generated with <a href="#L131" title="access/transam/xlog.c:131">wal_level</a>=minimal, cannot continue recovering&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;This happens if you temporarily set <a href="#L131" title="access/transam/xlog.c:131">wal_level</a>=minimal on the server.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use a backup taken after setting <a href="#L131" title="access/transam/xlog.c:131">wal_level</a> to higher than minimal.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For Hot Standby, the WAL must be generated with 'replica' mode, and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must have at least as many backend slots as the primary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a> &amp;&amp; <a href="#L121" title="access/transam/xlog.c:121">EnableHotStandby</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We ignore <a href="../../postmaster/autovacuum.c.html#L117" title="postmaster/autovacuum.c:117">autovacuum_max_workers</a> when we make this test. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogrecovery.c.html#L4659" title="access/transam/xlogrecovery.c:4659">RecoveryRequiresIntParameter</a>(<span class="Constant">&quot;max_connections&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="../../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogrecovery.c.html#L4659" title="access/transam/xlogrecovery.c:4659">RecoveryRequiresIntParameter</a>(<span class="Constant">&quot;<a href="../../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="../../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogrecovery.c.html#L4659" title="access/transam/xlogrecovery.c:4659">RecoveryRequiresIntParameter</a>(<span class="Constant">&quot;<a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogrecovery.c.html#L4659" title="access/transam/xlogrecovery.c:4659">RecoveryRequiresIntParameter</a>(<span class="Constant">&quot;max_prepared_transactions&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogrecovery.c.html#L4659" title="access/transam/xlogrecovery.c:4659">RecoveryRequiresIntParameter</a>(<span class="Constant">&quot;max_locks_per_transaction&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/lmgr/lock.c.html#L53" title="storage/lmgr/lock.c:53">max_locks_per_xact</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="../../storage/lmgr/lock.c.html#L53" title="storage/lmgr/lock.c:53">max_locks_per_xact</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This must be called ONCE during postmaster or standalone-backend startup<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5388">&#x200c;</a></span><span class="linkable">StartupXLOG</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L396" title="access/transam/xlog.c:396">XLogCtlInsert</a> *<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>;<br/></li>
<li>&nbsp; &nbsp; CheckPoint&nbsp; &nbsp; checkPoint;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; wasShutdown;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; didCrash;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; haveTblspcMap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; haveBackupLabel;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; EndOfLog;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; EndOfLogTLI;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; newTLI;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; performedWalRecovery;<br/></li>
<li>&nbsp; &nbsp; EndOfWalRecoveryInfo *endOfRecoveryInfo;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; <a href="xlogrecovery.c.html#L372" title="access/transam/xlogrecovery.c:372">abortedRecPtr</a>;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; <a href="xlogrecovery.c.html#L373" title="access/transam/xlogrecovery.c:373">missingContrecPtr</a>;<br/></li>
<li>&nbsp; &nbsp; TransactionId oldestActiveXID;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; promoted = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We should have an aux process resource owner to use, and we should not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be in a transaction that's installed some other resowner.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../utils/resowner/resowner.c.html#L168" title="utils/resowner/resowner.c:168">AuxProcessResourceOwner</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> == <a href="../../utils/resowner/resowner.c.html#L168" title="utils/resowner/resowner.c:168">AuxProcessResourceOwner</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = <a href="../../utils/resowner/resowner.c.html#L168" title="utils/resowner/resowner.c:168">AuxProcessResourceOwner</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that contents look valid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!XRecOffIsValid(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPoint))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;control file contains invalid checkpoint location&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;state)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DB_SHUTDOWNED:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is the expected case, so don't be chatty in standalone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mode<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(<a href="../../utils/init/globals.c.html#L116" title="utils/init/globals.c:116">IsPostmasterEnvironment</a> ? LOG : NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database system was shut down at </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5165" title="access/transam/xlog.c:5165">str_time</a>(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;time))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DB_SHUTDOWNED_IN_RECOVERY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database system was shut down in recovery at </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5165" title="access/transam/xlog.c:5165">str_time</a>(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;time))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DB_SHUTDOWNING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database system shutdown was interrupted; last known up at </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5165" title="access/transam/xlog.c:5165">str_time</a>(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;time))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DB_IN_CRASH_RECOVERY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database system was interrupted while in recovery at </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5165" title="access/transam/xlog.c:5165">str_time</a>(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;time)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;This probably means that some data is corrupted and&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; you will have to use the last backup for recovery.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DB_IN_ARCHIVE_RECOVERY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database system was interrupted while in recovery at log time </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5165" title="access/transam/xlog.c:5165">str_time</a>(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.time)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;If this has occurred more than once some data might be corrupted&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; and you might need to choose an earlier recovery target.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> DB_IN_PRODUCTION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database system was interrupted; last known up at </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5165" title="access/transam/xlog.c:5165">str_time</a>(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;time))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;control file contains invalid database <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> state&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is just to allow attaching to startup process with a debugger */<br/></li>
<li></span><span class="PreProc">#ifdef XLOG_REPLAY_DELAY<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;state != DB_SHUTDOWNED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<span class="Constant">60000000L</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Verify that pg_wal, pg_wal/archive_status, and pg_wal/summaries exist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In cases where someone has performed a copy for PITR, these directories<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * may have been excluded and need to be re-created.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4088" title="access/transam/xlog.c:4088">ValidateXLOGDirectoryStructure</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up timeout handler needed to report startup progress. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/timeout.c.html#L505" title="utils/misc/timeout.c:505">RegisterTimeout</a>(STARTUP_PROGRESS_TIMEOUT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/startup.c.html#L303" title="postmaster/startup.c:303">startup_progress_timeout_handler</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we previously crashed, perform a couple of actions:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - The pg_wal directory may still include some temporary WAL segments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; used when creating a new segment, so perform some clean up to not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; bloat this path.&nbsp; This is done first as there is no point to sync<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; this temporary data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * - There might be data which we had written, intending to fsync it, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; which we had not actually fsync'd yet.&nbsp; Therefore, a power failure in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; the near future might cause earlier unflushed writes to be lost, even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; though more recent data written to disk from here on would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; persisted.&nbsp; To avoid that, fsync the entire data directory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;state != DB_SHUTDOWNED &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;state != DB_SHUTDOWNED_IN_RECOVERY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3821" title="access/transam/xlog.c:3821">RemoveTempXlogFiles</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L3544" title="storage/file/fd.c:3544">SyncDataDirectory</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; didCrash = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; didCrash = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare for WAL recovery if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="xlogrecovery.c.html#L512" title="access/transam/xlogrecovery.c:512">InitWalRecovery</a> analyzes the control file and the backup label file, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; It updates the in-memory <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a> buffer according to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * starting checkpoint, and sets <a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a> and <a href="xlogrecovery.c.html#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It also applies the tablespace map file, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xlogrecovery.c.html#L512" title="access/transam/xlogrecovery.c:512">InitWalRecovery</a>(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>, &amp;wasShutdown,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;haveBackupLabel, &amp;haveTblspcMap);<br/></li>
<li>&nbsp; &nbsp; checkPoint = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> shared memory variables from the checkpoint record */<br/></li>
<li></span>&nbsp; &nbsp; <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid = checkPoint.nextXid;<br/></li>
<li>&nbsp; &nbsp; <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextOid = checkPoint.nextOid;<br/></li>
<li>&nbsp; &nbsp; <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oidCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="multixact.c.html#L2279" title="access/transam/multixact.c:2279">MultiXactSetNextMXact</a>(checkPoint.nextMulti, checkPoint.nextMultiOffset);<br/></li>
<li>&nbsp; &nbsp; <a href="varsup.c.html#L355" title="access/transam/varsup.c:355">AdvanceOldestClogXid</a>(checkPoint.oldestXid);<br/></li>
<li>&nbsp; &nbsp; <a href="varsup.c.html#L372" title="access/transam/varsup.c:372">SetTransactionIdLimit</a>(checkPoint.oldestXid, checkPoint.oldestXidDB);<br/></li>
<li>&nbsp; &nbsp; <a href="multixact.c.html#L2313" title="access/transam/multixact.c:2313">SetMultiXactIdLimit</a>(checkPoint.oldestMulti, checkPoint.oldestMultiDB, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="commit_ts.c.html#L909" title="access/transam/commit_ts.c:909">SetCommitTsLimit</a>(checkPoint.oldestCommitTsXid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; checkPoint.newestCommitTsXid);<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;ckptFullXid = checkPoint.nextXid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clear out <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> old relcache cache files.&nbsp; This is *necessary* if we do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WAL replay, since that would probably result in the cache files<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * being out of sync with database reality.&nbsp; In theory we could leave them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in place if the database had been cleanly shut down, but it seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * safest to just remove them always and let them be rebuilt during the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first backend startup.&nbsp; These files needs to be removed from all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * directories including pg_tblspc, however the symlinks are created only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after reading <a href="xlogfuncs.c.html#L41" title="access/transam/xlogfuncs.c:41">tablespace_map</a> file in case of archive recovery from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backup, so needs to clear old relcache files here after creating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * symlinks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L6794" title="utils/cache/relcache.c:6794">RelationCacheInitFileRemove</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize replication slots, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> there's a chance to remove<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * required resources.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../replication/slot.c.html#L1898" title="replication/slot.c:1898">StartupReplicationSlots</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Startup logical state, needs to be setup <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> so we have proper data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during crash recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../replication/logical/reorderbuffer.c.html#L4625" title="replication/logical/reorderbuffer.c:4625">StartupReorderBuffer</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Startup CLOG. This must be done after <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been initialized and <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> connections or begin WAL replay.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="clog.c.html#L877" title="access/transam/clog.c:877">StartupCLOG</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Startup MultiXact. We need to do this early to be able to replay<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * truncations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="multixact.c.html#L2104" title="access/transam/multixact.c:2104">StartupMultiXact</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ditto for commit timestamps.&nbsp; Activate the facility if the setting is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enabled in the control file, as there should be no tracking of commit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timestamps done when the setting was disabled.&nbsp; This facility can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * started or stopped when replaying a XLOG_PARAMETER_CHANGE record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="commit_ts.c.html#L109" title="access/transam/commit_ts.c:109">track_commit_timestamp</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="commit_ts.c.html#L632" title="access/transam/commit_ts.c:632">StartupCommitTs</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recover knowledge about replay progress of known replication partners.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../replication/logical/origin.c.html#L699" title="replication/logical/origin.c:699">StartupReplicationOrigin</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize unlogged LSN. On a clean shutdown, it's restored from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * control file. On recovery, all unlogged relations are blown away, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the unlogged LSN counter can be reset too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;state == DB_SHUTDOWNED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_write_membarrier_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;unloggedLSN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;unloggedLSN);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_write_membarrier_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;unloggedLSN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FirstNormalUnloggedLSN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> missing timeline history files between '<a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>' and the recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target timeline from archive to pg_wal. While we don't need those files<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ourselves - the history file of the recovery target timeline covers all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the previous timelines in the history too - a cascading standby server<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might be interested in them. Or, if you archive the WAL from this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * server to a different archive than the primary, it'd be good for all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the history files to get archived there after failover, so that you can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use one of the old timelines as a PITR target. Timeline history files<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are small, so it's better to copy them unnecessarily than not copy them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and regret later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="timeline.c.html#L50" title="access/transam/timeline.c:50">restoreTimeLineHistoryFiles</a>(checkPoint.ThisTimeLineID, <a href="xlogrecovery.c.html#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Before running in recovery, scan pg_twophase and fill in its status to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be able to work on entries generated by redo.&nbsp; Doing a scan <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * taking <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> recovery action has the merit to discard <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> 2PC files that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are newer than the first record to replay, saving from <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> conflicts at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replay.&nbsp; This avoids as well <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsequent scans when doing recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the on-disk two-phase data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="twophase.c.html#L1898" title="access/transam/twophase.c:1898">restoreTwoPhaseData</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When starting with crash recovery, reset pgstat data - it might not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * valid. Otherwise restore pgstat data. It's safe to do this here,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because postmaster will not yet have started <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other processes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: Restoring replication slot stats relies on slot state to have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already been restored from disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">TODO</span><span class="Comment">: With a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of extra work we could just start with a pgstat file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * associated with the checkpoint redo location we're starting from.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (didCrash)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat.c.html#L419" title="utils/activity/pgstat.c:419">pgstat_discard_stats</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat.c.html#L407" title="utils/activity/pgstat.c:407">pgstat_restore_stats</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L217" title="access/transam/xlog.c:217">lastFullPageWrites</a> = checkPoint.<a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>.<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> = checkPoint.redo;<br/></li>
<li>&nbsp; &nbsp; <a href="#L286" title="access/transam/xlog.c:286">doPageWrites</a> = <a href="#L217" title="access/transam/xlog.c:217">lastFullPageWrites</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* REDO */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize state for <a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L138" title="access/transam/xlogrecovery.c:138">InArchiveRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;SharedRecoveryState = RECOVERY_STATE_ARCHIVE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;SharedRecoveryState = RECOVERY_STATE_CRASH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update pg_control to show that we are recovering and to show the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * selected checkpoint as the place we are starting from. We also mark<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_control with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> minimum recovery stop point obtained from a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backup history file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No need to hold ControlFileLock yet, we aren't up far enough.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4526" title="access/transam/xlog.c:4526">UpdateControlFile</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there was a backup label file, it's done its job and the info<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> been propagated into pg_control.&nbsp; We must get rid of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * label file so that if we crash during recovery, we'll pick up at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the latest recovery restartpoint instead of going all the way back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the backup start point.&nbsp; It seems prudent though to just rename<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the file out of the way rather than delete it completely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (haveBackupLabel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unlink(BACKUP_LABEL_OLD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L782" title="storage/file/fd.c:782">durable_rename</a>(BACKUP_LABEL_FILE, BACKUP_LABEL_OLD, FATAL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there was a <a href="xlogfuncs.c.html#L41" title="access/transam/xlogfuncs.c:41">tablespace_map</a> file, it's done its job and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * symlinks have been created.&nbsp; We must get rid of the map file so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that if we crash during recovery, we don't create symlinks again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It seems prudent though to just rename the file out of the way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rather than delete it completely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (haveTblspcMap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unlink(TABLESPACE_MAP_OLD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L782" title="storage/file/fd.c:782">durable_rename</a>(TABLESPACE_MAP, TABLESPACE_MAP_OLD, FATAL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initialize our local copy of <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>.&nbsp; When doing crash<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recovery we want to replay up to the end of WAL.&nbsp; Particularly, in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the case of a promoted standby <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> value in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * control file is only updated after the first checkpoint.&nbsp; However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if the instance crashes <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the first post-recovery checkpoint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is completed then recovery will use a stale location causing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * startup process to think that there are still invalid page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * references when checking for data consistency.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L138" title="access/transam/xlogrecovery.c:138">InArchiveRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a> = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L642" title="access/transam/xlog.c:642">LocalMinRecoveryPointTLI</a> = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a> = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L642" title="access/transam/xlog.c:642">LocalMinRecoveryPointTLI</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check that the GUCs used to generate the WAL allow recovery */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5344" title="access/transam/xlog.c:5344">CheckRequiredParameterValues</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're in recovery, so unlogged relations may be trashed and must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reset.&nbsp; This should be done BEFORE allowing Hot Standby<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * connections, so that read-only backends don't try to read whatever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * garbage is left over from <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/reinit.c.html#L47" title="storage/file/reinit.c:47">ResetUnloggedRelations</a>(UNLOGGED_RELATION_CLEANUP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Likewise, delete <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> saved transaction snapshot files that got left<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * behind by crashed backends.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L1567" title="utils/time/snapmgr.c:1567">DeleteAllExportedSnapshotFiles</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initialize for Hot Standby, if enabled. We won't let backends in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * yet, not until we've reached the min recovery point specified in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * control file and we've established a recovery snapshot from a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * running-xacts WAL record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a> &amp;&amp; <a href="#L121" title="access/transam/xlog.c:121">EnableHotStandby</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId *xids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nxids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;initializing for hot standby&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/standby.c.html#L94" title="storage/ipc/standby.c:94">InitRecoveryTransactionEnvironment</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wasShutdown)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestActiveXID = <a href="twophase.c.html#L1962" title="access/transam/twophase.c:1962">PrescanPreparedTransactions</a>(&amp;xids, &amp;nxids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestActiveXID = checkPoint.oldestActiveXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsValid(oldestActiveXID));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Tell procarray about the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of xids it has to deal with */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L1023" title="storage/ipc/procarray.c:1023">ProcArrayInitRecovery</a>(XidFromFullTransactionId(<a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Startup subtrans only.&nbsp; CLOG, MultiXact and commit timestamp<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have already been started up and other SLRUs are not maintained<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during recovery and need not be started yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="subtrans.c.html#L309" title="access/transam/subtrans.c:309">StartupSUBTRANS</a>(oldestActiveXID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're beginning at a shutdown checkpoint, we know that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nothing was running on the primary at this point. So fake-up an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * empty running-xacts record and use that here and <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. Recover<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * additional standby state for prepared transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (wasShutdown)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RunningTransactionsData running;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId latestCompletedXid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Construct a RunningTransactions snapshot representing a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shut down server, with only prepared transactions still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * alive. We're never overflowed at this point because all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subxids are listed with their parent prepared transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; running.xcnt = nxids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; running.subxcnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; running.subxid_overflow = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; running.nextXid = XidFromFullTransactionId(checkPoint.nextXid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; running.oldestRunningXid = oldestActiveXID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latestCompletedXid = XidFromFullTransactionId(checkPoint.nextXid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionIdRetreat(latestCompletedXid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsNormal(latestCompletedXid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; running.latestCompletedXid = latestCompletedXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; running.xids = xids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L1054" title="storage/ipc/procarray.c:1054">ProcArrayApplyRecoveryInfo</a>(&amp;running);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="twophase.c.html#L2043" title="access/transam/twophase.c:2043">StandbyRecoverPreparedTransactions</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're all set for replaying the WAL <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. Do it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogrecovery.c.html#L1652" title="access/transam/xlogrecovery.c:1652">PerformWalRecovery</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; performedWalRecovery = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; performedWalRecovery = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finish WAL recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; endOfRecoveryInfo = <a href="xlogrecovery.c.html#L1458" title="access/transam/xlogrecovery.c:1458">FinishWalRecovery</a>();<br/></li>
<li>&nbsp; &nbsp; EndOfLog = endOfRecoveryInfo-&gt;endOfLog;<br/></li>
<li>&nbsp; &nbsp; EndOfLogTLI = endOfRecoveryInfo-&gt;endOfLogTLI;<br/></li>
<li>&nbsp; &nbsp; <a href="xlogrecovery.c.html#L372" title="access/transam/xlogrecovery.c:372">abortedRecPtr</a> = endOfRecoveryInfo-&gt;<a href="xlogrecovery.c.html#L372" title="access/transam/xlogrecovery.c:372">abortedRecPtr</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="xlogrecovery.c.html#L373" title="access/transam/xlogrecovery.c:373">missingContrecPtr</a> = endOfRecoveryInfo-&gt;<a href="xlogrecovery.c.html#L373" title="access/transam/xlogrecovery.c:373">missingContrecPtr</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset ps status display, so as no information related to recovery shows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; set_ps_display(<span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When recovering from a backup (we are in recovery, and archive recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * was requested), complain if we did not roll forward far enough to reach<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the point where the database is consistent.&nbsp; For regular online<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backup-from-primary, that means reaching the end-of-backup WAL record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (at which point we reset <a href="xlogrecovery.c.html#L281" title="access/transam/xlogrecovery.c:281">backupStartPoint</a> to be Invalid), for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backup-from-replica (which can't inject <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> into the WAL stream),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that point is when we reach the <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> in pg_control (which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we purposefully copy last when backing up from a replica).&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_rewind (which creates a backup_label with a method of &quot;pg_rewind&quot;)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or snapshot-style backups (which don't), <a href="xlogrecovery.c.html#L283" title="access/transam/xlogrecovery.c:283">backupEndRequired</a> will be set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to false.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: it is indeed okay to look at the local variable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a> here, even though <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might be further ahead --- <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> cannot have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been advanced beyond the WAL we processed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (EndOfLog &lt; <a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !XLogRecPtrIsInvalid(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L281" title="access/transam/xlogrecovery.c:281">backupStartPoint</a>)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ran off end of WAL <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> reaching end-of-backup WAL record, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>. That's a bad sign, indicating that you tried to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recover from an online backup but never called <a href="xlogfuncs.c.html#L123" title="access/transam/xlogfuncs.c:123">pg_backup_stop</a>(), or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * you didn't archive all the WAL needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a> || <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L283" title="access/transam/xlogrecovery.c:283">backupEndRequired</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L281" title="access/transam/xlogrecovery.c:281">backupStartPoint</a>) || <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L283" title="access/transam/xlogrecovery.c:283">backupEndRequired</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;WAL ends <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> end of online backup&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;All WAL generated while online backup was taken must be available at recovery.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;WAL ends <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> consistent recovery point&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset unlogged relations to the contents of their INIT fork. This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done AFTER recovery is complete so as to include <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unlogged relations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * created during recovery, but BEFORE recovery is marked as having<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * completed successfully. Otherwise we'd not retry if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the post<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end-of-recovery steps fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/reinit.c.html#L47" title="storage/file/reinit.c:47">ResetUnloggedRelations</a>(UNLOGGED_RELATION_INIT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pre-scan prepared transactions to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of XIDs present.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This information is not quite needed yet, but it is positioned here so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as potential problems are detected <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> on-disk change is done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldestActiveXID = <a href="twophase.c.html#L1962" title="access/transam/twophase.c:1962">PrescanPreparedTransactions</a>(<span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allow ordinary WAL segment creation <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> possibly switching to a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timeline, which creates a new segment, and after the last <a href="xlogrecovery.c.html#L3131" title="access/transam/xlogrecovery.c:3131">ReadRecord</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L9404" title="access/transam/xlog.c:9404">SetInstallXLogFileSegmentActive</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Consider whether we need to assign a new timeline ID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we did archive recovery, we always assign a new ID.&nbsp; This handles a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * couple of issues.&nbsp; If we stopped short of the end of WAL during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery, then we are clearly generating a new timeline and must assign<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it a unique new ID.&nbsp; Even if we ran to the end, modifying the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * last segment is problematic because it may result in trying to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overwrite an already-archived copy of that segment, and we encourage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * DBAs to make their archive_commands reject that.&nbsp; We can dodge the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * problem by making the new active segment have a new timeline ID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In a normal crash recovery, we can just extend the timeline we were in.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newTLI = endOfRecoveryInfo-&gt;lastRecTLI;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newTLI = <a href="timeline.c.html#L264" title="access/transam/timeline.c:264">findNewestTimeLine</a>(<a href="xlogrecovery.c.html#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a>) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;selected new timeline ID: </span><span class="Special">%u</span><span class="Constant">&quot;</span>, newTLI)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make a writable copy of the last WAL segment.&nbsp; (Note that we also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have a copy of the last block of the old WAL in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * endOfRecovery-&gt;lastPage; we will use that below.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5180" title="access/transam/xlog.c:5180">XLogInitNewTimeline</a>(EndOfLogTLI, EndOfLog, newTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remove the signal files out of the way, so that we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * accidentally re-enter archive recovery mode in a subsequent crash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endOfRecoveryInfo-&gt;<a href="xlogrecovery.c.html#L150" title="access/transam/xlogrecovery.c:150">standby_signal_file_found</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L872" title="storage/file/fd.c:872">durable_unlink</a>(STANDBY_SIGNAL_FILE, FATAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (endOfRecoveryInfo-&gt;<a href="xlogrecovery.c.html#L151" title="access/transam/xlogrecovery.c:151">recovery_signal_file_found</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L872" title="storage/file/fd.c:872">durable_unlink</a>(RECOVERY_SIGNAL_FILE, FATAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Write the timeline history file, and have it archived. After this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point (or rather, as soon as the file is archived), the timeline<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will appear as &quot;taken&quot; in the WAL archive and to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> standby<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * servers.&nbsp; If we crash <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> actually switching to the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * timeline, standby servers will nevertheless think that we switched<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the new timeline, and will try to <a href="../../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to the new timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To minimize the window for that, try to do as little as possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * between here and writing the end-of-recovery record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="timeline.c.html#L304" title="access/transam/timeline.c:304">writeTimeLineHistory</a>(newTLI, <a href="xlogrecovery.c.html#L122" title="access/transam/xlogrecovery.c:122">recoveryTargetTLI</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EndOfLog, endOfRecoveryInfo-&gt;recoveryStopReason);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;archive recovery complete&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save the selected TimeLineID in shared memory, too */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InsertTimeLineID = newTLI;<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;PrevTimeLineID = endOfRecoveryInfo-&gt;lastRecTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Actually, if WAL ended in an incomplete record, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the parts that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * made it through and start writing after the portion that persisted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (It's critical to first write an OVERWRITE_CONTRECORD message, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'll do as soon as we're open for writing new WAL.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(<a href="xlogrecovery.c.html#L373" title="access/transam/xlogrecovery.c:373">missingContrecPtr</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should only have a <a href="xlogrecovery.c.html#L373" title="access/transam/xlogrecovery.c:373">missingContrecPtr</a> if we're not switching to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new timeline. When a timeline switch occurs, WAL is copied from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * old timeline to the new only up to the end of the last complete<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * record, so there can't be an incomplete WAL record that we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * disregard.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(newTLI == endOfRecoveryInfo-&gt;lastRecTLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!XLogRecPtrIsInvalid(<a href="xlogrecovery.c.html#L372" title="access/transam/xlogrecovery.c:372">abortedRecPtr</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EndOfLog = <a href="xlogrecovery.c.html#L373" title="access/transam/xlogrecovery.c:373">missingContrecPtr</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare to write WAL starting at EndOfLog location, and init xlog<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer cache using the block containing the last record from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previous incarnation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> = &amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;PrevBytePos = <a href="#L1936" title="access/transam/xlog.c:1936">XLogRecPtrToBytePos</a>(endOfRecoveryInfo-&gt;lastRec);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;CurrBytePos = <a href="#L1936" title="access/transam/xlog.c:1936">XLogRecPtrToBytePos</a>(EndOfLog);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Tricky point here: lastPage contains the *last* block that the LastRec<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record spans, not the one it starts in.&nbsp; The last block is indeed the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one we want to use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (EndOfLog % XLOG_BLCKSZ != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstIdx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; firstIdx = <a href="#L586" title="access/transam/xlog.c:586">XLogRecPtrToBufIdx</a>(EndOfLog);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = EndOfLog - endOfRecoveryInfo-&gt;lastPageBeginPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(len &lt; XLOG_BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy the valid part of the last block, and zero the rest */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; page = &amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;pages[firstIdx * XLOG_BLCKSZ];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(page, endOfRecoveryInfo-&gt;lastPage, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(page + len, <span class="Constant">0</span>, XLOG_BLCKSZ - len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;xlblocks[firstIdx], endOfRecoveryInfo-&gt;lastPageBeginPtr + XLOG_BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InitializedUpTo = endOfRecoveryInfo-&gt;lastPageBeginPtr + XLOG_BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is no partial block to copy. Just set InitializedUpTo, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * let the first attempt to insert a log record to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InitializedUpTo = EndOfLog;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update local and shared status.&nbsp; This is OK to do without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> locks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because no other process can be reading or writing WAL yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write = <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush = EndOfLog;<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;logInsertResult, EndOfLog);<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;logWriteResult, EndOfLog);<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;logFlushResult, EndOfLog);<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;LogwrtRqst.Write = EndOfLog;<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;LogwrtRqst.Flush = EndOfLog;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Preallocate additional log files, if wanted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3679" title="access/transam/xlog.c:3679">PreallocXlogFiles</a>(EndOfLog, newTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Okay, we're officially UP.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* start the archive_timeout timer and LSN running */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;lastSegSwitchTime = (pg_time_t) time(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;lastSegSwitchLSN = EndOfLog;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* also <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> latestCompletedXid, to nextXid - 1 */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ProcArrayLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;latestCompletedXid = <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid;<br/></li>
<li>&nbsp; &nbsp; FullTransactionIdRetreat(&amp;<a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;latestCompletedXid);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ProcArrayLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start up subtrans, if not already done for hot standby.&nbsp; (commit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timestamps are started below, if necessary.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> == STANDBY_DISABLED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="subtrans.c.html#L309" title="access/transam/subtrans.c:309">StartupSUBTRANS</a>(oldestActiveXID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Perform end of recovery actions for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SLRUs that need it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="clog.c.html#L892" title="access/transam/clog.c:892">TrimCLOG</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="multixact.c.html#L2129" title="access/transam/multixact.c:2129">TrimMultiXact</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reload shared-memory state for prepared transactions.&nbsp; This needs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happen <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> renaming the last partial segment of the old timeline as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it may be possible that we have to recovery some transactions from it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="twophase.c.html#L2084" title="access/transam/twophase.c:2084">RecoverPreparedTransactions</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shut down <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xlogrecovery.c.html#L1608" title="access/transam/xlogrecovery.c:1608">ShutdownWalRecovery</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Enable WAL writes for this backend only. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L6378" title="access/transam/xlog.c:6378">LocalSetXLogInsertAllowed</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If necessary, write overwrite-contrecord <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing anything else */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(<a href="xlogrecovery.c.html#L372" title="access/transam/xlogrecovery.c:372">abortedRecPtr</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!XLogRecPtrIsInvalid(<a href="xlogrecovery.c.html#L373" title="access/transam/xlogrecovery.c:373">missingContrecPtr</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7361" title="access/transam/xlog.c:7361">CreateOverwriteContrecordRecord</a>(<a href="xlogrecovery.c.html#L372" title="access/transam/xlogrecovery.c:372">abortedRecPtr</a>, <a href="xlogrecovery.c.html#L373" title="access/transam/xlogrecovery.c:373">missingContrecPtr</a>, newTLI);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update full_page_writes in shared memory and write an XLOG_FPW_CHANGE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> resource manager writes <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> or checkpoint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record is written.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;<a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a> = <a href="#L217" title="access/transam/xlog.c:217">lastFullPageWrites</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L8087" title="access/transam/xlog.c:8087">UpdateFullPageWrites</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Emit checkpoint or end-of-recovery record in XLOG, if required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (performedWalRecovery)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; promoted = <a href="#L6240" title="access/transam/xlog.c:6240">PerformRecoveryXLogAction</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the critical GUCs have changed, log them <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backends to write WAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L8024" title="access/transam/xlog.c:8024">XLogReportParameters</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If this is archive recovery, perform post-recovery <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> actions. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5255" title="access/transam/xlog.c:5255">CleanupAfterArchiveRecovery</a>(EndOfLogTLI, EndOfLog, newTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Local WAL inserts enabled, so it's time to finish initialization of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit timestamp.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="commit_ts.c.html#L642" title="access/transam/commit_ts.c:642">CompleteCommitTsInitialization</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All done with end-of-recovery actions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now allow backends to write WAL and update the control file status in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consequence.&nbsp; SharedRecoveryState, that controls if backends can write<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WAL, is updated while holding ControlFileLock to prevent other backends<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to look at an inconsistent state of the control file in shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There is still a small window during which backends can write WAL and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the control file is still referring to a system not in DB_IN_PRODUCTION<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state while looking at the on-disk control file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, we use info_lck to update SharedRecoveryState to ensure that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there are no race conditions concerning visibility of other recent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * updates to shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ControlFileLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;state = DB_IN_PRODUCTION;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;SharedRecoveryState = RECOVERY_STATE_DONE;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4526" title="access/transam/xlog.c:4526">UpdateControlFile</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../postmaster/postmaster.c.html#L269" title="postmaster/postmaster.c:269">Shutdown</a> the recovery environment.&nbsp; This must occur after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="twophase.c.html#L2084" title="access/transam/twophase.c:2084">RecoverPreparedTransactions</a>() (see notes in <a href="../../storage/lmgr/lock.c.html#L4142" title="storage/lmgr/lock.c:4142">lock_twophase_recover</a>())<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and after switching SharedRecoveryState to RECOVERY_STATE_DONE so as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> session building a snapshot will not rely on <a href="../../storage/ipc/procarray.c.html#L281" title="storage/ipc/procarray.c:281">KnownAssignedXids</a> as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>() would return false at this stage.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * particularly critical for prepared 2PC transactions, that would still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to be included in snapshots once recovery has ended.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> != STANDBY_DISABLED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/standby.c.html#L160" title="storage/ipc/standby.c:160">ShutdownRecoveryTransactionEnvironment</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there were cascading standby servers connected to us, nudge <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> wal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sender processes to notice that we've been promoted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../replication/walsender.c.html#L3666" title="replication/walsender.c:3666">WalSndWakeup</a>(<span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this was a promotion, request an (online) checkpoint <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. This isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * required for consistency, but the last restartpoint might be far back,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and in case of a crash, recovering from it might take a longer than is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appropriate <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that we're not in standby mode anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (promoted)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/checkpointer.c.html#L941" title="postmaster/checkpointer.c:941">RequestCheckpoint</a>(CHECKPOINT_FORCE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Callback from <a href="xlogrecovery.c.html#L1652" title="access/transam/xlogrecovery.c:1652">PerformWalRecovery</a>(), called when we switch from crash<br/></li>
<li></span><span class="Comment"> * recovery to archive recovery mode.&nbsp; Updates the control file accordingly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L6165">&#x200c;</a></span><span class="linkable">SwitchIntoArchiveRecovery</span>(XLogRecPtr EndRecPtr, TimeLineID replayTLI)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> to this record */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ControlFileLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;state = DB_IN_ARCHIVE_RECOVERY;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> &lt; EndRecPtr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> = EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a> = replayTLI;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update local copy */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a> = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L642" title="access/transam/xlog.c:642">LocalMinRecoveryPointTLI</a> = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The startup process can update its local copy of <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L643" title="access/transam/xlog.c:643">updateMinRecoveryPoint</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4526" title="access/transam/xlog.c:4526">UpdateControlFile</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We update SharedRecoveryState while holding the lock on ControlFileLock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so both states are consistent in shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;SharedRecoveryState = RECOVERY_STATE_ARCHIVE;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Callback from <a href="xlogrecovery.c.html#L1652" title="access/transam/xlogrecovery.c:1652">PerformWalRecovery</a>(), called when we reach the end of backup.<br/></li>
<li></span><span class="Comment"> * Updates the control file accordingly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L6203">&#x200c;</a></span><span class="linkable">ReachedEndOfBackup</span>(XLogRecPtr EndRecPtr, TimeLineID tli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have reached the end of base backup, as indicated by pg_control. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data on disk is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> consistent (unless <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> is further<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ahead, which can happen if we crashed during previous recovery).&nbsp; Reset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="xlogrecovery.c.html#L281" title="access/transam/xlogrecovery.c:281">backupStartPoint</a> and <a href="xlogrecovery.c.html#L282" title="access/transam/xlogrecovery.c:282">backupEndPoint</a>, and update <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * make sure we don't allow starting up at an earlier point even if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery is stopped and restarted soon after this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ControlFileLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> &lt; EndRecPtr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> = EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a> = tli;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L281" title="access/transam/xlogrecovery.c:281">backupStartPoint</a> = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L282" title="access/transam/xlogrecovery.c:282">backupEndPoint</a> = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L283" title="access/transam/xlogrecovery.c:283">backupEndRequired</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L4526" title="access/transam/xlog.c:4526">UpdateControlFile</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform whatever XLOG actions are necessary at end of REDO.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The goal here is to make sure that we'll be able to recover properly if<br/></li>
<li></span><span class="Comment"> * we crash again. If we choose to write a checkpoint, we'll write a shutdown<br/></li>
<li></span><span class="Comment"> * checkpoint rather than an on-line one. This is not particularly critical,<br/></li>
<li></span><span class="Comment"> * but since we may be assigning a new TLI, using a shutdown checkpoint allows<br/></li>
<li></span><span class="Comment"> * us to have the rule that TLI only changes in shutdown checkpoints, which<br/></li>
<li></span><span class="Comment"> * allows some extra error checking in <a href="#L8156" title="access/transam/xlog.c:8156">xlog_redo</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L6240">&#x200c;</a></span><span class="linkable">PerformRecoveryXLogAction</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; promoted = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Perform a checkpoint to update all our recovery activity to disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we write a shutdown checkpoint rather than an on-line one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is not particularly critical, but since we may be assigning a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TLI, using a shutdown checkpoint allows us to have the rule that TLI<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only changes in shutdown checkpoints, which allows some extra error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checking in <a href="#L8156" title="access/transam/xlog.c:8156">xlog_redo</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In promotion, only create a lightweight end-of-recovery record instead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of a full checkpoint. A checkpoint is requested later, after we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fully out of recovery mode and already accepting queries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a> &amp;&amp; <a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogrecovery.c.html#L4394" title="access/transam/xlogrecovery.c:4394">PromoteIsTriggered</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; promoted = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> a special WAL record to mark the end of recovery, since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aren't doing a checkpoint. That means that the checkpointer process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * may likely be in the middle of a time-smoothed restartpoint and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could continue to be for minutes after this.&nbsp; That sounds strange,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but the effect is roughly the same and it would be stranger to try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to come out of the restartpoint and then checkpoint. We request a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checkpoint later anyway, just for safety.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7297" title="access/transam/xlog.c:7297">CreateEndOfRecoveryRecord</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/checkpointer.c.html#L941" title="postmaster/checkpointer.c:941">RequestCheckpoint</a>(CHECKPOINT_END_OF_RECOVERY |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECKPOINT_IMMEDIATE |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECKPOINT_WAIT);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> promoted;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Is the system still in recovery?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike testing <a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>, this works in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> process that's connected to<br/></li>
<li></span><span class="Comment"> * shared memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L6290">&#x200c;</a></span><span class="linkable">RecoveryInProgress</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We check shared state each time only until we leave recovery mode. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't re-enter recovery, so there's no need to keep checking after the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared variable has once been seen false.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L224" title="access/transam/xlog.c:224">LocalRecoveryInProgress</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use volatile pointer to make sure we make a fresh read of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shared variable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">volatile</span> <a href="#L450" title="access/transam/xlog.c:450">XLogCtlData</a> *xlogctl = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L224" title="access/transam/xlog.c:224">LocalRecoveryInProgress</a> = (xlogctl-&gt;SharedRecoveryState != RECOVERY_STATE_DONE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: We don't need a memory barrier when we're still in recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We might exit recovery immediately after return, so the caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't rely on 'true' meaning that we're still in recovery anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L224" title="access/transam/xlog.c:224">LocalRecoveryInProgress</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns current recovery state from shared memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This returned state is kept consistent with the contents of the control<br/></li>
<li></span><span class="Comment"> * file.&nbsp; See details about the possible <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of RecoveryState in xlog.h.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RecoveryState<br/></li>
<li><a id="L6326">&#x200c;</a><span class="linkable">GetRecoveryState</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RecoveryState retval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; retval = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;SharedRecoveryState;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Is this process allowed to insert new WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Ordinarily this is essentially equivalent to !<a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>().<br/></li>
<li></span><span class="Comment"> * But we also have provisions for forcing the result &quot;true&quot; or &quot;false&quot;<br/></li>
<li></span><span class="Comment"> * within specific processes regardless of the global state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L6345">&#x200c;</a></span><span class="linkable">XLogInsertAllowed</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If value is &quot;unconditionally true&quot; or &quot;unconditionally false&quot;, just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * return it.&nbsp; This provides the normal fast path once recovery is known<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L236" title="access/transam/xlog.c:236">LocalXLogInsertAllowed</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) <a href="#L236" title="access/transam/xlog.c:236">LocalXLogInsertAllowed</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Else, must check to see if we're still in recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On exit from recovery, reset to &quot;unconditionally true&quot;, since there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no need to keep checking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L236" title="access/transam/xlog.c:236">LocalXLogInsertAllowed</a> = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make <a href="#L6345" title="access/transam/xlog.c:6345">XLogInsertAllowed</a>() return true in the current process only.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: it is allowed to switch <a href="#L236" title="access/transam/xlog.c:236">LocalXLogInsertAllowed</a> back to -1 later,<br/></li>
<li></span><span class="Comment"> * and even call <a href="#L6378" title="access/transam/xlog.c:6378">LocalSetXLogInsertAllowed</a>() again after that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the previous value of <a href="#L236" title="access/transam/xlog.c:236">LocalXLogInsertAllowed</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L6378">&#x200c;</a></span><span class="linkable">LocalSetXLogInsertAllowed</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldXLogAllowed = <a href="#L236" title="access/transam/xlog.c:236">LocalXLogInsertAllowed</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L236" title="access/transam/xlog.c:236">LocalXLogInsertAllowed</a> = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> oldXLogAllowed;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the current Redo pointer from shared memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As a side-effect, the local <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> copy is updated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L6393">&#x200c;</a><span class="linkable">GetRedoRecPtr</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The possibly not up-to-date copy in XlogCtl is enough. Even if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * grabbed a WAL insertion lock to read the authoritative value in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>, someone might update it just after we've released<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; ptr = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> &lt; ptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> = ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return information needed to decide whether a modified block needs a<br/></li>
<li></span><span class="Comment"> * full-page image to be included in the WAL record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are cached copies from backend-private memory, and<br/></li>
<li></span><span class="Comment"> * possibly out-of-date or, indeed, uninitialized, in which case they will<br/></li>
<li></span><span class="Comment"> * be InvalidXLogRecPtr and false, respectively.&nbsp; <a href="#L743" title="access/transam/xlog.c:743">XLogInsertRecord</a> will<br/></li>
<li></span><span class="Comment"> * re-check them against up-to-date <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, while holding the WAL insert lock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L6423">&#x200c;</a></span><span class="linkable">GetFullPageWriteInfo</span>(XLogRecPtr *RedoRecPtr_p, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *doPageWrites_p)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; *RedoRecPtr_p = <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>;<br/></li>
<li>&nbsp; &nbsp; *doPageWrites_p = <a href="#L286" title="access/transam/xlog.c:286">doPageWrites</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6438" title="access/transam/xlog.c:6438">GetInsertRecPtr</a> -- Returns the current insert position.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: The value *actually* returned is the position of the last full<br/></li>
<li></span><span class="Comment"> * xlog page. It lags behind the real insert position by at most 1 page.<br/></li>
<li></span><span class="Comment"> * For that, we don't need to scan through WAL insertion locks, and an<br/></li>
<li></span><span class="Comment"> * approximation is enough for the current usage of this function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L6438">&#x200c;</a><span class="linkable">GetInsertRecPtr</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; recptr = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;LogwrtRqst.Write;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> recptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6455" title="access/transam/xlog.c:6455">GetFlushRecPtr</a> -- Returns the current flush position, ie, the last WAL<br/></li>
<li></span><span class="Comment"> * position known to be fsync'd to disk. This should only be used on a<br/></li>
<li></span><span class="Comment"> * system that is known not to be in recovery.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L6455">&#x200c;</a><span class="linkable">GetFlushRecPtr</span>(TimeLineID *insertTLI)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;SharedRecoveryState == RECOVERY_STATE_DONE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L615" title="access/transam/xlog.c:615">RefreshXLogWriteResult</a>(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're writing and flushing WAL, the time line can't be changing, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no lock is required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (insertTLI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *insertTLI = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InsertTimeLineID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Flush;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6476" title="access/transam/xlog.c:6476">GetWALInsertionTimeLine</a> -- Returns the current timeline of a system that<br/></li>
<li></span><span class="Comment"> * is not in recovery.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TimeLineID<br/></li>
<li><a id="L6476">&#x200c;</a><span class="linkable">GetWALInsertionTimeLine</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;SharedRecoveryState == RECOVERY_STATE_DONE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Since the value can't be changing, no lock is required. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InsertTimeLineID;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6493" title="access/transam/xlog.c:6493">GetLastImportantRecPtr</a> -- Returns the LSN of the last important record<br/></li>
<li></span><span class="Comment"> * inserted. All <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> not explicitly marked as unimportant are considered<br/></li>
<li></span><span class="Comment"> * important.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The LSN is determined by computing the maximum of<br/></li>
<li></span><span class="Comment"> * <a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[i].lastImportantAt.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L6493">&#x200c;</a><span class="linkable">GetLastImportantRecPtr</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; res = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L150" title="access/transam/xlog.c:150">NUM_XLOGINSERT_LOCKS</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; last_important;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Need to take a lock to prevent torn reads of the LSN, which are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible on some of the supported platforms. WAL insert locks only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * support exclusive mode, so we have to use that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(&amp;<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[i].l.lock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; last_important = <a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[i].l.lastImportantAt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(&amp;<a href="#L564" title="access/transam/xlog.c:564">WALInsertLocks</a>[i].l.lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res &lt; last_important)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = last_important;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the time and LSN of the last xlog segment switch<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>pg_time_t<br/></li>
<li><a id="L6522">&#x200c;</a><span class="linkable">GetLastSegSwitchData</span>(XLogRecPtr *lastSwitchLSN)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_time_t&nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need WALWriteLock, but shared lock is sufficient */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(WALWriteLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; result = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;lastSegSwitchTime;<br/></li>
<li>&nbsp; &nbsp; *lastSwitchLSN = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;lastSegSwitchLSN;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WALWriteLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This must be called ONCE during postmaster or standalone-backend shutdown<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L6539">&#x200c;</a></span><span class="linkable">ShutdownXLOG</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We should have an aux process resource owner to use, and we should not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be in a transaction that's installed some other resowner.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../utils/resowner/resowner.c.html#L168" title="utils/resowner/resowner.c:168">AuxProcessResourceOwner</a> != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> == <a href="../../utils/resowner/resowner.c.html#L168" title="utils/resowner/resowner.c:168">AuxProcessResourceOwner</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = <a href="../../utils/resowner/resowner.c.html#L168" title="utils/resowner/resowner.c:168">AuxProcessResourceOwner</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't be chatty in standalone mode */<br/></li>
<li></span>&nbsp; &nbsp; ereport(<a href="../../utils/init/globals.c.html#L116" title="utils/init/globals.c:116">IsPostmasterEnvironment</a> ? LOG : NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;shutting down&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Signal walsenders to move to stopping state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../replication/walsender.c.html#L3745" title="replication/walsender.c:3745">WalSndInitStopping</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Wait for WAL senders to be in stopping state.&nbsp; This prevents commands<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from writing new WAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../replication/walsender.c.html#L3771" title="replication/walsender.c:3771">WalSndWaitStopping</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7512" title="access/transam/xlog.c:7512">CreateRestartPoint</a>(CHECKPOINT_IS_SHUTDOWN | CHECKPOINT_IMMEDIATE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If archiving is enabled, rotate the last XLOG file so that all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remaining <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> are archived (postmaster wakes up the archiver<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process one more time at the end of shutdown). The checkpoint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * record will go to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> XLOG file and won't be archived (yet).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogArchivingActive())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7981" title="access/transam/xlog.c:7981">RequestXLogSwitch</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6821" title="access/transam/xlog.c:6821">CreateCheckPoint</a>(CHECKPOINT_IS_SHUTDOWN | CHECKPOINT_IMMEDIATE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Log start of a checkpoint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6586">&#x200c;</a></span><span class="linkable">LogCheckpointStart</span>(<span class="Type">int</span> flags, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> restartpoint)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (restartpoint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: the placeholders show checkpoint options */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;restartpoint starting:</span><span class="Special">%s%s%s%s%s%s%s%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; CHECKPOINT_IS_SHUTDOWN) ? <span class="Constant">&quot; shutdown&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; CHECKPOINT_END_OF_RECOVERY) ? <span class="Constant">&quot; end-of-recovery&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; CHECKPOINT_IMMEDIATE) ? <span class="Constant">&quot; immediate&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; CHECKPOINT_FORCE) ? <span class="Constant">&quot; force&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; CHECKPOINT_WAIT) ? <span class="Constant">&quot; wait&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; CHECKPOINT_CAUSE_XLOG) ? <span class="Constant">&quot; wal&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; CHECKPOINT_CAUSE_TIME) ? <span class="Constant">&quot; time&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; CHECKPOINT_FLUSH_ALL) ? <span class="Constant">&quot; flush-all&quot;</span> : <span class="Constant">&quot;&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: the placeholders show checkpoint options */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;checkpoint starting:</span><span class="Special">%s%s%s%s%s%s%s%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; CHECKPOINT_IS_SHUTDOWN) ? <span class="Constant">&quot; shutdown&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; CHECKPOINT_END_OF_RECOVERY) ? <span class="Constant">&quot; end-of-recovery&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; CHECKPOINT_IMMEDIATE) ? <span class="Constant">&quot; immediate&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; CHECKPOINT_FORCE) ? <span class="Constant">&quot; force&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; CHECKPOINT_WAIT) ? <span class="Constant">&quot; wait&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; CHECKPOINT_CAUSE_XLOG) ? <span class="Constant">&quot; wal&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; CHECKPOINT_CAUSE_TIME) ? <span class="Constant">&quot; time&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; CHECKPOINT_FLUSH_ALL) ? <span class="Constant">&quot; flush-all&quot;</span> : <span class="Constant">&quot;&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Log end of a checkpoint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6618">&#x200c;</a></span><span class="linkable">LogCheckpointEnd</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> restartpoint)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; write_msecs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sync_msecs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_msecs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; longest_msecs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; average_msecs;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; average_sync_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_end_t = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; write_msecs = <a href="../../utils/adt/timestamp.c.html#L1766" title="utils/adt/timestamp.c:1766">TimestampDifferenceMilliseconds</a>(<a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_write_t,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_sync_t);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sync_msecs = <a href="../../utils/adt/timestamp.c.html#L1766" title="utils/adt/timestamp.c:1766">TimestampDifferenceMilliseconds</a>(<a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_sync_t,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_sync_end_t);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Accumulate checkpoint timing summary data, in milliseconds. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_checkpointer.c.html#L23" title="utils/activity/pgstat_checkpointer.c:23">PendingCheckpointerStats</a>.write_time += write_msecs;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_checkpointer.c.html#L23" title="utils/activity/pgstat_checkpointer.c:23">PendingCheckpointerStats</a>.sync_time += sync_msecs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All of the published timing statistics are accounted for.&nbsp; Only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * continue if a log message is to be written.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L129" title="access/transam/xlog.c:129">log_checkpoints</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; total_msecs = <a href="../../utils/adt/timestamp.c.html#L1766" title="utils/adt/timestamp.c:1766">TimestampDifferenceMilliseconds</a>(<a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_start_t,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_end_t);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Timing <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> returned from <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a> are in microseconds.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Convert to milliseconds for consistent printing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; longest_msecs = (<span class="Type">long</span>) ((<a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_longest_sync + <span class="Constant">999</span>) / <span class="Constant">1000</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; average_sync_time = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_sync_rels &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; average_sync_time = <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_agg_sync_time /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_sync_rels;<br/></li>
<li>&nbsp; &nbsp; average_msecs = (<span class="Type">long</span>) ((average_sync_time + <span class="Constant">999</span>) / <span class="Constant">1000</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ControlFileLock is not required to see <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPoint and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * -&gt;checkPointCopy here as we are the only updator of those variables at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this moment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (restartpoint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;restartpoint complete: wrote </span><span class="Special">%d</span><span class="Constant"> buffers (</span><span class="Special">%.1f%%</span><span class="Constant">); &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant"> WAL file(s) added, </span><span class="Special">%d</span><span class="Constant"> removed, </span><span class="Special">%d</span><span class="Constant"> recycled; &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;write=</span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%03d</span><span class="Constant"> s, sync=</span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%03d</span><span class="Constant"> s, total=</span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%03d</span><span class="Constant"> s; &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;sync files=</span><span class="Special">%d</span><span class="Constant">, <a href="../../regex/rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a>=</span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%03d</span><span class="Constant"> s, average=</span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%03d</span><span class="Constant"> s; &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;distance=</span><span class="Special">%d</span><span class="Constant"> kB, estimate=</span><span class="Special">%d</span><span class="Constant"> kB; &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;lsn=</span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, redo lsn=</span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_bufs_written,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">double</span>) <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_bufs_written * <span class="Constant">100</span> / <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_segs_added,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_segs_removed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_segs_recycled,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; write_msecs / <span class="Constant">1000</span>, (<span class="Type">int</span>) (write_msecs % <span class="Constant">1000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sync_msecs / <span class="Constant">1000</span>, (<span class="Type">int</span>) (sync_msecs % <span class="Constant">1000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_msecs / <span class="Constant">1000</span>, (<span class="Type">int</span>) (total_msecs % <span class="Constant">1000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_sync_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; longest_msecs / <span class="Constant">1000</span>, (<span class="Type">int</span>) (longest_msecs % <span class="Constant">1000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; average_msecs / <span class="Constant">1000</span>, (<span class="Type">int</span>) (average_msecs % <span class="Constant">1000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) (<a href="#L160" title="access/transam/xlog.c:160">PrevCheckPointDistance</a> / <span class="Constant">1024.0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) (<a href="#L159" title="access/transam/xlog.c:159">CheckPointDistanceEstimate</a> / <span class="Constant">1024.0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPoint),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.redo))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;checkpoint complete: wrote </span><span class="Special">%d</span><span class="Constant"> buffers (</span><span class="Special">%.1f%%</span><span class="Constant">); &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant"> WAL file(s) added, </span><span class="Special">%d</span><span class="Constant"> removed, </span><span class="Special">%d</span><span class="Constant"> recycled; &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;write=</span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%03d</span><span class="Constant"> s, sync=</span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%03d</span><span class="Constant"> s, total=</span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%03d</span><span class="Constant"> s; &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;sync files=</span><span class="Special">%d</span><span class="Constant">, <a href="../../regex/rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a>=</span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%03d</span><span class="Constant"> s, average=</span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%03d</span><span class="Constant"> s; &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;distance=</span><span class="Special">%d</span><span class="Constant"> kB, estimate=</span><span class="Special">%d</span><span class="Constant"> kB; &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;lsn=</span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, redo lsn=</span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_bufs_written,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">double</span>) <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_bufs_written * <span class="Constant">100</span> / <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_segs_added,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_segs_removed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_segs_recycled,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; write_msecs / <span class="Constant">1000</span>, (<span class="Type">int</span>) (write_msecs % <span class="Constant">1000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sync_msecs / <span class="Constant">1000</span>, (<span class="Type">int</span>) (sync_msecs % <span class="Constant">1000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_msecs / <span class="Constant">1000</span>, (<span class="Type">int</span>) (total_msecs % <span class="Constant">1000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_sync_rels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; longest_msecs / <span class="Constant">1000</span>, (<span class="Type">int</span>) (longest_msecs % <span class="Constant">1000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; average_msecs / <span class="Constant">1000</span>, (<span class="Type">int</span>) (average_msecs % <span class="Constant">1000</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) (<a href="#L160" title="access/transam/xlog.c:160">PrevCheckPointDistance</a> / <span class="Constant">1024.0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) (<a href="#L159" title="access/transam/xlog.c:159">CheckPointDistanceEstimate</a> / <span class="Constant">1024.0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPoint),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.redo))));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update the estimate of distance between checkpoints.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The estimate is used to calculate the number of WAL segments to keep<br/></li>
<li></span><span class="Comment"> * preallocated, see <a href="#L2235" title="access/transam/xlog.c:2235">XLOGfileslop</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6721">&#x200c;</a></span><span class="linkable">UpdateCheckPointDistanceEstimate</span>(uint64 nbytes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To estimate the number of segments consumed between checkpoints, keep a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * moving average of the amount of WAL generated in previous checkpoint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cycles. However, if the load is bursty, with quiet periods and busy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * periods, we want to cater for the peak load. So instead of a plain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * moving average, let the average decline slowly if the previous cycle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used less WAL than estimated, but bump it up immediately if it used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When checkpoints are triggered by max_wal_size, this should converge to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CheckpointSegments * <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: This doesn't pay <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> attention to what caused the checkpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Checkpoints triggered manually with CHECKPOINT command, or by e.g.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * starting a base backup, are counted the same as those created<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * automatically. The slow-decline will largely mask them out, if they are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not frequent. If they are frequent, it seems reasonable to count them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in as <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> others; if you issue a manual checkpoint every 5 minutes and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * never let a timed checkpoint happen, it makes sense to base the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * preallocation on that 5 minute interval rather than whatever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoint_timeout is set to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L160" title="access/transam/xlog.c:160">PrevCheckPointDistance</a> = nbytes;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L159" title="access/transam/xlog.c:159">CheckPointDistanceEstimate</a> &lt; nbytes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L159" title="access/transam/xlog.c:159">CheckPointDistanceEstimate</a> = nbytes;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L159" title="access/transam/xlog.c:159">CheckPointDistanceEstimate</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Constant">0.90</span> * <a href="#L159" title="access/transam/xlog.c:159">CheckPointDistanceEstimate</a> + <span class="Constant">0.10</span> * (<span class="Type">double</span>) nbytes);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update the ps display for a process running a checkpoint.&nbsp; Note that<br/></li>
<li></span><span class="Comment"> * this routine should not do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> allocations so as it can be called<br/></li>
<li></span><span class="Comment"> * from a critical section.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6759">&#x200c;</a></span><span class="linkable">update_checkpoint_display</span>(<span class="Type">int</span> flags, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> restartpoint, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> reset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The status is reported only for end-of-recovery and shutdown<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoints or shutdown restartpoints.&nbsp; Updating the ps display is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * useful in those situations as it may not be possible to rely on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_stat_activity to see the status of the checkpointer or the startup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; (CHECKPOINT_END_OF_RECOVERY | CHECKPOINT_IS_SHUTDOWN)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (reset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(<span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; activitymsg[<span class="Constant">128</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(activitymsg, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(activitymsg), <span class="Constant">&quot;performing </span><span class="Special">%s%s%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (flags &amp; CHECKPOINT_END_OF_RECOVERY) ? <span class="Constant">&quot;end-of-recovery &quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (flags &amp; CHECKPOINT_IS_SHUTDOWN) ? <span class="Constant">&quot;shutdown &quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; restartpoint ? <span class="Constant">&quot;restartpoint&quot;</span> : <span class="Constant">&quot;checkpoint&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(activitymsg);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform a checkpoint --- either during shutdown, or on-the-fly<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * flags is a bitwise OR of the following:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; CHECKPOINT_IS_SHUTDOWN: checkpoint is for database shutdown.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; CHECKPOINT_END_OF_RECOVERY: checkpoint is for end of WAL recovery.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; CHECKPOINT_IMMEDIATE: finish the checkpoint ASAP,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ignoring checkpoint_completion_target parameter.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; CHECKPOINT_FORCE: force a checkpoint even if no XLOG activity has occurred<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; since the last one (implied by CHECKPOINT_IS_SHUTDOWN or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; CHECKPOINT_END_OF_RECOVERY).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; CHECKPOINT_FLUSH_ALL: also flush buffers of unlogged tables.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: flags contains other bits, of interest here only for logging purposes.<br/></li>
<li></span><span class="Comment"> * In particular note that this routine is synchronous and does not pay<br/></li>
<li></span><span class="Comment"> * attention to CHECKPOINT_WAIT.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If !shutdown then we are writing an online checkpoint. An XLOG_CHECKPOINT_REDO<br/></li>
<li></span><span class="Comment"> * record is inserted into WAL at the logical location of the checkpoint, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * flushing anything to disk, and when the checkpoint is eventually completed,<br/></li>
<li></span><span class="Comment"> * and it is from this point that WAL replay will begin in the case of a recovery<br/></li>
<li></span><span class="Comment"> * from this checkpoint. Once everything is written to disk, an<br/></li>
<li></span><span class="Comment"> * XLOG_CHECKPOINT_ONLINE record is written to complete the checkpoint, and<br/></li>
<li></span><span class="Comment"> * points back to the earlier XLOG_CHECKPOINT_REDO record. This mechanism allows<br/></li>
<li></span><span class="Comment"> * other write-ahead log <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> to be written while the checkpoint is in<br/></li>
<li></span><span class="Comment"> * progress, but we must be very careful about order of operations. This function<br/></li>
<li></span><span class="Comment"> * may take many minutes to execute on a busy system.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On the other hand, when shutdown is true, concurrent insertion into the<br/></li>
<li></span><span class="Comment"> * write-ahead log is impossible, so there is no need for two separate <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment"> * In this case, we only insert an XLOG_CHECKPOINT_SHUTDOWN record, and it's<br/></li>
<li></span><span class="Comment"> * both the record marking the completion of the checkpoint and the location<br/></li>
<li></span><span class="Comment"> * from which WAL replay would begin if needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L6821">&#x200c;</a></span><span class="linkable">CreateCheckPoint</span>(<span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; shutdown;<br/></li>
<li>&nbsp; &nbsp; CheckPoint&nbsp; &nbsp; checkPoint;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; _logSegNo;<br/></li>
<li>&nbsp; &nbsp; <a href="#L396" title="access/transam/xlog.c:396">XLogCtlInsert</a> *<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> = &amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; freespace;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; PriorRedoPtr;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; last_important_lsn;<br/></li>
<li>&nbsp; &nbsp; VirtualTransactionId *vxids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nvxids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldXLogAllowed = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * An end-of-recovery checkpoint is really a shutdown checkpoint, just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * issued at a different time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; (CHECKPOINT_IS_SHUTDOWN | CHECKPOINT_END_OF_RECOVERY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shutdown = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; shutdown = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>() &amp;&amp; (flags &amp; CHECKPOINT_END_OF_RECOVERY) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;can't create a checkpoint during recovery&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare to accumulate statistics.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: because it is possible for <a href="#L129" title="access/transam/xlog.c:129">log_checkpoints</a> to change while a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoint proceeds, we always accumulate stats, even if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L129" title="access/transam/xlog.c:129">log_checkpoints</a> is currently off.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(&amp;<a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>));<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_start_t = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Let smgr prepare for checkpoint; this has to happen outside the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * critical section and <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we determine the REDO pointer.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * smgr must not do anything that'd have to be undone if we decide no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoint is needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/sync/sync.c.html#L177" title="storage/sync/sync.c:177">SyncPreCheckpoint</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use a critical section to force system panic if we have trouble.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shutdown)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ControlFileLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;state = DB_SHUTDOWNING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4526" title="access/transam/xlog.c:4526">UpdateControlFile</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Begin filling in the checkpoint WAL record */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(&amp;checkPoint, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(checkPoint));<br/></li>
<li>&nbsp; &nbsp; checkPoint.time = (pg_time_t) time(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For Hot Standby, derive the oldestActiveXid <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we fix the redo<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointer. This allows us to begin accumulating changes to assemble our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * starting snapshot of locks and transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!shutdown &amp;&amp; XLogStandbyInfoActive())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; checkPoint.oldestActiveXid = <a href="../../storage/ipc/procarray.c.html#L2867" title="storage/ipc/procarray.c:2867">GetOldestActiveTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; checkPoint.oldestActiveXid = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get location of last important record <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> acquiring insert locks (as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L6493" title="access/transam/xlog.c:6493">GetLastImportantRecPtr</a>() also locks WAL locks).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; last_important_lsn = <a href="#L6493" title="access/transam/xlog.c:6493">GetLastImportantRecPtr</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this isn't a shutdown or forced checkpoint, and if there has been no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WAL activity requiring a checkpoint, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it.&nbsp; The idea here is to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid inserting duplicate checkpoints when the system is idle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; (CHECKPOINT_IS_SHUTDOWN | CHECKPOINT_END_OF_RECOVERY |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECKPOINT_FORCE)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (last_important_lsn == <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPoint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;checkpoint skipped because system is idle&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * An end-of-recovery checkpoint is created <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> anyone is allowed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * write WAL. To allow us to write the checkpoint record, temporarily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enable <a href="#L6345" title="access/transam/xlog.c:6345">XLogInsertAllowed</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; CHECKPOINT_END_OF_RECOVERY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldXLogAllowed = <a href="#L6378" title="access/transam/xlog.c:6378">LocalSetXLogInsertAllowed</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; checkPoint.ThisTimeLineID = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InsertTimeLineID;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; CHECKPOINT_END_OF_RECOVERY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; checkPoint.PrevTimeLineID = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;PrevTimeLineID;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; checkPoint.PrevTimeLineID = checkPoint.ThisTimeLineID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must block concurrent insertions while examining insert state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1411" title="access/transam/xlog.c:1411">WALInsertLockAcquireExclusive</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; checkPoint.<a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a> = <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;<a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shutdown)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; curInsert = <a href="#L1853" title="access/transam/xlog.c:1853">XLogBytePosToRecPtr</a>(<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;CurrBytePos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compute new REDO record ptr = location of <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> XLOG record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since this is a shutdown checkpoint, there can't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL insertion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; freespace = <a href="#L575" title="access/transam/xlog.c:575">INSERT_FREESPACE</a>(curInsert);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (freespace == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogSegmentOffset(curInsert, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curInsert += SizeOfXLogLongPHD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curInsert += SizeOfXLogShortPHD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; checkPoint.redo = curInsert;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here we update the shared <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> for future <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a> calls;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this must be done while holding all the insertion locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: if we fail to complete the checkpoint, <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * left pointing past where it really needs to point.&nbsp; This is okay;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the only consequence is that <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a> might back up whole buffers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that it didn't really need to.&nbsp; We can't postpone advancing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> because XLogInserts that happen while we are dumping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffers must assume that their buffer changes are not included in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the checkpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>.<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> = checkPoint.redo;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we can release the WAL insertion locks, allowing other xacts to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * proceed while we are flushing disk buffers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1440" title="access/transam/xlog.c:1440">WALInsertLockRelease</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is an online checkpoint, we have not yet determined the redo<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point. We do so <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> by inserting the special XLOG_CHECKPOINT_REDO<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record; the LSN at which it starts becomes the new redo pointer. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't do this for a shutdown checkpoint, because in that case no WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can be written between the redo point and the insertion of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoint record itself, so the checkpoint record itself serves to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mark the redo point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!shutdown)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dummy = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Record must have payload to avoid assertion failure. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;dummy, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dummy));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_XLOG_ID, XLOG_CHECKPOINT_REDO);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L743" title="access/transam/xlog.c:743">XLogInsertRecord</a> will have updated <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>.<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shared memory and <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> in backend-local memory, but we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to copy that into the record that will be inserted when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checkpoint is complete.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; checkPoint.redo = <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update the info_lck-protected copy of <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> as well */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> = checkPoint.redo;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If enabled, log checkpoint start.&nbsp; We postpone this until <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> so as not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to log anything if we decided to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the checkpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L129" title="access/transam/xlog.c:129">log_checkpoints</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6586" title="access/transam/xlog.c:6586">LogCheckpointStart</a>(flags, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update the process title */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L6759" title="access/transam/xlog.c:6759">update_checkpoint_display</a>(flags, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_CHECKPOINT_START(flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the other info we need for the checkpoint record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't need to save oldestClogXid in the checkpoint, it only matters<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the short period in which clog is being truncated, and if we crash<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during that we'll redo the clog truncation and fix up oldestClogXid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(XidGenLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; checkPoint.nextXid = <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid;<br/></li>
<li>&nbsp; &nbsp; checkPoint.oldestXid = <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oldestXid;<br/></li>
<li>&nbsp; &nbsp; checkPoint.oldestXidDB = <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oldestXidDB;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(XidGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(CommitTsLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; checkPoint.oldestCommitTsXid = <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oldestCommitTsXid;<br/></li>
<li>&nbsp; &nbsp; checkPoint.newestCommitTsXid = <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;newestCommitTsXid;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(CommitTsLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(OidGenLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; checkPoint.nextOid = <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!shutdown)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; checkPoint.nextOid += <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oidCount;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(OidGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="multixact.c.html#L2233" title="access/transam/multixact.c:2233">MultiXactGetCheckptMulti</a>(shutdown,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;checkPoint.nextMulti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;checkPoint.nextMultiOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;checkPoint.oldestMulti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;checkPoint.oldestMultiDB);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Having constructed the checkpoint record, ensure all shmem disk buffers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and commit-log buffers are flushed to disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This I/O could fail for various reasons.&nbsp; If so, we will fail to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * complete the checkpoint, but there is no reason to force a system<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * panic. Accordingly, exit critical section while doing it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In some cases there are groups of actions that must all occur on one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * side or the other of a checkpoint record. Before flushing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoint record we must explicitly wait for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backend currently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * performing those groups of actions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * One example is end of transaction, so we must wait for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transactions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that are currently in commit critical sections.&nbsp; If an xact inserted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its commit record into XLOG just <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the REDO point, then a crash<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restart from the REDO point would not replay that record, which means<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that our flushing had better include the xact's update of pg_xact.&nbsp; So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we wait till he's out of his commit critical section <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> proceeding.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See notes in <a href="xact.c.html#L1304" title="access/transam/xact.c:1304">RecordTransactionCommit</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because we've already released the insertion locks, this test is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fuzzy: it is possible that we will wait for xacts we didn't really need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to wait for.&nbsp; But the delay should be short and it seems better to make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoint take a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> longer than to hold off insertions longer than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessary. (In fact, the whole reason we have this issue is that xact.c<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * does commit record XLOG insertion and clog update as two separate steps<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * protected by different locks, but again that seems best on grounds of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * minimizing lock contention.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A transaction that has not yet set delayChkptFlags when we look cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be at risk, since it has not inserted its commit record yet; and one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that's already cleared it is not at risk either, since it's done fixing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clog and we will correctly flush the update below.&nbsp; So we cannot <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> xacts we need to wait for.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; vxids = <a href="../../storage/ipc/procarray.c.html#L3030" title="storage/ipc/procarray.c:3030">GetVirtualXIDsDelayingChkpt</a>(&amp;nvxids, DELAY_CHKPT_START);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nvxids &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_CHECKPOINT_DELAY_START);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<span class="Constant">10000L</span>);&nbsp; &nbsp; <span class="Comment">/* wait for 10 msec */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (<a href="../../storage/ipc/procarray.c.html#L3076" title="storage/ipc/procarray.c:3076">HaveVirtualXIDsDelayingChkpt</a>(vxids, nvxids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DELAY_CHKPT_START));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(vxids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L7431" title="access/transam/xlog.c:7431">CheckPointGuts</a>(checkPoint.redo, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vxids = <a href="../../storage/ipc/procarray.c.html#L3030" title="storage/ipc/procarray.c:3030">GetVirtualXIDsDelayingChkpt</a>(&amp;nvxids, DELAY_CHKPT_COMPLETE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nvxids &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_CHECKPOINT_DELAY_COMPLETE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<span class="Constant">10000L</span>);&nbsp; &nbsp; <span class="Comment">/* wait for 10 msec */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (<a href="../../storage/ipc/procarray.c.html#L3076" title="storage/ipc/procarray.c:3076">HaveVirtualXIDsDelayingChkpt</a>(vxids, nvxids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DELAY_CHKPT_COMPLETE));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(vxids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Take a snapshot of running transactions and write this to WAL. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allows us to reconstruct the state of running transactions during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * archive recovery, if required. Skip, if this info disabled.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are shutting down, or Startup process is completing crash<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery we don't need to write running xact data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!shutdown &amp;&amp; XLogStandbyInfoActive())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/standby.c.html#L1285" title="storage/ipc/standby.c:1285">LogStandbySnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now insert the checkpoint record into XLOG.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;checkPoint), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(checkPoint));<br/></li>
<li>&nbsp; &nbsp; recptr = <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_XLOG_ID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shutdown ? XLOG_CHECKPOINT_SHUTDOWN :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLOG_CHECKPOINT_ONLINE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(recptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We mustn't write <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new WAL after a shutdown checkpoint, or it will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overwritten at <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> startup.&nbsp; No-one should even try, this just allows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sanity-checking.&nbsp; In the case of an end-of-recovery checkpoint, we want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to just temporarily disable writing until the system has exited<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shutdown)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; CHECKPOINT_END_OF_RECOVERY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L236" title="access/transam/xlog.c:236">LocalXLogInsertAllowed</a> = oldXLogAllowed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L236" title="access/transam/xlog.c:236">LocalXLogInsertAllowed</a> = <span class="Constant">0</span>; <span class="Comment">/* never again write WAL */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have <a href="#L253" title="access/transam/xlog.c:253">ProcLastRecPtr</a> = start of actual checkpoint record, recptr<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * = end of actual checkpoint record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shutdown &amp;&amp; checkPoint.redo != <a href="#L253" title="access/transam/xlog.c:253">ProcLastRecPtr</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;concurrent write-ahead log activity while database system is shutting down&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember the prior checkpoint's redo ptr for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L6721" title="access/transam/xlog.c:6721">UpdateCheckPointDistanceEstimate</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PriorRedoPtr = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.redo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update the control file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ControlFileLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (shutdown)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;state = DB_SHUTDOWNED;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPoint = <a href="#L253" title="access/transam/xlog.c:253">ProcLastRecPtr</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy = checkPoint;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* crash recovery should always recover to the end of WAL */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Persist unloggedLSN value. It's reset on crash recovery, so this goes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unused on non-shutdown checkpoints, but seems useful to store it always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for debugging purposes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;unloggedLSN = pg_atomic_read_membarrier_u64(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;unloggedLSN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4526" title="access/transam/xlog.c:4526">UpdateControlFile</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update shared-memory copy of checkpoint XID/epoch */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;ckptFullXid = checkPoint.nextXid;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> done with critical updates; no need for system panic if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have trouble while fooling with old log segments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WAL summaries end when the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> XLOG_CHECKPOINT_REDO or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLOG_CHECKPOINT_SHUTDOWN record is reached. This is the first point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where (a) we're not inside of a critical section and (b) we can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * certain that the relevant record has been flushed to disk, which must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happen <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it can be summarized.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is a shutdown checkpoint, then this happens reasonably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * promptly: we've only just inserted and flushed the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLOG_CHECKPOINT_SHUTDOWN record. If this is not a shutdown checkpoint,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then this might not be very prompt at all: the XLOG_CHECKPOINT_REDO<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record was written <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we began flushing data to disk, and that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could be many minutes ago at this point. However, we don't <a href="#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after inserting that record, so we're not guaranteed that it's on disk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until after the above call that flushes the XLOG_CHECKPOINT_ONLINE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../postmaster/walsummarizer.c.html#L621" title="postmaster/walsummarizer.c:621">SetWalSummarizerLatch</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Let smgr do post-checkpoint <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> (eg, deleting old files).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/sync/sync.c.html#L202" title="storage/sync/sync.c:202">SyncPostCheckpoint</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update the average distance between checkpoints if the prior checkpoint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PriorRedoPtr != InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6721" title="access/transam/xlog.c:6721">UpdateCheckPointDistanceEstimate</a>(<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> - PriorRedoPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> old log files, those no longer needed for last checkpoint to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prevent the disk holding the xlog from growing full.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLByteToSeg(<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>, _logSegNo, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7874" title="access/transam/xlog.c:7874">KeepLogSeg</a>(recptr, &amp;_logSegNo);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../replication/slot.c.html#L1783" title="replication/slot.c:1783">InvalidateObsoleteReplicationSlots</a>(RS_INVAL_WAL_REMOVED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; _logSegNo, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidTransactionId))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some slots have been invalidated; recalculate the old-segment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * horizon, starting again from <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; XLByteToSeg(<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>, _logSegNo, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7874" title="access/transam/xlog.c:7874">KeepLogSeg</a>(recptr, &amp;_logSegNo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; _logSegNo--;<br/></li>
<li>&nbsp; &nbsp; <a href="#L3854" title="access/transam/xlog.c:3854">RemoveOldXlogFiles</a>(_logSegNo, <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>, recptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; checkPoint.ThisTimeLineID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make more log segments if needed.&nbsp; (Do this after recycling old log<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * segments, since that may supply some of the needed files.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!shutdown)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3679" title="access/transam/xlog.c:3679">PreallocXlogFiles</a>(recptr, checkPoint.ThisTimeLineID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Truncate pg_subtrans if possible.&nbsp; We can throw away all data <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the oldest XMIN of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> running transaction.&nbsp; No future transaction will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attempt to reference <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pg_subtrans entry older than that (see Asserts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in subtrans.c).&nbsp; During recovery, though, we mustn't do this because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="subtrans.c.html#L309" title="access/transam/subtrans.c:309">StartupSUBTRANS</a> hasn't been called yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="subtrans.c.html#L411" title="access/transam/subtrans.c:411">TruncateSUBTRANS</a>(<a href="../../storage/ipc/procarray.c.html#L2022" title="storage/ipc/procarray.c:2022">GetOldestTransactionIdConsideredRunning</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Real work is done; log and update stats. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L6618" title="access/transam/xlog.c:6618">LogCheckpointEnd</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset the process title */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L6759" title="access/transam/xlog.c:6759">update_checkpoint_display</a>(flags, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_CHECKPOINT_DONE(<a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_bufs_written,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_segs_added,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_segs_removed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_segs_recycled);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Mark the end of recovery in WAL though without running a full checkpoint.<br/></li>
<li></span><span class="Comment"> * We can expect that a restartpoint is likely to be in progress as we<br/></li>
<li></span><span class="Comment"> * do this, though we are unwilling to wait for it to complete.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L7512" title="access/transam/xlog.c:7512">CreateRestartPoint</a>() allows for the case where recovery may end <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * the restartpoint completes so there is no concern of concurrent behaviour.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L7297">&#x200c;</a></span><span class="linkable">CreateEndOfRecoveryRecord</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xl_end_of_recovery xlrec;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity check */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;can only be used to end recovery&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec.end_time = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1411" title="access/transam/xlog.c:1411">WALInsertLockAcquireExclusive</a>();<br/></li>
<li>&nbsp; &nbsp; xlrec.ThisTimeLineID = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InsertTimeLineID;<br/></li>
<li>&nbsp; &nbsp; xlrec.PrevTimeLineID = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;PrevTimeLineID;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1440" title="access/transam/xlog.c:1440">WALInsertLockRelease</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_end_of_recovery));<br/></li>
<li>&nbsp; &nbsp; recptr = <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_XLOG_ID, XLOG_END_OF_RECOVERY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(recptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update the control file so that crash recovery can follow the timeline<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * changes to this point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ControlFileLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> = recptr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a> = xlrec.ThisTimeLineID;<br/></li>
<li>&nbsp; &nbsp; <a href="#L4526" title="access/transam/xlog.c:4526">UpdateControlFile</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write an OVERWRITE_CONTRECORD message.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When on WAL replay we expect a continuation record at the start of a page<br/></li>
<li></span><span class="Comment"> * that is not there, recovery ends and WAL writing resumes at that point.<br/></li>
<li></span><span class="Comment"> * But it's wrong to resume writing new WAL back at the start of the record<br/></li>
<li></span><span class="Comment"> * that was broken, because downstream consumers of that WAL (physical<br/></li>
<li></span><span class="Comment"> * replicas) are not prepared to &quot;rewind&quot;.&nbsp; So the first action after<br/></li>
<li></span><span class="Comment"> * finishing replay of all valid WAL must be to write a record of this type<br/></li>
<li></span><span class="Comment"> * at the point where the contrecord was missing; to support <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a><br/></li>
<li></span><span class="Comment"> * detecting the special case, XLP_FIRST_IS_OVERWRITE_CONTRECORD is also added<br/></li>
<li></span><span class="Comment"> * to the page header where the record occurs.&nbsp; <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a> has an ad-hoc<br/></li>
<li></span><span class="Comment"> * mechanism to report metadata about the broken record, which is what we<br/></li>
<li></span><span class="Comment"> * use here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At replay time, XLP_FIRST_IS_OVERWRITE_CONTRECORD instructs <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a> to<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the record it was reading, and pass back the LSN of the skipped<br/></li>
<li></span><span class="Comment"> * record, so that its caller can verify (on &quot;replay&quot; of that record) that the<br/></li>
<li></span><span class="Comment"> * XLOG_OVERWRITE_CONTRECORD matches what was effectively overwritten.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'aborted_lsn' is the beginning position of the record that was incomplete.<br/></li>
<li></span><span class="Comment"> * It is included in the WAL record.&nbsp; 'pagePtr' and 'newTLI' point to the<br/></li>
<li></span><span class="Comment"> * beginning of the XLOG page where the record is to be inserted.&nbsp; They must<br/></li>
<li></span><span class="Comment"> * match the current WAL insert position, they're passed here just so that we<br/></li>
<li></span><span class="Comment"> * can verify that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> XLogRecPtr<br/></li>
<li><a id="L7361">&#x200c;</a><span class="linkable">CreateOverwriteContrecordRecord</span>(XLogRecPtr aborted_lsn, XLogRecPtr pagePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID newTLI)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xl_overwrite_contrecord xlrec;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; XLogPageHeader pagehdr;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; startPos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity checks */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;can only be used at end of recovery&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pagePtr % XLOG_BLCKSZ != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid position for missing continuation record </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(pagePtr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The current WAL insert position should be right after the page header */<br/></li>
<li></span>&nbsp; &nbsp; startPos = pagePtr;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (XLogSegmentOffset(startPos, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startPos += SizeOfXLogLongPHD;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; startPos += SizeOfXLogShortPHD;<br/></li>
<li>&nbsp; &nbsp; recptr = <a href="#L9355" title="access/transam/xlog.c:9355">GetXLogInsertRecPtr</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (recptr != startPos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid WAL insert position </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> for OVERWRITE_CONTRECORD&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(recptr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the XLOG page header (by <a href="#L1627" title="access/transam/xlog.c:1627">GetXLogBuffer</a>), and set the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLP_FIRST_IS_OVERWRITE_CONTRECORD flag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No other backend is allowed to write WAL yet, so acquiring the WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * insertion lock is just pro forma.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1366" title="access/transam/xlog.c:1366">WALInsertLockAcquire</a>();<br/></li>
<li>&nbsp; &nbsp; pagehdr = (XLogPageHeader) <a href="#L1627" title="access/transam/xlog.c:1627">GetXLogBuffer</a>(pagePtr, newTLI);<br/></li>
<li>&nbsp; &nbsp; pagehdr-&gt;xlp_info |= XLP_FIRST_IS_OVERWRITE_CONTRECORD;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1440" title="access/transam/xlog.c:1440">WALInsertLockRelease</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> the XLOG_OVERWRITE_CONTRECORD record as the first record on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page.&nbsp; We know it becomes the first record, because no other backend is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allowed to write WAL yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; xlrec.overwritten_lsn = aborted_lsn;<br/></li>
<li>&nbsp; &nbsp; xlrec.overwrite_time = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_overwrite_contrecord));<br/></li>
<li>&nbsp; &nbsp; recptr = <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_XLOG_ID, XLOG_OVERWRITE_CONTRECORD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check that the record was inserted to the right place */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L253" title="access/transam/xlog.c:253">ProcLastRecPtr</a> != startPos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;OVERWRITE_CONTRECORD was inserted to unexpected position </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="#L253" title="access/transam/xlog.c:253">ProcLastRecPtr</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(recptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> recptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Flush all data in shared memory to disk, and fsync<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is the common code shared between regular checkpoints and<br/></li>
<li></span><span class="Comment"> * recovery restartpoints.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L7431">&#x200c;</a></span><span class="linkable">CheckPointGuts</span>(XLogRecPtr checkPointRedo, <span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/cache/relmapper.c.html#L611" title="utils/cache/relmapper.c:611">CheckPointRelationMap</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../replication/slot.c.html#L1839" title="replication/slot.c:1839">CheckPointReplicationSlots</a>(flags &amp; CHECKPOINT_IS_SHUTDOWN);<br/></li>
<li>&nbsp; &nbsp; <a href="../../replication/logical/snapbuild.c.html#L2054" title="replication/logical/snapbuild.c:2054">CheckPointSnapBuild</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../heap/rewriteheap.c.html#L1155" title="access/heap/rewriteheap.c:1155">CheckPointLogicalRewriteHeap</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../replication/logical/origin.c.html#L573" title="replication/logical/origin.c:573">CheckPointReplicationOrigin</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write out all dirty data in SLRUs and the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> buffer pool */<br/></li>
<li></span>&nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_CHECKPOINT_START(flags);<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_write_t = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="clog.c.html#L937" title="access/transam/clog.c:937">CheckPointCLOG</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="commit_ts.c.html#L820" title="access/transam/commit_ts.c:820">CheckPointCommitTs</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="subtrans.c.html#L355" title="access/transam/subtrans.c:355">CheckPointSUBTRANS</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="multixact.c.html#L2255" title="access/transam/multixact.c:2255">CheckPointMultiXact</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L1036" title="storage/lmgr/predicate.c:1036">CheckPointPredicate</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3653" title="storage/buffer/bufmgr.c:3653">CheckPointBuffers</a>(flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform all queued up fsyncs */<br/></li>
<li></span>&nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_CHECKPOINT_SYNC_START();<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_sync_t = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/sync/sync.c.html#L286" title="storage/sync/sync.c:286">ProcessSyncRequests</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_sync_end_t = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_BUFFER_CHECKPOINT_DONE();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We deliberately delay 2PC checkpointing as long as possible */<br/></li>
<li></span>&nbsp; &nbsp; <a href="twophase.c.html#L1816" title="access/transam/twophase.c:1816">CheckPointTwoPhase</a>(checkPointRedo);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Save a checkpoint for recovery restart if appropriate<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is called each time a checkpoint record is read from XLOG.<br/></li>
<li></span><span class="Comment"> * It must determine whether the checkpoint represents a safe restartpoint or<br/></li>
<li></span><span class="Comment"> * not.&nbsp; If so, the checkpoint record is stashed in shared memory so that<br/></li>
<li></span><span class="Comment"> * <a href="#L7512" title="access/transam/xlog.c:7512">CreateRestartPoint</a> can consult it.&nbsp; (Note that the latter function is<br/></li>
<li></span><span class="Comment"> * executed by the checkpointer, while this one will be executed by the<br/></li>
<li></span><span class="Comment"> * startup process.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L7471">&#x200c;</a></span><span class="linkable">RecoveryRestartPoint</span>(<span class="Type">const</span> CheckPoint *checkPoint, XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also refrain from creating a restartpoint if we have seen <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * references to non-existent pages. Restarting recovery from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restartpoint would not see the references, so we would lose the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cross-check that the pages belonged to a relation that was dropped<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogutils.c.html#L235" title="access/transam/xlogutils.c:235">XLogHaveInvalidPages</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;could not record restart point at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> because there &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;are unresolved references to invalid pages&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(checkPoint-&gt;redo));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the checkpoint record to shared memory, so that checkpointer can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * work out the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time it wants to perform a restartpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;lastCheckPointRecPtr = record-&gt;ReadRecPtr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;lastCheckPointEndPtr = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;lastCheckPoint = *checkPoint;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Establish a restartpoint if possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is similar to <a href="#L6821" title="access/transam/xlog.c:6821">CreateCheckPoint</a>, but is used during WAL recovery<br/></li>
<li></span><span class="Comment"> * to establish a point from which recovery can roll forward without<br/></li>
<li></span><span class="Comment"> * replaying the entire recovery log.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if a new restartpoint was established. We can only establish<br/></li>
<li></span><span class="Comment"> * a restartpoint if we have replayed a safe checkpoint record since last<br/></li>
<li></span><span class="Comment"> * restartpoint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L7512">&#x200c;</a></span><span class="linkable">CreateRestartPoint</span>(<span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lastCheckPointRecPtr;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lastCheckPointEndPtr;<br/></li>
<li>&nbsp; &nbsp; CheckPoint&nbsp; &nbsp; lastCheckPoint;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; PriorRedoPtr;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; receivePtr;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; replayPtr;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; replayTLI;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; endptr;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; _logSegNo;<br/></li>
<li>&nbsp; &nbsp; TimestampTz xtime;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Concurrent checkpoint/restartpoint cannot happen */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> || <a href="../../utils/init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a> == B_CHECKPOINTER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get a local copy of the last safe checkpoint record. */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; lastCheckPointRecPtr = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;lastCheckPointRecPtr;<br/></li>
<li>&nbsp; &nbsp; lastCheckPointEndPtr = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;lastCheckPointEndPtr;<br/></li>
<li>&nbsp; &nbsp; lastCheckPoint = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;lastCheckPoint;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that we're still in recovery mode. It's ok if we exit recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mode after this check, the restart point is valid anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;skipping restartpoint, recovery has already ended&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the last checkpoint record we've replayed is already our last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restartpoint, we can't perform a new restart point. We still update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> in that case, so that if this is a shutdown restart<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point, we won't start up earlier than <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>. That's not strictly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessary, but when hot standby is enabled, it would be rather weird if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the database opened up for read-only connections at a point-in-time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the last shutdown. Such time travel is still possible in case of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediate shutdown, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't explicitly advance <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> when we do create a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restartpoint. It's assumed that flushing the buffers will do that as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * side-effect.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(lastCheckPointRecPtr) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lastCheckPoint.redo &lt;= <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.redo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;skipping restartpoint, already performed at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(lastCheckPoint.redo))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2711" title="access/transam/xlog.c:2711">UpdateMinRecoveryPoint</a>(InvalidXLogRecPtr, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; CHECKPOINT_IS_SHUTDOWN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ControlFileLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;state = DB_SHUTDOWNED_IN_RECOVERY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4526" title="access/transam/xlog.c:4526">UpdateControlFile</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update the shared <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> so that the startup process can calculate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the number of segments replayed since last restartpoint, and request a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restartpoint if it exceeds <a href="#L156" title="access/transam/xlog.c:156">CheckPointSegments</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Like in <a href="#L6821" title="access/transam/xlog.c:6821">CreateCheckPoint</a>(), hold off insertions to update it, although<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during recovery this is just pro forma, because no WAL insertions are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happening.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1411" title="access/transam/xlog.c:1411">WALInsertLockAcquireExclusive</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>.<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> = lastCheckPoint.redo;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1440" title="access/transam/xlog.c:1440">WALInsertLockRelease</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Also update the info_lck-protected copy */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> = lastCheckPoint.redo;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare to accumulate statistics.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: because it is possible for <a href="#L129" title="access/transam/xlog.c:129">log_checkpoints</a> to change while a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoint proceeds, we always accumulate stats, even if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L129" title="access/transam/xlog.c:129">log_checkpoints</a> is currently off.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(&amp;<a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>));<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="access/transam/xlog.c:209">CheckpointStats</a>.ckpt_start_t = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L129" title="access/transam/xlog.c:129">log_checkpoints</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6586" title="access/transam/xlog.c:6586">LogCheckpointStart</a>(flags, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update the process title */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L6759" title="access/transam/xlog.c:6759">update_checkpoint_display</a>(flags, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L7431" title="access/transam/xlog.c:7431">CheckPointGuts</a>(lastCheckPoint.redo, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This location needs to be after <a href="#L7431" title="access/transam/xlog.c:7431">CheckPointGuts</a>() to ensure that some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * work has already happened during this checkpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; INJECTION_POINT(<span class="Constant">&quot;create-restart-point&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember the prior checkpoint's redo ptr for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L6721" title="access/transam/xlog.c:6721">UpdateCheckPointDistanceEstimate</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PriorRedoPtr = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.redo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update pg_control, using current time.&nbsp; Check that it still shows an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * older checkpoint, else do nothing; this is a quick hack to make sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nothing really bad happens if somehow we get here after the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end-of-recovery checkpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ControlFileLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.redo &lt; lastCheckPoint.redo)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update the checkpoint information.&nbsp; We do this even if the <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * does not show DB_IN_ARCHIVE_RECOVERY to match with the set of WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * segments recycled below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPoint = lastCheckPointRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy = lastCheckPoint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ensure <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> is past the checkpoint record and update it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if the control file still shows DB_IN_ARCHIVE_RECOVERY.&nbsp; Normally,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this will have happened already while writing out dirty buffers,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but not necessarily - e.g. because no buffers were dirtied.&nbsp; We do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this because a backup performed in recovery uses <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to determine which WAL files must be included in the backup, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the file (or files) containing the checkpoint record must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * included, at a minimum.&nbsp; Note that for an ordinary restart of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recovery there's no value in having the minimum recovery point <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * earlier than this anyway, because redo will begin just after the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checkpoint record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;state == DB_IN_ARCHIVE_RECOVERY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> &lt; lastCheckPointEndPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> = lastCheckPointEndPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a> = lastCheckPoint.ThisTimeLineID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update local copy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a> = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L642" title="access/transam/xlog.c:642">LocalMinRecoveryPointTLI</a> = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; CHECKPOINT_IS_SHUTDOWN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;state = DB_SHUTDOWNED_IN_RECOVERY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4526" title="access/transam/xlog.c:4526">UpdateControlFile</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update the average distance between checkpoints/restartpoints if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prior checkpoint exists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PriorRedoPtr != InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6721" title="access/transam/xlog.c:6721">UpdateCheckPointDistanceEstimate</a>(<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> - PriorRedoPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> old log files, those no longer needed for last restartpoint to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prevent the disk holding the xlog from growing full.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLByteToSeg(<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>, _logSegNo, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Retreat _logSegNo using the current end of xlog replayed or received,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whichever is later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; receivePtr = <a href="../../replication/walreceiverfuncs.c.html#L331" title="replication/walreceiverfuncs.c:331">GetWalRcvFlushRecPtr</a>(<span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; replayPtr = <a href="xlogrecovery.c.html#L4539" title="access/transam/xlogrecovery.c:4539">GetXLogReplayRecPtr</a>(&amp;replayTLI);<br/></li>
<li>&nbsp; &nbsp; endptr = (receivePtr &lt; replayPtr) ? replayPtr : receivePtr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L7874" title="access/transam/xlog.c:7874">KeepLogSeg</a>(endptr, &amp;_logSegNo);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../replication/slot.c.html#L1783" title="replication/slot.c:1783">InvalidateObsoleteReplicationSlots</a>(RS_INVAL_WAL_REMOVED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; _logSegNo, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidTransactionId))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some slots have been invalidated; recalculate the old-segment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * horizon, starting again from <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; XLByteToSeg(<a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>, _logSegNo, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7874" title="access/transam/xlog.c:7874">KeepLogSeg</a>(endptr, &amp;_logSegNo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; _logSegNo--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to recycle segments on a useful timeline. If we've been promoted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since the beginning of this restartpoint, use the new timeline chosen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at end of recovery.&nbsp; If we're still in recovery, use the timeline we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * currently replaying.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There is no guarantee that the WAL segments will be useful on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current timeline; if recovery proceeds to a new timeline right after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this, the pre-allocated WAL segments on this timeline will not be used,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and will go wasted until recycled on the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> restartpoint. We'll live<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; replayTLI = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InsertTimeLineID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3854" title="access/transam/xlog.c:3854">RemoveOldXlogFiles</a>(_logSegNo, <a href="#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>, endptr, replayTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make more log segments if needed.&nbsp; (Do this after recycling old log<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * segments, since that may supply some of the needed files.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3679" title="access/transam/xlog.c:3679">PreallocXlogFiles</a>(endptr, replayTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Truncate pg_subtrans if possible.&nbsp; We can throw away all data <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the oldest XMIN of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> running transaction.&nbsp; No future transaction will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attempt to reference <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pg_subtrans entry older than that (see Asserts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in subtrans.c).&nbsp; When hot standby is disabled, though, we mustn't do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this because <a href="subtrans.c.html#L309" title="access/transam/subtrans.c:309">StartupSUBTRANS</a> hasn't been called yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L121" title="access/transam/xlog.c:121">EnableHotStandby</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="subtrans.c.html#L411" title="access/transam/subtrans.c:411">TruncateSUBTRANS</a>(<a href="../../storage/ipc/procarray.c.html#L2022" title="storage/ipc/procarray.c:2022">GetOldestTransactionIdConsideredRunning</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Real work is done; log and update stats. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L6618" title="access/transam/xlog.c:6618">LogCheckpointEnd</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset the process title */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L6759" title="access/transam/xlog.c:6759">update_checkpoint_display</a>(flags, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xtime = <a href="xlogrecovery.c.html#L4596" title="access/transam/xlogrecovery.c:4596">GetLatestXTime</a>();<br/></li>
<li>&nbsp; &nbsp; ereport((<a href="#L129" title="access/transam/xlog.c:129">log_checkpoints</a> ? LOG : DEBUG2),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovery restart point at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(lastCheckPoint.redo)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xtime ? <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Last completed transaction was at log time </span><span class="Special">%s</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/adt/timestamp.c.html#L1853" title="utils/adt/timestamp.c:1853">timestamptz_to_str</a>(xtime)) : <span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finally, execute archive_cleanup_command, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L84" title="access/transam/xlogrecovery.c:84">archiveCleanupCommand</a> &amp;&amp; strcmp(<a href="xlogrecovery.c.html#L84" title="access/transam/xlogrecovery.c:84">archiveCleanupCommand</a>, <span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogarchive.c.html#L295" title="access/transam/xlogarchive.c:295">ExecuteRecoveryCommand</a>(<a href="xlogrecovery.c.html#L84" title="access/transam/xlogrecovery.c:84">archiveCleanupCommand</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;archive_cleanup_command&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_ARCHIVE_CLEANUP_COMMAND);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report availability of WAL for the given target LSN<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (typically a slot's restart_lsn)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns one of the following enum <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * * WALAVAIL_RESERVED means targetLSN is available and it is in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; max_wal_size.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * * WALAVAIL_EXTENDED means it is still available by preserving extra<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; segments beyond max_wal_size. If max_slot_wal_keep_size is smaller<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; than max_wal_size, this state is not returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * * WALAVAIL_UNRESERVED means it is being lost and the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint will<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; remove reserved segments. The walsender using this slot may return to the<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; above.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * * WALAVAIL_REMOVED means it has been removed. A replication stream on<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; a slot with this LSN cannot continue.&nbsp; (Any associated walsender<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; processes should have been terminated already.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * * WALAVAIL_INVALID_LSN means the slot hasn't been set to reserve WAL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>WALAvailability<br/></li>
<li><a id="L7790">&#x200c;</a><span class="linkable">GetWALAvailability</span>(XLogRecPtr targetLSN)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; currpos;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current write LSN */<br/></li>
<li></span>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; currSeg;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* segid of currpos */<br/></li>
<li></span>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; targetSeg;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* segid of targetLSN */<br/></li>
<li></span>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; oldestSeg;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* actual oldest segid */<br/></li>
<li></span>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; oldestSegMaxWalSize;&nbsp; &nbsp; <span class="Comment">/* oldest segid kept by max_wal_size */<br/></li>
<li></span>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; oldestSlotSeg;&nbsp; &nbsp; <span class="Comment">/* oldest segid kept by slot */<br/></li>
<li></span>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; keepSegs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slot does not reserve WAL. Either deactivated, or has never been active<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(targetLSN))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> WALAVAIL_INVALID_LSN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate the oldest segment currently reserved by all slots,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * considering wal_keep_size and max_slot_wal_keep_size.&nbsp; Initialize<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * oldestSlotSeg to the current segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; currpos = <a href="#L9371" title="access/transam/xlog.c:9371">GetXLogWriteRecPtr</a>();<br/></li>
<li>&nbsp; &nbsp; XLByteToSeg(currpos, oldestSlotSeg, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L7874" title="access/transam/xlog.c:7874">KeepLogSeg</a>(currpos, &amp;oldestSlotSeg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find the oldest extant segment file. We get 1 until checkpoint removes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the first WAL segment file since startup, which causes the status being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wrong under certain abnormal conditions but that doesn't actually harm.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldestSeg = <a href="#L3747" title="access/transam/xlog.c:3747">XLogGetLastRemovedSegno</a>() + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* calculate oldest segment by max_wal_size */<br/></li>
<li></span>&nbsp; &nbsp; XLByteToSeg(currpos, currSeg, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; keepSegs = <a href="#L598" title="access/transam/xlog.c:598">ConvertToXSegs</a>(<a href="#L114" title="access/transam/xlog.c:114">max_wal_size_mb</a>, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>) + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (currSeg &gt; keepSegs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldestSegMaxWalSize = currSeg - keepSegs;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldestSegMaxWalSize = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the segment we care about */<br/></li>
<li></span>&nbsp; &nbsp; XLByteToSeg(targetLSN, targetSeg, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No point in returning reserved or extended status <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * targetSeg is known to be lost.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (targetSeg &gt;= oldestSlotSeg)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* show &quot;reserved&quot; when targetSeg is within max_wal_size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (targetSeg &gt;= oldestSegMaxWalSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> WALAVAIL_RESERVED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* being retained by slots exceeding max_wal_size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> WALAVAIL_EXTENDED;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* WAL segments are no longer retained but haven't been removed yet */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (targetSeg &gt;= oldestSeg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> WALAVAIL_UNRESERVED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Definitely lost */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> WALAVAIL_REMOVED;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Retreat *logSegNo to the last segment that we need to retain because of<br/></li>
<li></span><span class="Comment"> * either wal_keep_size or replication slots.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is calculated by subtracting wal_keep_size from the given xlog<br/></li>
<li></span><span class="Comment"> * location, recptr and by making sure that that result is below the<br/></li>
<li></span><span class="Comment"> * requirement of replication slots.&nbsp; For the latter criterion we do consider<br/></li>
<li></span><span class="Comment"> * the effects of max_slot_wal_keep_size: reserve at most that much space back<br/></li>
<li></span><span class="Comment"> * from recptr.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note about replication slots: if this function calculates a value<br/></li>
<li></span><span class="Comment"> * that's further ahead than what slots need reserved, then affected<br/></li>
<li></span><span class="Comment"> * slots need to be invalidated and this function invoked again.<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> it might be a good idea to rewrite this function so that<br/></li>
<li></span><span class="Comment"> * invalidation is optionally done here, instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L7874">&#x200c;</a></span><span class="linkable">KeepLogSeg</span>(XLogRecPtr recptr, XLogSegNo *logSegNo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; currSegNo;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; segno;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; keep;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLByteToSeg(recptr, currSegNo, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; segno = currSegNo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate how many segments are kept by slots first, adjusting for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * max_slot_wal_keep_size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; keep = <a href="#L2690" title="access/transam/xlog.c:2690">XLogGetReplicationSlotMinimumLSN</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (keep != InvalidXLogRecPtr &amp;&amp; keep &lt; recptr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLByteToSeg(keep, segno, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Cap by max_slot_wal_keep_size ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L135" title="access/transam/xlog.c:135">max_slot_wal_keep_size_mb</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; slot_keep_segs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot_keep_segs =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L598" title="access/transam/xlog.c:598">ConvertToXSegs</a>(<a href="#L135" title="access/transam/xlog.c:135">max_slot_wal_keep_size_mb</a>, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (currSegNo - segno &gt; slot_keep_segs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segno = currSegNo - slot_keep_segs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If WAL summarization is in use, don't remove WAL that has yet to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * summarized.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; keep = <a href="../../postmaster/walsummarizer.c.html#L494" title="postmaster/walsummarizer.c:494">GetOldestUnsummarizedLSN</a>(<span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (keep != InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; unsummarized_segno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLByteToSeg(keep, unsummarized_segno, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unsummarized_segno &lt; segno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segno = unsummarized_segno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* but, keep at least wal_keep_size if that's set */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L116" title="access/transam/xlog.c:116">wal_keep_size_mb</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; keep_segs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; keep_segs = <a href="#L598" title="access/transam/xlog.c:598">ConvertToXSegs</a>(<a href="#L116" title="access/transam/xlog.c:116">wal_keep_size_mb</a>, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (currSegNo - segno &lt; keep_segs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* avoid underflow, don't go below 1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (currSegNo &lt;= keep_segs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segno = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segno = currSegNo - keep_segs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't delete WAL segments newer than the calculated segment */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (segno &lt; *logSegNo)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *logSegNo = segno;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write a NEXTOID log record<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L7944">&#x200c;</a></span><span class="linkable">XLogPutNextOid</span>(Oid nextOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;nextOid), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_XLOG_ID, XLOG_NEXTOID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need not flush the NEXTOID record immediately, because <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just-allocated OIDs could only reach disk as part of a tuple insert or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update that would have its own XLOG record that must follow the NEXTOID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record.&nbsp; Therefore, the standard buffer LSN interlock applied to those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> will ensure no such OID reaches disk <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the NEXTOID record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * does.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note, however, that the above statement only covers state &quot;within&quot; the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database.&nbsp; When we use a generated OID as a file or directory name, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are in a sense violating the basic WAL rule, because that filesystem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * change may reach disk <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the NEXTOID WAL record does.&nbsp; The impact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of this is that if a database crash occurs immediately afterward, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might after restart re-generate the same OID and <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> that it conflicts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with the leftover file or directory.&nbsp; But since for safety's sake we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * always loop until finding a nonconflicting filename, this poses no real<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * problem in practice. See pgsql-hackers discussion 27-Sep-2006.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write an XLOG SWITCH record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Here we just blindly issue an <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a> request for the record.<br/></li>
<li></span><span class="Comment"> * All the magic happens inside <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The return value is either the end+1 address of the switch record,<br/></li>
<li></span><span class="Comment"> * or the end+1 address of the prior segment if we did not need to<br/></li>
<li></span><span class="Comment"> * write a switch record because we are already at segment start.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L7981">&#x200c;</a><span class="linkable">RequestXLogSwitch</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> mark_unimportant)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; RecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG SWITCH has no data */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mark_unimportant)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L456" title="access/transam/xloginsert.c:456">XLogSetRecordFlags</a>(XLOG_MARK_UNIMPORTANT);<br/></li>
<li>&nbsp; &nbsp; RecPtr = <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_XLOG_ID, XLOG_SWITCH);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> RecPtr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write a RESTORE POINT record<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L7999">&#x200c;</a><span class="linkable">XLogRestorePoint</span>(<span class="Type">const</span> <span class="Type">char</span> *rpName)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; RecPtr;<br/></li>
<li>&nbsp; &nbsp; xl_restore_point xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec.rp_time = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; strlcpy(xlrec.rp_name, rpName, MAXFNAMELEN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_restore_point));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; RecPtr = <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_XLOG_ID, XLOG_RESTORE_POINT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;restore point </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> created at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rpName, LSN_FORMAT_ARGS(RecPtr))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> RecPtr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the GUC parameters that are critical for hot standby<br/></li>
<li></span><span class="Comment"> * have changed, and update the value in pg_control file if necessary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L8024">&#x200c;</a></span><span class="linkable">XLogReportParameters</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L131" title="access/transam/xlog.c:131">wal_level</a> != <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L131" title="access/transam/xlog.c:131">wal_level</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L123" title="access/transam/xlog.c:123">wal_log_hints</a> != <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L123" title="access/transam/xlog.c:123">wal_log_hints</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a> != <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="../../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a> != <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="../../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a> != <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a> != <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lock.c.html#L53" title="storage/lmgr/lock.c:53">max_locks_per_xact</a> != <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="../../storage/lmgr/lock.c.html#L53" title="storage/lmgr/lock.c:53">max_locks_per_xact</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="commit_ts.c.html#L109" title="access/transam/commit_ts.c:109">track_commit_timestamp</a> != <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="commit_ts.c.html#L109" title="access/transam/commit_ts.c:109">track_commit_timestamp</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The change in number of backend slots doesn't need to be WAL-logged<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if archiving is not enabled, as you can't start archive recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with <a href="#L131" title="access/transam/xlog.c:131">wal_level</a>=minimal anyway. We don't really care about the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in pg_control either if <a href="#L131" title="access/transam/xlog.c:131">wal_level</a>=minimal, but seems better<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to keep them up-to-date to avoid confusion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L131" title="access/transam/xlog.c:131">wal_level</a> != <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L131" title="access/transam/xlog.c:131">wal_level</a> || XLogIsNeeded())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_parameter_change xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.<a href="../../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a> = <a href="../../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.<a href="../../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a> = <a href="../../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.<a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a> = <a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.<a href="twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a> = <a href="twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.<a href="../../storage/lmgr/lock.c.html#L53" title="storage/lmgr/lock.c:53">max_locks_per_xact</a> = <a href="../../storage/lmgr/lock.c.html#L53" title="storage/lmgr/lock.c:53">max_locks_per_xact</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.<a href="#L131" title="access/transam/xlog.c:131">wal_level</a> = <a href="#L131" title="access/transam/xlog.c:131">wal_level</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.<a href="#L123" title="access/transam/xlog.c:123">wal_log_hints</a> = <a href="#L123" title="access/transam/xlog.c:123">wal_log_hints</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.<a href="commit_ts.c.html#L109" title="access/transam/commit_ts.c:109">track_commit_timestamp</a> = <a href="commit_ts.c.html#L109" title="access/transam/commit_ts.c:109">track_commit_timestamp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xlrec));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_XLOG_ID, XLOG_PARAMETER_CHANGE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ControlFileLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="../../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a> = <a href="../../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="../../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a> = <a href="../../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a> = <a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a> = <a href="twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="../../storage/lmgr/lock.c.html#L53" title="storage/lmgr/lock.c:53">max_locks_per_xact</a> = <a href="../../storage/lmgr/lock.c.html#L53" title="storage/lmgr/lock.c:53">max_locks_per_xact</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L131" title="access/transam/xlog.c:131">wal_level</a> = <a href="#L131" title="access/transam/xlog.c:131">wal_level</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L123" title="access/transam/xlog.c:123">wal_log_hints</a> = <a href="#L123" title="access/transam/xlog.c:123">wal_log_hints</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="commit_ts.c.html#L109" title="access/transam/commit_ts.c:109">track_commit_timestamp</a> = <a href="commit_ts.c.html#L109" title="access/transam/commit_ts.c:109">track_commit_timestamp</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4526" title="access/transam/xlog.c:4526">UpdateControlFile</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update full_page_writes in shared memory, and write an<br/></li>
<li></span><span class="Comment"> * XLOG_FPW_CHANGE record if necessary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this function assumes there is no other process running<br/></li>
<li></span><span class="Comment"> * concurrently that could update it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L8087">&#x200c;</a></span><span class="linkable">UpdateFullPageWrites</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L396" title="access/transam/xlog.c:396">XLogCtlInsert</a> *<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> = &amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; recoveryInProgress;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do nothing if full_page_writes has not been changed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's safe to check the shared full_page_writes without the lock,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because we assume that there is no concurrently running process which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can update it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a> == <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;<a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Perform this outside critical section so that the WAL insert<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initialization done by <a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>() doesn't <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assertion failure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; recoveryInProgress = <a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's always safe to take full page images, even when not strictly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * required, but not the other round. So if we're setting full_page_writes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to true, first set it true and then write the WAL record. If we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * setting it to false, first write the WAL record and then set the global<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1411" title="access/transam/xlog.c:1411">WALInsertLockAcquireExclusive</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;<a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1440" title="access/transam/xlog.c:1440">WALInsertLockRelease</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write an XLOG_FPW_CHANGE record. This allows us to keep track of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * full_page_writes during archive recovery, if required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (XLogStandbyInfoActive() &amp;&amp; !recoveryInProgress)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;<a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a>), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_XLOG_ID, XLOG_FPW_CHANGE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1411" title="access/transam/xlog.c:1411">WALInsertLockAcquireExclusive</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;<a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1440" title="access/transam/xlog.c:1440">WALInsertLockRelease</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * XLOG resource manager's routines<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Definitions of info <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are in include/catalog/pg_control.h, though<br/></li>
<li></span><span class="Comment"> * not all record types are related to control file updates.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: Some XLOG record types that are directly related to WAL recovery<br/></li>
<li></span><span class="Comment"> * are handled in <a href="xlogrecovery.c.html#L2072" title="access/transam/xlogrecovery.c:2072">xlogrecovery_redo</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L8156">&#x200c;</a></span><span class="linkable">xlog_redo</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(record) &amp; ~XLR_INFO_MASK;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In XLOG rmgr, backup blocks are only used by XLOG_FPI and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLOG_FPI_FOR_HINT <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(info == XLOG_FPI || info == XLOG_FPI_FOR_HINT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !XLogRecHasAnyBlockRefs(record));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (info == XLOG_NEXTOID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We used to try to take the maximum of <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextOid and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the recorded nextOid, but that fails if the OID counter wraps<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * around.&nbsp; Since no OID allocation should be happening during replay<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway, better to just believe the record exactly.&nbsp; We still take<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OidGenLock while setting the variable, just in case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;nextOid, XLogRecGetData(record), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(OidGenLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextOid = nextOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oidCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(OidGenLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_CHECKPOINT_SHUTDOWN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CheckPoint&nbsp; &nbsp; checkPoint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeLineID&nbsp; &nbsp; replayTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;checkPoint, XLogRecGetData(record), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CheckPoint));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In a SHUTDOWN checkpoint, believe the counters exactly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(XidGenLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid = checkPoint.nextXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(XidGenLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(OidGenLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextOid = checkPoint.nextOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oidCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(OidGenLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="multixact.c.html#L2279" title="access/transam/multixact.c:2279">MultiXactSetNextMXact</a>(checkPoint.nextMulti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checkPoint.nextMultiOffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="multixact.c.html#L2487" title="access/transam/multixact.c:2487">MultiXactAdvanceOldest</a>(checkPoint.oldestMulti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; checkPoint.oldestMultiDB);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No need to set oldestClogXid here as well; it'll be set when we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * redo an xl_clog_truncate if it changed since initialization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="varsup.c.html#L372" title="access/transam/varsup.c:372">SetTransactionIdLimit</a>(checkPoint.oldestXid, checkPoint.oldestXidDB);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we see a shutdown checkpoint while <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for an end-of-backup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * record, the backup was canceled and the end-of-backup record will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * never arrive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L137" title="access/transam/xlogrecovery.c:137">ArchiveRecoveryRequested</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !XLogRecPtrIsInvalid(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L281" title="access/transam/xlogrecovery.c:281">backupStartPoint</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtrIsInvalid(<a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L282" title="access/transam/xlogrecovery.c:282">backupEndPoint</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;online backup was canceled, recovery cannot continue&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we see a shutdown checkpoint, we know that nothing was running<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on the primary at this point. So fake-up an empty running-xacts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * record and use that here and <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. Recover additional standby state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for prepared transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogutils.c.html#L53" title="access/transam/xlogutils.c:53">standbyState</a> &gt;= STANDBY_INITIALIZED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId *xids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nxids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId oldestActiveXID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId latestCompletedXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RunningTransactionsData running;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestActiveXID = <a href="twophase.c.html#L1962" title="access/transam/twophase.c:1962">PrescanPreparedTransactions</a>(&amp;xids, &amp;nxids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Construct a RunningTransactions snapshot representing a shut<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * down server, with only prepared transactions still alive. We're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * never overflowed at this point because all subxids are listed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with their parent prepared transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; running.xcnt = nxids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; running.subxcnt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; running.subxid_overflow = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; running.nextXid = XidFromFullTransactionId(checkPoint.nextXid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; running.oldestRunningXid = oldestActiveXID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latestCompletedXid = XidFromFullTransactionId(checkPoint.nextXid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionIdRetreat(latestCompletedXid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsNormal(latestCompletedXid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; running.latestCompletedXid = latestCompletedXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; running.xids = xids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L1054" title="storage/ipc/procarray.c:1054">ProcArrayApplyRecoveryInfo</a>(&amp;running);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="twophase.c.html#L2043" title="access/transam/twophase.c:2043">StandbyRecoverPreparedTransactions</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy always tracks the latest ckpt XID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ControlFileLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.nextXid = checkPoint.nextXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update shared-memory copy of checkpoint XID/epoch */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;ckptFullXid = checkPoint.nextXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should've already switched to the new TLI <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> replaying this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="xlogrecovery.c.html#L4562" title="access/transam/xlogrecovery.c:4562">GetCurrentReplayRecPtr</a>(&amp;replayTLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (checkPoint.ThisTimeLineID != replayTLI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected timeline ID </span><span class="Special">%u</span><span class="Constant"> (should be </span><span class="Special">%u</span><span class="Constant">) in shutdown checkpoint record&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checkPoint.ThisTimeLineID, replayTLI)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7471" title="access/transam/xlog.c:7471">RecoveryRestartPoint</a>(&amp;checkPoint, record);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_CHECKPOINT_ONLINE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CheckPoint&nbsp; &nbsp; checkPoint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeLineID&nbsp; &nbsp; replayTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;checkPoint, XLogRecGetData(record), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CheckPoint));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In an ONLINE checkpoint, treat the XID counter as a minimum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(XidGenLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (FullTransactionIdPrecedes(<a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checkPoint.nextXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid = checkPoint.nextXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(XidGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We ignore the nextOid counter in an ONLINE checkpoint, preferring<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to track OID assignment through XLOG_NEXTOID <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.&nbsp; The nextOid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * counter is from the start of the checkpoint and might well be stale<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * compared to later XLOG_NEXTOID <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.&nbsp; We could try to take the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * maximum of the nextOid counter and our latest value, but since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there's no particular guarantee about the speed with which the OID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * counter wraps around, that's a risky thing to do.&nbsp; In <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * users of the nextOid counter are required to avoid assignment of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * duplicates, so that a somewhat out-of-date value should be safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle multixact */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="multixact.c.html#L2462" title="access/transam/multixact.c:2462">MultiXactAdvanceNextMXact</a>(checkPoint.nextMulti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checkPoint.nextMultiOffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB: This may perform multixact truncation when replaying WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generated by an older primary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="multixact.c.html#L2487" title="access/transam/multixact.c:2487">MultiXactAdvanceOldest</a>(checkPoint.oldestMulti,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; checkPoint.oldestMultiDB);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(<a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oldestXid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checkPoint.oldestXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="varsup.c.html#L372" title="access/transam/varsup.c:372">SetTransactionIdLimit</a>(checkPoint.oldestXid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checkPoint.oldestXidDB);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy always tracks the latest ckpt XID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ControlFileLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.nextXid = checkPoint.nextXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update shared-memory copy of checkpoint XID/epoch */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;ckptFullXid = checkPoint.nextXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* TLI should not change in an on-line checkpoint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="xlogrecovery.c.html#L4562" title="access/transam/xlogrecovery.c:4562">GetCurrentReplayRecPtr</a>(&amp;replayTLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (checkPoint.ThisTimeLineID != replayTLI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected timeline ID </span><span class="Special">%u</span><span class="Constant"> (should be </span><span class="Special">%u</span><span class="Constant">) in online checkpoint record&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checkPoint.ThisTimeLineID, replayTLI)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7471" title="access/transam/xlog.c:7471">RecoveryRestartPoint</a>(&amp;checkPoint, record);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_OVERWRITE_CONTRECORD)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do here, handled in <a href="xlogrecovery.c.html#L2072" title="access/transam/xlogrecovery.c:2072">xlogrecovery_redo</a>() */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_END_OF_RECOVERY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_end_of_recovery xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeLineID&nbsp; &nbsp; replayTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;xlrec, XLogRecGetData(record), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_end_of_recovery));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For Hot Standby, we could treat this like a <a href="../../postmaster/postmaster.c.html#L269" title="postmaster/postmaster.c:269">Shutdown</a> Checkpoint,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but this case is rarer and harder to test, so the benefit doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outweigh the potential extra cost of maintenance.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should've already switched to the new TLI <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> replaying this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="xlogrecovery.c.html#L4562" title="access/transam/xlogrecovery.c:4562">GetCurrentReplayRecPtr</a>(&amp;replayTLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec.ThisTimeLineID != replayTLI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected timeline ID </span><span class="Special">%u</span><span class="Constant"> (should be </span><span class="Special">%u</span><span class="Constant">) in end-of-recovery record&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.ThisTimeLineID, replayTLI)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_NOOP)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do here */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_SWITCH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do here */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_RESTORE_POINT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do here, handled in xlogrecovery.c */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_FPI || info == XLOG_FPI_FOR_HINT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * XLOG_FPI <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> contain nothing else but one or more block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * references. Every block reference must include a full-page image<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * even if full_page_writes was disabled when the record was generated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * - otherwise there would be no point in this record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * XLOG_FPI_FOR_HINT <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> are generated when a page needs to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL-logged because of a hint <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> update. They are only generated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when checksums and/or <a href="#L123" title="access/transam/xlog.c:123">wal_log_hints</a> are enabled. They may include<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no full-page images if full_page_writes was disabled when they were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generated. In this case there is nothing to do here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No recovery conflicts are generated by these generic <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> - if a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * resource manager needs to generate conflicts, it has to define a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * separate WAL record type and redo routine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (uint8 block_id = <span class="Constant">0</span>; block_id &lt;= XLogRecMaxBlockId(record); block_id++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecHasBlockImage(record, block_id))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (info == XLOG_FPI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;XLOG_FPI record did not contain a full-page image&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, block_id, &amp;buffer) != BLK_RESTORED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected <a href="xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a> result when restoring backup block&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_BACKUP_END)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do here, handled in <a href="xlogrecovery.c.html#L2072" title="access/transam/xlogrecovery.c:2072">xlogrecovery_redo</a>() */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_PARAMETER_CHANGE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_parameter_change xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update our copy of the parameters in pg_control */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;xlrec, XLogRecGetData(record), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_parameter_change));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Invalidate logical slots if we are in hot standby and the primary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * does not have a WAL level sufficient for logical decoding. No need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to search for potentially conflicting logically slots if standby is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * running with <a href="#L131" title="access/transam/xlog.c:131">wal_level</a> <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> than logical, because in that case, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would have either disallowed creation of logical slots or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * invalidated existing ones.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a> &amp;&amp; InHotStandby &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.<a href="#L131" title="access/transam/xlog.c:131">wal_level</a> &lt; WAL_LEVEL_LOGICAL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="access/transam/xlog.c:131">wal_level</a> &gt;= WAL_LEVEL_LOGICAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/slot.c.html#L1783" title="replication/slot.c:1783">InvalidateObsoleteReplicationSlots</a>(RS_INVAL_WAL_LEVEL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ControlFileLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="../../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a> = xlrec.<a href="../../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="../../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a> = xlrec.<a href="../../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a> = xlrec.<a href="../../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a> = xlrec.<a href="twophase.c.html#L115" title="access/transam/twophase.c:115">max_prepared_xacts</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="../../storage/lmgr/lock.c.html#L53" title="storage/lmgr/lock.c:53">max_locks_per_xact</a> = xlrec.<a href="../../storage/lmgr/lock.c.html#L53" title="storage/lmgr/lock.c:53">max_locks_per_xact</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L131" title="access/transam/xlog.c:131">wal_level</a> = xlrec.<a href="#L131" title="access/transam/xlog.c:131">wal_level</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="#L123" title="access/transam/xlog.c:123">wal_log_hints</a> = xlrec.<a href="#L123" title="access/transam/xlog.c:123">wal_log_hints</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update <a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> to ensure that if recovery is aborted, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recover back up to this point <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> allowing hot standby again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is important if the max_* settings are decreased, to ensure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * you don't run queries against the WAL preceding the change. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * local copies cannot be updated as long as crash recovery is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happening and we expect all the WAL to be replayed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L138" title="access/transam/xlogrecovery.c:138">InArchiveRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a> = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L642" title="access/transam/xlog.c:642">LocalMinRecoveryPointTLI</a> = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a> != InvalidXLogRecPtr &amp;&amp; <a href="#L641" title="access/transam/xlog.c:641">LocalMinRecoveryPoint</a> &lt; lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID&nbsp; &nbsp; replayTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="xlogrecovery.c.html#L4562" title="access/transam/xlogrecovery.c:4562">GetCurrentReplayRecPtr</a>(&amp;replayTLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a> = lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a> = replayTLI;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="commit_ts.c.html#L664" title="access/transam/commit_ts.c:664">CommitTsParameterChange</a>(xlrec.<a href="commit_ts.c.html#L109" title="access/transam/commit_ts.c:109">track_commit_timestamp</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="commit_ts.c.html#L109" title="access/transam/commit_ts.c:109">track_commit_timestamp</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="commit_ts.c.html#L109" title="access/transam/commit_ts.c:109">track_commit_timestamp</a> = xlrec.<a href="commit_ts.c.html#L109" title="access/transam/commit_ts.c:109">track_commit_timestamp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4526" title="access/transam/xlog.c:4526">UpdateControlFile</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check to see if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parameter change gives a problem on recovery */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5344" title="access/transam/xlog.c:5344">CheckRequiredParameterValues</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_FPW_CHANGE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; fpw;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;fpw, XLogRecGetData(record), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update the LSN of the last replayed XLOG_FPW_CHANGE record so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L8712" title="access/transam/xlog.c:8712">do_pg_backup_start</a>() and <a href="#L9040" title="access/transam/xlog.c:9040">do_pg_backup_stop</a>() can check whether<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * full_page_writes has been disabled during online backup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!fpw)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;lastFpwDisableRecPtr &lt; record-&gt;ReadRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;lastFpwDisableRecPtr = record-&gt;ReadRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Keep track of full_page_writes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L217" title="access/transam/xlog.c:217">lastFullPageWrites</a> = fpw;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_CHECKPOINT_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do here, just for informational purposes */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the extra open flags used for opening a file, depending on the<br/></li>
<li></span><span class="Comment"> * value of the GUCs <a href="#L130" title="access/transam/xlog.c:130">wal_sync_method</a>, fsync and io_direct.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L8513">&#x200c;</a></span><span class="linkable">get_sync_bit</span>(<span class="Type">int</span> method)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; o_direct_flag = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use O_DIRECT if requested, except in walreceiver process.&nbsp; The WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * written by walreceiver is normally read by the startup process soon<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after it's written.&nbsp; Also, walreceiver performs unaligned writes, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't work with O_DIRECT, so it is required for correctness too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((<a href="../../storage/file/fd.c.html#L168" title="storage/file/fd.c:168">io_direct_flags</a> &amp; IO_DIRECT_WAL) &amp;&amp; !AmWalReceiverProcess())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; o_direct_flag = PG_O_DIRECT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If fsync is disabled, never open in sync mode */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/init/globals.c.html#L126" title="utils/init/globals.c:126">enableFsync</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> o_direct_flag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (method)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enum <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for all sync options are defined even if they are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not supported on the current platform.&nbsp; But if not, they are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not included in the enum option array, and therefore will never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be seen here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAL_SYNC_METHOD_FSYNC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAL_SYNC_METHOD_FSYNC_WRITETHROUGH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAL_SYNC_METHOD_FDATASYNC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> o_direct_flag;<br/></li>
<li><span class="PreProc">#ifdef O_SYNC<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAL_SYNC_METHOD_OPEN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> O_SYNC | o_direct_flag;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef O_DSYNC<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAL_SYNC_METHOD_OPEN_DSYNC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> O_DSYNC | o_direct_flag;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't happen (unless we are out of sync with option array) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized <a href="#L130" title="access/transam/xlog.c:130">wal_sync_method</a>: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, method);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* silence warning */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC support<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L8561">&#x200c;</a></span><span class="linkable">assign_wal_sync_method</span>(<span class="Type">int</span> new_wal_sync_method, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L130" title="access/transam/xlog.c:130">wal_sync_method</a> != new_wal_sync_method)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To ensure that no blocks escape unsynced, force an fsync on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * currently open log segment (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).&nbsp; Also, if the open flag is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changing, close the log file so it will be reopened (with new flag<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>) at <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L630" title="access/transam/xlog.c:630">openLogFile</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_WAL_SYNC_METHOD_ASSIGN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L386" title="storage/file/fd.c:386">pg_fsync</a>(<a href="#L630" title="access/transam/xlog.c:630">openLogFile</a>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; xlogfname[MAXFNAMELEN];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(xlogfname, <a href="#L632" title="access/transam/xlog.c:632">openLogTLI</a>, <a href="#L631" title="access/transam/xlog.c:631">openLogSegNo</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fsync file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, xlogfname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L8513" title="access/transam/xlog.c:8513">get_sync_bit</a>(<a href="#L130" title="access/transam/xlog.c:130">wal_sync_method</a>) != <a href="#L8513" title="access/transam/xlog.c:8513">get_sync_bit</a>(new_wal_sync_method))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3628" title="access/transam/xlog.c:3628">XLogFileClose</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Issue appropriate kind of fsync (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) for an XLOG output file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'fd' is a file descriptor for the XLOG file to be fsync'd.<br/></li>
<li></span><span class="Comment"> * 'segno' is for error reporting purposes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L8603">&#x200c;</a></span><span class="linkable">issue_xlog_fsync</span>(<span class="Type">int</span> fd, XLogSegNo segno, TimeLineID tli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *msg = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; instr_time&nbsp; &nbsp; start;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(tli != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Quick exit if fsync is disabled or write() has already synced the WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/init/globals.c.html#L126" title="utils/init/globals.c:126">enableFsync</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L130" title="access/transam/xlog.c:130">wal_sync_method</a> == WAL_SYNC_METHOD_OPEN ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L130" title="access/transam/xlog.c:130">wal_sync_method</a> == WAL_SYNC_METHOD_OPEN_DSYNC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Measure I/O timing to sync the WAL file */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L137" title="access/transam/xlog.c:137">track_wal_io_timing</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(start);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_ZERO(start);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_WAL_SYNC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L130" title="access/transam/xlog.c:130">wal_sync_method</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAL_SYNC_METHOD_FSYNC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L441" title="storage/file/fd.c:441">pg_fsync_no_writethrough</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;could not fsync file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><span class="PreProc">#ifdef HAVE_FSYNC_WRITETHROUGH<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAL_SYNC_METHOD_FSYNC_WRITETHROUGH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L461" title="storage/file/fd.c:461">pg_fsync_writethrough</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;could not fsync write-through file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAL_SYNC_METHOD_FDATASYNC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L480" title="storage/file/fd.c:480">pg_fdatasync</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msg = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;could not fdatasync file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAL_SYNC_METHOD_OPEN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> WAL_SYNC_METHOD_OPEN_DSYNC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not reachable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;unrecognized <a href="#L130" title="access/transam/xlog.c:130">wal_sync_method</a>: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, <a href="#L130" title="access/transam/xlog.c:130">wal_sync_method</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* PANIC if failed to fsync */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (msg)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; xlogfname[MAXFNAMELEN];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(xlogfname, tli, segno, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(msg, xlogfname)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Increment the I/O timing and the number of times WAL files were synced.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L137" title="access/transam/xlog.c:137">track_wal_io_timing</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instr_time&nbsp; &nbsp; end;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(end);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_ACCUM_DIFF(<a href="../../utils/activity/pgstat_wal.c.html#L24" title="utils/activity/pgstat_wal.c:24">PendingWalStats</a>.wal_sync_time, end, start);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_wal.c.html#L24" title="utils/activity/pgstat_wal.c:24">PendingWalStats</a>.wal_sync++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L8712" title="access/transam/xlog.c:8712">do_pg_backup_start</a> is the workhorse of the user-visible <a href="xlogfuncs.c.html#L56" title="access/transam/xlogfuncs.c:56">pg_backup_start</a>()<br/></li>
<li></span><span class="Comment"> * function. It creates the necessary starting checkpoint and constructs the<br/></li>
<li></span><span class="Comment"> * backup state and tablespace map.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input parameters are &quot;state&quot; (the backup state), &quot;fast&quot; (if true, we do<br/></li>
<li></span><span class="Comment"> * the checkpoint in immediate mode to make it faster), and &quot;tablespaces&quot;<br/></li>
<li></span><span class="Comment"> * (if non-NULL, indicates a list of tablespaceinfo structs describing the<br/></li>
<li></span><span class="Comment"> * <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>'s tablespaces.).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The tablespace map contents are appended to passed-in parameter<br/></li>
<li></span><span class="Comment"> * <a href="xlogfuncs.c.html#L41" title="access/transam/xlogfuncs.c:41">tablespace_map</a> and the caller is responsible for including it in the backup<br/></li>
<li></span><span class="Comment"> * archive as '<a href="xlogfuncs.c.html#L41" title="access/transam/xlogfuncs.c:41">tablespace_map</a>'. The <a href="xlogfuncs.c.html#L41" title="access/transam/xlogfuncs.c:41">tablespace_map</a> file is required mainly for<br/></li>
<li></span><span class="Comment"> * tar format in windows as native windows utilities are not able to create<br/></li>
<li></span><span class="Comment"> * symlinks while extracting files from tar. However for consistency and<br/></li>
<li></span><span class="Comment"> * platform-independence, we do it the same way everywhere.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It fills in &quot;state&quot; with the information required for the backup, such<br/></li>
<li></span><span class="Comment"> * as the minimum WAL location that must be present to restore from this<br/></li>
<li></span><span class="Comment"> * backup (starttli) and the corresponding timeline ID (starttli).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Every successfully started backup must be stopped by calling<br/></li>
<li></span><span class="Comment"> * <a href="#L9040" title="access/transam/xlog.c:9040">do_pg_backup_stop</a>() or <a href="#L9314" title="access/transam/xlog.c:9314">do_pg_abort_backup</a>(). There can be many<br/></li>
<li></span><span class="Comment"> * backups active at the same time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is the responsibility of the caller of this function to verify the<br/></li>
<li></span><span class="Comment"> * permissions of the calling user!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L8712">&#x200c;</a></span><span class="linkable">do_pg_backup_start</span>(<span class="Type">const</span> <span class="Type">char</span> *backupidstr, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> fast, List **tablespaces,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BackupState *state, StringInfo tblspcmapfile)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../backup/basebackup.c.html#L123" title="backup/basebackup.c:123">backup_started_in_recovery</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(state != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../backup/basebackup.c.html#L123" title="backup/basebackup.c:123">backup_started_in_recovery</a> = <a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During recovery, we don't need to check WAL level. Because, if WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * level is not sufficient, it's impossible to get here during recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../backup/basebackup.c.html#L123" title="backup/basebackup.c:123">backup_started_in_recovery</a> &amp;&amp; !XLogIsNeeded())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;WAL level not sufficient for making an online backup&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;<a href="#L131" title="access/transam/xlog.c:131">wal_level</a> must be set to </span><span class="Special">\&quot;</span><span class="Constant">replica</span><span class="Special">\&quot;</span><span class="Constant"> or </span><span class="Special">\&quot;</span><span class="Constant">logical</span><span class="Special">\&quot;</span><span class="Constant"> at server start.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strlen(backupidstr) &gt; MAXPGPATH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;backup label too long (max </span><span class="Special">%d</span><span class="Constant"> bytes)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAXPGPATH)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy(state-&gt;name, backupidstr, strlen(backupidstr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark backup active in shared memory.&nbsp; We must do full-page WAL writes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during an on-line backup even if not doing so at other times, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's quite possible for the backup <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> to obtain a &quot;torn&quot; (partially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * written) copy of a database page if it reads the page concurrently with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * our write to the same page.&nbsp; This can be fixed as long as the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * write to the page in the WAL sequence is a full-page write. Hence, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * increment runningBackups then force a CHECKPOINT, to ensure there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no dirty pages in shared memory that might get dumped while the backup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is in progress without having a corresponding WAL record.&nbsp; (Once the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backup is complete, we need not force full-page writes anymore, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we expect that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pages not modified during the backup interval must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have been correctly captured by the backup.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that forcing full-page writes has no effect during an online<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backup from the standby.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must hold all the insertion locks to change the value of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * runningBackups, to ensure adequate interlocking against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L743" title="access/transam/xlog.c:743">XLogInsertRecord</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1411" title="access/transam/xlog.c:1411">WALInsertLockAcquireExclusive</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>.runningBackups++;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1440" title="access/transam/xlog.c:1440">WALInsertLockRelease</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure we decrement runningBackups if we fail below. NB -- for this to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * work correctly, it is critical that <a href="#L391" title="access/transam/xlog.c:391">sessionBackupState</a> is only updated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after this block is over.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_ENSURE_ERROR_CLEANUP(<a href="#L9314" title="access/transam/xlog.c:9314">do_pg_abort_backup</a>, DatumGetBool(<span class="Constant">true</span>));<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; gotUniqueStartpoint = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *tblspcdir;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> dirent *de;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tablespaceinfo *ti;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datadirpathlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Force an XLOG file switch <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the checkpoint, to ensure that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL segment the checkpoint is written to doesn't contain pages with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * old timeline IDs.&nbsp; That would otherwise happen if you called<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="xlogfuncs.c.html#L56" title="access/transam/xlogfuncs.c:56">pg_backup_start</a>() right after restoring from a PITR archive: the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first WAL segment containing the startup checkpoint has pages in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the beginning with the old timeline ID.&nbsp; That can cause trouble at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recovery: we won't have a history file covering the old timeline if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_wal directory was not included in the base backup and the WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * archive was cleared too <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> starting the backup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This also ensures that we have emitted a WAL page header that has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * XLP_BKP_REMOVABLE off <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we emit the checkpoint record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Therefore, if a WAL archiver (such as pglesslog) is trying to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * compress out removable backup blocks, it won't remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * occur after this point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * During recovery, we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> forcing XLOG file switch, which means that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the backup taken during recovery is not available for the special<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recovery case described above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../backup/basebackup.c.html#L123" title="backup/basebackup.c:123">backup_started_in_recovery</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7981" title="access/transam/xlog.c:7981">RequestXLogSwitch</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; checkpointfpw;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Force a CHECKPOINT.&nbsp; Aside from being necessary to prevent torn<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page problems, this guarantees that two successive backup runs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will have different checkpoint positions and hence different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * history file names, even if nothing happened in between.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * During recovery, establish a restartpoint if possible. We use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the last restartpoint as the backup starting checkpoint. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * means that two successive backup runs can have same checkpoint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * positions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since the fact that we are executing <a href="#L8712" title="access/transam/xlog.c:8712">do_pg_backup_start</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during recovery means that checkpointer is running, we can use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../postmaster/checkpointer.c.html#L941" title="postmaster/checkpointer.c:941">RequestCheckpoint</a>() to establish a restartpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We use CHECKPOINT_IMMEDIATE only if requested by user (via<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * passing fast = true).&nbsp; Otherwise this can take awhile.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/checkpointer.c.html#L941" title="postmaster/checkpointer.c:941">RequestCheckpoint</a>(CHECKPOINT_FORCE | CHECKPOINT_WAIT |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fast ? CHECKPOINT_IMMEDIATE : <span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now we need to fetch the checkpoint record location, and also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its REDO pointer.&nbsp; The oldest point in WAL that would be needed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to restore starting from the checkpoint is precisely the REDO<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ControlFileLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;checkpointloc = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPoint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;startpoint = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.redo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;starttli = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.ThisTimeLineID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checkpointfpw = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.<a href="#L122" title="access/transam/xlog.c:122">fullPageWrites</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../backup/basebackup.c.html#L123" title="backup/basebackup.c:123">backup_started_in_recovery</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check to see if all WAL replayed during online backup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (i.e., since last restartpoint used as backup starting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checkpoint) contain full-page writes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;lastFpwDisableRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!checkpointfpw || state-&gt;startpoint &lt;= recptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;WAL generated with full_page_writes=off was replayed &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;since last restartpoint&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;This means that the backup being taken on the standby &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;is corrupt and should not be used. &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Enable full_page_writes and run CHECKPOINT on the primary, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;and then try an online backup again.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * During recovery, since we don't use the end-of-backup WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * record and don't write the backup history file, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * starting WAL location doesn't need to be unique. This means<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that two base backups started at the same time might use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same checkpoint as starting locations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gotUniqueStartpoint = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If two base backups are started at the same time (in WAL sender<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processes), we need to make sure that they use different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checkpoints as starting locations, because we use the starting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL location as a unique identifier for the base backup in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end-of-backup WAL record and when we write the backup history<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file. Perhaps it would be better generate a separate unique ID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for each backup instead of forcing another checkpoint, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * taking a checkpoint right after another is not that expensive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either because only few buffers have been dirtied yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1411" title="access/transam/xlog.c:1411">WALInsertLockAcquireExclusive</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>.lastBackupStart &lt; state-&gt;startpoint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>.lastBackupStart = state-&gt;startpoint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gotUniqueStartpoint = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1440" title="access/transam/xlog.c:1440">WALInsertLockRelease</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (!gotUniqueStartpoint);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Construct <a href="xlogfuncs.c.html#L41" title="access/transam/xlogfuncs.c:41">tablespace_map</a> file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; datadirpathlen = strlen(<a href="../../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Collect information about all tablespaces */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tblspcdir = <a href="../../storage/file/fd.c.html#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(<span class="Constant">&quot;pg_tblspc&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((de = <a href="../../storage/file/fd.c.html#L2909" title="storage/file/fd.c:2909">ReadDir</a>(tblspcdir, <span class="Constant">&quot;pg_tblspc&quot;</span>)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; fullpath[MAXPGPATH + <span class="Constant">10</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; linkpath[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *relpath = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *s;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGFileType&nbsp; &nbsp; de_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *badp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tsoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the directory name as an unsigned integer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Tablespace directories should be positive integers that can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * represented in 32 bits, with no leading zeroes or trailing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * garbage. If we come across a name that doesn't meet those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * criteria, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (de-&gt;d_name[<span class="Constant">0</span>] &lt; <span class="Constant">'1'</span> || de-&gt;d_name[<span class="Constant">1</span>] &gt; <span class="Constant">'9'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tsoid = strtoul(de-&gt;d_name, &amp;badp, <span class="Constant">10</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*badp != <span class="Special">'\0'</span> || errno == <span class="Constant">EINVAL</span> || errno == <span class="Constant">ERANGE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(fullpath, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(fullpath), <span class="Constant">&quot;pg_tblspc/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, de-&gt;d_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; de_type = get_dirent_type(fullpath, de, <span class="Constant">false</span>, ERROR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (de_type == PGFILETYPE_LNK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfoData escapedpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rllen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rllen = readlink(fullpath, linkpath, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(linkpath));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rllen &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read symbolic link </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fullpath)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rllen &gt;= <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(linkpath))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;symbolic link </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> target is too long&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fullpath)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linkpath[rllen] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Relpath holds the relative path of the tablespace directory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when it's located within PGDATA, or NULL if it's located<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * elsewhere.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rllen &gt; datadirpathlen &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strncmp(linkpath, <a href="../../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, datadirpathlen) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IS_DIR_SEP(linkpath[datadirpathlen]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relpath = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(linkpath + datadirpathlen + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add a backslash-escaped version of the link path to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tablespace map file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;escapedpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (s = linkpath; *s; s++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*s == <span class="Special">'\n'</span> || *s == <span class="Special">'\r'</span> || *s == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;escapedpath, <span class="Special">'\\'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(&amp;escapedpath, *s);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(tblspcmapfile, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; de-&gt;d_name, escapedpath.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(escapedpath.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (de_type == PGFILETYPE_DIR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's possible to use <a href="../../commands/tablespace.c.html#L85" title="commands/tablespace.c:85">allow_in_place_tablespaces</a> to create<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * directories directly under pg_tblspc, for testing purposes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In this case, we store a relative path rather than an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * absolute path into the tablespaceinfo.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(linkpath, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(linkpath), <span class="Constant">&quot;pg_tblspc/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; de-&gt;d_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relpath = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(linkpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other file type that appears here. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ti = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(tablespaceinfo));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ti-&gt;oid = tsoid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ti-&gt;path = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(linkpath);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ti-&gt;rpath = relpath;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ti-&gt;size = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tablespaces)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tablespaces = <a href="../../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*tablespaces, ti);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2961" title="storage/file/fd.c:2961">FreeDir</a>(tblspcdir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;starttime = (pg_time_t) time(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_ENSURE_ERROR_CLEANUP(<a href="#L9314" title="access/transam/xlog.c:9314">do_pg_abort_backup</a>, DatumGetBool(<span class="Constant">true</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;started_in_recovery = <a href="../../backup/basebackup.c.html#L123" title="backup/basebackup.c:123">backup_started_in_recovery</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark that the start phase has correctly finished for the backup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L391" title="access/transam/xlog.c:391">sessionBackupState</a> = SESSION_BACKUP_RUNNING;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Utility routine to fetch the session-level status of a backup running.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>SessionBackupState<br/></li>
<li><a id="L9021">&#x200c;</a><span class="linkable">get_backup_status</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L391" title="access/transam/xlog.c:391">sessionBackupState</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L9040" title="access/transam/xlog.c:9040">do_pg_backup_stop</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Utility function called at the end of an online backup.&nbsp; It creates history<br/></li>
<li></span><span class="Comment"> * file (if required), resets <a href="#L391" title="access/transam/xlog.c:391">sessionBackupState</a> and so on.&nbsp; It can optionally<br/></li>
<li></span><span class="Comment"> * wait for WAL segments to be archived.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;state&quot; is filled with the information necessary to restore from this<br/></li>
<li></span><span class="Comment"> * backup with its stop LSN (stoppoint), its timeline ID (stoptli), etc.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is the responsibility of the caller of this function to verify the<br/></li>
<li></span><span class="Comment"> * permissions of the calling user!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L9040">&#x200c;</a></span><span class="linkable">do_pg_backup_stop</span>(BackupState *state, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> waitforarchive)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; backup_stopped_in_recovery = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; histfilepath[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; lastxlogfilename[MAXFNAMELEN];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; histfilename[MAXFNAMELEN];<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; _logSegNo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *fp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seconds_before_warning;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; waits = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; reported_waiting = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(state != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; backup_stopped_in_recovery = <a href="#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During recovery, we don't need to check WAL level. Because, if WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * level is not sufficient, it's impossible to get here during recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!backup_stopped_in_recovery &amp;&amp; !XLogIsNeeded())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;WAL level not sufficient for making an online backup&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;<a href="#L131" title="access/transam/xlog.c:131">wal_level</a> must be set to </span><span class="Special">\&quot;</span><span class="Constant">replica</span><span class="Special">\&quot;</span><span class="Constant"> or </span><span class="Special">\&quot;</span><span class="Constant">logical</span><span class="Special">\&quot;</span><span class="Constant"> at server start.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK to update backup counter and session-level lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that CHECK_FOR_INTERRUPTS() must not occur while updating them,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise they can be updated inconsistently, which might cause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L9314" title="access/transam/xlog.c:9314">do_pg_abort_backup</a>() to fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1411" title="access/transam/xlog.c:1411">WALInsertLockAcquireExclusive</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is expected that each <a href="#L8712" title="access/transam/xlog.c:8712">do_pg_backup_start</a>() call is matched by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exactly one <a href="#L9040" title="access/transam/xlog.c:9040">do_pg_backup_stop</a>() call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>.runningBackups &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>.runningBackups--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clean up session-level lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * You might think that <a href="#L1440" title="access/transam/xlog.c:1440">WALInsertLockRelease</a>() can be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cleaning up session-level lock because session-level lock doesn't need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be protected with WAL insertion lock. But since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CHECK_FOR_INTERRUPTS() can occur in it, session-level lock must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cleaned up <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L391" title="access/transam/xlog.c:391">sessionBackupState</a> = SESSION_BACKUP_NONE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1440" title="access/transam/xlog.c:1440">WALInsertLockRelease</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are taking an online backup from the standby, we confirm that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * standby has not been promoted during the backup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;started_in_recovery &amp;&amp; !backup_stopped_in_recovery)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;the standby was promoted during online backup&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;This means that the backup being taken is corrupt &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;and should not be used. &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Try taking another online backup.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During recovery, we don't write an end-of-backup record. We assume that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_control was backed up last and its minimum recovery point can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * available as the backup end location. Since we don't have an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end-of-backup record, we use the pg_control value to check whether<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we've reached the end of backup when starting recovery from this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backup. We have no way of checking if pg_control wasn't backed up last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * however.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't force a switch to new WAL file but it is still possible to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wait for all the required files to be archived if waitforarchive is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * true. This is okay if we use the backup to start a standby and fetch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the missing WAL using streaming replication. But in the case of an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * archive recovery, a user should set waitforarchive to true and wait for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them to be archived to ensure that all the required files are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * available.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We return the current minimum recovery point as the backup end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * location. Note that it can be greater than the exact backup end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * location if the minimum recovery point is updated after the backup of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_control. This is harmless for current uses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> currently a backup history file is for informational and debug<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * purposes only. It's not essential for an online backup. Furthermore,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * even if it's created, it will not be archived during recovery because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an archiver is not invoked. So it doesn't seem worthwhile to write a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backup history file during recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (backup_stopped_in_recovery)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check to see if all WAL replayed during online backup contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * full-page writes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;lastFpwDisableRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;startpoint &lt;= recptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;WAL generated with full_page_writes=off was replayed &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;during online backup&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;This means that the backup being taken on the standby &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;is corrupt and should not be used. &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Enable full_page_writes and run CHECKPOINT on the primary, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;and then try an online backup again.&quot;</span>)));<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ControlFileLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;stoppoint = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L278" title="access/transam/xlogrecovery.c:278">minRecoveryPoint</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;stoptli = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;<a href="xlogrecovery.c.html#L279" title="access/transam/xlogrecovery.c:279">minRecoveryPointTLI</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *history_file;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Write the backup-end xlog record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;state-&gt;startpoint),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(state-&gt;startpoint));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;stoppoint = <a href="xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_XLOG_ID, XLOG_BACKUP_END);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Given that we're not in recovery, InsertTimeLineID is set and can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * change, so we can read it without a lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;stoptli = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InsertTimeLineID;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Force a switch to a new xlog segment file, so that the backup is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * valid as soon as archiver moves out the current segment file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7981" title="access/transam/xlog.c:7981">RequestXLogSwitch</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;stoptime = (pg_time_t) time(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Write the backup history file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; XLByteToSeg(state-&gt;startpoint, _logSegNo, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BackupHistoryFilePath(histfilepath, state-&gt;stoptli, _logSegNo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;startpoint, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fp = <a href="../../storage/file/fd.c.html#L2583" title="storage/file/fd.c:2583">AllocateFile</a>(histfilepath, <span class="Constant">&quot;w&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!fp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; histfilepath)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Build and save the contents of the backup history file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; history_file = <a href="xlogbackup.c.html#L29" title="access/transam/xlogbackup.c:29">build_backup_content</a>(state, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(fp, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, history_file);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(history_file);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fflush(fp) || ferror(fp) || <a href="../../storage/file/fd.c.html#L2781" title="storage/file/fd.c:2781">FreeFile</a>(fp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; histfilepath)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Clean out <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> no-longer-needed history files.&nbsp; As a side effect,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this will post a .ready file for the newly created history file,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * notifying the archiver that history file may be archived<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4150" title="access/transam/xlog.c:4150">CleanupBackupHistory</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If archiving is enabled, wait for all the required WAL files to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * archived <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning. If archiving isn't enabled, the required WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needs to be transported via streaming replication (hopefully with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wal_keep_size set high enough), or some more exotic mechanism like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * polling and copying files from pg_wal with script. We have no knowledge<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of those mechanisms, so it's up to the user to ensure that he gets all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the required WAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We wait until both the last WAL file filled during backup and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * history file have been archived, and assume that the alphabetic sorting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * property of the WAL files ensures <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> earlier WAL files are safely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * archived as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We wait forever, since archive_command is supposed to work and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume the admin wanted his backup to work completely. If you don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wish to wait, then either waitforarchive should be passed in as false,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or you can set statement_timeout.&nbsp; Also, some notices are issued to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clue in anyone who might be doing this interactively.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (waitforarchive &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((!backup_stopped_in_recovery &amp;&amp; XLogArchivingActive()) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (backup_stopped_in_recovery &amp;&amp; XLogArchivingAlways())))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLByteToPrevSeg(state-&gt;stoppoint, _logSegNo, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(lastxlogfilename, state-&gt;stoptli, _logSegNo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLByteToSeg(state-&gt;startpoint, _logSegNo, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BackupHistoryFileName(histfilename, state-&gt;stoptli, _logSegNo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;startpoint, <a href="#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seconds_before_warning = <span class="Constant">60</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; waits = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="xlogarchive.c.html#L619" title="access/transam/xlogarchive.c:619">XLogArchiveIsBusy</a>(lastxlogfilename) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="xlogarchive.c.html#L619" title="access/transam/xlogarchive.c:619">XLogArchiveIsBusy</a>(histfilename))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!reported_waiting &amp;&amp; waits &gt; <span class="Constant">5</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;base backup done, <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for required WAL segments to be archived&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reported_waiting = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_TIMEOUT | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1000L</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_BACKUP_WAIT_WAL_ARCHIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++waits &gt;= seconds_before_warning)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seconds_before_warning *= <span class="Constant">2</span>;&nbsp; &nbsp; <span class="Comment">/* This wraps in &gt;10 years... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;still <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for all required WAL segments to be archived (</span><span class="Special">%d</span><span class="Constant"> seconds elapsed)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; waits),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Check that your archive_command is executing properly.&nbsp; &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;You can safely cancel this backup, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;but the database backup will not be usable without all the WAL segments.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;all required WAL segments have been archived&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (waitforarchive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;WAL archiving is not enabled; you must ensure that all required WAL segments are copied through other means to complete the backup&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L9314" title="access/transam/xlog.c:9314">do_pg_abort_backup</a>: abort a running backup<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This does just the most basic steps of <a href="#L9040" title="access/transam/xlog.c:9040">do_pg_backup_stop</a>(), by taking the<br/></li>
<li></span><span class="Comment"> * system out of backup mode, thus making it a lot more safe to call from<br/></li>
<li></span><span class="Comment"> * an error handler.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'arg' indicates that it's being called during backup setup; so<br/></li>
<li></span><span class="Comment"> * <a href="#L391" title="access/transam/xlog.c:391">sessionBackupState</a> has not been modified yet, but runningBackups has<br/></li>
<li></span><span class="Comment"> * already been incremented.&nbsp; When it's false, then it's invoked as a<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a> handler, and therefore we must not change state<br/></li>
<li></span><span class="Comment"> * unless <a href="#L391" title="access/transam/xlog.c:391">sessionBackupState</a> indicates that a backup is actually running.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: This gets used as a PG_ENSURE_ERROR_CLEANUP callback and<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a> handler, hence the odd-looking signature.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L9314">&#x200c;</a></span><span class="linkable">do_pg_abort_backup</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; during_backup_start = DatumGetBool(arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If called during backup start, there shouldn't be one already running */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!during_backup_start || <a href="#L391" title="access/transam/xlog.c:391">sessionBackupState</a> == SESSION_BACKUP_NONE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (during_backup_start || <a href="#L391" title="access/transam/xlog.c:391">sessionBackupState</a> != SESSION_BACKUP_NONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1411" title="access/transam/xlog.c:1411">WALInsertLockAcquireExclusive</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>.runningBackups &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>.runningBackups--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L391" title="access/transam/xlog.c:391">sessionBackupState</a> = SESSION_BACKUP_NONE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1440" title="access/transam/xlog.c:1440">WALInsertLockRelease</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!during_backup_start)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;aborting backup due to backend exiting <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="xlogfuncs.c.html#L123" title="access/transam/xlogfuncs.c:123">pg_backup_stop</a> was called&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Register a handler that will warn about unterminated backups at end of<br/></li>
<li></span><span class="Comment"> * session, unless this has already been done.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L9341">&#x200c;</a></span><span class="linkable">register_persistent_abort_backup_handler</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> already_done = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (already_done)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>(<a href="#L9314" title="access/transam/xlog.c:9314">do_pg_abort_backup</a>, DatumGetBool(<span class="Constant">false</span>));<br/></li>
<li>&nbsp; &nbsp; already_done = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get latest WAL insert pointer<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L9355">&#x200c;</a><span class="linkable">GetXLogInsertRecPtr</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L396" title="access/transam/xlog.c:396">XLogCtlInsert</a> *<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> = &amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; current_bytepos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;insertpos_lck);<br/></li>
<li>&nbsp; &nbsp; current_bytepos = <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;CurrBytePos;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a>-&gt;insertpos_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1853" title="access/transam/xlog.c:1853">XLogBytePosToRecPtr</a>(current_bytepos);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get latest WAL write pointer<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L9371">&#x200c;</a><span class="linkable">GetXLogWriteRecPtr</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L615" title="access/transam/xlog.c:615">RefreshXLogWriteResult</a>(<a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L607" title="access/transam/xlog.c:607">LogwrtResult</a>.Write;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns the redo pointer of the last checkpoint or restartpoint. This is<br/></li>
<li></span><span class="Comment"> * the oldest point in WAL that we still need, if we have to restart recovery.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L9383">&#x200c;</a></span><span class="linkable">GetOldestRestartPoint</span>(XLogRecPtr *oldrecptr, TimeLineID *oldtli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ControlFileLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; *oldrecptr = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.redo;<br/></li>
<li>&nbsp; &nbsp; *oldtli = <a href="#L569" title="access/transam/xlog.c:569">ControlFile</a>-&gt;checkPointCopy.ThisTimeLineID;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Thin wrapper around <a href="../../replication/walreceiverfuncs.c.html#L178" title="replication/walreceiverfuncs.c:178">ShutdownWalRcv</a>(). */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L9393">&#x200c;</a></span><span class="linkable">XLogShutdownWalRcv</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../replication/walreceiverfuncs.c.html#L178" title="replication/walreceiverfuncs.c:178">ShutdownWalRcv</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ControlFileLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InstallXLogFileSegmentActive = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Enable WAL file recycling and preallocation. */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L9404">&#x200c;</a></span><span class="linkable">SetInstallXLogFileSegmentActive</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ControlFileLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InstallXLogFileSegmentActive = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L9412">&#x200c;</a></span><span class="linkable">IsInstallXLogFileSegmentActive</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(ControlFileLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; result = <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;InstallXLogFileSegmentActive;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(ControlFileLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update the WalWriterSleeping flag.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L9427">&#x200c;</a></span><span class="linkable">SetWalWriterSleeping</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> sleeping)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>&nbsp; &nbsp; <a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;WalWriterSleeping = sleeping;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L561" title="access/transam/xlog.c:561">XLogCtl</a>-&gt;info_lck);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
