<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/transam/varsup.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/transam/varsup.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L34">TransamVariables</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L304">AdvanceNextFullTransactionIdPastXid</a></li>
<li><a href="#L355">AdvanceOldestClogXid</a></li>
<li><a href="#L673">AssertTransactionIdInAllowableRange</a></li>
<li><a href="#L517">ForceTransactionIdLimitUpdate</a></li>
<li><a href="#L555">GetNewObjectId</a></li>
<li><a href="#L77">GetNewTransactionId</a></li>
<li><a href="#L288">ReadNextFullTransactionId</a></li>
<li><a href="#L623">SetNextObjectId</a></li>
<li><a href="#L372">SetTransactionIdLimit</a></li>
<li><a href="#L652">StopGeneratingPinnedObjectIds</a></li>
<li><a href="#L47">VarsupShmemInit</a></li>
<li><a href="#L41">VarsupShmemSize</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L31">VAR_OID_PREFETCH</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * varsup.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; postgres OID &amp; XID variables support routines<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2000-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/transam/varsup.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/clog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/commit_ts.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/subtrans.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/dbcommands.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/autovacuum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pmsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* Number of OIDs to prefetch (preallocate) per XLOG write */<br/></li>
<li><a id="L31">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">VAR_OID_PREFETCH</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">8192<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* pointer to variables struct in shared memory */<br/></li>
<li><a id="L34">&#x200c;</a></span>TransamVariablesData *<span class="linkable">TransamVariables</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialization of shared memory for <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L41">&#x200c;</a><span class="linkable">VarsupShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransamVariablesData);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L47">&#x200c;</a></span><span class="linkable">VarsupShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize our shared state struct */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a> = <a href="../../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;<a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransamVariablesData),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(<a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransamVariablesData));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> FullTransactionId for a new transaction or<br/></li>
<li></span><span class="Comment"> * subtransaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The new XID is also stored into <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xid/<a href="../../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[] <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * returning.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: when this is called, we are actually already inside a valid<br/></li>
<li></span><span class="Comment"> * transaction, since XIDs are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> not allocated until the transaction<br/></li>
<li></span><span class="Comment"> * does something.&nbsp; So it is safe to do a database lookup if we want to<br/></li>
<li></span><span class="Comment"> * issue a warning about XID wrap.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>FullTransactionId<br/></li>
<li><a id="L77">&#x200c;</a><span class="linkable">GetNewTransactionId</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isSubXact)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FullTransactionId full_xid;<br/></li>
<li>&nbsp; &nbsp; TransactionId xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Workers synchronize transaction state at the beginning of each parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operation, so we can't account for new XIDs after that point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot assign TransactionIds during a parallel operation&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During bootstrap initialization, we return the special bootstrap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction id.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!isSubXact);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xid = BootstrapTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;pgxactoff] = BootstrapTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> FullTransactionIdFromEpochAndXid(<span class="Constant">0</span>, BootstrapTransactionId);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* safety check, we should never get this far in a HS standby */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot assign TransactionIds during recovery&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(XidGenLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; full_xid = <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid;<br/></li>
<li>&nbsp; &nbsp; xid = XidFromFullTransactionId(full_xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check to see if it's safe to assign another XID.&nbsp; This protects against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catastrophic data loss due to XID wraparound.&nbsp; The basic rules are:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're past xidVacLimit, start trying to force autovacuum cycles.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're past xidWarnLimit, start issuing warnings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're past xidStopLimit, refuse to execute transactions, unless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we are running in single-user mode (which gives an escape hatch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the DBA who somehow got past the earlier defenses).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that this coding also appears in <a href="multixact.c.html#L985" title="access/transam/multixact.c:985">GetNewMultiXactId</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(xid, <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;xidVacLimit))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For safety's sake, we release XidGenLock while sending signals,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * warnings, etc.&nbsp; This is not so much because we care about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * preserving concurrency in this situation, as to avoid <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possibility of deadlock while doing <a href="../../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a>(). First,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * copy all the shared <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> we'll need in this path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xidWarnLimit = <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;xidWarnLimit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xidStopLimit = <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;xidStopLimit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xidWrapLimit = <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;xidWrapLimit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldest_datoid = <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oldestXidDB;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(XidGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To avoid swamping the postmaster with signals, we issue the autovac<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * request only once per 64K transaction starts.&nbsp; This still gives<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * plenty of chances <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we get into real trouble.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> &amp;&amp; (xid % <span class="Constant">65536</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/pmsignal.c.html#L181" title="storage/ipc/pmsignal.c:181">SendPostmasterSignal</a>(PMSIGNAL_START_AUTOVAC_LAUNCHER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(xid, xidStopLimit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *oldest_datname = <a href="../../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a>(oldest_datoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* complain even if that DB has disappeared */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldest_datname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database is not accepting commands that assign new XIDs to avoid wraparound data loss in database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldest_datname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Execute a database-wide VACUUM in that database.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;You might also need to commit or roll back old prepared transactions, or drop stale replication slots.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database is not accepting commands that assign new XIDs to avoid wraparound data loss in database with OID </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldest_datoid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Execute a database-wide VACUUM in that database.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;You might also need to commit or roll back old prepared transactions, or drop stale replication slots.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(xid, xidWarnLimit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *oldest_datname = <a href="../../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a>(oldest_datoid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* complain even if that DB has disappeared */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldest_datname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be vacuumed within </span><span class="Special">%u</span><span class="Constant"> transactions&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldest_datname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xidWrapLimit - xid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;To avoid XID assignment failures, execute a database-wide VACUUM in that database.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;You might also need to commit or roll back old prepared transactions, or drop stale replication slots.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database with OID </span><span class="Special">%u</span><span class="Constant"> must be vacuumed within </span><span class="Special">%u</span><span class="Constant"> transactions&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldest_datoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xidWrapLimit - xid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;To avoid XID assignment failures, execute a database-wide VACUUM in that database.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;You might also need to commit or roll back old prepared transactions, or drop stale replication slots.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Re-acquire lock and start over */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(XidGenLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; full_xid = <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xid = XidFromFullTransactionId(full_xid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are allocating the first XID of a new page of the commit log,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * zero out that commit-log page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning. We must do this while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * holding XidGenLock, else another xact could acquire and commit a later<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XID <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we zero the page.&nbsp; Fortunately, a page of the commit log<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * holds 32K or more transactions, so we don't have to do this very often.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Extend pg_subtrans and pg_commit_ts too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="clog.c.html#L959" title="access/transam/clog.c:959">ExtendCLOG</a>(xid);<br/></li>
<li>&nbsp; &nbsp; <a href="commit_ts.c.html#L842" title="access/transam/commit_ts.c:842">ExtendCommitTs</a>(xid);<br/></li>
<li>&nbsp; &nbsp; <a href="subtrans.c.html#L379" title="access/transam/subtrans.c:379">ExtendSUBTRANS</a>(xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now advance the nextXid counter.&nbsp; This must not happen until after we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have successfully completed <a href="clog.c.html#L959" title="access/transam/clog.c:959">ExtendCLOG</a>() --- if that routine fails, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * want the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> incoming transaction to try it again.&nbsp; We cannot assign<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more XIDs until there is CLOG space for them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; FullTransactionIdAdvance(&amp;<a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must store the new XID into the shared ProcArray <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XidGenLock.&nbsp; This ensures that every active XID older than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * latestCompletedXid is present in the ProcArray, which is essential for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * correct OldestXmin tracking; see src/backend/access/transam/README.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that readers of <a href="../../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids/PGPROC-&gt;xid should be careful to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fetch the value for each proc only once, rather than assume they can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read a value multiple times and get the same answer each time.&nbsp; Note we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are assuming that TransactionId and int fetch/store are atomic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The same comments apply to the subxact xid count and overflow fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use of a write barrier prevents dangerous code rearrangement in this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function; other backends could otherwise e.g. be examining my subxids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * info concurrently, and we don't want them to see an invalid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * intermediate state, such as an incremented nxids <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the array entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is filled.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Other processes that read nxids should do so <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> reading xids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * elements with a pg_read_barrier() in between, so that they can be sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not to read an uninitialized array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>; see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * src/backend/storage/lmgr/README.barrier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's no room to fit a subtransaction XID into PGPROC, set the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cache-overflowed flag instead.&nbsp; This forces readers to look in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_subtrans to map subtransaction XIDs up to top-level XIDs. There is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * race-condition window, in that the new XID will not appear as running<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until its parent link has been placed into pg_subtrans. However, that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will happen <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> anyone could possibly have a reason to inquire about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the status of the XID, so it seems OK.&nbsp; (Snapshots taken during this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * window *will* include the parent XID, so they will deliver the correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * answer later on when someone does have a reason to inquire.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isSubXact)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;pgxactoff].count == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;pgxactoff].overflowed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxidStatus.count == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxidStatus.overflowed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a> acts as barrier */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;xid = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;xids[<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;pgxactoff] = xid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XidCacheStatus *substat = &amp;<a href="../../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;subxidStates[<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;pgxactoff];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nxids = <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxidStatus.count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(substat-&gt;count == <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxidStatus.count);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(substat-&gt;overflowed == <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxidStatus.overflowed);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nxids &lt; PGPROC_MAX_CACHED_SUBXIDS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxids.xids[nxids] = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_write_barrier();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxidStatus.count = substat-&gt;count = nxids + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;subxidStatus.overflowed = substat-&gt;overflowed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(XidGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> full_xid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read nextXid but don't allocate it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>FullTransactionId<br/></li>
<li><a id="L288">&#x200c;</a><span class="linkable">ReadNextFullTransactionId</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FullTransactionId fullXid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(XidGenLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; fullXid = <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(XidGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> fullXid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Advance nextXid to the value after a given xid.&nbsp; The epoch is inferred.<br/></li>
<li></span><span class="Comment"> * This must only be called during recovery or from two-phase start-up code.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L304">&#x200c;</a></span><span class="linkable">AdvanceNextFullTransactionIdPastXid</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FullTransactionId newNextFullXid;<br/></li>
<li>&nbsp; &nbsp; TransactionId next_xid;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; epoch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is safe to read nextXid without a lock, because this is only called<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the startup process or single-process mode, meaning that no other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process can modify it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(AmStartupProcess() || !<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fast return if this isn't an xid high enough to move the needle. */<br/></li>
<li></span>&nbsp; &nbsp; next_xid = XidFromFullTransactionId(<a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(xid, next_xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute the FullTransactionId that comes after the given xid.&nbsp; To do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this, we preserve the existing epoch, but detect when we've wrapped<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into a new epoch.&nbsp; This is necessary because WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> and 2PC state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * currently contain 32 <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> xids.&nbsp; The wrap logic is safe in those cases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because the span of active xids cannot exceed one epoch at <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point in the WAL stream.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TransactionIdAdvance(xid);<br/></li>
<li>&nbsp; &nbsp; epoch = EpochFromFullTransactionId(<a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(xid &lt; next_xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ++epoch;<br/></li>
<li>&nbsp; &nbsp; newNextFullXid = FullTransactionIdFromEpochAndXid(epoch, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We still need to take a lock to modify the value when there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrent readers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(XidGenLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid = newNextFullXid;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(XidGenLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Advance the <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>-wide value for the oldest valid clog entry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We must acquire XactTruncationLock to advance the oldestClogXid. It's not<br/></li>
<li></span><span class="Comment"> * necessary to hold the lock during the actual clog truncation, only when we<br/></li>
<li></span><span class="Comment"> * advance the limit, as code looking up arbitrary xids is required to hold<br/></li>
<li></span><span class="Comment"> * XactTruncationLock from when it tests oldestClogXid through to when it<br/></li>
<li></span><span class="Comment"> * completes the clog lookup.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L355">&#x200c;</a></span><span class="linkable">AdvanceOldestClogXid</span>(TransactionId oldest_datfrozenxid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(XactTruncationLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(<a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oldestClogXid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldest_datfrozenxid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oldestClogXid = oldest_datfrozenxid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(XactTruncationLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine the last safe XID to allocate using the currently oldest<br/></li>
<li></span><span class="Comment"> * datfrozenxid (ie, the oldest XID that might exist in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> database<br/></li>
<li></span><span class="Comment"> * of our <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>), and the OID of the (or a) database with that value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L372">&#x200c;</a></span><span class="linkable">SetTransactionIdLimit</span>(TransactionId oldest_datfrozenxid, Oid oldest_datoid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xidVacLimit;<br/></li>
<li>&nbsp; &nbsp; TransactionId xidWarnLimit;<br/></li>
<li>&nbsp; &nbsp; TransactionId xidStopLimit;<br/></li>
<li>&nbsp; &nbsp; TransactionId xidWrapLimit;<br/></li>
<li>&nbsp; &nbsp; TransactionId curXid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsNormal(oldest_datfrozenxid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The place where we actually get into deep trouble is halfway around<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the oldest potentially-existing XID.&nbsp; (This calculation is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * probably off by one or two counts, because the special XIDs reduce the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * size of the loop a little <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>.&nbsp; But we throw in plenty of slop below,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so it doesn't matter.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; xidWrapLimit = oldest_datfrozenxid + (MaxTransactionId &gt;&gt; <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xidWrapLimit &lt; FirstNormalTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xidWrapLimit += FirstNormalTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We'll refuse to continue assigning XIDs in interactive mode once we get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * within 3M transactions of data loss.&nbsp; This leaves lots of room for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * DBA to fool around fixing things in a standalone backend, while not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * being significant compared to total XID space. (VACUUM requires an XID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if it truncates at <a href="xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a>!=minimal.&nbsp; &quot;VACUUM (ANALYZE)&quot;, which a DBA<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might do by reflex, assigns an XID.&nbsp; Hence, we had better be sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there's lots of XIDs left...)&nbsp; Also, at default BLCKSZ, this leaves two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * completely-idle segments.&nbsp; In the event of edge-case bugs involving<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page or segment arithmetic, idle segments render the bugs unreachable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outside of single-user mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; xidStopLimit = xidWrapLimit - <span class="Constant">3000000</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xidStopLimit &lt; FirstNormalTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xidStopLimit -= FirstNormalTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We'll start complaining loudly when we get within 40M transactions of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data loss.&nbsp; This is kind of arbitrary, but if you let your gas gauge<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get down to 2% of full, would you be looking for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> gas station?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to be fairly liberal about this number because there are lots<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of scenarios where most transactions are done by automatic clients that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * won't pay attention to warnings.&nbsp; (No, we're not gonna make this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * configurable.&nbsp; If you know enough to configure it, you know enough to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not get in this kind of trouble in the first place.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; xidWarnLimit = xidWrapLimit - <span class="Constant">40000000</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xidWarnLimit &lt; FirstNormalTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xidWarnLimit -= FirstNormalTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We'll start trying to force autovacuums when oldest_datfrozenxid gets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be more than <a href="../../postmaster/autovacuum.c.html#L126" title="postmaster/autovacuum.c:126">autovacuum_freeze_max_age</a> transactions old.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: guc.c ensures that <a href="../../postmaster/autovacuum.c.html#L126" title="postmaster/autovacuum.c:126">autovacuum_freeze_max_age</a> is in a sane <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so that xidVacLimit will be well <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> xidWarnLimit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: <a href="../../postmaster/autovacuum.c.html#L126" title="postmaster/autovacuum.c:126">autovacuum_freeze_max_age</a> is a PGC_POSTMASTER parameter so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we don't have to worry about dealing with on-the-fly changes in its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value.&nbsp; It doesn't look practical to update shared state from a GUC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assign hook (too many processes would try to execute the hook,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * resulting in race conditions as well as crashes of those not connected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to shared memory).&nbsp; Perhaps this can be improved someday.&nbsp; See also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="multixact.c.html#L2313" title="access/transam/multixact.c:2313">SetMultiXactIdLimit</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; xidVacLimit = oldest_datfrozenxid + <a href="../../postmaster/autovacuum.c.html#L126" title="postmaster/autovacuum.c:126">autovacuum_freeze_max_age</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xidVacLimit &lt; FirstNormalTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xidVacLimit += FirstNormalTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Grab lock for just long enough to set the new limit <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(XidGenLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oldestXid = oldest_datfrozenxid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;xidVacLimit = xidVacLimit;<br/></li>
<li>&nbsp; &nbsp; <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;xidWarnLimit = xidWarnLimit;<br/></li>
<li>&nbsp; &nbsp; <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;xidStopLimit = xidStopLimit;<br/></li>
<li>&nbsp; &nbsp; <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;xidWrapLimit = xidWrapLimit;<br/></li>
<li>&nbsp; &nbsp; <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oldestXidDB = oldest_datoid;<br/></li>
<li>&nbsp; &nbsp; curXid = XidFromFullTransactionId(<a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(XidGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Log the info */<br/></li>
<li></span>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;transaction ID wrap limit is </span><span class="Special">%u</span><span class="Constant">, limited by database with OID </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xidWrapLimit, oldest_datoid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If past the autovacuum force point, immediately signal an autovac<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * request.&nbsp; The reason for this is that autovac only processes one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database per invocation.&nbsp; Once it's finished cleaning up the oldest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database, it'll call here, and we'll signal the postmaster to start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another iteration immediately if there are still <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> old databases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(curXid, xidVacLimit) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> &amp;&amp; !<a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/pmsignal.c.html#L181" title="storage/ipc/pmsignal.c:181">SendPostmasterSignal</a>(PMSIGNAL_START_AUTOVAC_LAUNCHER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Give an immediate warning if past the wrap warn point */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(curXid, xidWarnLimit) &amp;&amp; !<a href="xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *oldest_datname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can be called when not inside a transaction, for example during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="xlog.c.html#L5388" title="access/transam/xlog.c:5388">StartupXLOG</a>().&nbsp; In such a case we cannot do database access, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must just report the oldest DB's OID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: it's also possible that <a href="../../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a> fails and returns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULL, for example because the database just got dropped.&nbsp; We'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still warn, even though the warning might <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be unnecessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldest_datname = <a href="../../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a>(oldest_datoid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldest_datname = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldest_datname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> must be vacuumed within </span><span class="Special">%u</span><span class="Constant"> transactions&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldest_datname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xidWrapLimit - curXid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;To avoid XID assignment failures, execute a database-wide VACUUM in that database.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;You might also need to commit or roll back old prepared transactions, or drop stale replication slots.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database with OID </span><span class="Special">%u</span><span class="Constant"> must be vacuumed within </span><span class="Special">%u</span><span class="Constant"> transactions&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldest_datoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xidWrapLimit - curXid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;To avoid XID assignment failures, execute a database-wide VACUUM in that database.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;You might also need to commit or roll back old prepared transactions, or drop stale replication slots.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L517" title="access/transam/varsup.c:517">ForceTransactionIdLimitUpdate</a> -- does the XID wrap-limit data need updating?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We primarily check whether oldestXidDB is valid.&nbsp; The cases we have in<br/></li>
<li></span><span class="Comment"> * mind are that that database was dropped, or the field was reset to zero<br/></li>
<li></span><span class="Comment"> * by pg_resetwal.&nbsp; In either case we should force recalculation of the<br/></li>
<li></span><span class="Comment"> * wrap limit.&nbsp; Also do it if oldestXid is old enough to be forcing<br/></li>
<li></span><span class="Comment"> * autovacuums or other actions; this ensures we update our state as soon<br/></li>
<li></span><span class="Comment"> * as possible once extra overhead is being incurred.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L517">&#x200c;</a></span><span class="linkable">ForceTransactionIdLimitUpdate</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId nextXid;<br/></li>
<li>&nbsp; &nbsp; TransactionId xidVacLimit;<br/></li>
<li>&nbsp; &nbsp; TransactionId oldestXid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldestXidDB;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Locking is probably not really necessary, but let's be careful */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(XidGenLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; nextXid = XidFromFullTransactionId(<a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid);<br/></li>
<li>&nbsp; &nbsp; xidVacLimit = <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;xidVacLimit;<br/></li>
<li>&nbsp; &nbsp; oldestXid = <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oldestXid;<br/></li>
<li>&nbsp; &nbsp; oldestXidDB = <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oldestXidDB;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(XidGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsNormal(oldestXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen, but just in case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(xidVacLimit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this shouldn't happen anymore either */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(nextXid, xidVacLimit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* past xidVacLimit, don't delay updating */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!SearchSysCacheExists1(DATABASEOID, ObjectIdGetDatum(oldestXidDB)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* could happen, per comments above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L555" title="access/transam/varsup.c:555">GetNewObjectId</a> -- allocate a new OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * OIDs are generated by a <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>-wide counter.&nbsp; Since they are only 32 bits<br/></li>
<li></span><span class="Comment"> * wide, counter wraparound will occur eventually, and therefore it is unwise<br/></li>
<li></span><span class="Comment"> * to assume they are unique unless precautions are taken to make them so.<br/></li>
<li></span><span class="Comment"> * Hence, this routine should generally not be used directly.&nbsp; The only direct<br/></li>
<li></span><span class="Comment"> * callers should be <a href="../../catalog/catalog.c.html#L391" title="catalog/catalog.c:391">GetNewOidWithIndex</a>() and <a href="../../catalog/catalog.c.html#L500" title="catalog/catalog.c:500">GetNewRelFileNumber</a>() in<br/></li>
<li></span><span class="Comment"> * catalog/catalog.c.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L555">&#x200c;</a><span class="linkable">GetNewObjectId</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* safety check, we should never get this far in a HS standby */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot assign OIDs during recovery&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(OidGenLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for wraparound of the OID counter.&nbsp; We *must* not return 0<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (InvalidOid), and in normal operation we mustn't return anything below<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FirstNormalObjectId since that <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is reserved for initdb (see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../catalog/catalog.c.html#L120" title="catalog/catalog.c:120">IsCatalogRelationOid</a>()).&nbsp; Note we are relying on unsigned comparison.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During initdb, we start the OID generator at FirstGenbkiObjectId, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only wrap if <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> that point when in bootstrap or standalone mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The first time through this routine after normal postmaster start, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * counter will be forced up to FirstNormalObjectId.&nbsp; This mechanism<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leaves the OIDs between FirstGenbkiObjectId and FirstNormalObjectId<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * available for automatic assignment during initdb, while ensuring they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will never conflict with user-assigned OIDs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextOid &lt; ((Oid) FirstNormalObjectId))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L116" title="utils/init/globals.c:116">IsPostmasterEnvironment</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wraparound, or first post-initdb assignment, in normal mode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextOid = FirstNormalObjectId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oidCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we may be bootstrapping, so don't enforce the full <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextOid &lt; ((Oid) FirstGenbkiObjectId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wraparound in standalone mode (unlikely but possible) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextOid = FirstNormalObjectId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oidCount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we run out of logged for use oids then we must log more */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oidCount == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlog.c.html#L7944" title="access/transam/xlog.c:7944">XLogPutNextOid</a>(<a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextOid + <a href="#L31" title="access/transam/varsup.c:31">VAR_OID_PREFETCH</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oidCount = <a href="#L31" title="access/transam/varsup.c:31">VAR_OID_PREFETCH</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextOid)++;<br/></li>
<li>&nbsp; &nbsp; (<a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oidCount)--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(OidGenLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L623" title="access/transam/varsup.c:623">SetNextObjectId</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This may only be called during initdb; it advances the OID counter<br/></li>
<li></span><span class="Comment"> * to the specified value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L623">&#x200c;</a></span><span class="linkable">SetNextObjectId</span>(Oid nextOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Safety check, this is only allowable during initdb */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/init/globals.c.html#L116" title="utils/init/globals.c:116">IsPostmasterEnvironment</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot advance OID counter anymore&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Taking the lock is, therefore, just pro forma; but do it anyway */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(OidGenLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextOid &gt; nextOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too late to advance OID counter to </span><span class="Special">%u</span><span class="Constant">, it is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nextOid, <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextOid = nextOid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oidCount = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(OidGenLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L652" title="access/transam/varsup.c:652">StopGeneratingPinnedObjectIds</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called once during initdb to force the OID counter up to<br/></li>
<li></span><span class="Comment"> * FirstUnpinnedObjectId.&nbsp; This supports letting initdb's post-bootstrap<br/></li>
<li></span><span class="Comment"> * processing create some pinned objects early on.&nbsp; Once it's done doing<br/></li>
<li></span><span class="Comment"> * so, it calls this (via <a href="../../catalog/catalog.c.html#L665" title="catalog/catalog.c:665">pg_stop_making_pinned_objects</a>()) so that the<br/></li>
<li></span><span class="Comment"> * remaining objects it makes will be considered un-pinned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L652">&#x200c;</a></span><span class="linkable">StopGeneratingPinnedObjectIds</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L623" title="access/transam/varsup.c:623">SetNextObjectId</a>(FirstUnpinnedObjectId);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Assert that xid is between [oldestXid, nextXid], which is the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> we<br/></li>
<li></span><span class="Comment"> * expect XIDs coming from tables etc to be in.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oldestXid could change just after this call without<br/></li>
<li></span><span class="Comment"> * further precautions, and as a wrapped-around xid could again fall within<br/></li>
<li></span><span class="Comment"> * the valid <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, this assertion can only detect if something is definitely<br/></li>
<li></span><span class="Comment"> * wrong, but not establish correctness.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This intentionally does not expose a return value, to avoid code being<br/></li>
<li></span><span class="Comment"> * introduced that depends on the return value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L673">&#x200c;</a></span><span class="linkable">AssertTransactionIdInAllowableRange</span>(TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId oldest_xid;<br/></li>
<li>&nbsp; &nbsp; TransactionId next_xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we may see bootstrap / frozen */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsNormal(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't acquire XidGenLock, as this may be called with XidGenLock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already held (or with other locks that don't allow XidGenLock to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nested). That's ok for our purposes though, since we already rely on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 32bit reads to be atomic. While nextXid is 64 <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>, we only look at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> 32bit, so a skewed read doesn't hurt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There's no increased danger of falling outside [oldest, <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>] by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accessing them without a lock. xid needs to have been created with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L77" title="access/transam/varsup.c:77">GetNewTransactionId</a>() in the originating session, and the locks there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pair with the memory barrier below.&nbsp; We do however <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> xid to be &lt;=<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to next_xid, instead of just &lt;, as xid could be from the procarray,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we see the updated nextXid value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_memory_barrier();<br/></li>
<li>&nbsp; &nbsp; oldest_xid = <a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;oldestXid;<br/></li>
<li>&nbsp; &nbsp; next_xid = XidFromFullTransactionId(<a href="#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(xid, oldest_xid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(xid, next_xid));<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
