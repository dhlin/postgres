<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/transam/xlogutils.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/transam/xlogutils.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L50">InRecovery</a></li>
<li><a href="#L34">ignore_invalid_pages</a></li>
<li><a href="#L78">invalid_page_tab</a></li>
<li><a href="#L53">standbyState</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L565">FakeRelCacheEntry</a></li>
<li><a href="#L563">FakeRelCacheEntryData</a></li>
<li><a href="#L72">xl_invalid_page</a></li>
<li><a href="#L76">xl_invalid_page</a></li>
<li><a href="#L65">xl_invalid_page_key</a></li>
<li><a href="#L70">xl_invalid_page_key</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L582">CreateFakeRelcacheEntry</a></li>
<li><a href="#L629">FreeFakeRelcacheEntry</a></li>
<li><a href="#L1020">WALReadRaiseError</a></li>
<li><a href="#L245">XLogCheckInvalidPages</a></li>
<li><a href="#L652">XLogDropDatabase</a></li>
<li><a href="#L641">XLogDropRelation</a></li>
<li><a href="#L235">XLogHaveInvalidPages</a></li>
<li><a href="#L326">XLogInitBufferForRedo</a></li>
<li><a href="#L471">XLogReadBufferExtended</a></li>
<li><a href="#L314">XLogReadBufferForRedo</a></li>
<li><a href="#L351">XLogReadBufferForRedoExtended</a></li>
<li><a href="#L718">XLogReadDetermineTimeline</a></li>
<li><a href="#L671">XLogTruncateRelation</a></li>
<li><a href="#L166">forget_invalid_pages</a></li>
<li><a href="#L202">forget_invalid_pages_db</a></li>
<li><a href="#L102">log_invalid_page</a></li>
<li><a href="#L861">read_local_xlog_page</a></li>
<li><a href="#L885">read_local_xlog_page_guts</a></li>
<li><a href="#L873">read_local_xlog_page_no_wait</a></li>
<li><a href="#L86">report_invalid_page</a></li>
<li><a href="#L842">wal_segment_close</a></li>
<li><a href="#L817">wal_segment_open</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * xlogutils.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * PostgreSQL write-ahead log manager utility routines<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This file contains support routines that are used by XLOG replay <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> * None of this code is used during normal system operation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * src/backend/access/transam/xlogutils.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/timeline.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogrecovery.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/hsearch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* GUC variable */<br/></li>
<li><a id="L34">&#x200c;</a></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">ignore_invalid_pages</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Are we doing recovery from XLOG?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is only ever true in the startup process; it should be read as meaning<br/></li>
<li></span><span class="Comment"> * &quot;this process is replaying WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>&quot;, rather than &quot;the system is in<br/></li>
<li></span><span class="Comment"> * recovery mode&quot;.&nbsp; It should be examined primarily by <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that need<br/></li>
<li></span><span class="Comment"> * to act differently when called from a WAL redo function (e.g., to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> WAL<br/></li>
<li></span><span class="Comment"> * logging).&nbsp; To check whether the system is in recovery regardless of which<br/></li>
<li></span><span class="Comment"> * process you're running in, use <a href="xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>() but only after shared<br/></li>
<li></span><span class="Comment"> * memory startup and lock initialization.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is updated from xlog.c and xlogrecovery.c, but lives here because<br/></li>
<li></span><span class="Comment"> * it's mostly read by WAL redo <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L50">&#x200c;</a></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">InRecovery</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Are we in Hot Standby mode? Only valid in startup process, see xlogutils.h */<br/></li>
<li><a id="L53">&#x200c;</a></span>HotStandbyState <span class="linkable">standbyState</span> = STANDBY_DISABLED;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * During XLOG replay, we may see XLOG <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> for incremental updates of<br/></li>
<li></span><span class="Comment"> * pages that no longer exist, because their relation was later dropped or<br/></li>
<li></span><span class="Comment"> * truncated.&nbsp; (Note: this is only possible when full_page_writes = <a href="../../regex/regexec.c.html#L131" title="regex/regexec.c:131">OFF</a>,<br/></li>
<li></span><span class="Comment"> * since when it's ON, the first reference we see to a page should always<br/></li>
<li></span><span class="Comment"> * be a full-page rewrite not an incremental update.)&nbsp; Rather than simply<br/></li>
<li></span><span class="Comment"> * ignoring such <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, we make a note of the referenced page, and then<br/></li>
<li></span><span class="Comment"> * complain if we don't actually see a drop or truncate covering the page<br/></li>
<li></span><span class="Comment"> * later in replay.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L65">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">xl_invalid_page_key</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelFileLocator locator;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the relation */<br/></li>
<li></span>&nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forkno;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the fork number */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber blkno;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the page */<br/></li>
<li><a id="L70">&#x200c;</a></span>} <span class="linkable">xl_invalid_page_key</span>;<br/></li>
<li><br/></li>
<li><a id="L72">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">xl_invalid_page</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="access/transam/xlogutils.c:65">xl_invalid_page_key</a> key;&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key ... must be first */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; present;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* page existed but contained zeroes */<br/></li>
<li><a id="L76">&#x200c;</a></span>} <span class="linkable">xl_invalid_page</span>;<br/></li>
<li><br/></li>
<li><a id="L78">&#x200c;</a><span class="Type">static</span> <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">invalid_page_tab</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L885" title="access/transam/xlogutils.c:885">read_local_xlog_page_guts</a>(XLogReaderState *state, XLogRecPtr targetPagePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> reqLen, XLogRecPtr targetRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> *cur_page, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> wait_for_wal);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Report a reference to an invalid page */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L86">&#x200c;</a></span><span class="linkable">report_invalid_page</span>(<span class="Type">int</span> elevel, RelFileLocator locator, ForkNumber forkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> present)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *path = relpathperm(locator, forkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (present)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(elevel, <span class="Constant">&quot;page </span><span class="Special">%u</span><span class="Constant"> of relation </span><span class="Special">%s</span><span class="Constant"> is uninitialized&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blkno, path);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(elevel, <span class="Constant">&quot;page </span><span class="Special">%u</span><span class="Constant"> of relation </span><span class="Special">%s</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blkno, path);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(path);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Log a reference to an invalid page */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L102">&#x200c;</a></span><span class="linkable">log_invalid_page</span>(RelFileLocator locator, ForkNumber forkno, BlockNumber blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> present)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L65" title="access/transam/xlogutils.c:65">xl_invalid_page_key</a> key;<br/></li>
<li>&nbsp; &nbsp; <a href="#L72" title="access/transam/xlogutils.c:72">xl_invalid_page</a> *hentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Once recovery has reached a consistent state, the invalid-page table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should be empty and remain so. If a reference to an invalid page is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * found after consistency is reached, PANIC immediately. This might seem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggressive, but it's better than letting the invalid reference linger<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table until the end of recovery and PANIC there, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might come only much later if this is a standby server.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L294" title="access/transam/xlogrecovery.c:294">reachedConsistency</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L86" title="access/transam/xlogutils.c:86">report_invalid_page</a>(WARNING, locator, forkno, blkno, present);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(<a href="#L34" title="access/transam/xlogutils.c:34">ignore_invalid_pages</a> ? WARNING : PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;WAL contains references to invalid pages&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Log references to invalid pages at DEBUG1 level.&nbsp; This allows some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tracing of the cause (note the elog context mechanism will tell us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * something about the XLOG record that generated the reference).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/error/elog.c.html#L276" title="utils/error/elog.c:276">message_level_is_interesting</a>(DEBUG1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L86" title="access/transam/xlogutils.c:86">report_invalid_page</a>(DEBUG1, locator, forkno, blkno, present);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L78" title="access/transam/xlogutils.c:78">invalid_page_tab</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* create <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table when first needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L65" title="access/transam/xlogutils.c:65">xl_invalid_page_key</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L72" title="access/transam/xlogutils.c:72">xl_invalid_page</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L78" title="access/transam/xlogutils.c:78">invalid_page_tab</a> = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;XLOG invalid-page table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">100</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ELEM | HASH_BLOBS);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we currently assume <a href="#L65" title="access/transam/xlogutils.c:65">xl_invalid_page_key</a> contains no padding */<br/></li>
<li></span>&nbsp; &nbsp; key.locator = locator;<br/></li>
<li>&nbsp; &nbsp; key.forkno = forkno;<br/></li>
<li>&nbsp; &nbsp; key.blkno = blkno;<br/></li>
<li>&nbsp; &nbsp; hentry = (<a href="#L72" title="access/transam/xlogutils.c:72">xl_invalid_page</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L78" title="access/transam/xlogutils.c:78">invalid_page_tab</a>, &amp;key, HASH_ENTER, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a> already filled in the key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hentry-&gt;present = present;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> reference ... leave &quot;present&quot; as it was */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Forget <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> invalid pages &gt;= minblkno, because they've been dropped */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L166">&#x200c;</a></span><span class="linkable">forget_invalid_pages</span>(RelFileLocator locator, ForkNumber forkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber minblkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L72" title="access/transam/xlogutils.c:72">xl_invalid_page</a> *hentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L78" title="access/transam/xlogutils.c:78">invalid_page_tab</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L78" title="access/transam/xlogutils.c:78">invalid_page_tab</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((hentry = (<a href="#L72" title="access/transam/xlogutils.c:72">xl_invalid_page</a> *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelFileLocatorEquals(hentry-&gt;key.locator, locator) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hentry-&gt;key.forkno == forkno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hentry-&gt;key.blkno &gt;= minblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/error/elog.c.html#L276" title="utils/error/elog.c:276">message_level_is_interesting</a>(DEBUG2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *path = relpathperm(hentry-&gt;key.locator, forkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;page </span><span class="Special">%u</span><span class="Constant"> of relation </span><span class="Special">%s</span><span class="Constant"> has been dropped&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hentry-&gt;key.blkno, path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L78" title="access/transam/xlogutils.c:78">invalid_page_tab</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hentry-&gt;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_REMOVE, <span class="Constant">NULL</span>) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table corrupted&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Forget <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> invalid pages in a whole database */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L202">&#x200c;</a></span><span class="linkable">forget_invalid_pages_db</span>(Oid dbid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L72" title="access/transam/xlogutils.c:72">xl_invalid_page</a> *hentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L78" title="access/transam/xlogutils.c:78">invalid_page_tab</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L78" title="access/transam/xlogutils.c:78">invalid_page_tab</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((hentry = (<a href="#L72" title="access/transam/xlogutils.c:72">xl_invalid_page</a> *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hentry-&gt;key.locator.dbOid == dbid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/error/elog.c.html#L276" title="utils/error/elog.c:276">message_level_is_interesting</a>(DEBUG2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *path = relpathperm(hentry-&gt;key.locator, hentry-&gt;key.forkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;page </span><span class="Special">%u</span><span class="Constant"> of relation </span><span class="Special">%s</span><span class="Constant"> has been dropped&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hentry-&gt;key.blkno, path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L78" title="access/transam/xlogutils.c:78">invalid_page_tab</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hentry-&gt;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_REMOVE, <span class="Constant">NULL</span>) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table corrupted&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Are there <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unresolved references to invalid pages? */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L235">&#x200c;</a></span><span class="linkable">XLogHaveInvalidPages</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L78" title="access/transam/xlogutils.c:78">invalid_page_tab</a> != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1341" title="utils/hash/dynahash.c:1341">hash_get_num_entries</a>(<a href="#L78" title="access/transam/xlogutils.c:78">invalid_page_tab</a>) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Complain about <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining invalid-page entries */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L245">&#x200c;</a></span><span class="linkable">XLogCheckInvalidPages</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L72" title="access/transam/xlogutils.c:72">xl_invalid_page</a> *hentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; foundone = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L78" title="access/transam/xlogutils.c:78">invalid_page_tab</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L78" title="access/transam/xlogutils.c:78">invalid_page_tab</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Our strategy is to emit WARNING messages for all remaining entries and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only PANIC after we've dumped all the available info.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> ((hentry = (<a href="#L72" title="access/transam/xlogutils.c:72">xl_invalid_page</a> *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L86" title="access/transam/xlogutils.c:86">report_invalid_page</a>(WARNING, hentry-&gt;key.locator, hentry-&gt;key.forkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hentry-&gt;key.blkno, hentry-&gt;present);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foundone = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (foundone)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(<a href="#L34" title="access/transam/xlogutils.c:34">ignore_invalid_pages</a> ? WARNING : PANIC,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;WAL contains references to invalid pages&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(<a href="#L78" title="access/transam/xlogutils.c:78">invalid_page_tab</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="access/transam/xlogutils.c:78">invalid_page_tab</a> = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Read a page during XLOG replay<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Reads a block referenced by a WAL record into shared buffer cache, and<br/></li>
<li></span><span class="Comment"> * determines what needs to be done to redo the changes to it.&nbsp; If the WAL<br/></li>
<li></span><span class="Comment"> * record includes a full-page image of the page, it is restored.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'record.EndRecPtr' is compared to the page's LSN to determine if the record<br/></li>
<li></span><span class="Comment"> * has already been replayed.&nbsp; 'block_id' is the ID number the block was<br/></li>
<li></span><span class="Comment"> * registered with, when the WAL record was created.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns one of the following:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; BLK_NEEDS_REDO&nbsp; &nbsp; - changes from the WAL record need to be applied<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; BLK_DONE&nbsp; &nbsp; &nbsp; &nbsp; - block doesn't need replaying<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; BLK_RESTORED&nbsp; &nbsp; - block was restored from a full-page image included in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the record<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; BLK_NOTFOUND&nbsp; &nbsp; - block was not found (because it was truncated away by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; an operation later in the WAL stream)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On return, the buffer is locked in exclusive-mode, and returned in *buf.<br/></li>
<li></span><span class="Comment"> * Note that the buffer is locked and returned even if it doesn't need<br/></li>
<li></span><span class="Comment"> * replaying.&nbsp; (Getting the buffer lock is not really necessary during<br/></li>
<li></span><span class="Comment"> * single-process crash recovery, but some subroutines such as <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a><br/></li>
<li></span><span class="Comment"> * will complain if we don't have the lock.&nbsp; In hot standby mode it's<br/></li>
<li></span><span class="Comment"> * definitely necessary.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: when a backup block is available in XLOG with the BKPIMAGE_APPLY flag<br/></li>
<li></span><span class="Comment"> * set, we restore it, even if the page in the database appears newer.&nbsp; This<br/></li>
<li></span><span class="Comment"> * is to protect ourselves against database pages that were partially or<br/></li>
<li></span><span class="Comment"> * incorrectly written during a crash.&nbsp; We assume that the XLOG data must be<br/></li>
<li></span><span class="Comment"> * good because it has passed a CRC check, while the database page might not<br/></li>
<li></span><span class="Comment"> * be.&nbsp; This will force us to replay all subsequent modifications of the page<br/></li>
<li></span><span class="Comment"> * that appear in XLOG, rather than possibly ignoring them as already<br/></li>
<li></span><span class="Comment"> * applied, but that's not a huge drawback.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRedoAction<br/></li>
<li><a id="L314">&#x200c;</a><span class="linkable">XLogReadBufferForRedo</span>(XLogReaderState *record, uint8 block_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer *buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L351" title="access/transam/xlogutils.c:351">XLogReadBufferForRedoExtended</a>(record, block_id, RBM_NORMAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Pin and lock a buffer referenced by a WAL record, for the purpose of<br/></li>
<li></span><span class="Comment"> * re-initializing it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L326">&#x200c;</a><span class="linkable">XLogInitBufferForRedo</span>(XLogReaderState *record, uint8 block_id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L351" title="access/transam/xlogutils.c:351">XLogReadBufferForRedoExtended</a>(record, block_id, RBM_ZERO_AND_LOCK, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L351" title="access/transam/xlogutils.c:351">XLogReadBufferForRedoExtended</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Like <a href="#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>, but with extra options.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In RBM_ZERO_* modes, if the page doesn't exist, the relation is extended<br/></li>
<li></span><span class="Comment"> * with all-zeroes pages up to the referenced block number.&nbsp; In<br/></li>
<li></span><span class="Comment"> * RBM_ZERO_AND_LOCK and RBM_ZERO_AND_CLEANUP_LOCK modes, the return value<br/></li>
<li></span><span class="Comment"> * is always BLK_NEEDS_REDO.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (The RBM_ZERO_AND_CLEANUP_LOCK mode is redundant with the get_cleanup_lock<br/></li>
<li></span><span class="Comment"> * parameter. Do not use an inconsistent combination!)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If 'get_cleanup_lock' is true, a &quot;<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock&quot; is acquired on the buffer<br/></li>
<li></span><span class="Comment"> * using <a href="../../storage/buffer/bufmgr.c.html#L5165" title="storage/buffer/bufmgr.c:5165">LockBufferForCleanup</a>(), instead of a regular exclusive lock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRedoAction<br/></li>
<li><a id="L351">&#x200c;</a><span class="linkable">XLogReadBufferForRedoExtended</span>(XLogReaderState *record,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8 block_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReadBufferMode mode, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> get_cleanup_lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer *buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li>&nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forknum;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; prefetch_buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; zeromode;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; willinit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="xlogreader.c.html#L1997" title="access/transam/xlogreader.c:1997">XLogRecGetBlockTagExtended</a>(record, block_id, &amp;rlocator, &amp;forknum, &amp;blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;prefetch_buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Caller specified a bogus block_id */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;failed to locate backup block with ID </span><span class="Special">%d</span><span class="Constant"> in WAL record&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; block_id);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure that if the block is marked with WILL_INIT, the caller is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * going to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it. And vice versa.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; zeromode = (mode == RBM_ZERO_AND_LOCK || mode == RBM_ZERO_AND_CLEANUP_LOCK);<br/></li>
<li>&nbsp; &nbsp; willinit = (XLogRecGetBlock(record, block_id)-&gt;flags &amp; BKPBLOCK_WILL_INIT) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (willinit &amp;&amp; !zeromode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;block with WILL_INIT flag in WAL record must be zeroed by redo routine&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!willinit &amp;&amp; zeromode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;block to be initialized in redo routine must be marked with WILL_INIT flag in the WAL record&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it has a full-page image and it should be restored, do it. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (XLogRecBlockImageApply(record, block_id))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(XLogRecHasBlockImage(record, block_id));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *buf = <a href="#L471" title="access/transam/xlogutils.c:471">XLogReadBufferExtended</a>(rlocator, forknum, blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; get_cleanup_lock ? RBM_ZERO_AND_CLEANUP_LOCK : RBM_ZERO_AND_LOCK,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefetch_buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(*buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="xlogreader.c.html#L2056" title="access/transam/xlogreader.c:2056">RestoreBlockImage</a>(record, block_id, page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERNAL_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, record-&gt;errormsg_buf)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The page may be uninitialized. If so, we can't set the LSN because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that would corrupt the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!PageIsNew(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(*buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At the end of crash recovery the init forks of unlogged relations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are copied, without going through shared buffers. So we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * force the on-disk state of init forks to always be in sync with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * state in shared buffers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (forknum == INIT_FORKNUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4830" title="storage/buffer/bufmgr.c:4830">FlushOneBuffer</a>(*buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BLK_RESTORED;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *buf = <a href="#L471" title="access/transam/xlogutils.c:471">XLogReadBufferExtended</a>(rlocator, forknum, blkno, mode, prefetch_buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(*buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mode != RBM_ZERO_AND_LOCK &amp;&amp; mode != RBM_ZERO_AND_CLEANUP_LOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (get_cleanup_lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5165" title="storage/buffer/bufmgr.c:5165">LockBufferForCleanup</a>(*buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lsn &lt;= PageGetLSN(BufferGetPage(*buf)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BLK_DONE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BLK_NEEDS_REDO;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BLK_NOTFOUND;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L471" title="access/transam/xlogutils.c:471">XLogReadBufferExtended</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Read a page during XLOG replay<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is functionally comparable to <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>. There's some<br/></li>
<li></span><span class="Comment"> * differences in the behavior wrt. the &quot;mode&quot; argument:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In RBM_NORMAL mode, if the page doesn't exist, or contains all-zeroes, we<br/></li>
<li></span><span class="Comment"> * return InvalidBuffer. In this case the caller should silently <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the<br/></li>
<li></span><span class="Comment"> * update on this page. (In this situation, we expect that the page was later<br/></li>
<li></span><span class="Comment"> * dropped or truncated. If we don't see evidence of that later in the WAL<br/></li>
<li></span><span class="Comment"> * sequence, we'll complain at the end of WAL replay.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In RBM_ZERO_* modes, if the page doesn't exist, the relation is extended<br/></li>
<li></span><span class="Comment"> * with all-zeroes pages up to the given block number.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In RBM_NORMAL_NO_LOG mode, we return InvalidBuffer if the page doesn't<br/></li>
<li></span><span class="Comment"> * exist, and we don't check for all-zeroes.&nbsp; Thus, no log entry is made<br/></li>
<li></span><span class="Comment"> * to imply that the page should be dropped or truncated later.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Optionally, recent_buffer can be used to provide a hint about the location<br/></li>
<li></span><span class="Comment"> * of the page in the buffer pool; it does not have to be correct, but avoids<br/></li>
<li></span><span class="Comment"> * a buffer mapping table probe if it is.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: A redo function should normally not call this directly. To get a page<br/></li>
<li></span><span class="Comment"> * to modify, use <a href="#L351" title="access/transam/xlogutils.c:351">XLogReadBufferForRedoExtended</a> instead. It is important that<br/></li>
<li></span><span class="Comment"> * all pages modified by a WAL record are registered in the WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, or<br/></li>
<li></span><span class="Comment"> * they will be invisible to tools that need to know which pages are modified.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L471">&#x200c;</a><span class="linkable">XLogReadBufferExtended</span>(RelFileLocator rlocator, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber blkno, ReadBufferMode mode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer recent_buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber lastblock;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; SMgrRelation smgr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(blkno != P_NEW);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do we have a clue where the buffer might be already? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(recent_buffer) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mode == RBM_NORMAL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L669" title="storage/buffer/bufmgr.c:669">ReadRecentBuffer</a>(rlocator, forknum, blkno, recent_buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = recent_buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> recent_buffer_fast_path;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open the relation at smgr level */<br/></li>
<li></span>&nbsp; &nbsp; smgr = <a href="../../storage/smgr/smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>(rlocator, INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the target file if it doesn't already exist.&nbsp; This lets us cope<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the replay sequence contains writes to a relation that is later<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deleted.&nbsp; (The original coding of this routine would instead suppress<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the writes, but that seems like it risks losing valuable data if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * filesystem loses an inode during a crash.&nbsp; Better to write the data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until we are actually told to delete the file.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/smgr/smgr.c.html#L411" title="storage/smgr/smgr.c:411">smgrcreate</a>(smgr, forknum, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lastblock = <a href="../../storage/smgr/smgr.c.html#L655" title="storage/smgr/smgr.c:655">smgrnblocks</a>(smgr, forknum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (blkno &lt; lastblock)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* page exists in file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L829" title="storage/buffer/bufmgr.c:829">ReadBufferWithoutRelcache</a>(rlocator, forknum, blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mode, <span class="Constant">NULL</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* hm, page doesn't exist in file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mode == RBM_NORMAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L102" title="access/transam/xlogutils.c:102">log_invalid_page</a>(rlocator, forknum, blkno, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mode == RBM_NORMAL_NO_LOG)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK to extend the file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we do this in recovery only - no rel-extension lock needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L50" title="access/transam/xlogutils.c:50">InRecovery</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L909" title="storage/buffer/bufmgr.c:909">ExtendBufferedRelTo</a>(BMR_SMGR(smgr, RELPERSISTENCE_PERMANENT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EB_PERFORMING_RECOVERY |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EB_SKIP_EXTENSION_LOCK,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blkno + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">recent_buffer_fast_path</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (mode == RBM_NORMAL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check that page has been initialized */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We assume that PageIsNew is safe without a lock. During recovery,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there should be no other backends that could modify the buffer at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L102" title="access/transam/xlogutils.c:102">log_invalid_page</a>(rlocator, forknum, blkno, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Struct actually returned by <a href="#L582" title="access/transam/xlogutils.c:582">CreateFakeRelcacheEntry</a>, though the declared<br/></li>
<li></span><span class="Comment"> * return type is Relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; RelationData reldata;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Note: this must be first */<br/></li>
<li></span>&nbsp; &nbsp; FormData_pg_class pgc;<br/></li>
<li><a id="L563">&#x200c;</a>} <span class="linkable">FakeRelCacheEntryData</span>;<br/></li>
<li><br/></li>
<li><a id="L565">&#x200c;</a><span class="Type">typedef</span> <a href="#L563" title="access/transam/xlogutils.c:563">FakeRelCacheEntryData</a> *<span class="linkable">FakeRelCacheEntry</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a fake relation cache entry for a physical relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's often convenient to use the same <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in XLOG replay as in the<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> codepath, but those <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> typically work with a relcache entry.<br/></li>
<li></span><span class="Comment"> * We don't have a working relation cache during XLOG replay, but this<br/></li>
<li></span><span class="Comment"> * function can be used to create a fake relcache entry instead. Only the<br/></li>
<li></span><span class="Comment"> * fields related to physical storage, like rd_rel, are initialized, so the<br/></li>
<li></span><span class="Comment"> * fake entry is only usable in low-level operations like <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is also used for syncing WAL-skipped files.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must free the returned entry with <a href="#L629" title="access/transam/xlogutils.c:629">FreeFakeRelcacheEntry</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Relation<br/></li>
<li><a id="L582">&#x200c;</a><span class="linkable">CreateFakeRelcacheEntry</span>(RelFileLocator rlocator)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L565" title="access/transam/xlogutils.c:565">FakeRelCacheEntry</a> fakeentry;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate the Relation struct and all related space in one block. */<br/></li>
<li></span>&nbsp; &nbsp; fakeentry = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L563" title="access/transam/xlogutils.c:563">FakeRelCacheEntryData</a>));<br/></li>
<li>&nbsp; &nbsp; rel = (Relation) fakeentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel-&gt;rd_rel = &amp;fakeentry-&gt;pgc;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;rd_locator = rlocator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We will never be working with temp rels during recovery or while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * syncing WAL-skipped files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;rd_backend = INVALID_PROC_NUMBER;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It must be a permanent table here */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;rd_rel-&gt;relpersistence = RELPERSISTENCE_PERMANENT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't know the name of the relation; use relfilenumber instead */<br/></li>
<li></span>&nbsp; &nbsp; sprintf(RelationGetRelationName(rel), <span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant">&quot;</span>, rlocator.relNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We set up the lockRelId in case anything tries to lock the dummy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation.&nbsp; Note that this is fairly bogus since relNumber may be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different from the relation's OID.&nbsp; It shouldn't really matter though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In recovery, we are running by ourselves and can't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conflicts.&nbsp; While syncing, we already hold AccessExclusiveLock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;rd_lockInfo.lockRelId.dbId = rlocator.dbOid;<br/></li>
<li>&nbsp; &nbsp; rel-&gt;rd_lockInfo.lockRelId.relId = rlocator.relNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up a non-pinned SMgrRelation reference, so that we don't need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worry about unpinning it on error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel-&gt;rd_smgr = <a href="../../storage/smgr/smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>(rlocator, INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free a fake relation cache entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L629">&#x200c;</a></span><span class="linkable">FreeFakeRelcacheEntry</span>(Relation fakerel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(fakerel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Drop a relation during XLOG replay<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called when the relation is about to be deleted; we need to remove<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> open &quot;invalid-page&quot; <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> for the relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L641">&#x200c;</a></span><span class="linkable">XLogDropRelation</span>(RelFileLocator rlocator, ForkNumber forknum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L166" title="access/transam/xlogutils.c:166">forget_invalid_pages</a>(rlocator, forknum, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Drop a whole database during XLOG replay<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As above, but for DROP DATABASE instead of dropping a single rel<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L652">&#x200c;</a></span><span class="linkable">XLogDropDatabase</span>(Oid dbid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is unnecessarily heavy-handed, as it will close SMgrRelation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * objects for other databases as well. DROP DATABASE occurs seldom enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that it's not worth introducing a variant of <a href="../../storage/smgr/smgr.c.html#L277" title="storage/smgr/smgr.c:277">smgrdestroy</a> for just this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * purpose.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/smgr/smgr.c.html#L332" title="storage/smgr/smgr.c:332">smgrdestroyall</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L202" title="access/transam/xlogutils.c:202">forget_invalid_pages_db</a>(dbid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Truncate a relation during XLOG replay<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We need to clean up <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> open &quot;invalid-page&quot; <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> for the dropped pages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L671">&#x200c;</a></span><span class="linkable">XLogTruncateRelation</span>(RelFileLocator rlocator, ForkNumber forkNum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber nblocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L166" title="access/transam/xlogutils.c:166">forget_invalid_pages</a>(rlocator, forkNum, nblocks);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine which timeline to read an xlog page from and set the<br/></li>
<li></span><span class="Comment"> * XLogReaderState's currTLI to that timeline ID.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We care about timelines in <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a> when we might be reading xlog<br/></li>
<li></span><span class="Comment"> * generated prior to a promotion, either if we're currently a standby in<br/></li>
<li></span><span class="Comment"> * recovery or if we're a promoted primary reading xlogs generated by the old<br/></li>
<li></span><span class="Comment"> * primary <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> our promotion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * wantPage must be set to the start address of the page to read and<br/></li>
<li></span><span class="Comment"> * wantLength to the amount of the page that will be read, up to<br/></li>
<li></span><span class="Comment"> * XLOG_BLCKSZ. If the amount to be read isn't known, pass XLOG_BLCKSZ.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The currTLI argument should be the system-wide current timeline.<br/></li>
<li></span><span class="Comment"> * Note that this may be different from state-&gt;currTLI, which is the timeline<br/></li>
<li></span><span class="Comment"> * from which the caller is currently reading previous xlog <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We switch to an xlog segment from the new timeline eagerly when on a<br/></li>
<li></span><span class="Comment"> * historical timeline, as soon as we reach the start of the xlog segment<br/></li>
<li></span><span class="Comment"> * containing the timeline switch.&nbsp; The server copied the segment to the new<br/></li>
<li></span><span class="Comment"> * timeline so all the data up to the switch point is the same, but there's no<br/></li>
<li></span><span class="Comment"> * guarantee the old segment will still exist. It may have been deleted or<br/></li>
<li></span><span class="Comment"> * renamed with a .partial suffix so we can't necessarily keep reading from<br/></li>
<li></span><span class="Comment"> * the old TLI even though <a href="timeline.c.html#L572" title="access/transam/timeline.c:572">tliSwitchPoint</a> says it's OK.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can't just check the timeline when we read a page on a different segment<br/></li>
<li></span><span class="Comment"> * to the last page. We could've received a timeline switch from a cascading<br/></li>
<li></span><span class="Comment"> * upstream, so the current segment ends abruptly (possibly getting renamed to<br/></li>
<li></span><span class="Comment"> * .partial) and we have to switch to a new one.&nbsp; Even in the middle of reading<br/></li>
<li></span><span class="Comment"> * a page we could have to <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> the cached page and switch to a new TLI.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Because of this, callers MAY NOT assume that currTLI is the timeline that<br/></li>
<li></span><span class="Comment"> * will be in a page's xlp_tli; the page may begin on an older timeline or we<br/></li>
<li></span><span class="Comment"> * might be reading from historical timeline data on a segment that's been<br/></li>
<li></span><span class="Comment"> * copied to a new timeline.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must also make sure it doesn't read past the current replay<br/></li>
<li></span><span class="Comment"> * position (using <a href="xlogrecovery.c.html#L4539" title="access/transam/xlogrecovery.c:4539">GetXLogReplayRecPtr</a>) if executing in recovery, so it<br/></li>
<li></span><span class="Comment"> * doesn't fail to notice that the current timeline became historical.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L718">&#x200c;</a></span><span class="linkable">XLogReadDetermineTimeline</span>(XLogReaderState *state, XLogRecPtr wantPage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 wantLength, TimeLineID currTLI)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> XLogRecPtr lastReadPage = (state-&gt;seg.ws_segno *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;segcxt.ws_segsize + state-&gt;segoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(wantPage != InvalidXLogRecPtr &amp;&amp; wantPage % XLOG_BLCKSZ == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(wantLength &lt;= XLOG_BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> == <span class="Constant">0</span> || state-&gt;<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> &lt;= XLOG_BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; Assert(currTLI != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the desired page is currently read in and valid, we have nothing to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The caller should've ensured that it didn't previously advance <a href="xlogrecovery.c.html#L232" title="access/transam/xlogrecovery.c:232">readOff</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * past the valid limit of this timeline, so it doesn't matter if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current TLI has since become historical.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lastReadPage == wantPage &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lastReadPage + state-&gt;<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> &gt;= wantPage + <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(wantLength, XLOG_BLCKSZ - <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're reading from the current timeline, it hasn't become historical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and the page we're reading is after the last page read, we can again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just carry on. (Seeking backwards requires a check to make sure the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * older page isn't on a prior timeline).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * currTLI might've become historical since the caller obtained the value,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but the caller is required not to read past the flush limit it saw at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the time it looked up the timeline. There's nothing we can do about it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if <a href="xlog.c.html#L5388" title="access/transam/xlog.c:5388">StartupXLOG</a>() renames it to .partial concurrently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;currTLI == currTLI &amp;&amp; wantPage &gt;= lastReadPage)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;currTLIValidUntil == InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're just reading pages from a previously validated historical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timeline and the timeline we're reading from is valid until the end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the current segment we can just keep reading.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;currTLIValidUntil != InvalidXLogRecPtr &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;currTLI != currTLI &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;currTLI != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((wantPage + wantLength) / state-&gt;segcxt.ws_segsize) &lt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (state-&gt;currTLIValidUntil / state-&gt;segcxt.ws_segsize))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we reach this point we're either looking up a page for random<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * access, the current timeline just became historical, or we're reading<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from a new segment containing a timeline switch. In all cases we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to determine the newest timeline on the segment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's the current timeline we can just keep reading from here unless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we detect a timeline switch that makes the current timeline historical.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's a historical timeline we can read all the segment on the newest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timeline because it contains all the old timelines' data too. So only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one switch check is required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to re-read the timeline history in case it's been changed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by a promotion or replay from a cascaded replica.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *timelineHistory = <a href="timeline.c.html#L76" title="access/transam/timeline.c:76">readTimeLineHistory</a>(currTLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; endOfSegment;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; endOfSegment = ((wantPage / state-&gt;segcxt.ws_segsize) + <span class="Constant">1</span>) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;segcxt.ws_segsize - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(wantPage / state-&gt;segcxt.ws_segsize ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; endOfSegment / state-&gt;segcxt.ws_segsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find the timeline of the last LSN on the segment containing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wantPage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;currTLI = <a href="timeline.c.html#L544" title="access/transam/timeline.c:544">tliOfPointInHistory</a>(endOfSegment, timelineHistory);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;currTLIValidUntil = <a href="timeline.c.html#L572" title="access/transam/timeline.c:572">tliSwitchPoint</a>(state-&gt;currTLI, timelineHistory,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state-&gt;nextTLI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;currTLIValidUntil == InvalidXLogRecPtr ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wantPage + wantLength &lt; state-&gt;currTLIValidUntil);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(timelineHistory);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;switched to timeline </span><span class="Special">%u</span><span class="Constant"> valid until </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;currTLI,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(state-&gt;currTLIValidUntil));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* XLogReaderRoutine-&gt;segment_open callback for local pg_wal files */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L817">&#x200c;</a></span><span class="linkable">wal_segment_open</span>(XLogReaderState *state, XLogSegNo nextSegNo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimeLineID *tli_p)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; tli = *tli_p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLogFilePath(path, tli, nextSegNo, state-&gt;segcxt.ws_segsize);<br/></li>
<li>&nbsp; &nbsp; state-&gt;seg.ws_file = <a href="../../storage/file/fd.c.html#L1087" title="storage/file/fd.c:1087">BasicOpenFile</a>(path, O_RDONLY | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;seg.ws_file &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;requested WAL segment </span><span class="Special">%s</span><span class="Constant"> has already been removed&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* stock XLogReaderRoutine-&gt;segment_close callback */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L842">&#x200c;</a></span><span class="linkable">wal_segment_close</span>(XLogReaderState *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; close(state-&gt;seg.ws_file);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* need to check errno? */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;seg.ws_file = -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * XLogReaderRoutine-&gt;page_read callback for reading local xlog files<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Public because it would likely be very helpful for someone writing another<br/></li>
<li></span><span class="Comment"> * output method outside walsender, e.g. in a bgworker.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">TODO</span><span class="Comment">: The walsender has its own version of this, but it relies on the<br/></li>
<li></span><span class="Comment"> * walsender's latch being set whenever WAL is flushed. No such infrastructure<br/></li>
<li></span><span class="Comment"> * exists for normal backends, so we have to do a check/sleep/<a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> style of<br/></li>
<li></span><span class="Comment"> * loop for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L861">&#x200c;</a></span><span class="linkable">read_local_xlog_page</span>(XLogReaderState *state, XLogRecPtr targetPagePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> reqLen, XLogRecPtr targetRecPtr, <span class="Type">char</span> *cur_page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L885" title="access/transam/xlogutils.c:885">read_local_xlog_page_guts</a>(state, targetPagePtr, reqLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targetRecPtr, cur_page, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Same as <a href="#L861" title="access/transam/xlogutils.c:861">read_local_xlog_page</a> except that it doesn't wait for future WAL<br/></li>
<li></span><span class="Comment"> * to be available.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L873">&#x200c;</a></span><span class="linkable">read_local_xlog_page_no_wait</span>(XLogReaderState *state, XLogRecPtr targetPagePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> reqLen, XLogRecPtr targetRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *cur_page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L885" title="access/transam/xlogutils.c:885">read_local_xlog_page_guts</a>(state, targetPagePtr, reqLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targetRecPtr, cur_page, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Implementation of <a href="#L861" title="access/transam/xlogutils.c:861">read_local_xlog_page</a> and its no wait version.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L885">&#x200c;</a></span><span class="linkable">read_local_xlog_page_guts</span>(XLogReaderState *state, XLogRecPtr targetPagePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> reqLen, XLogRecPtr targetRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> *cur_page, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> wait_for_wal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; read_upto,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loc;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; tli;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count;<br/></li>
<li>&nbsp; &nbsp; WALReadError errinfo;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; currTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; loc = targetPagePtr + reqLen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for xlog to be available if necessary */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine the limit of xlog we can currently read to, and what the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * most recent timeline is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; read_upto = <a href="xlog.c.html#L6455" title="access/transam/xlog.c:6455">GetFlushRecPtr</a>(&amp;currTLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; read_upto = <a href="xlogrecovery.c.html#L4539" title="access/transam/xlogrecovery.c:4539">GetXLogReplayRecPtr</a>(&amp;currTLI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tli = currTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check which timeline to get the record from.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to do it each time through the loop because if we're in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recovery as a cascading standby, the current timeline might've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * become historical. We can't rely on <a href="xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>() because in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a standby configuration like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A =&gt; B =&gt; C<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we're a logical decoding session on C, and B gets promoted, our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * timeline will change while we remain in recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't just keep reading from the old timeline as the last WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * archive in the timeline will get renamed to .partial by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="xlog.c.html#L5388" title="access/transam/xlog.c:5388">StartupXLOG</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If that happens after our caller determined the TLI but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actually read the xlog page, we might still try to read from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * old (<a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> renamed) segment and fail. There's not much we can do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about this, but it can only happen when we're a leaf of a cascading<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * standby whose primary gets promoted while we're decoding, so a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one-off ERROR isn't too bad.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L718" title="access/transam/xlogutils.c:718">XLogReadDetermineTimeline</a>(state, targetPagePtr, reqLen, tli);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;currTLI == currTLI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (loc &lt;= read_upto)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If asked, let's not wait for future WAL. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!wait_for_wal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ReadLocalXLogPageNoWaitPrivate *private_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Inform the caller of <a href="#L873" title="access/transam/xlogutils.c:873">read_local_xlog_page_no_wait</a> that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end of WAL has been reached.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; private_data = (ReadLocalXLogPageNoWaitPrivate *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; private_data-&gt;end_of_wal = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<span class="Constant">1000L</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're on a historical timeline, so limit reading to the switch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point where we moved to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need to <a href="xlog.c.html#L6455" title="access/transam/xlog.c:6455">GetFlushRecPtr</a> or <a href="xlogrecovery.c.html#L4539" title="access/transam/xlogrecovery.c:4539">GetXLogReplayRecPtr</a>. We know<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about the new timeline, so we must've received past the end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; read_upto = state-&gt;currTLIValidUntil;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Setting tli to our wanted record's TLI is slightly wrong; the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page might begin on an older timeline if it contains a timeline<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * switch, since its xlog segment will have been copied from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prior timeline. This is pretty harmless though, as nothing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cares so long as the timeline doesn't go backwards.&nbsp; We should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * read the page header instead; </span><span class="Todo">FIXME</span><span class="Comment"> someday.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tli = state-&gt;currTLI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No need to wait on a historical timeline */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (targetPagePtr + XLOG_BLCKSZ &lt;= read_upto)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more than one block available; read only that block, have caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * come back if they need more.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; count = XLOG_BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (targetPagePtr + reqLen &gt; read_upto)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not enough data there */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* enough bytes available to satisfy the request */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; count = read_upto - targetPagePtr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="xlogreader.c.html#L1503" title="access/transam/xlogreader.c:1503">WALRead</a>(state, cur_page, targetPagePtr, count, tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;errinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1020" title="access/transam/xlogutils.c:1020">WALReadRaiseError</a>(&amp;errinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* number of valid bytes in the buffer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> count;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../postmaster/postmaster.c.html#L177" title="postmaster/postmaster.c:177">Backend</a>-specific convenience code to handle read errors encountered by<br/></li>
<li></span><span class="Comment"> * <a href="xlogreader.c.html#L1503" title="access/transam/xlogreader.c:1503">WALRead</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1020">&#x200c;</a></span><span class="linkable">WALReadRaiseError</span>(WALReadError *errinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; WALOpenSegment *seg = &amp;errinfo-&gt;wre_seg;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; fname[MAXFNAMELEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLogFileName(fname, seg-&gt;ws_tli, seg-&gt;ws_segno, <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errinfo-&gt;wre_read &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = errinfo-&gt;wre_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read from WAL segment </span><span class="Special">%s</span><span class="Constant">, offset </span><span class="Special">%d</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fname, errinfo-&gt;wre_off)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (errinfo-&gt;wre_read == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read from WAL segment </span><span class="Special">%s</span><span class="Constant">, offset </span><span class="Special">%d</span><span class="Constant">: read </span><span class="Special">%d</span><span class="Constant"> of </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fname, errinfo-&gt;wre_off, errinfo-&gt;wre_read,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errinfo-&gt;wre_req)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
