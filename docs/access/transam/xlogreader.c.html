<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/transam/xlogreader.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/transam/xlogreader.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1662">DecodeXLogRecord</a></li>
<li><a href="#L1629">DecodeXLogRecordRequiredSpace</a></li>
<li><a href="#L1000">ReadPageInternal</a></li>
<li><a href="#L1595">ResetDecoder</a></li>
<li><a href="#L2056">RestoreBlockImage</a></li>
<li><a href="#L1193">ValidXLogRecord</a></li>
<li><a href="#L1127">ValidXLogRecordHeader</a></li>
<li><a href="#L207">WALOpenSegmentInit</a></li>
<li><a href="#L1503">WALRead</a></li>
<li><a href="#L231">XLogBeginRead</a></li>
<li><a href="#L528">XLogDecodeNextRecord</a></li>
<li><a href="#L1383">XLogFindNextRecord</a></li>
<li><a href="#L325">XLogNextRecord</a></li>
<li><a href="#L966">XLogReadAhead</a></li>
<li><a href="#L389">XLogReadRecord</a></li>
<li><a href="#L438">XLogReadRecordAlloc</a></li>
<li><a href="#L106">XLogReaderAllocate</a></li>
<li><a href="#L161">XLogReaderFree</a></li>
<li><a href="#L1113">XLogReaderInvalReadState</a></li>
<li><a href="#L1365">XLogReaderResetError</a></li>
<li><a href="#L90">XLogReaderSetDecodeBuffer</a></li>
<li><a href="#L1224">XLogReaderValidatePageHeader</a></li>
<li><a href="#L2025">XLogRecGetBlockData</a></li>
<li><a href="#L1971">XLogRecGetBlockTag</a></li>
<li><a href="#L1997">XLogRecGetBlockTagExtended</a></li>
<li><a href="#L2167">XLogRecGetFullXid</a></li>
<li><a href="#L249">XLogReleasePreviousRecord</a></li>
<li><a href="#L190">allocate_recordbuf</a></li>
<li><a href="#L71">report_invalid_record</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L1671">COPY_HEADER_FIELD</a></li>
<li><a href="#L64">DEFAULT_DECODE_BUFFER_SIZE</a></li>
<li><a href="#L58">MAX_ERRORMSG_LEN</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Generic XLog reading facility<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 2013-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; src/backend/access/transam/<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; See <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>.h for more notes on this facility.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This file is compiled as both front-end and backend code, so it<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; may not use ereport, server-defined static variables, etc.<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#ifdef USE_LZ4<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;lz4.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef USE_ZSTD<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;zstd.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogrecord.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_control.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/pg_lzcompress.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/origin.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifndef FRONTEND<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/logging.h&quot;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(XLogReaderState *state, <span class="Type">const</span> <span class="Type">char</span> *fmt,...)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_attribute_printf(<span class="Constant">2</span>, <span class="Constant">3</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L190" title="access/transam/xlogreader.c:190">allocate_recordbuf</a>(XLogReaderState *state, uint32 reclength);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1000" title="access/transam/xlogreader.c:1000">ReadPageInternal</a>(XLogReaderState *state, XLogRecPtr pageptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> reqLen);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1113" title="access/transam/xlogreader.c:1113">XLogReaderInvalReadState</a>(XLogReaderState *state);<br/></li>
<li><span class="Type">static</span> XLogPageReadResult <a href="#L528" title="access/transam/xlogreader.c:528">XLogDecodeNextRecord</a>(XLogReaderState *state, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nonblocking);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1127" title="access/transam/xlogreader.c:1127">ValidXLogRecordHeader</a>(XLogReaderState *state, XLogRecPtr RecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr PrevRecPtr, XLogRecord *record, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> randAccess);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1193" title="access/transam/xlogreader.c:1193">ValidXLogRecord</a>(XLogReaderState *state, XLogRecord *record,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr recptr);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1595" title="access/transam/xlogreader.c:1595">ResetDecoder</a>(XLogReaderState *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L207" title="access/transam/xlogreader.c:207">WALOpenSegmentInit</a>(WALOpenSegment *seg, WALSegmentContext *segcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> segsize, <span class="Type">const</span> <span class="Type">char</span> *waldir);<br/></li>
<li><br/></li>
<li><span class="Comment">/* size of the buffer allocated for error message. */<br/></li>
<li><a id="L58">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_ERRORMSG_LEN</span> </span><span class="Constant">1000<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Default size; large enough that typical users of XLogReader won't often need<br/></li>
<li></span><span class="Comment"> * to use the 'oversized' memory allocation code path.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L64">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DEFAULT_DECODE_BUFFER_SIZE</span> (</span><span class="Constant">64</span><span class="PreProc"> * </span><span class="Constant">1024</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Construct a string in state-&gt;errormsg_buf explaining what's wrong with<br/></li>
<li></span><span class="Comment"> * the current record being read.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="linkable">report_invalid_record</span>(XLogReaderState *state, <span class="Type">const</span> <span class="Type">char</span> *fmt,...)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">va_list</span>&nbsp; &nbsp; &nbsp; &nbsp; args;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fmt = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(fmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; va_start(args, fmt);<br/></li>
<li>&nbsp; &nbsp; vsnprintf(state-&gt;errormsg_buf, <a href="#L58" title="access/transam/xlogreader.c:58">MAX_ERRORMSG_LEN</a>, fmt, args);<br/></li>
<li>&nbsp; &nbsp; va_end(args);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;errormsg_deferred = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set the size of the decoding buffer.&nbsp; A pointer to a caller supplied memory<br/></li>
<li></span><span class="Comment"> * region may also be passed in, in which case non-oversized <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> will be<br/></li>
<li></span><span class="Comment"> * decoded there.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L90">&#x200c;</a></span><span class="linkable">XLogReaderSetDecodeBuffer</span>(XLogReaderState *state, <span class="Type">void</span> *buffer, <span class="Type">size_t</span> size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;decode_buffer == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;decode_buffer = buffer;<br/></li>
<li>&nbsp; &nbsp; state-&gt;decode_buffer_size = size;<br/></li>
<li>&nbsp; &nbsp; state-&gt;decode_buffer_tail = buffer;<br/></li>
<li>&nbsp; &nbsp; state-&gt;decode_buffer_head = buffer;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a new XLogReader.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns NULL if the <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a> couldn't be allocated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogReaderState *<br/></li>
<li><a id="L106">&#x200c;</a><span class="linkable">XLogReaderAllocate</span>(<span class="Type">int</span> <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>, <span class="Type">const</span> <span class="Type">char</span> *waldir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogReaderRoutine *routine, <span class="Type">void</span> *private_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogReaderState *state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = (XLogReaderState *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1367" title="utils/mmgr/mcxt.c:1367">palloc_extended</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(XLogReaderState),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MCXT_ALLOC_NO_OOM | MCXT_ALLOC_ZERO);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!state)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> caller-provided support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;routine = *routine;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Permanently allocate readBuf.&nbsp; We do it this way, rather than just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * making a static array, for two reasons: (1) no need to waste the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * storage in most instantiations of the backend; (2) a static char array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * isn't guaranteed to have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> particular alignment, whereas<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/mmgr/mcxt.c.html#L1367" title="utils/mmgr/mcxt.c:1367">palloc_extended</a>() will provide MAXALIGN'd storage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;readBuf = (<span class="Type">char</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1367" title="utils/mmgr/mcxt.c:1367">palloc_extended</a>(XLOG_BLCKSZ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MCXT_ALLOC_NO_OOM);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;readBuf)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize segment info. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L207" title="access/transam/xlogreader.c:207">WALOpenSegmentInit</a>(&amp;state-&gt;seg, &amp;state-&gt;segcxt, <a href="xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; waldir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* system_identifier initialized to zeroes above */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;private_data = private_data;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ReadRecPtr, EndRecPtr and <a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> initialized to zeroes above */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;errormsg_buf = <a href="../../utils/mmgr/mcxt.c.html#L1367" title="utils/mmgr/mcxt.c:1367">palloc_extended</a>(<a href="#L58" title="access/transam/xlogreader.c:58">MAX_ERRORMSG_LEN</a> + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MCXT_ALLOC_NO_OOM);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;errormsg_buf)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;readBuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; state-&gt;errormsg_buf[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate an initial readRecordBuf of minimal size, which can later be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enlarged if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L190" title="access/transam/xlogreader.c:190">allocate_recordbuf</a>(state, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L161">&#x200c;</a></span><span class="linkable">XLogReaderFree</span>(XLogReaderState *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;seg.ws_file != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;routine.segment_close(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;decode_buffer &amp;&amp; state-&gt;free_decode_buffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;decode_buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;errormsg_buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;readRecordBuf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;readRecordBuf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;readBuf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate readRecordBuf to fit a record of at least the given length.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * readRecordBufSize is set to the new buffer size.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid useless small increases, round its size to a multiple of<br/></li>
<li></span><span class="Comment"> * XLOG_BLCKSZ, and make sure it's at least 5*Max(BLCKSZ, XLOG_BLCKSZ) to start<br/></li>
<li></span><span class="Comment"> * with.&nbsp; (That is enough for all &quot;normal&quot; <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, but very large commit or<br/></li>
<li></span><span class="Comment"> * abort <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> might need more space.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: This routine should *never* be called for xl_tot_len until the header<br/></li>
<li></span><span class="Comment"> * of the record has been fully validated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L190">&#x200c;</a></span><span class="linkable">allocate_recordbuf</span>(XLogReaderState *state, uint32 reclength)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; newSize = reclength;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newSize += XLOG_BLCKSZ - (newSize % XLOG_BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; newSize = Max(newSize, <span class="Constant">5</span> * Max(BLCKSZ, XLOG_BLCKSZ));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;readRecordBuf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;readRecordBuf);<br/></li>
<li>&nbsp; &nbsp; state-&gt;readRecordBuf = (<span class="Type">char</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(newSize);<br/></li>
<li>&nbsp; &nbsp; state-&gt;readRecordBufSize = newSize;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize the passed segment structs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L207">&#x200c;</a></span><span class="linkable">WALOpenSegmentInit</span>(WALOpenSegment *seg, WALSegmentContext *segcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> segsize, <span class="Type">const</span> <span class="Type">char</span> *waldir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; seg-&gt;ws_file = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; seg-&gt;ws_segno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; seg-&gt;ws_tli = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; segcxt-&gt;ws_segsize = segsize;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (waldir)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(segcxt-&gt;ws_dir, MAXPGPATH, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, waldir);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Begin reading WAL at 'RecPtr'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'RecPtr' should point to the beginning of a valid WAL record.&nbsp; Pointing at<br/></li>
<li></span><span class="Comment"> * the beginning of a page is also OK, if there is a new record right after<br/></li>
<li></span><span class="Comment"> * the page header, i.e. not a continuation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This does not make <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> attempt to read the WAL yet, and hence cannot fail.<br/></li>
<li></span><span class="Comment"> * If the starting address is not correct, the first call to <a href="#L389" title="access/transam/xlogreader.c:389">XLogReadRecord</a>()<br/></li>
<li></span><span class="Comment"> * will error out.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L231">&#x200c;</a></span><span class="linkable">XLogBeginRead</span>(XLogReaderState *state, XLogRecPtr RecPtr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!XLogRecPtrIsInvalid(RecPtr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1595" title="access/transam/xlogreader.c:1595">ResetDecoder</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Begin at the passed-in record pointer. */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;EndRecPtr = RecPtr;<br/></li>
<li>&nbsp; &nbsp; state-&gt;NextRecPtr = RecPtr;<br/></li>
<li>&nbsp; &nbsp; state-&gt;ReadRecPtr = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; state-&gt;DecodeRecPtr = InvalidXLogRecPtr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release the last record that was returned by <a href="#L325" title="access/transam/xlogreader.c:325">XLogNextRecord</a>(), if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, to<br/></li>
<li></span><span class="Comment"> * free up space.&nbsp; Returns the LSN past the end of the record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L249">&#x200c;</a><span class="linkable">XLogReleasePreviousRecord</span>(XLogReaderState *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DecodedXLogRecord *record;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; next_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;record)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove it from the decoded record queue.&nbsp; It must be the oldest item<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decoded, decode_queue_head.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; record = state-&gt;record;<br/></li>
<li>&nbsp; &nbsp; next_lsn = record-&gt;next_lsn;<br/></li>
<li>&nbsp; &nbsp; Assert(record == state-&gt;decode_queue_head);<br/></li>
<li>&nbsp; &nbsp; state-&gt;record = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;decode_queue_head = record-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It might also be the newest item decoded, decode_queue_tail. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;decode_queue_tail == record)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;decode_queue_tail = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release the space. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(record-&gt;oversized))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It's not in the decode buffer, so free it to release space. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(record);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It must be the head (oldest) record in the decode buffer. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;decode_buffer_head == (<span class="Type">char</span> *) record);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to update head to point to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> record that is in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decode buffer, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, being careful to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> oversized ones<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (they're not in the decode buffer).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; record = record-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (unlikely(record &amp;&amp; record-&gt;oversized))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record = record-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (record)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust head to release space up to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> record. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;decode_buffer_head = (<span class="Type">char</span> *) record;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise we might as well just reset head and tail to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * start of the buffer space, because we're empty.&nbsp; This means<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll keep overwriting the same piece of memory if we're not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> prefetching.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;decode_buffer_head = state-&gt;decode_buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;decode_buffer_tail = state-&gt;decode_buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> next_lsn;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attempt to read an XLOG record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L231" title="access/transam/xlogreader.c:231">XLogBeginRead</a>() or <a href="#L1383" title="access/transam/xlogreader.c:1383">XLogFindNextRecord</a>() and then <a href="#L966" title="access/transam/xlogreader.c:966">XLogReadAhead</a>() must be<br/></li>
<li></span><span class="Comment"> * called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the first call to <a href="#L325" title="access/transam/xlogreader.c:325">XLogNextRecord</a>().&nbsp; This <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> returns<br/></li>
<li></span><span class="Comment"> * <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> and errors that were put into an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> queue by <a href="#L966" title="access/transam/xlogreader.c:966">XLogReadAhead</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On success, a record is returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned record (or *errormsg) points to an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> buffer that's<br/></li>
<li></span><span class="Comment"> * valid until the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call to <a href="#L325" title="access/transam/xlogreader.c:325">XLogNextRecord</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>DecodedXLogRecord *<br/></li>
<li><a id="L325">&#x200c;</a><span class="linkable">XLogNextRecord</span>(XLogReaderState *state, <span class="Type">char</span> **errormsg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release the last record returned by <a href="#L325" title="access/transam/xlogreader.c:325">XLogNextRecord</a>(). */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L249" title="access/transam/xlogreader.c:249">XLogReleasePreviousRecord</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;decode_queue_head == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *errormsg = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;errormsg_deferred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;errormsg_buf[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *errormsg = state-&gt;errormsg_buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;errormsg_deferred = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * state-&gt;EndRecPtr is expected to have been set by the last call to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L231" title="access/transam/xlogreader.c:231">XLogBeginRead</a>() or <a href="#L325" title="access/transam/xlogreader.c:325">XLogNextRecord</a>(), and is the location of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!XLogRecPtrIsInvalid(state-&gt;EndRecPtr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Record this as the most recent record returned, so that we'll release<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time.&nbsp; This also exposes it to the traditional<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLogRecXXX(<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>) macros, which work with the decoder rather than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the record for historical reasons.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;record = state-&gt;decode_queue_head;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update the pointers to the beginning and one-past-the-end of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record, again for the benefit of historical code that expected the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decoder to track this rather than accessing these fields of the record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;ReadRecPtr = state-&gt;record-&gt;lsn;<br/></li>
<li>&nbsp; &nbsp; state-&gt;EndRecPtr = state-&gt;record-&gt;next_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *errormsg = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state-&gt;record;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attempt to read an XLOG record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L231" title="access/transam/xlogreader.c:231">XLogBeginRead</a>() or <a href="#L1383" title="access/transam/xlogreader.c:1383">XLogFindNextRecord</a>() must be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the first call<br/></li>
<li></span><span class="Comment"> * to <a href="#L389" title="access/transam/xlogreader.c:389">XLogReadRecord</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the page_read callback fails to read the requested data, NULL is<br/></li>
<li></span><span class="Comment"> * returned.&nbsp; The callback is expected to have reported the error; errormsg<br/></li>
<li></span><span class="Comment"> * is set to NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the reading fails for some other reason, NULL is also returned, and<br/></li>
<li></span><span class="Comment"> * *errormsg is set to a string with details of the failure.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned pointer (or *errormsg) points to an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> buffer that's<br/></li>
<li></span><span class="Comment"> * valid until the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call to <a href="#L389" title="access/transam/xlogreader.c:389">XLogReadRecord</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecord *<br/></li>
<li><a id="L389">&#x200c;</a><span class="linkable">XLogReadRecord</span>(XLogReaderState *state, <span class="Type">char</span> **errormsg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DecodedXLogRecord *decoded;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release last returned record, if there is one.&nbsp; We need to do this so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we can check for empty decode queue accurately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L249" title="access/transam/xlogreader.c:249">XLogReleasePreviousRecord</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call <a href="#L966" title="access/transam/xlogreader.c:966">XLogReadAhead</a>() in blocking mode to make sure there is something<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the queue, though we don't use the result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogReaderHasQueuedRecordOrError(state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L966" title="access/transam/xlogreader.c:966">XLogReadAhead</a>(state, <span class="Constant">false</span> <span class="Comment">/* nonblocking */</span> );<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Consume the head record or error. */<br/></li>
<li></span>&nbsp; &nbsp; decoded = <a href="#L325" title="access/transam/xlogreader.c:325">XLogNextRecord</a>(state, errormsg);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (decoded)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This function returns a pointer to the record's header, not the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actual decoded record.&nbsp; The caller will access the decoded record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * through the XLogRecGetXXX() macros, which reach the decoded<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recorded as <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;record == decoded);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> &amp;decoded-&gt;header;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate space for a decoded record.&nbsp; The only member of the returned<br/></li>
<li></span><span class="Comment"> * object that is initialized is the 'oversized' flag, indicating that the<br/></li>
<li></span><span class="Comment"> * decoded record wouldn't fit in the decode buffer and must eventually be<br/></li>
<li></span><span class="Comment"> * freed explicitly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller is responsible for adjusting decode_buffer_tail with the real<br/></li>
<li></span><span class="Comment"> * size after successfully decoding a record into this space.&nbsp; This way, if<br/></li>
<li></span><span class="Comment"> * decoding fails, then there is nothing to undo unless the 'oversized' flag<br/></li>
<li></span><span class="Comment"> * was set and <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>() must be called.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return NULL if there is no space in the decode buffer and allow_oversized<br/></li>
<li></span><span class="Comment"> * is false, or if memory allocation fails for an oversized buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> DecodedXLogRecord *<br/></li>
<li><a id="L438">&#x200c;</a><span class="linkable">XLogReadRecordAlloc</span>(XLogReaderState *state, <span class="Type">size_t</span> xl_tot_len, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allow_oversized)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; required_space = <a href="#L1629" title="access/transam/xlogreader.c:1629">DecodeXLogRecordRequiredSpace</a>(xl_tot_len);<br/></li>
<li>&nbsp; &nbsp; DecodedXLogRecord *decoded = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate a circular decode buffer if we don't have one already. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(state-&gt;decode_buffer == <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;decode_buffer_size == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;decode_buffer_size = <a href="#L64" title="access/transam/xlogreader.c:64">DEFAULT_DECODE_BUFFER_SIZE</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;decode_buffer = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(state-&gt;decode_buffer_size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;decode_buffer_head = state-&gt;decode_buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;decode_buffer_tail = state-&gt;decode_buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;free_decode_buffer = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to allocate space in the circular decode buffer. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;decode_buffer_tail &gt;= state-&gt;decode_buffer_head)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Empty, or tail is to the right of head. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (required_space &lt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;decode_buffer_size -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (state-&gt;decode_buffer_tail - state-&gt;decode_buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*-<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is space between tail and end.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * +-----+--------------------+-----+<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * |&nbsp; &nbsp;&nbsp; |////////////////////|here!|<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * +-----+--------------------+-----+<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; ^&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decoded = (DecodedXLogRecord *) state-&gt;decode_buffer_tail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decoded-&gt;oversized = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> decoded;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (required_space &lt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;decode_buffer_head - state-&gt;decode_buffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*-<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is space between start and head.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * +-----+--------------------+-----+<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * |here!|////////////////////|&nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * +-----+--------------------+-----+<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; ^&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; h&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decoded = (DecodedXLogRecord *) state-&gt;decode_buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decoded-&gt;oversized = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> decoded;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Tail is to the left of head. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (required_space &lt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;decode_buffer_head - state-&gt;decode_buffer_tail)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*-<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is space between tail and head.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * +-----+--------------------+-----+<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * |/////|here!&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |/////|<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * +-----+--------------------+-----+<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; ^&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; t&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; h<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decoded = (DecodedXLogRecord *) state-&gt;decode_buffer_tail;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decoded-&gt;oversized = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> decoded;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Not enough space in the decode buffer.&nbsp; Are we allowed to allocate? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (allow_oversized)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; decoded = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(required_space);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; decoded-&gt;oversized = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> decoded;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> XLogPageReadResult<br/></li>
<li><a id="L528">&#x200c;</a><span class="linkable">XLogDecodeNextRecord</span>(XLogReaderState *state, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nonblocking)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; RecPtr;<br/></li>
<li>&nbsp; &nbsp; XLogRecord *record;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; targetPagePtr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; randAccess;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_len;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; targetRecOff;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; pageHeaderSize;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; assembled;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; gotheader;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogrecovery.c.html#L232" title="access/transam/xlogrecovery.c:232">readOff</a>;<br/></li>
<li>&nbsp; &nbsp; DecodedXLogRecord *decoded;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *errormsg;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not used */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * randAccess indicates whether to verify the previous-record pointer of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the record we're reading.&nbsp; We only do this if we're reading<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sequentially, which is what we initially assume.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; randAccess = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reset error state */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;errormsg_buf[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; decoded = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;<a href="xlogrecovery.c.html#L372" title="access/transam/xlogrecovery.c:372">abortedRecPtr</a> = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; state-&gt;<a href="xlogrecovery.c.html#L373" title="access/transam/xlogrecovery.c:373">missingContrecPtr</a> = InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; RecPtr = state-&gt;NextRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;DecodeRecPtr != InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* read the record after the one we just read */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NextRecPtr is pointing to end+1 of the previous WAL record.&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're at a page boundary, no more <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> can fit on the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page. We must <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over the page header, but we can't do that until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we've read in the page, since the header size is variable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Caller supplied a position to start at.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In this case, NextRecPtr should already be pointing either to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * valid record starting position or alternatively to the beginning of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a page. See the header comments for <a href="#L231" title="access/transam/xlogreader.c:231">XLogBeginRead</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(RecPtr % XLOG_BLCKSZ == <span class="Constant">0</span> || XRecOffIsValid(RecPtr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; randAccess = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">restart</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;nonblocking = nonblocking;<br/></li>
<li>&nbsp; &nbsp; state-&gt;currRecPtr = RecPtr;<br/></li>
<li>&nbsp; &nbsp; assembled = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; targetPagePtr = RecPtr - (RecPtr % XLOG_BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; targetRecOff = RecPtr % XLOG_BLCKSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read the page containing the record into state-&gt;readBuf. Request enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * byte to cover the whole record header, or at least the part of it that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fits on the same page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xlogrecovery.c.html#L232" title="access/transam/xlogrecovery.c:232">readOff</a> = <a href="#L1000" title="access/transam/xlogreader.c:1000">ReadPageInternal</a>(state, targetPagePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(targetRecOff + SizeOfXLogRecord, XLOG_BLCKSZ));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L232" title="access/transam/xlogrecovery.c:232">readOff</a> == XLREAD_WOULDBLOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XLREAD_WOULDBLOCK;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L232" title="access/transam/xlogrecovery.c:232">readOff</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1000" title="access/transam/xlogreader.c:1000">ReadPageInternal</a> always returns at least the page header, so we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * examine it <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pageHeaderSize = XLogPageHeaderSize((XLogPageHeader) state-&gt;readBuf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (targetRecOff == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At page start, so <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over page header.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; RecPtr += pageHeaderSize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targetRecOff = pageHeaderSize;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (targetRecOff &lt; pageHeaderSize)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state, <span class="Constant">&quot;invalid record offset at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">: expected at least </span><span class="Special">%u</span><span class="Constant">, got </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(RecPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageHeaderSize, targetRecOff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((((XLogPageHeader) state-&gt;readBuf)-&gt;xlp_info &amp; XLP_FIRST_IS_CONTRECORD) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targetRecOff == pageHeaderSize)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state, <span class="Constant">&quot;contrecord is requested by </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(RecPtr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L1000" title="access/transam/xlogreader.c:1000">ReadPageInternal</a> has verified the page header */<br/></li>
<li></span>&nbsp; &nbsp; Assert(pageHeaderSize &lt;= <a href="xlogrecovery.c.html#L232" title="access/transam/xlogrecovery.c:232">readOff</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read the record length.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: Even though we use an XLogRecord pointer here, the whole record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * header might not fit on this page. xl_tot_len is the first field of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * struct, so it must be on this page (the <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> are MAXALIGNed), but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cannot access <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other fields until we've verified that we got the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whole header.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; record = (XLogRecord *) (state-&gt;readBuf + RecPtr % XLOG_BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; total_len = record-&gt;xl_tot_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the whole record header is on this page, validate it immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise do just a basic sanity check on xl_tot_len, and validate the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rest of the header after reading it from the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page.&nbsp; The xl_tot_len<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check is necessary here to ensure that we enter the &quot;Need to reassemble<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record&quot; code path below; otherwise we might fail to apply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1127" title="access/transam/xlogreader.c:1127">ValidXLogRecordHeader</a> at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (targetRecOff &lt;= XLOG_BLCKSZ - SizeOfXLogRecord)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1127" title="access/transam/xlogreader.c:1127">ValidXLogRecordHeader</a>(state, RecPtr, state-&gt;DecodeRecPtr, record,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; randAccess))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gotheader = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There may be no <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page if it's too small. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (total_len &lt; SizeOfXLogRecord)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;invalid record length at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">: expected at least </span><span class="Special">%u</span><span class="Constant">, got </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(RecPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (uint32) SizeOfXLogRecord, total_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We'll validate the header once we have the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; gotheader = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> space to decode this record, if we can do so without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calling <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>.&nbsp; If we can't, we'll try again below after we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * validated that total_len isn't garbage bytes from a recycled WAL page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; decoded = <a href="#L438" title="access/transam/xlogreader.c:438">XLogReadRecordAlloc</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span> <span class="Comment">/* allow_oversized */</span> );<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (decoded == <span class="Constant">NULL</span> &amp;&amp; nonblocking)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is no space in the circular decode buffer, and the caller is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only reading ahead.&nbsp; The caller should consume existing <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XLREAD_WOULDBLOCK;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = XLOG_BLCKSZ - RecPtr % XLOG_BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (total_len &gt; len)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need to reassemble record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *contdata;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogPageHeader pageHeader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; gotlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; assembled = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We always have space for a couple of pages, enough to validate a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * boundary-spanning record header.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;readRecordBufSize &gt;= XLOG_BLCKSZ * <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;readRecordBufSize &gt;= len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy the first fragment of the record from the first page. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(state-&gt;readRecordBuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;readBuf + RecPtr % XLOG_BLCKSZ, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = state-&gt;readRecordBuf + len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gotlen = len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Calculate pointer to beginning of <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetPagePtr += XLOG_BLCKSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wait for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page to become available */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogrecovery.c.html#L232" title="access/transam/xlogrecovery.c:232">readOff</a> = <a href="#L1000" title="access/transam/xlogreader.c:1000">ReadPageInternal</a>(state, targetPagePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(total_len - gotlen + SizeOfXLogShortPHD,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLOG_BLCKSZ));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L232" title="access/transam/xlogrecovery.c:232">readOff</a> == XLREAD_WOULDBLOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XLREAD_WOULDBLOCK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L232" title="access/transam/xlogrecovery.c:232">readOff</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(SizeOfXLogShortPHD &lt;= <a href="xlogrecovery.c.html#L232" title="access/transam/xlogrecovery.c:232">readOff</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageHeader = (XLogPageHeader) state-&gt;readBuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we were expecting a continuation record and got an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;overwrite contrecord&quot; flag, that means the continuation record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * was overwritten with a different record.&nbsp; Restart the read by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assuming the address to read is the location where we found<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this flag; but keep track of the LSN of the record we were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reading, for later verification.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pageHeader-&gt;xlp_info &amp; XLP_FIRST_IS_OVERWRITE_CONTRECORD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;overwrittenRecPtr = RecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RecPtr = targetPagePtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> restart;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check that the continuation on <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page looks valid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(pageHeader-&gt;xlp_info &amp; XLP_FIRST_IS_CONTRECORD))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;there is no contrecord flag at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(RecPtr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Cross-check that xlp_rem_len agrees with how much of the record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we expect there to be left.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pageHeader-&gt;xlp_rem_len == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_len != (pageHeader-&gt;xlp_rem_len + gotlen))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;invalid contrecord length </span><span class="Special">%u</span><span class="Constant"> (expected </span><span class="Special">%lld</span><span class="Constant">) at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageHeader-&gt;xlp_rem_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">long</span> <span class="Type">long</span>) total_len) - gotlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(RecPtr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Append the continuation from this page to the buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageHeaderSize = XLogPageHeaderSize(pageHeader);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L232" title="access/transam/xlogrecovery.c:232">readOff</a> &lt; pageHeaderSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogrecovery.c.html#L232" title="access/transam/xlogrecovery.c:232">readOff</a> = <a href="#L1000" title="access/transam/xlogreader.c:1000">ReadPageInternal</a>(state, targetPagePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pageHeaderSize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(pageHeaderSize &lt;= <a href="xlogrecovery.c.html#L232" title="access/transam/xlogrecovery.c:232">readOff</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; contdata = (<span class="Type">char</span> *) state-&gt;readBuf + pageHeaderSize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = XLOG_BLCKSZ - pageHeaderSize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pageHeader-&gt;xlp_rem_len &lt; len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = pageHeader-&gt;xlp_rem_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L232" title="access/transam/xlogrecovery.c:232">readOff</a> &lt; pageHeaderSize + len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogrecovery.c.html#L232" title="access/transam/xlogrecovery.c:232">readOff</a> = <a href="#L1000" title="access/transam/xlogreader.c:1000">ReadPageInternal</a>(state, targetPagePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pageHeaderSize + len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(buffer, (<span class="Type">char</span> *) contdata, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer += len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gotlen += len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we just reassembled the record header, validate it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!gotheader)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record = (XLogRecord *) state-&gt;readRecordBuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1127" title="access/transam/xlogreader.c:1127">ValidXLogRecordHeader</a>(state, RecPtr, state-&gt;DecodeRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; record, randAccess))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gotheader = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We might need a bigger buffer.&nbsp; We have validated the record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * header, in the case that it split over a page boundary.&nbsp; We've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * also cross-checked total_len against xlp_rem_len on the second<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page, and verified xlp_pageaddr on both.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (total_len &gt; state-&gt;readRecordBufSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; save_copy[XLOG_BLCKSZ * <span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Save and restore the data we already had.&nbsp; It can't be more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than two pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(gotlen &lt;= lengthof(save_copy));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(gotlen &lt;= state-&gt;readRecordBufSize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(save_copy, state-&gt;readRecordBuf, gotlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L190" title="access/transam/xlogreader.c:190">allocate_recordbuf</a>(state, total_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(state-&gt;readRecordBuf, save_copy, gotlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer = state-&gt;readRecordBuf + gotlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">while</span> (gotlen &lt; total_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(gotheader);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; record = (XLogRecord *) state-&gt;readRecordBuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1193" title="access/transam/xlogreader.c:1193">ValidXLogRecord</a>(state, record, RecPtr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageHeaderSize = XLogPageHeaderSize((XLogPageHeader) state-&gt;readBuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;DecodeRecPtr = RecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;NextRecPtr = targetPagePtr + pageHeaderSize<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + MAXALIGN(pageHeader-&gt;xlp_rem_len);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wait for the record data to become available */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogrecovery.c.html#L232" title="access/transam/xlogrecovery.c:232">readOff</a> = <a href="#L1000" title="access/transam/xlogreader.c:1000">ReadPageInternal</a>(state, targetPagePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(targetRecOff + total_len, XLOG_BLCKSZ));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L232" title="access/transam/xlogrecovery.c:232">readOff</a> == XLREAD_WOULDBLOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XLREAD_WOULDBLOCK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L232" title="access/transam/xlogrecovery.c:232">readOff</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Record does not cross a page boundary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1193" title="access/transam/xlogreader.c:1193">ValidXLogRecord</a>(state, record, RecPtr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;NextRecPtr = RecPtr + MAXALIGN(total_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;DecodeRecPtr = RecPtr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Special processing if it's an XLOG SWITCH record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (record-&gt;xl_rmid == RM_XLOG_ID &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (record-&gt;xl_info &amp; ~XLR_INFO_MASK) == XLOG_SWITCH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Pretend it extends to end of segment */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;NextRecPtr += state-&gt;segcxt.ws_segsize - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;NextRecPtr -= XLogSegmentOffset(state-&gt;NextRecPtr, state-&gt;segcxt.ws_segsize);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we got here without a DecodedXLogRecord, it means we needed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * validate total_len <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> trusting it, but by <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we've done that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (decoded == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!nonblocking);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; decoded = <a href="#L438" title="access/transam/xlogreader.c:438">XLogReadRecordAlloc</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span> <span class="Comment">/* allow_oversized */</span> );<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocation should always happen under allow_oversized */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(decoded != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1662" title="access/transam/xlogreader.c:1662">DecodeXLogRecord</a>(state, decoded, record, RecPtr, &amp;errormsg))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Record the location of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> record. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; decoded-&gt;next_lsn = state-&gt;NextRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's in the decode buffer, mark the decode buffer space as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * occupied.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!decoded-&gt;oversized)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The new decode buffer head must be MAXALIGNed. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(decoded-&gt;size == MAXALIGN(decoded-&gt;size));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((<span class="Type">char</span> *) decoded == state-&gt;decode_buffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;decode_buffer_tail = state-&gt;decode_buffer + decoded-&gt;size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;decode_buffer_tail += decoded-&gt;size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> it into the queue of decoded <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;decode_queue_tail != decoded);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;decode_queue_tail)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;decode_queue_tail-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = decoded;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;decode_queue_tail = decoded;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;decode_queue_head)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;decode_queue_head = decoded;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XLREAD_SUCCESS;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">err</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (assembled)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We get here when a record that spans multiple pages needs to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assembled, but something went wrong -- perhaps a contrecord piece<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * was lost.&nbsp; If caller is WAL replay, it will know where the aborted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * record was and where to direct followup WAL to be written, marking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> piece with XLP_FIRST_IS_OVERWRITE_CONTRECORD, which will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in turn signal downstream WAL consumers that the broken WAL record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is to be ignored.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;<a href="xlogrecovery.c.html#L372" title="access/transam/xlogrecovery.c:372">abortedRecPtr</a> = RecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;<a href="xlogrecovery.c.html#L373" title="access/transam/xlogrecovery.c:373">missingContrecPtr</a> = targetPagePtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we got here without reporting an error, make sure an error is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * queued so that <a href="xlogprefetcher.c.html#L983" title="access/transam/xlogprefetcher.c:983">XLogPrefetcherReadRecord</a>() doesn't bring us back a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * second time and clobber the above state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;errormsg_deferred = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (decoded &amp;&amp; decoded-&gt;oversized)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(decoded);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Invalidate the read state. We might read from a different source after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * failure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1113" title="access/transam/xlogreader.c:1113">XLogReaderInvalReadState</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If an error was written to errmsg_buf, it'll be returned to the caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of <a href="#L389" title="access/transam/xlogreader.c:389">XLogReadRecord</a>() after all successfully decoded <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> XLREAD_FAIL;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Try to decode the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> available record, and return it.&nbsp; The record will<br/></li>
<li></span><span class="Comment"> * also be returned to <a href="#L325" title="access/transam/xlogreader.c:325">XLogNextRecord</a>(), which must be called to 'consume'<br/></li>
<li></span><span class="Comment"> * each record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If nonblocking is true, may return NULL due to lack of data or WAL decoding<br/></li>
<li></span><span class="Comment"> * space.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>DecodedXLogRecord *<br/></li>
<li><a id="L966">&#x200c;</a><span class="linkable">XLogReadAhead</span>(XLogReaderState *state, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nonblocking)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogPageReadResult result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;errormsg_deferred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L528" title="access/transam/xlogreader.c:528">XLogDecodeNextRecord</a>(state, nonblocking);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result == XLREAD_SUCCESS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;decode_queue_tail != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> state-&gt;decode_queue_tail;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read a single xlog page including at least [pageptr, reqLen] of valid data<br/></li>
<li></span><span class="Comment"> * via the page_read() callback.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns XLREAD_FAIL if the required page cannot be read for some<br/></li>
<li></span><span class="Comment"> * reason; errormsg_buf is set in that case (unless the error occurs in the<br/></li>
<li></span><span class="Comment"> * page_read callback).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns XLREAD_WOULDBLOCK if the requested data can't be read without<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>.&nbsp; This can be returned only if the installed page_read callback<br/></li>
<li></span><span class="Comment"> * respects the state-&gt;nonblocking flag, and cannot read the requested data<br/></li>
<li></span><span class="Comment"> * immediately.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We fetch the page from a reader-local cache if we know we have the required<br/></li>
<li></span><span class="Comment"> * data and if there hasn't been <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error since caching the data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1000">&#x200c;</a></span><span class="linkable">ReadPageInternal</span>(XLogReaderState *state, XLogRecPtr pageptr, <span class="Type">int</span> reqLen)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a>;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; targetPageOff;<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; targetSegNo;<br/></li>
<li>&nbsp; &nbsp; XLogPageHeader hdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert((pageptr % XLOG_BLCKSZ) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLByteToSeg(pageptr, targetSegNo, state-&gt;segcxt.ws_segsize);<br/></li>
<li>&nbsp; &nbsp; targetPageOff = XLogSegmentOffset(pageptr, state-&gt;segcxt.ws_segsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check whether we have all the requested data already */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (targetSegNo == state-&gt;seg.ws_segno &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targetPageOff == state-&gt;segoff &amp;&amp; reqLen &lt;= state-&gt;<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> state-&gt;<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Invalidate contents of <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> buffer <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> read attempt.&nbsp; Just set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the length to 0, rather than a full <a href="#L1113" title="access/transam/xlogreader.c:1113">XLogReaderInvalReadState</a>(), so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't forget the segment we last successfully read.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Data is not in our buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Every time we actually read the segment, even if we looked at parts of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, we need to do verification as the page_read callback might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be rereading data from a different source.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Whenever switching to a new WAL segment, we read the first page of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * file and validate its header, even if that's not where the target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record is.&nbsp; This is so that we can check the additional identification<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * info that is present in the first page's &quot;long&quot; header.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (targetSegNo != state-&gt;seg.ws_segno &amp;&amp; targetPageOff != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; targetSegmentPtr = pageptr - targetPageOff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> = state-&gt;routine.page_read(state, targetSegmentPtr, XLOG_BLCKSZ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;currRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;readBuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> == XLREAD_WOULDBLOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XLREAD_WOULDBLOCK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we can be sure to have enough WAL available, we scrolled back */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> == XLOG_BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1224" title="access/transam/xlogreader.c:1224">XLogReaderValidatePageHeader</a>(state, targetSegmentPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;readBuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, read the requested data length, but at least a short page header<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so that we can validate it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> = state-&gt;routine.page_read(state, pageptr, Max(reqLen, SizeOfXLogShortPHD),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;currRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;readBuf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> == XLREAD_WOULDBLOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XLREAD_WOULDBLOCK;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> &lt;= XLOG_BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do we have enough data to check the header length? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> &lt;= SizeOfXLogShortPHD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> &gt;= reqLen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hdr = (XLogPageHeader) state-&gt;readBuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* still not enough */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> &lt; XLogPageHeaderSize(hdr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> = state-&gt;routine.page_read(state, pageptr, XLogPageHeaderSize(hdr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;currRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;readBuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> == XLREAD_WOULDBLOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> XLREAD_WOULDBLOCK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we know we have the full header, validate it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1224" title="access/transam/xlogreader.c:1224">XLogReaderValidatePageHeader</a>(state, pageptr, (<span class="Type">char</span> *) hdr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update read state information */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;seg.ws_segno = targetSegNo;<br/></li>
<li>&nbsp; &nbsp; state-&gt;segoff = targetPageOff;<br/></li>
<li>&nbsp; &nbsp; state-&gt;<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> = <a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a>;<br/></li>
<li><br/></li>
<li><span class="Statement">err</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1113" title="access/transam/xlogreader.c:1113">XLogReaderInvalReadState</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> XLREAD_FAIL;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Invalidate the <a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>'s read state to force a re-read.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1113">&#x200c;</a></span><span class="linkable">XLogReaderInvalReadState</span>(XLogReaderState *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; state-&gt;seg.ws_segno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;segoff = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Validate an XLOG record header.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is just a convenience subroutine to avoid duplicated code in<br/></li>
<li></span><span class="Comment"> * <a href="#L389" title="access/transam/xlogreader.c:389">XLogReadRecord</a>.&nbsp; It's not intended for use from anywhere else.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1127">&#x200c;</a></span><span class="linkable">ValidXLogRecordHeader</span>(XLogReaderState *state, XLogRecPtr RecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr PrevRecPtr, XLogRecord *record,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> randAccess)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (record-&gt;xl_tot_len &lt; SizeOfXLogRecord)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;invalid record length at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">: expected at least </span><span class="Special">%u</span><span class="Constant">, got </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(RecPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (uint32) SizeOfXLogRecord, record-&gt;xl_tot_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!RmgrIdIsValid(record-&gt;xl_rmid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;invalid resource manager ID </span><span class="Special">%u</span><span class="Constant"> at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record-&gt;xl_rmid, LSN_FORMAT_ARGS(RecPtr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (randAccess)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't exactly verify the prev-link, but surely it should be less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than the record's own address.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(record-&gt;xl_prev &lt; RecPtr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;record with incorrect prev-link </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(record-&gt;xl_prev),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(RecPtr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Record's prev-link should exactly match our previous location. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check guards against torn WAL pages where a stale but valid-looking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL record starts on a sector boundary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (record-&gt;xl_prev != PrevRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;record with incorrect prev-link </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(record-&gt;xl_prev),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(RecPtr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * CRC-check an XLOG record.&nbsp; We do not believe the contents of an XLOG<br/></li>
<li></span><span class="Comment"> * record (other than to the minimal extent of computing the amount of<br/></li>
<li></span><span class="Comment"> * data to read in) until we've checked the CRCs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume all of the record (that is, xl_tot_len bytes) has been read<br/></li>
<li></span><span class="Comment"> * into memory at *record.&nbsp; Also, <a href="#L1127" title="access/transam/xlogreader.c:1127">ValidXLogRecordHeader</a>() has accepted the<br/></li>
<li></span><span class="Comment"> * record's header, which means in particular that xl_tot_len is at least<br/></li>
<li></span><span class="Comment"> * SizeOfXLogRecord.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1193">&#x200c;</a></span><span class="linkable">ValidXLogRecord</span>(XLogReaderState *state, XLogRecord *record, XLogRecPtr recptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_crc32c&nbsp; &nbsp; crc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(record-&gt;xl_tot_len &gt;= SizeOfXLogRecord);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Calculate the CRC */<br/></li>
<li></span>&nbsp; &nbsp; INIT_CRC32C(crc);<br/></li>
<li>&nbsp; &nbsp; COMP_CRC32C(crc, ((<span class="Type">char</span> *) record) + SizeOfXLogRecord, record-&gt;xl_tot_len - SizeOfXLogRecord);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* include the record header last */<br/></li>
<li></span>&nbsp; &nbsp; COMP_CRC32C(crc, (<span class="Type">char</span> *) record, offsetof(XLogRecord, xl_crc));<br/></li>
<li>&nbsp; &nbsp; FIN_CRC32C(crc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!EQ_CRC32C(record-&gt;xl_crc, crc))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;incorrect resource manager data checksum in record at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(recptr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Validate a page header.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check if 'phdr' is valid as the header of the XLog page at position<br/></li>
<li></span><span class="Comment"> * 'recptr'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1224">&#x200c;</a></span><span class="linkable">XLogReaderValidatePageHeader</span>(XLogReaderState *state, XLogRecPtr recptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> *phdr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; segno;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; offset;<br/></li>
<li>&nbsp; &nbsp; XLogPageHeader hdr = (XLogPageHeader) phdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert((recptr % XLOG_BLCKSZ) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLByteToSeg(recptr, segno, state-&gt;segcxt.ws_segsize);<br/></li>
<li>&nbsp; &nbsp; offset = XLogSegmentOffset(recptr, state-&gt;segcxt.ws_segsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hdr-&gt;xlp_magic != XLOG_PAGE_MAGIC)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; fname[MAXFNAMELEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(fname, state-&gt;seg.ws_tli, segno, state-&gt;segcxt.ws_segsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;invalid magic number </span><span class="Special">%04X</span><span class="Constant"> in WAL segment </span><span class="Special">%s</span><span class="Constant">, LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, offset </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdr-&gt;xlp_magic,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(recptr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((hdr-&gt;xlp_info &amp; ~XLP_ALL_FLAGS) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; fname[MAXFNAMELEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(fname, state-&gt;seg.ws_tli, segno, state-&gt;segcxt.ws_segsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;invalid info bits </span><span class="Special">%04X</span><span class="Constant"> in WAL segment </span><span class="Special">%s</span><span class="Constant">, LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, offset </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdr-&gt;xlp_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(recptr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hdr-&gt;xlp_info &amp; XLP_LONG_HEADER)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogLongPageHeader longhdr = (XLogLongPageHeader) hdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;system_identifier &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; longhdr-&gt;xlp_sysid != state-&gt;system_identifier)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;WAL file is from different database system: WAL file database system identifier is </span><span class="Special">%llu</span><span class="Constant">, pg_control database system identifier is </span><span class="Special">%llu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">long</span>) longhdr-&gt;xlp_sysid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">long</span>) state-&gt;system_identifier);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (longhdr-&gt;xlp_seg_size != state-&gt;segcxt.ws_segsize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;WAL file is from different database system: incorrect segment size in page header&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (longhdr-&gt;xlp_xlog_blcksz != XLOG_BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;WAL file is from different database system: incorrect XLOG_BLCKSZ in page header&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (offset == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; fname[MAXFNAMELEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(fname, state-&gt;seg.ws_tli, segno, state-&gt;segcxt.ws_segsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* hmm, first page of file doesn't have a long header? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;invalid info bits </span><span class="Special">%04X</span><span class="Constant"> in WAL segment </span><span class="Special">%s</span><span class="Constant">, LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, offset </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdr-&gt;xlp_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(recptr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that the address on the page agrees with what we expected. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check typically fails when an old WAL segment is recycled, and hasn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * yet been overwritten with new data yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hdr-&gt;xlp_pageaddr != recptr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; fname[MAXFNAMELEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(fname, state-&gt;seg.ws_tli, segno, state-&gt;segcxt.ws_segsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;unexpected pageaddr </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> in WAL segment </span><span class="Special">%s</span><span class="Constant">, LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, offset </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(hdr-&gt;xlp_pageaddr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(recptr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since child timelines are always assigned a TLI greater than their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediate parent's TLI, we should never see TLI go backwards across<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * successive pages of a consistent WAL sequence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sometimes we re-read a segment that's already been (partially) read. So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we only verify TLIs for pages that are later than the last remembered<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LSN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (recptr &gt; state-&gt;latestPagePtr)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hdr-&gt;xlp_tli &lt; state-&gt;latestPageTLI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; fname[MAXFNAMELEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogFileName(fname, state-&gt;seg.ws_tli, segno, state-&gt;segcxt.ws_segsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;out-of-sequence timeline ID </span><span class="Special">%u</span><span class="Constant"> (after </span><span class="Special">%u</span><span class="Constant">) in WAL segment </span><span class="Special">%s</span><span class="Constant">, LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, offset </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hdr-&gt;xlp_tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;latestPageTLI,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(recptr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; state-&gt;latestPagePtr = recptr;<br/></li>
<li>&nbsp; &nbsp; state-&gt;latestPageTLI = hdr-&gt;xlp_tli;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Forget about an error produced by <a href="#L1224" title="access/transam/xlogreader.c:1224">XLogReaderValidatePageHeader</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1365">&#x200c;</a></span><span class="linkable">XLogReaderResetError</span>(XLogReaderState *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; state-&gt;errormsg_buf[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;errormsg_deferred = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find the first record with an lsn &gt;= RecPtr.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is different from <a href="#L231" title="access/transam/xlogreader.c:231">XLogBeginRead</a>() in that RecPtr doesn't need to point<br/></li>
<li></span><span class="Comment"> * to a valid record boundary.&nbsp; Useful for checking whether RecPtr is a valid<br/></li>
<li></span><span class="Comment"> * xlog address for reading, and to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the first valid address after some<br/></li>
<li></span><span class="Comment"> * address when dumping <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> for debugging purposes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This positions the reader, like <a href="#L231" title="access/transam/xlogreader.c:231">XLogBeginRead</a>(), so that the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call to<br/></li>
<li></span><span class="Comment"> * <a href="#L389" title="access/transam/xlogreader.c:389">XLogReadRecord</a>() will read the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> valid record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L1383">&#x200c;</a><span class="linkable">XLogFindNextRecord</span>(XLogReaderState *state, XLogRecPtr RecPtr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; tmpRecPtr;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; found = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; XLogPageHeader header;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *errormsg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!XLogRecPtrIsInvalid(RecPtr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure <a href="#L1000" title="access/transam/xlogreader.c:1000">ReadPageInternal</a>() can't return XLREAD_WOULDBLOCK. */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;nonblocking = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over potential continuation data, keeping in mind that it may span<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multiple pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tmpRecPtr = RecPtr;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; targetPagePtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetRecOff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; pageHeaderSize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compute targetRecOff. It should typically be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> or greater than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * short page-header since a valid record can't start anywhere <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that, except when caller has explicitly specified the offset that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * falls somewhere there or when we are skipping multi-page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * continuation record. It doesn't matter though because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1000" title="access/transam/xlogreader.c:1000">ReadPageInternal</a>() is prepared to handle that and will read at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * least short page-header worth of data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; targetRecOff = tmpRecPtr % XLOG_BLCKSZ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* scroll back to page boundary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; targetPagePtr = tmpRecPtr - targetRecOff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Read the page containing the record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> = <a href="#L1000" title="access/transam/xlogreader.c:1000">ReadPageInternal</a>(state, targetPagePtr, targetRecOff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; header = (XLogPageHeader) state-&gt;readBuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageHeaderSize = XLogPageHeaderSize(header);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure we have enough data for the page header */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> = <a href="#L1000" title="access/transam/xlogreader.c:1000">ReadPageInternal</a>(state, targetPagePtr, pageHeaderSize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="xlogrecovery.c.html#L233" title="access/transam/xlogrecovery.c:233">readLen</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over potential continuation data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (header-&gt;xlp_info &amp; XLP_FIRST_IS_CONTRECORD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the length of the remaining continuation data is more than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * what can fit in this page, the continuation record crosses over<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this page. Read the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page and try again. xlp_rem_len in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page header will contain the remaining length of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * continuation data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that record headers are MAXALIGN'ed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (MAXALIGN(header-&gt;xlp_rem_len) &gt;= (XLOG_BLCKSZ - pageHeaderSize))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmpRecPtr = targetPagePtr + XLOG_BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The previous continuation record ends in this page. Set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tmpRecPtr to point to the first valid record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmpRecPtr = targetPagePtr + pageHeaderSize<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + MAXALIGN(header-&gt;xlp_rem_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmpRecPtr = targetPagePtr + pageHeaderSize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we know <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that tmpRecPtr is an address pointing to a valid XLogRecord<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because either we're at the first record after the beginning of a page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or we just jumped over the remaining data of a continuation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L231" title="access/transam/xlogreader.c:231">XLogBeginRead</a>(state, tmpRecPtr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L389" title="access/transam/xlogreader.c:389">XLogReadRecord</a>(state, &amp;errormsg) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* past the record we've found, break out */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RecPtr &lt;= state-&gt;ReadRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Rewind the reader to the beginning of the last record. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = state-&gt;ReadRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L231" title="access/transam/xlogreader.c:231">XLogBeginRead</a>(state, found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> found;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">err</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1113" title="access/transam/xlogreader.c:1113">XLogReaderInvalReadState</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidXLogRecPtr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function to ease writing of XLogReaderRoutine-&gt;page_read callbacks.<br/></li>
<li></span><span class="Comment"> * If this function is used, caller must supply a segment_open callback in<br/></li>
<li></span><span class="Comment"> * 'state', as that is used here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Read 'count' bytes into 'buf', starting at location 'startptr', from WAL<br/></li>
<li></span><span class="Comment"> * fetched from timeline 'tli'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if succeeded, false if an error occurs, in which case<br/></li>
<li></span><span class="Comment"> * 'errinfo' receives error details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1503">&#x200c;</a></span><span class="linkable">WALRead</span>(XLogReaderState *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> *buf, XLogRecPtr startptr, Size count, TimeLineID tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WALReadError *errinfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *p;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; p = buf;<br/></li>
<li>&nbsp; &nbsp; recptr = startptr;<br/></li>
<li>&nbsp; &nbsp; nbytes = count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (nbytes &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; startoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; readbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startoff = XLogSegmentOffset(recptr, state-&gt;segcxt.ws_segsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the data we want is not in a segment we have open, close what we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have (if anything) and open the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one, using the caller's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * provided segment_open callback.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;seg.ws_file &lt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !XLByteInSeg(recptr, state-&gt;seg.ws_segno, state-&gt;segcxt.ws_segsize) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tli != state-&gt;seg.ws_tli)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; nextSegNo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;seg.ws_file &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;routine.segment_close(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLByteToSeg(recptr, nextSegNo, state-&gt;segcxt.ws_segsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;routine.segment_open(state, nextSegNo, &amp;tli);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This shouldn't happen -- indicates a bug in segment_open */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;seg.ws_file &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update the current segment info. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;seg.ws_tli = tli;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;seg.ws_segno = nextSegNo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* How many bytes are within this segment? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nbytes &gt; (state-&gt;segcxt.ws_segsize - startoff))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segbytes = state-&gt;segcxt.ws_segsize - startoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segbytes = nbytes;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef FRONTEND<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_WAL_READ);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset errno first; eases reporting non-errno-affecting errors */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; readbytes = pg_pread(state-&gt;seg.ws_file, p, segbytes, (<span class="Type">off_t</span>) startoff);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef FRONTEND<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readbytes &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errinfo-&gt;wre_errno = errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errinfo-&gt;wre_req = segbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errinfo-&gt;wre_read = readbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errinfo-&gt;wre_off = startoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errinfo-&gt;wre_seg = state-&gt;seg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update state for read */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; recptr += readbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbytes -= readbytes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; p += readbytes;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------<br/></li>
<li></span><span class="Comment"> * Functions for decoding the data and block references in a record.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Private function to reset the state, forgetting all decoded <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, if we<br/></li>
<li></span><span class="Comment"> * are asked to move to a new read position.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1595">&#x200c;</a></span><span class="linkable">ResetDecoder</span>(XLogReaderState *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DecodedXLogRecord *r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset the decoded record queue, freeing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> oversized <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> ((r = state-&gt;decode_queue_head) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;decode_queue_head = r-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (r-&gt;oversized)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(r);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; state-&gt;decode_queue_tail = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;decode_queue_head = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;record = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset the decode buffer to empty. */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;decode_buffer_tail = state-&gt;decode_buffer;<br/></li>
<li>&nbsp; &nbsp; state-&gt;decode_buffer_head = state-&gt;decode_buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clear error state. */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;errormsg_buf[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;errormsg_deferred = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the maximum possible amount of padding that could be required to<br/></li>
<li></span><span class="Comment"> * decode a record, given xl_tot_len from the record's header.&nbsp; This is the<br/></li>
<li></span><span class="Comment"> * amount of output buffer space that we need to decode a record, though we<br/></li>
<li></span><span class="Comment"> * might not finish up using it all.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This computation is pessimistic and assumes the maximum possible number of<br/></li>
<li></span><span class="Comment"> * blocks, due to lack of better information.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">size_t<br/></li>
<li><a id="L1629">&#x200c;</a></span><span class="linkable">DecodeXLogRecordRequiredSpace</span>(<span class="Type">size_t</span> xl_tot_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; size = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Account for the fixed size part of the decoded record struct. */<br/></li>
<li></span>&nbsp; &nbsp; size += offsetof(DecodedXLogRecord, blocks[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Account for the flexible blocks array of maximum possible size. */<br/></li>
<li></span>&nbsp; &nbsp; size += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(DecodedBkpBlock) * (XLR_MAX_BLOCK_ID + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Account for all the raw <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> and block data. */<br/></li>
<li></span>&nbsp; &nbsp; size += xl_tot_len;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We might insert padding <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> main_data. */<br/></li>
<li></span>&nbsp; &nbsp; size += (MAXIMUM_ALIGNOF - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We might insert padding <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> each block's data. */<br/></li>
<li></span>&nbsp; &nbsp; size += (MAXIMUM_ALIGNOF - <span class="Constant">1</span>) * (XLR_MAX_BLOCK_ID + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We might insert padding at the end. */<br/></li>
<li></span>&nbsp; &nbsp; size += (MAXIMUM_ALIGNOF - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Decode a record.&nbsp; &quot;decoded&quot; must point to a MAXALIGNed memory area that has<br/></li>
<li></span><span class="Comment"> * space for at least <a href="#L1629" title="access/transam/xlogreader.c:1629">DecodeXLogRecordRequiredSpace</a>(record) bytes.&nbsp; On<br/></li>
<li></span><span class="Comment"> * success, decoded-&gt;size contains the actual space occupied by the decoded<br/></li>
<li></span><span class="Comment"> * record, which may turn out to be less.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Only decoded-&gt;oversized member must be initialized already, and will not be<br/></li>
<li></span><span class="Comment"> * modified.&nbsp; Other members will be initialized as required.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On error, a human-readable error message is returned in *errormsg, and<br/></li>
<li></span><span class="Comment"> * the return value is false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1662">&#x200c;</a></span><span class="linkable">DecodeXLogRecord</span>(XLogReaderState *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DecodedXLogRecord *decoded,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecord *record,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> **errormsg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> _size bytes from record buffer, but check for overrun first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li><a id="L1671">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">COPY_HEADER_FIELD</span>(_dst, _size)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; </span><span class="Statement">do</span><span class="PreProc"> {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="PreProc"> (remaining &lt; _size)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">goto</span><span class="PreProc"> shortdata_err;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; memcpy(_dst, ptr, _size);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; ptr += _size;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; remaining -= _size;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; } </span><span class="Statement">while</span><span class="PreProc">(</span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *out;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; remaining;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; datatotal;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator *rlocator = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; block_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; decoded-&gt;header = *record;<br/></li>
<li>&nbsp; &nbsp; decoded-&gt;lsn = lsn;<br/></li>
<li>&nbsp; &nbsp; decoded-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; decoded-&gt;record_origin = InvalidRepOriginId;<br/></li>
<li>&nbsp; &nbsp; decoded-&gt;toplevel_xid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; decoded-&gt;main_data = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; decoded-&gt;main_data_len = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; decoded-&gt;max_block_id = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; ptr = (<span class="Type">char</span> *) record;<br/></li>
<li>&nbsp; &nbsp; ptr += SizeOfXLogRecord;<br/></li>
<li>&nbsp; &nbsp; remaining = record-&gt;xl_tot_len - SizeOfXLogRecord;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Decode the headers */<br/></li>
<li></span>&nbsp; &nbsp; datatotal = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (remaining &gt; datatotal)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1671" title="access/transam/xlogreader.c:1671">COPY_HEADER_FIELD</a>(&amp;block_id, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint8));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block_id == XLR_BLOCK_ID_DATA_SHORT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* XLogRecordDataHeaderShort */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; main_data_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1671" title="access/transam/xlogreader.c:1671">COPY_HEADER_FIELD</a>(&amp;main_data_len, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint8));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decoded-&gt;main_data_len = main_data_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datatotal += main_data_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* by convention, the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> data fragment is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * always last */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (block_id == XLR_BLOCK_ID_DATA_LONG)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* XLogRecordDataHeaderLong */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; main_data_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1671" title="access/transam/xlogreader.c:1671">COPY_HEADER_FIELD</a>(&amp;main_data_len, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decoded-&gt;main_data_len = main_data_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datatotal += main_data_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* by convention, the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> data fragment is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * always last */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (block_id == XLR_BLOCK_ID_ORIGIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1671" title="access/transam/xlogreader.c:1671">COPY_HEADER_FIELD</a>(&amp;decoded-&gt;record_origin, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RepOriginId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (block_id == XLR_BLOCK_ID_TOPLEVEL_XID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1671" title="access/transam/xlogreader.c:1671">COPY_HEADER_FIELD</a>(&amp;decoded-&gt;toplevel_xid, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (block_id &lt;= XLR_MAX_BLOCK_ID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* XLogRecordBlockHeader */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DecodedBkpBlock *blk;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; fork_flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> intervening block IDs as not in use */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = decoded-&gt;max_block_id + <span class="Constant">1</span>; i &lt; block_id; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decoded-&gt;blocks[i].in_use = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block_id &lt;= decoded-&gt;max_block_id)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;out-of-order block_id </span><span class="Special">%u</span><span class="Constant"> at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(state-&gt;ReadRecPtr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decoded-&gt;max_block_id = block_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk = &amp;decoded-&gt;blocks[block_id];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk-&gt;in_use = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk-&gt;apply_image = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1671" title="access/transam/xlogreader.c:1671">COPY_HEADER_FIELD</a>(&amp;fork_flags, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint8));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk-&gt;forknum = fork_flags &amp; BKPBLOCK_FORK_MASK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk-&gt;flags = fork_flags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk-&gt;has_image = ((fork_flags &amp; BKPBLOCK_HAS_IMAGE) != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk-&gt;has_data = ((fork_flags &amp; BKPBLOCK_HAS_DATA) != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk-&gt;prefetch_buffer = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1671" title="access/transam/xlogreader.c:1671">COPY_HEADER_FIELD</a>(&amp;blk-&gt;data_len, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cross-check that the HAS_DATA flag is set iff data_length &gt; 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blk-&gt;has_data &amp;&amp; blk-&gt;data_len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;BKPBLOCK_HAS_DATA set, but no data included at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(state-&gt;ReadRecPtr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!blk-&gt;has_data &amp;&amp; blk-&gt;data_len != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;BKPBLOCK_HAS_DATA not set, but data length is </span><span class="Special">%u</span><span class="Constant"> at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) blk-&gt;data_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(state-&gt;ReadRecPtr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datatotal += blk-&gt;data_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blk-&gt;has_image)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1671" title="access/transam/xlogreader.c:1671">COPY_HEADER_FIELD</a>(&amp;blk-&gt;bimg_len, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1671" title="access/transam/xlogreader.c:1671">COPY_HEADER_FIELD</a>(&amp;blk-&gt;hole_offset, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1671" title="access/transam/xlogreader.c:1671">COPY_HEADER_FIELD</a>(&amp;blk-&gt;bimg_info, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint8));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk-&gt;apply_image = ((blk-&gt;bimg_info &amp; BKPIMAGE_APPLY) != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BKPIMAGE_COMPRESSED(blk-&gt;bimg_info))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blk-&gt;bimg_info &amp; BKPIMAGE_HAS_HOLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1671" title="access/transam/xlogreader.c:1671">COPY_HEADER_FIELD</a>(&amp;blk-&gt;hole_length, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk-&gt;hole_length = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk-&gt;hole_length = BLCKSZ - blk-&gt;bimg_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datatotal += blk-&gt;bimg_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cross-check that hole_offset &gt; 0, hole_length &gt; 0 and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bimg_len &lt; BLCKSZ if the HAS_HOLE flag is set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((blk-&gt;bimg_info &amp; BKPIMAGE_HAS_HOLE) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (blk-&gt;hole_offset == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blk-&gt;hole_length == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blk-&gt;bimg_len == BLCKSZ))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;BKPIMAGE_HAS_HOLE set, but hole offset </span><span class="Special">%u</span><span class="Constant"> length </span><span class="Special">%u</span><span class="Constant"> block image length </span><span class="Special">%u</span><span class="Constant"> at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) blk-&gt;hole_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) blk-&gt;hole_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) blk-&gt;bimg_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(state-&gt;ReadRecPtr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cross-check that hole_offset == 0 and hole_length == 0 if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the HAS_HOLE flag is not set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(blk-&gt;bimg_info &amp; BKPIMAGE_HAS_HOLE) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (blk-&gt;hole_offset != <span class="Constant">0</span> || blk-&gt;hole_length != <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;BKPIMAGE_HAS_HOLE not set, but hole offset </span><span class="Special">%u</span><span class="Constant"> length </span><span class="Special">%u</span><span class="Constant"> at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) blk-&gt;hole_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) blk-&gt;hole_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(state-&gt;ReadRecPtr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Cross-check that bimg_len &lt; BLCKSZ if it is compressed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BKPIMAGE_COMPRESSED(blk-&gt;bimg_info) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk-&gt;bimg_len == BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;BKPIMAGE_COMPRESSED set, but block image length </span><span class="Special">%u</span><span class="Constant"> at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) blk-&gt;bimg_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(state-&gt;ReadRecPtr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cross-check that bimg_len = BLCKSZ if neither HAS_HOLE is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set nor COMPRESSED().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(blk-&gt;bimg_info &amp; BKPIMAGE_HAS_HOLE) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !BKPIMAGE_COMPRESSED(blk-&gt;bimg_info) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk-&gt;bimg_len != BLCKSZ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;neither BKPIMAGE_HAS_HOLE nor BKPIMAGE_COMPRESSED set, but block image length is </span><span class="Special">%u</span><span class="Constant"> at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) blk-&gt;data_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(state-&gt;ReadRecPtr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(fork_flags &amp; BKPBLOCK_SAME_REL))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1671" title="access/transam/xlogreader.c:1671">COPY_HEADER_FIELD</a>(&amp;blk-&gt;rlocator, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlocator = &amp;blk-&gt;rlocator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rlocator == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;BKPBLOCK_SAME_REL set but no previous rel at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(state-&gt;ReadRecPtr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk-&gt;rlocator = *rlocator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1671" title="access/transam/xlogreader.c:1671">COPY_HEADER_FIELD</a>(&amp;blk-&gt;blkno, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BlockNumber));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;invalid block_id </span><span class="Special">%u</span><span class="Constant"> at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block_id, LSN_FORMAT_ARGS(state-&gt;ReadRecPtr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> err;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (remaining != datatotal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> shortdata_err;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ok, we've parsed the fragment headers, and verified that the total<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * length of the payload in the fragments is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the amount of data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * left.&nbsp; Copy the data of each fragment to contiguous space after the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * blocks array, inserting alignment padding <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the data fragments so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they can be cast to struct pointers by REDO routines.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; out = ((<span class="Type">char</span> *) decoded) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offsetof(DecodedXLogRecord, blocks) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(decoded-&gt;blocks[<span class="Constant">0</span>]) * (decoded-&gt;max_block_id + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* block data first */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (block_id = <span class="Constant">0</span>; block_id &lt;= decoded-&gt;max_block_id; block_id++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DecodedBkpBlock *blk = &amp;decoded-&gt;blocks[block_id];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!blk-&gt;in_use)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(blk-&gt;has_image || !blk-&gt;apply_image);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blk-&gt;has_image)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no need to align image */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk-&gt;bkp_image = out;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(out, ptr, blk-&gt;bimg_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += blk-&gt;bimg_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out += blk-&gt;bimg_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blk-&gt;has_data)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out = (<span class="Type">char</span> *) MAXALIGN(out);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blk-&gt;data = out;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(blk-&gt;data, ptr, blk-&gt;data_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += blk-&gt;data_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; out += blk-&gt;data_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and finally, the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> data */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (decoded-&gt;main_data_len &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out = (<span class="Type">char</span> *) MAXALIGN(out);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; decoded-&gt;main_data = out;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(decoded-&gt;main_data, ptr, decoded-&gt;main_data_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += decoded-&gt;main_data_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; out += decoded-&gt;main_data_len;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report the actual size we used. */<br/></li>
<li></span>&nbsp; &nbsp; decoded-&gt;size = MAXALIGN(out - (<span class="Type">char</span> *) decoded);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L1629" title="access/transam/xlogreader.c:1629">DecodeXLogRecordRequiredSpace</a>(record-&gt;xl_tot_len) &gt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; decoded-&gt;size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">shortdata_err</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;record with invalid length at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(state-&gt;ReadRecPtr));<br/></li>
<li><span class="Statement">err</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; *errormsg = state-&gt;errormsg_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns information about the block that a block reference refers to.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is like <a href="#L1997" title="access/transam/xlogreader.c:1997">XLogRecGetBlockTagExtended</a>, except that the block reference<br/></li>
<li></span><span class="Comment"> * must exist and there's no access to prefetch_buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1971">&#x200c;</a></span><span class="linkable">XLogRecGetBlockTag</span>(XLogReaderState *record, uint8 block_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelFileLocator *rlocator, ForkNumber *forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber *blknum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1997" title="access/transam/xlogreader.c:1997">XLogRecGetBlockTagExtended</a>(record, block_id, rlocator, forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blknum, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifndef FRONTEND<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not locate backup block with ID </span><span class="Special">%d</span><span class="Constant"> in WAL record&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; block_id);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_fatal(<span class="Constant">&quot;could not locate backup block with ID </span><span class="Special">%d</span><span class="Constant"> in WAL record&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; block_id);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns information about the block that a block reference refers to,<br/></li>
<li></span><span class="Comment"> * optionally including the buffer that the block may already be in.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the WAL record contains a block reference with the given ID, *rlocator,<br/></li>
<li></span><span class="Comment"> * *forknum, *blknum and *prefetch_buffer are filled in (if not NULL), and<br/></li>
<li></span><span class="Comment"> * returns true.&nbsp; Otherwise returns false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1997">&#x200c;</a></span><span class="linkable">XLogRecGetBlockTagExtended</span>(XLogReaderState *record, uint8 block_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelFileLocator *rlocator, ForkNumber *forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber *blknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer *prefetch_buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DecodedBkpBlock *bkpb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecHasBlockRef(record, block_id))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bkpb = &amp;record-&gt;record-&gt;blocks[block_id];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rlocator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *rlocator = bkpb-&gt;rlocator;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (forknum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *forknum = bkpb-&gt;forknum;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (blknum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *blknum = bkpb-&gt;blkno;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prefetch_buffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *prefetch_buffer = bkpb-&gt;prefetch_buffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns the data associated with a block reference, or NULL if there is<br/></li>
<li></span><span class="Comment"> * no data (e.g. because a full-page image was taken instead). The returned<br/></li>
<li></span><span class="Comment"> * pointer points to a MAXALIGNed buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L2025">&#x200c;</a><span class="linkable">XLogRecGetBlockData</span>(XLogReaderState *record, uint8 block_id, Size *len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DecodedBkpBlock *bkpb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (block_id &gt; record-&gt;record-&gt;max_block_id ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !record-&gt;record-&gt;blocks[block_id].in_use)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bkpb = &amp;record-&gt;record-&gt;blocks[block_id];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!bkpb-&gt;has_data)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *len = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *len = bkpb-&gt;data_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> bkpb-&gt;data;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Restore a full-page image from a backup block attached to an XLOG record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if a full-page image is restored, and false on failure with<br/></li>
<li></span><span class="Comment"> * an error to be consumed by the caller.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2056">&#x200c;</a></span><span class="linkable">RestoreBlockImage</span>(XLogReaderState *record, uint8 block_id, <span class="Type">char</span> *page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DecodedBkpBlock *bkpb;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; PGAlignedBlock tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (block_id &gt; record-&gt;record-&gt;max_block_id ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !record-&gt;record-&gt;blocks[block_id].in_use)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(record,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;could not restore image at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> with invalid block </span><span class="Special">%d</span><span class="Constant"> specified&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(record-&gt;ReadRecPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block_id);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!record-&gt;record-&gt;blocks[block_id].has_image)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(record, <span class="Constant">&quot;could not restore image at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> with invalid state, block </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(record-&gt;ReadRecPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block_id);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bkpb = &amp;record-&gt;record-&gt;blocks[block_id];<br/></li>
<li>&nbsp; &nbsp; ptr = bkpb-&gt;bkp_image;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BKPIMAGE_COMPRESSED(bkpb-&gt;bimg_info))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If a backup block image is compressed, decompress it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; decomp_success = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((bkpb-&gt;bimg_info &amp; BKPIMAGE_COMPRESS_PGLZ) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pglz_decompress(ptr, bkpb-&gt;bimg_len, tmp.data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BLCKSZ - bkpb-&gt;hole_length, <span class="Constant">true</span>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decomp_success = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((bkpb-&gt;bimg_info &amp; BKPIMAGE_COMPRESS_LZ4) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef USE_LZ4<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (LZ4_decompress_safe(ptr, tmp.data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bkpb-&gt;bimg_len, BLCKSZ - bkpb-&gt;hole_length) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decomp_success = <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(record, <span class="Constant">&quot;could not restore image at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> compressed with </span><span class="Special">%s</span><span class="Constant"> not supported by build, block </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(record-&gt;ReadRecPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;LZ4&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block_id);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((bkpb-&gt;bimg_info &amp; BKPIMAGE_COMPRESS_ZSTD) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef USE_ZSTD<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; decomp_result = ZSTD_decompress(tmp.data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BLCKSZ - bkpb-&gt;hole_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr, bkpb-&gt;bimg_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ZSTD_isError(decomp_result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; decomp_success = <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(record, <span class="Constant">&quot;could not restore image at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> compressed with </span><span class="Special">%s</span><span class="Constant"> not supported by build, block </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(record-&gt;ReadRecPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;zstd&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block_id);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(record, <span class="Constant">&quot;could not restore image at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> compressed with unknown method, block </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(record-&gt;ReadRecPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block_id);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!decomp_success)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="access/transam/xlogreader.c:71">report_invalid_record</a>(record, <span class="Constant">&quot;could not decompress image at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, block </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(record-&gt;ReadRecPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block_id);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = tmp.data;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* generate page, taking into account hole if necessary */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bkpb-&gt;hole_length == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(page, ptr, BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(page, ptr, bkpb-&gt;hole_offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must zero-fill the hole */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(page + bkpb-&gt;hole_offset, <span class="Constant">0</span>, bkpb-&gt;hole_length);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(page + (bkpb-&gt;hole_offset + bkpb-&gt;hole_length),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ptr + bkpb-&gt;hole_offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BLCKSZ - (bkpb-&gt;hole_offset + bkpb-&gt;hole_length));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef FRONTEND<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extract the FullTransactionId from a WAL record.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>FullTransactionId<br/></li>
<li><a id="L2167">&#x200c;</a><span class="linkable">XLogRecGetFullXid</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_xid;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; epoch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This function is only safe during replay, because it depends on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replay state.&nbsp; See <a href="varsup.c.html#L304" title="access/transam/varsup.c:304">AdvanceNextFullTransactionIdPastXid</a>() for more.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(AmStartupProcess() || !<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xid = XLogRecGetXid(record);<br/></li>
<li>&nbsp; &nbsp; next_xid = XidFromFullTransactionId(<a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid);<br/></li>
<li>&nbsp; &nbsp; epoch = EpochFromFullTransactionId(<a href="varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;nextXid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If xid is numerically greater than next_xid, it has to be from the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * epoch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(xid &gt; next_xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; --epoch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> FullTransactionIdFromEpochAndXid(epoch, xid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
