<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/transam/xlogprefetcher.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/transam/xlogprefetcher.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L199">SharedStats</a></li>
<li><a href="#L78">XLogPrefetchReconfigureCount</a></li>
<li><a href="#L68">recovery_prefetch</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L103">LsnReadQueue</a></li>
<li><a href="#L118">LsnReadQueue</a></li>
<li><a href="#L94">LsnReadQueueNextFun</a></li>
<li><a href="#L88">LsnReadQueueNextStatus</a></li>
<li><a href="#L171">XLogPrefetchStats</a></li>
<li><a href="#L185">XLogPrefetchStats</a></li>
<li><a href="#L124">XLogPrefetcher</a></li>
<li><a href="#L160">XLogPrefetcherFilter</a></li>
<li><a href="#L166">XLogPrefetcherFilter</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L351">XLogPrefetchIncrement</a></li>
<li><a href="#L340">XLogPrefetchReconfigure</a></li>
<li><a href="#L303">XLogPrefetchResetStats</a></li>
<li><a href="#L315">XLogPrefetchShmemInit</a></li>
<li><a href="#L294">XLogPrefetchShmemSize</a></li>
<li><a href="#L858">XLogPrefetcherAddFilter</a></li>
<li><a href="#L362">XLogPrefetcherAllocate</a></li>
<li><a href="#L964">XLogPrefetcherBeginRead</a></li>
<li><a href="#L896">XLogPrefetcherCompleteFilters</a></li>
<li><a href="#L412">XLogPrefetcherComputeStats</a></li>
<li><a href="#L392">XLogPrefetcherFree</a></li>
<li><a href="#L403">XLogPrefetcherGetReader</a></li>
<li><a href="#L916">XLogPrefetcherIsFiltered</a></li>
<li><a href="#L461">XLogPrefetcherNextBlock</a></li>
<li><a href="#L983">XLogPrefetcherReadRecord</a></li>
<li><a href="#L1097">assign_recovery_prefetch</a></li>
<li><a href="#L1083">check_recovery_prefetch</a></li>
<li><a href="#L202">lrq_alloc</a></li>
<li><a href="#L272">lrq_complete_lsn</a></li>
<li><a href="#L239">lrq_completed</a></li>
<li><a href="#L227">lrq_free</a></li>
<li><a href="#L233">lrq_inflight</a></li>
<li><a href="#L245">lrq_prefetch</a></li>
<li><a href="#L826">pg_stat_get_recovery_prefetch</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L828">PG_STAT_GET_RECOVERY_PREFETCH_COLS</a></li>
<li><a href="#L71">RecoveryPrefetchEnabled</a></li>
<li><a href="#L75">RecoveryPrefetchEnabled</a></li>
<li><a href="#L62">XLOGPREFETCHER_DISTANCE_MULTIPLIER</a></li>
<li><a href="#L56">XLOGPREFETCHER_SEQ_WINDOW_SIZE</a></li>
<li><a href="#L50">XLOGPREFETCHER_STATS_DISTANCE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="xlogrecovery.c.html#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Prefetching support for recovery.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 2022-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; src/backend/access/transam/<a href="xlogrecovery.c.html#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module provides a drop-in replacement for an XLogReader that tries to<br/></li>
<li></span><span class="Comment"> * minimize I/O stalls by looking ahead in the WAL.&nbsp; If blocks that will be<br/></li>
<li></span><span class="Comment"> * accessed in the near future are not already in the buffer pool, it initiates<br/></li>
<li></span><span class="Comment"> * I/Os that might complete <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the caller eventually needs the data.&nbsp; When<br/></li>
<li></span><span class="Comment"> * referenced blocks are found in the buffer pool already, the buffer is<br/></li>
<li></span><span class="Comment"> * recorded in the decoded record so that <a href="xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>() can try to<br/></li>
<li></span><span class="Comment"> * avoid a second buffer mapping table lookup.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently, only the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> fork is considered for prefetching.&nbsp; Currently,<br/></li>
<li></span><span class="Comment"> * prefetching is only effective on systems where <a href="../../storage/buffer/bufmgr.c.html#L638" title="storage/buffer/bufmgr.c:638">PrefetchBuffer</a>() does<br/></li>
<li></span><span class="Comment"> * something useful (mainly Linux).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/<a href="xlogrecovery.c.html#L191" title="access/transam/xlogrecovery.c:191">xlogprefetcher</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/<a href="../../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_control.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/storage_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/dbcommands_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;funcapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/atomics.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/hsearch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Every time we process this much WAL, we'll update the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in<br/></li>
<li></span><span class="Comment"> * pg_stat_recovery_prefetch.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L50">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">XLOGPREFETCHER_STATS_DISTANCE</span> BLCKSZ<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * To detect repeated access to the same block and <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> useless extra system<br/></li>
<li></span><span class="Comment"> * calls, we remember a small window of recently prefetched blocks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L56">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">XLOGPREFETCHER_SEQ_WINDOW_SIZE</span> </span><span class="Constant">4<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When <a href="../../storage/buffer/bufmgr.c.html#L157" title="storage/buffer/bufmgr.c:157">maintenance_io_concurrency</a> is not saturated, we're prepared to look<br/></li>
<li></span><span class="Comment"> * ahead up to N times that number of block references.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L62">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">XLOGPREFETCHER_DISTANCE_MULTIPLIER</span> </span><span class="Constant">4<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Define to log <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> debugging messages. */<br/></li>
<li></span><span class="Comment">/* #define XLOGPREFETCHER_DEBUG_LEVEL LOG */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* GUCs */<br/></li>
<li><a id="L68">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">recovery_prefetch</span> = RECOVERY_PREFETCH_TRY;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_PREFETCH<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RecoveryPrefetchEnabled</span>() \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L68" title="access/transam/xlogprefetcher.c:68">recovery_prefetch</a> != RECOVERY_PREFETCH_OFF &amp;&amp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/buffer/bufmgr.c.html#L157" title="storage/buffer/bufmgr.c:157">maintenance_io_concurrency</a> &gt; </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li><a id="L75">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">RecoveryPrefetchEnabled</span>() </span><span class="Constant">false<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L78">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">XLogPrefetchReconfigureCount</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Enum used to report whether an IO should be started.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; LRQ_NEXT_NO_IO,<br/></li>
<li>&nbsp; &nbsp; LRQ_NEXT_IO,<br/></li>
<li>&nbsp; &nbsp; LRQ_NEXT_AGAIN,<br/></li>
<li><a id="L88">&#x200c;</a>} <span class="linkable">LsnReadQueueNextStatus</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Type of callback that can decide which block to prefetch <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>.&nbsp; For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment"> * there is only one.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L94">&#x200c;</a></span><span class="Type">typedef</span> <a href="#L88" title="access/transam/xlogprefetcher.c:88">LsnReadQueueNextStatus</a> (*<span class="linkable">LsnReadQueueNextFun</span>) (<span class="Type">uintptr_t</span> lrq_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr *lsn);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A simple circular queue of LSNs, using to control the number of<br/></li>
<li></span><span class="Comment"> * (potentially) inflight IOs.&nbsp; This stands in for a later more general IO<br/></li>
<li></span><span class="Comment"> * control mechanism, which is why it has the apparently unnecessary<br/></li>
<li></span><span class="Comment"> * indirection through a function pointer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L103">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">LsnReadQueue</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L94" title="access/transam/xlogprefetcher.c:94">LsnReadQueueNextFun</a> <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">uintptr_t</span>&nbsp; &nbsp; lrq_private;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; max_inflight;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; inflight;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; completed;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; head;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; tail;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; io;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn;<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queue[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L118">&#x200c;</a>} <span class="linkable">LsnReadQueue</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A prefetcher.&nbsp; This is a mechanism that wraps an XLogReader, prefetching<br/></li>
<li></span><span class="Comment"> * blocks that will be soon be referenced, to try to avoid IO stalls.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L124">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">XLogPrefetcher</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* WAL reader and current reading state. */<br/></li>
<li></span>&nbsp; &nbsp; XLogReaderState *reader;<br/></li>
<li>&nbsp; &nbsp; DecodedXLogRecord *record;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_block_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* When to publish stats. */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; next_stats_shm_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Book-keeping to avoid accessing blocks that don't exist yet. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *filter_table;<br/></li>
<li>&nbsp; &nbsp; dlist_head&nbsp; &nbsp; filter_queue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Book-keeping to avoid <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> prefetches. */<br/></li>
<li></span>&nbsp; &nbsp; RelFileLocator recent_rlocator[<a href="#L56" title="access/transam/xlogprefetcher.c:56">XLOGPREFETCHER_SEQ_WINDOW_SIZE</a>];<br/></li>
<li>&nbsp; &nbsp; BlockNumber recent_block[<a href="#L56" title="access/transam/xlogprefetcher.c:56">XLOGPREFETCHER_SEQ_WINDOW_SIZE</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recent_idx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Book-keeping to disable prefetching temporarily. */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; no_readahead_until;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* IO depth manager. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L103" title="access/transam/xlogprefetcher.c:103">LsnReadQueue</a> *streaming_read;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; begin_ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reconfigure_count;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A temporary filter used to track block ranges that haven't been created<br/></li>
<li></span><span class="Comment"> * yet, whole relations that haven't been created yet, and whole relations<br/></li>
<li></span><span class="Comment"> * that (we assume) have already been dropped, or will be created by bulk WAL<br/></li>
<li></span><span class="Comment"> * operators.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L160">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">XLogPrefetcherFilter</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; filter_until_replayed;<br/></li>
<li>&nbsp; &nbsp; BlockNumber filter_from_block;<br/></li>
<li>&nbsp; &nbsp; dlist_node&nbsp; &nbsp; link;<br/></li>
<li><a id="L166">&#x200c;</a>} <span class="linkable">XLogPrefetcherFilter</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Counters exposed in shared memory for pg_stat_recovery_prefetch.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L171">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">XLogPrefetchStats</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_atomic_uint64 reset_time;&nbsp; &nbsp; <span class="Comment">/* Time of last reset. */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_uint64 prefetch;&nbsp; &nbsp; <span class="Comment">/* Prefetches initiated. */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_uint64 hit;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Blocks already in cache. */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_uint64 skip_init; <span class="Comment">/* Zero-inited blocks skipped. */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_uint64 skip_new;&nbsp; &nbsp; <span class="Comment">/* New/missing blocks filtered. */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_uint64 skip_fpw;&nbsp; &nbsp; <span class="Comment">/* FPWs skipped. */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_uint64 skip_rep;&nbsp; &nbsp; <span class="Comment">/* Repeat accesses skipped. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Dynamic <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wal_distance;&nbsp; &nbsp; <span class="Comment">/* Number of WAL bytes ahead. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block_distance; <span class="Comment">/* Number of block references ahead. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; io_depth;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Number of I/Os in progress. */<br/></li>
<li><a id="L185">&#x200c;</a></span>} <span class="linkable">XLogPrefetchStats</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L858" title="access/transam/xlogprefetcher.c:858">XLogPrefetcherAddFilter</a>(<a href="#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> *prefetcher,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelFileLocator rlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber blockno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L916" title="access/transam/xlogprefetcher.c:916">XLogPrefetcherIsFiltered</a>(<a href="#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> *prefetcher,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator rlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blockno);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L896" title="access/transam/xlogprefetcher.c:896">XLogPrefetcherCompleteFilters</a>(<a href="#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> *prefetcher,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr replaying_lsn);<br/></li>
<li><span class="Type">static</span> <a href="#L88" title="access/transam/xlogprefetcher.c:88">LsnReadQueueNextStatus</a> <a href="#L461" title="access/transam/xlogprefetcher.c:461">XLogPrefetcherNextBlock</a>(<span class="Type">uintptr_t</span> pgsr_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr *lsn);<br/></li>
<li><br/></li>
<li><a id="L199">&#x200c;</a><span class="Type">static</span> <a href="#L171" title="access/transam/xlogprefetcher.c:171">XLogPrefetchStats</a> *<span class="linkable">SharedStats</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <a href="#L103" title="access/transam/xlogprefetcher.c:103">LsnReadQueue</a> *<br/></li>
<li><a id="L202">&#x200c;</a><span class="linkable">lrq_alloc</span>(uint32 max_distance,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint32 max_inflight,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">uintptr_t</span> lrq_private,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L94" title="access/transam/xlogprefetcher.c:94">LsnReadQueueNextFun</a> <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L103" title="access/transam/xlogprefetcher.c:103">LsnReadQueue</a> *lrq;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(max_distance &gt;= max_inflight);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = max_distance + <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* full ring buffer has a gap */<br/></li>
<li></span>&nbsp; &nbsp; lrq = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(offsetof(<a href="#L103" title="access/transam/xlogprefetcher.c:103">LsnReadQueue</a>, queue) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(lrq-&gt;queue[<span class="Constant">0</span>]) * size);<br/></li>
<li>&nbsp; &nbsp; lrq-&gt;lrq_private = lrq_private;<br/></li>
<li>&nbsp; &nbsp; lrq-&gt;max_inflight = max_inflight;<br/></li>
<li>&nbsp; &nbsp; lrq-&gt;size = size;<br/></li>
<li>&nbsp; &nbsp; lrq-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; lrq-&gt;head = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; lrq-&gt;tail = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; lrq-&gt;inflight = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; lrq-&gt;completed = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lrq;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L227">&#x200c;</a></span><span class="linkable">lrq_free</span>(<a href="#L103" title="access/transam/xlogprefetcher.c:103">LsnReadQueue</a> *lrq)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(lrq);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> uint32<br/></li>
<li><a id="L233">&#x200c;</a><span class="linkable">lrq_inflight</span>(<a href="#L103" title="access/transam/xlogprefetcher.c:103">LsnReadQueue</a> *lrq)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lrq-&gt;inflight;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> uint32<br/></li>
<li><a id="L239">&#x200c;</a><span class="linkable">lrq_completed</span>(<a href="#L103" title="access/transam/xlogprefetcher.c:103">LsnReadQueue</a> *lrq)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> lrq-&gt;completed;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L245">&#x200c;</a></span><span class="linkable">lrq_prefetch</span>(<a href="#L103" title="access/transam/xlogprefetcher.c:103">LsnReadQueue</a> *lrq)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to start as many IOs as we can within our limits. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (lrq-&gt;inflight &lt; lrq-&gt;max_inflight &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lrq-&gt;inflight + lrq-&gt;completed &lt; lrq-&gt;size - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(((lrq-&gt;head + <span class="Constant">1</span>) % lrq-&gt;size) != lrq-&gt;tail);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (lrq-&gt;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>(lrq-&gt;lrq_private, &amp;lrq-&gt;queue[lrq-&gt;head].lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LRQ_NEXT_AGAIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LRQ_NEXT_IO:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lrq-&gt;queue[lrq-&gt;head].io = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lrq-&gt;inflight++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LRQ_NEXT_NO_IO:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lrq-&gt;queue[lrq-&gt;head].io = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lrq-&gt;completed++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lrq-&gt;head++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lrq-&gt;head == lrq-&gt;size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lrq-&gt;head = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L272">&#x200c;</a></span><span class="linkable">lrq_complete_lsn</span>(<a href="#L103" title="access/transam/xlogprefetcher.c:103">LsnReadQueue</a> *lrq, XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We know that LSNs <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> 'lsn' have been replayed, so we can <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> IOs that were started <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> then have finished.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (lrq-&gt;tail != lrq-&gt;head &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lrq-&gt;queue[lrq-&gt;tail].lsn &lt; lsn)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lrq-&gt;queue[lrq-&gt;tail].io)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lrq-&gt;inflight--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lrq-&gt;completed--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lrq-&gt;tail++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lrq-&gt;tail == lrq-&gt;size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lrq-&gt;tail = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L71" title="access/transam/xlogprefetcher.c:71">RecoveryPrefetchEnabled</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L245" title="access/transam/xlogprefetcher.c:245">lrq_prefetch</a>(lrq);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">size_t<br/></li>
<li><a id="L294">&#x200c;</a></span><span class="linkable">XLogPrefetchShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L171" title="access/transam/xlogprefetcher.c:171">XLogPrefetchStats</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reset all counters to zero.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L303">&#x200c;</a></span><span class="linkable">XLogPrefetchResetStats</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;reset_time, <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>());<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;prefetch, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;hit, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;skip_init, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;skip_new, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;skip_fpw, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;skip_rep, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L315">&#x200c;</a></span><span class="linkable">XLogPrefetchShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a> = (<a href="#L171" title="access/transam/xlogprefetcher.c:171">XLogPrefetchStats</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;<a href="#L171" title="access/transam/xlogprefetcher.c:171">XLogPrefetchStats</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L171" title="access/transam/xlogprefetcher.c:171">XLogPrefetchStats</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;reset_time, <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;prefetch, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;hit, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;skip_init, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;skip_new, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;skip_fpw, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;skip_rep, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Called when <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> GUC is changed that affects prefetching.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L340">&#x200c;</a></span><span class="linkable">XLogPrefetchReconfigure</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L78" title="access/transam/xlogprefetcher.c:78">XLogPrefetchReconfigureCount</a>++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Increment a counter in shared memory.&nbsp; This is equivalent to *counter++ on a<br/></li>
<li></span><span class="Comment"> * plain uint64 without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> memory barrier or locking, except on platforms<br/></li>
<li></span><span class="Comment"> * where readers can't read uint64 without possibly observing a torn value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L351">&#x200c;</a></span><span class="linkable">XLogPrefetchIncrement</span>(pg_atomic_uint64 *counter)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(AmStartupProcess() || !<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>);<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_u64(counter, pg_atomic_read_u64(counter) + <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a prefetcher that is ready to begin prefetching blocks referenced by<br/></li>
<li></span><span class="Comment"> * WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> *<br/></li>
<li><a id="L362">&#x200c;</a><span class="linkable">XLogPrefetcherAllocate</span>(XLogReaderState *reader)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> *prefetcher;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> HASHCTL hash_table_ctl = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; .entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L160" title="access/transam/xlogprefetcher.c:160">XLogPrefetcherFilter</a>)<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; prefetcher = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; prefetcher-&gt;reader = reader;<br/></li>
<li>&nbsp; &nbsp; prefetcher-&gt;filter_table = <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;XLogPrefetcherFilterTable&quot;</span>, <span class="Constant">1024</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;hash_table_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ELEM | HASH_BLOBS);<br/></li>
<li>&nbsp; &nbsp; dlist_init(&amp;prefetcher-&gt;filter_queue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;wal_distance = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;block_distance = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;io_depth = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First usage will cause streaming_read to be allocated. */<br/></li>
<li></span>&nbsp; &nbsp; prefetcher-&gt;reconfigure_count = <a href="#L78" title="access/transam/xlogprefetcher.c:78">XLogPrefetchReconfigureCount</a> - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> prefetcher;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Destroy a prefetcher and release all resources.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L392">&#x200c;</a></span><span class="linkable">XLogPrefetcherFree</span>(<a href="#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> *prefetcher)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L227" title="access/transam/xlogprefetcher.c:227">lrq_free</a>(prefetcher-&gt;streaming_read);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(prefetcher-&gt;filter_table);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(prefetcher);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Provide access to the reader.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogReaderState *<br/></li>
<li><a id="L403">&#x200c;</a><span class="linkable">XLogPrefetcherGetReader</span>(<a href="#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> *prefetcher)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> prefetcher-&gt;reader;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update the statistics visible in the pg_stat_recovery_prefetch view.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L412">&#x200c;</a></span><span class="linkable">XLogPrefetcherComputeStats</span>(<a href="#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> *prefetcher)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; io_depth;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; completed;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; wal_distance;<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* How far ahead of replay are we <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (prefetcher-&gt;reader-&gt;decode_queue_tail)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wal_distance =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefetcher-&gt;reader-&gt;decode_queue_tail-&gt;lsn -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefetcher-&gt;reader-&gt;decode_queue_head-&gt;lsn;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wal_distance = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* How many IOs are currently in flight and completed? */<br/></li>
<li></span>&nbsp; &nbsp; io_depth = <a href="#L233" title="access/transam/xlogprefetcher.c:233">lrq_inflight</a>(prefetcher-&gt;streaming_read);<br/></li>
<li>&nbsp; &nbsp; completed = <a href="#L239" title="access/transam/xlogprefetcher.c:239">lrq_completed</a>(prefetcher-&gt;streaming_read);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update the instantaneous stats visible in pg_stat_recovery_prefetch. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;io_depth = io_depth;<br/></li>
<li>&nbsp; &nbsp; <a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;block_distance = io_depth + completed;<br/></li>
<li>&nbsp; &nbsp; <a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;wal_distance = wal_distance;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; prefetcher-&gt;next_stats_shm_lsn =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prefetcher-&gt;reader-&gt;ReadRecPtr + <a href="#L50" title="access/transam/xlogprefetcher.c:50">XLOGPREFETCHER_STATS_DISTANCE</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A callback that examines the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block reference in the WAL, and possibly<br/></li>
<li></span><span class="Comment"> * starts an IO so that a later read will be fast.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns LRQ_NEXT_AGAIN if no more WAL data is available yet.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns LRQ_NEXT_IO if the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block reference is for a <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> fork block<br/></li>
<li></span><span class="Comment"> * that isn't in the buffer pool, and the kernel has been asked to start<br/></li>
<li></span><span class="Comment"> * reading it to make a future read system call faster. An LSN is written to<br/></li>
<li></span><span class="Comment"> * *lsn, and the I/O will be considered to have completed once that LSN is<br/></li>
<li></span><span class="Comment"> * replayed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns LRQ_NEXT_NO_IO if we examined the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block reference and found<br/></li>
<li></span><span class="Comment"> * that it was already in the buffer pool, or we decided for various reasons<br/></li>
<li></span><span class="Comment"> * not to prefetch.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L88" title="access/transam/xlogprefetcher.c:88">LsnReadQueueNextStatus</a><br/></li>
<li><a id="L461">&#x200c;</a><span class="linkable">XLogPrefetcherNextBlock</span>(<span class="Type">uintptr_t</span> pgsr_private, XLogRecPtr *lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> *prefetcher = (<a href="#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> *) pgsr_private;<br/></li>
<li>&nbsp; &nbsp; XLogReaderState *reader = prefetcher-&gt;reader;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; replaying_lsn = reader-&gt;ReadRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We keep track of the record and block we're up to between calls with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prefetcher-&gt;record and prefetcher-&gt;next_block_id.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DecodedXLogRecord *record;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to read a new future record, if we don't already have one. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prefetcher-&gt;record == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nonblocking;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there are already <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> or an error queued up that could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be replayed, we don't want to block here.&nbsp; Otherwise, it's OK<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to block <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for more data: presumably the caller has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nothing else to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nonblocking = XLogReaderHasQueuedRecordOrError(reader);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Readahead is disabled until we replay past a certain point. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nonblocking &amp;&amp; replaying_lsn &lt;= prefetcher-&gt;no_readahead_until)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> LRQ_NEXT_AGAIN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record = <a href="xlogreader.c.html#L966" title="access/transam/xlogreader.c:966">XLogReadAhead</a>(prefetcher-&gt;reader, nonblocking);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (record == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't read <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more, due to an error or lack of data in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nonblocking mode.&nbsp; Don't try to read ahead again until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we've replayed everything already decoded.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nonblocking &amp;&amp; prefetcher-&gt;reader-&gt;decode_queue_tail)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefetcher-&gt;no_readahead_until =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefetcher-&gt;reader-&gt;decode_queue_tail-&gt;lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> LRQ_NEXT_AGAIN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If prefetching is disabled, we don't need to <a href="../../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> the record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or issue <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> prefetches.&nbsp; We just need to cause one record to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be decoded.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L71" title="access/transam/xlogprefetcher.c:71">RecoveryPrefetchEnabled</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> LRQ_NEXT_NO_IO;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have a new record to process. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefetcher-&gt;record = record;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefetcher-&gt;next_block_id = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Continue to process from last call, or last loop. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record = prefetcher-&gt;record;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for operations that require us to filter out block ranges, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pause readahead completely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (replaying_lsn &lt; record-&gt;lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; rmid = record-&gt;header.xl_rmid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; record_type = record-&gt;header.xl_info &amp; ~XLR_INFO_MASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rmid == RM_XLOG_ID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (record_type == XLOG_CHECKPOINT_SHUTDOWN ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record_type == XLOG_END_OF_RECOVERY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> might change the TLI.&nbsp; Avoid potential<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bugs if we were to allow &quot;read TLI&quot; and &quot;replay TLI&quot; to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * differ without more analysis.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefetcher-&gt;no_readahead_until = record-&gt;lsn;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef XLOGPREFETCHER_DEBUG_LEVEL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(XLOGPREFETCHER_DEBUG_LEVEL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;suppressing all readahead until </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> is replayed due to possible TLI change&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(record-&gt;lsn));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fall through so we move past this record. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rmid == RM_DBASE_ID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When databases are created with the file-copy strategy,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there are no WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> to tell us about the creation of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * individual relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (record_type == XLOG_DBASE_CREATE_FILE_COPY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_dbase_create_file_copy_rec *xlrec =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (xl_dbase_create_file_copy_rec *) record-&gt;main_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator rlocator =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {InvalidOid, xlrec-&gt;db_id, InvalidRelFileNumber};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't try to prefetch anything in this database until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it has been created, or we might confuse the blocks of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * different generations, if a database OID or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relfilenumber is reused.&nbsp; It's also more efficient than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * discovering that relations don't exist on disk yet with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ENOENT errors.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L858" title="access/transam/xlogprefetcher.c:858">XLogPrefetcherAddFilter</a>(prefetcher, rlocator, <span class="Constant">0</span>, record-&gt;lsn);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef XLOGPREFETCHER_DEBUG_LEVEL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(XLOGPREFETCHER_DEBUG_LEVEL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;suppressing prefetch in database </span><span class="Special">%u</span><span class="Constant"> until </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> is replayed due to raw file copy&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rlocator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(record-&gt;lsn));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rmid == RM_SMGR_ID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (record_type == XLOG_SMGR_CREATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_smgr_create *xlrec = (xl_smgr_create *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record-&gt;main_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;forkNum == MAIN_FORKNUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't prefetch anything for this whole relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * until it has been created.&nbsp; Otherwise we might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * confuse the blocks of different generations, if a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relfilenumber is reused.&nbsp; This also avoids the need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to discover the problem via extra syscalls that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * report ENOENT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L858" title="access/transam/xlogprefetcher.c:858">XLogPrefetcherAddFilter</a>(prefetcher, xlrec-&gt;rlocator, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record-&gt;lsn);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef XLOGPREFETCHER_DEBUG_LEVEL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(XLOGPREFETCHER_DEBUG_LEVEL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;suppressing prefetch in relation </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant"> until </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> is replayed, which creates the relation&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;rlocator.spcOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;rlocator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;rlocator.relNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(record-&gt;lsn));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (record_type == XLOG_SMGR_TRUNCATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_smgr_truncate *xlrec = (xl_smgr_truncate *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record-&gt;main_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't consider prefetching anything in the truncated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> until the truncation has been performed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L858" title="access/transam/xlogprefetcher.c:858">XLogPrefetcherAddFilter</a>(prefetcher, xlrec-&gt;rlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec-&gt;blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record-&gt;lsn);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef XLOGPREFETCHER_DEBUG_LEVEL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(XLOGPREFETCHER_DEBUG_LEVEL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;suppressing prefetch in relation </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant"> from block </span><span class="Special">%u</span><span class="Constant"> until </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> is replayed, which truncates the relation&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;rlocator.spcOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;rlocator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;rlocator.relNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(record-&gt;lsn));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Scan the block references, starting where we left off last time. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (prefetcher-&gt;next_block_id &lt;= record-&gt;max_block_id)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block_id = prefetcher-&gt;next_block_id++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DecodedBkpBlock *block = &amp;record-&gt;blocks[block_id];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SMgrRelation reln;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PrefetchBufferResult result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!block-&gt;in_use)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!BufferIsValid(block-&gt;prefetch_buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Record the LSN of this record.&nbsp; When it's replayed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L103" title="access/transam/xlogprefetcher.c:103">LsnReadQueue</a> will consider <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> IOs submitted for earlier LSNs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to be finished.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *lsn = record-&gt;lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't try to prefetch anything but the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> fork for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block-&gt;forknum != MAIN_FORKNUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> LRQ_NEXT_NO_IO;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there is a full page image attached, we won't be reading the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page, so don't bother trying to prefetch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block-&gt;has_image)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L351" title="access/transam/xlogprefetcher.c:351">XLogPrefetchIncrement</a>(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;skip_fpw);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> LRQ_NEXT_NO_IO;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There is no point in reading a page that will be zeroed. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block-&gt;flags &amp; BKPBLOCK_WILL_INIT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L351" title="access/transam/xlogprefetcher.c:351">XLogPrefetchIncrement</a>(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;skip_init);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> LRQ_NEXT_NO_IO;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> prefetching this block due to a filter? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L916" title="access/transam/xlogprefetcher.c:916">XLogPrefetcherIsFiltered</a>(prefetcher, block-&gt;rlocator, block-&gt;blkno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L351" title="access/transam/xlogprefetcher.c:351">XLogPrefetchIncrement</a>(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;skip_new);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> LRQ_NEXT_NO_IO;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There is no point in repeatedly prefetching the same block. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="#L56" title="access/transam/xlogprefetcher.c:56">XLOGPREFETCHER_SEQ_WINDOW_SIZE</a>; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block-&gt;blkno == prefetcher-&gt;recent_block[i] &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelFileLocatorEquals(block-&gt;rlocator, prefetcher-&gt;recent_rlocator[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> If we also remembered where it was, we could set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recent_buffer so that recovery could <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> <a href="../../storage/smgr/smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and a buffer table lookup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L351" title="access/transam/xlogprefetcher.c:351">XLogPrefetchIncrement</a>(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;skip_rep);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> LRQ_NEXT_NO_IO;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefetcher-&gt;recent_rlocator[prefetcher-&gt;recent_idx] = block-&gt;rlocator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefetcher-&gt;recent_block[prefetcher-&gt;recent_idx] = block-&gt;blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefetcher-&gt;recent_idx =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (prefetcher-&gt;recent_idx + <span class="Constant">1</span>) % <a href="#L56" title="access/transam/xlogprefetcher.c:56">XLOGPREFETCHER_SEQ_WINDOW_SIZE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could try to have a fast path for repeated references to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same relation (with some scheme to handle invalidations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * safely), but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we'll call <a href="../../storage/smgr/smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>() every time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln = <a href="../../storage/smgr/smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>(block-&gt;rlocator, INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the relation file doesn't exist on disk, for example because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're replaying after a crash and the file will be created and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then unlinked by WAL that hasn't been replayed yet, suppress<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * further prefetching in the relation until this record is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * replayed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/smgr/smgr.c.html#L398" title="storage/smgr/smgr.c:398">smgrexists</a>(reln, MAIN_FORKNUM))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef XLOGPREFETCHER_DEBUG_LEVEL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(XLOGPREFETCHER_DEBUG_LEVEL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;suppressing all prefetch in relation </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant"> until </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> is replayed, because the relation does not exist on disk&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reln-&gt;smgr_rlocator.locator.spcOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reln-&gt;smgr_rlocator.locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reln-&gt;smgr_rlocator.locator.relNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(record-&gt;lsn));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L858" title="access/transam/xlogprefetcher.c:858">XLogPrefetcherAddFilter</a>(prefetcher, block-&gt;rlocator, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record-&gt;lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L351" title="access/transam/xlogprefetcher.c:351">XLogPrefetchIncrement</a>(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;skip_new);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> LRQ_NEXT_NO_IO;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the relation isn't big enough to contain the referenced<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * block yet, suppress prefetching of this block and higher until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this record is replayed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block-&gt;blkno &gt;= <a href="../../storage/smgr/smgr.c.html#L655" title="storage/smgr/smgr.c:655">smgrnblocks</a>(reln, block-&gt;forknum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef XLOGPREFETCHER_DEBUG_LEVEL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(XLOGPREFETCHER_DEBUG_LEVEL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;suppressing prefetch in relation </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant"> from block </span><span class="Special">%u</span><span class="Constant"> until </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> is replayed, because the relation is too small&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reln-&gt;smgr_rlocator.locator.spcOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reln-&gt;smgr_rlocator.locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reln-&gt;smgr_rlocator.locator.relNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; block-&gt;blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(record-&gt;lsn));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L858" title="access/transam/xlogprefetcher.c:858">XLogPrefetcherAddFilter</a>(prefetcher, block-&gt;rlocator, block-&gt;blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; record-&gt;lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L351" title="access/transam/xlogprefetcher.c:351">XLogPrefetchIncrement</a>(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;skip_new);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> LRQ_NEXT_NO_IO;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Try to initiate prefetching. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../storage/buffer/bufmgr.c.html#L548" title="storage/buffer/bufmgr.c:548">PrefetchSharedBuffer</a>(reln, block-&gt;forknum, block-&gt;blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(result.recent_buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Cache hit, nothing to do. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L351" title="access/transam/xlogprefetcher.c:351">XLogPrefetchIncrement</a>(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;hit);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block-&gt;prefetch_buffer = result.recent_buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> LRQ_NEXT_NO_IO;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (result.initiated_io)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Cache <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a>, I/O (presumably) started. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L351" title="access/transam/xlogprefetcher.c:351">XLogPrefetchIncrement</a>(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;prefetch);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block-&gt;prefetch_buffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> LRQ_NEXT_IO;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((<a href="../../storage/file/fd.c.html#L168" title="storage/file/fd.c:168">io_direct_flags</a> &amp; IO_DIRECT_DATA) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This shouldn't be possible, because we already determined<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the relation exists on disk and is big enough.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Something is wrong with the cache invalidation for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/smgr/smgr.c.html#L398" title="storage/smgr/smgr.c:398">smgrexists</a>(), <a href="../../storage/smgr/smgr.c.html#L655" title="storage/smgr/smgr.c:655">smgrnblocks</a>(), or the file was unlinked or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * truncated beneath our feet?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;could not prefetch relation </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant"> block </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reln-&gt;smgr_rlocator.locator.spcOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reln-&gt;smgr_rlocator.locator.dbOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reln-&gt;smgr_rlocator.locator.relNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; block-&gt;blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Several callsites need to be able to read exactly one record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> readahead.&nbsp; Examples: xlog.c reading<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checkpoint <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> with emode set to PANIC, which might otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cause <a href="xlogrecovery.c.html#L3298" title="access/transam/xlogrecovery.c:3298">XLogPageRead</a>() to panic on some future page, and xlog.c<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * determining where to start writing WAL <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>, which depends on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contents of the reader's <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> buffer after reading one record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Therefore, don't even think about prefetching until the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * record after <a href="#L964" title="access/transam/xlogprefetcher.c:964">XLogPrefetcherBeginRead</a>() has been consumed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prefetcher-&gt;reader-&gt;decode_queue_tail &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefetcher-&gt;reader-&gt;decode_queue_tail-&gt;lsn == prefetcher-&gt;begin_ptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> LRQ_NEXT_AGAIN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> record. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; prefetcher-&gt;record = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pg_unreachable();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Expose statistics about recovery prefetching.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L826">&#x200c;</a><span class="linkable">pg_stat_get_recovery_prefetch</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li><a id="L828">&#x200c;</a><span class="PreProc">#define <span class="linkable">PG_STAT_GET_RECOVERY_PREFETCH_COLS</span> </span><span class="Constant">10<br/></li>
<li></span>&nbsp; &nbsp; ReturnSetInfo *rsinfo = (ReturnSetInfo *) fcinfo-&gt;resultinfo;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<a href="#L828" title="access/transam/xlogprefetcher.c:828">PG_STAT_GET_RECOVERY_PREFETCH_COLS</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[<a href="#L828" title="access/transam/xlogprefetcher.c:828">PG_STAT_GET_RECOVERY_PREFETCH_COLS</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/fmgr/funcapi.c.html#L76" title="utils/fmgr/funcapi.c:76">InitMaterializedSRF</a>(fcinfo, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="#L828" title="access/transam/xlogprefetcher.c:828">PG_STAT_GET_RECOVERY_PREFETCH_COLS</a>; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = TimestampTzGetDatum(pg_atomic_read_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;reset_time));<br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">1</span>] = <a href="../../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(pg_atomic_read_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;prefetch));<br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span>] = <a href="../../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(pg_atomic_read_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;hit));<br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">3</span>] = <a href="../../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(pg_atomic_read_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;skip_init));<br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">4</span>] = <a href="../../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(pg_atomic_read_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;skip_new));<br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">5</span>] = <a href="../../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(pg_atomic_read_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;skip_fpw));<br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">6</span>] = <a href="../../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(pg_atomic_read_u64(&amp;<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;skip_rep));<br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">7</span>] = Int32GetDatum(<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;wal_distance);<br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">8</span>] = Int32GetDatum(<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;block_distance);<br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">9</span>] = Int32GetDatum(<a href="#L199" title="access/transam/xlogprefetcher.c:199">SharedStats</a>-&gt;io_depth);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplestore.c.html#L750" title="utils/sort/tuplestore.c:750">tuplestore_putvalues</a>(rsinfo-&gt;setResult, rsinfo-&gt;setDesc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Datum) <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Don't prefetch <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> blocks &gt;= 'blockno' from a given 'rlocator', until 'lsn'<br/></li>
<li></span><span class="Comment"> * has been replayed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L858">&#x200c;</a></span><span class="linkable">XLogPrefetcherAddFilter</span>(<a href="#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> *prefetcher, RelFileLocator rlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blockno, XLogRecPtr lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L160" title="access/transam/xlogprefetcher.c:160">XLogPrefetcherFilter</a> *filter;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; filter = <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(prefetcher-&gt;filter_table, &amp;rlocator, HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't allow <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> prefetching of this block or higher until replayed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; filter-&gt;filter_until_replayed = lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; filter-&gt;filter_from_block = blockno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_push_head(&amp;prefetcher-&gt;filter_queue, &amp;filter-&gt;link);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We were already filtering this rlocator.&nbsp; Extend the filter's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lifetime to cover this WAL record, but leave the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> of the block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * numbers there because we don't want to have to track individual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * blocks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; filter-&gt;filter_until_replayed = lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;filter-&gt;link);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_push_head(&amp;prefetcher-&gt;filter_queue, &amp;filter-&gt;link);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; filter-&gt;filter_from_block = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(filter-&gt;filter_from_block, blockno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Have we replayed <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> that caused us to begin filtering a block<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>?&nbsp; That means that relations should have been created, extended or<br/></li>
<li></span><span class="Comment"> * dropped as required, so we can stop filtering out accesses to a given<br/></li>
<li></span><span class="Comment"> * relfilenumber.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L896">&#x200c;</a></span><span class="linkable">XLogPrefetcherCompleteFilters</span>(<a href="#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> *prefetcher, XLogRecPtr replaying_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (unlikely(!dlist_is_empty(&amp;prefetcher-&gt;filter_queue)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/transam/xlogprefetcher.c:160">XLogPrefetcherFilter</a> *filter = dlist_tail_element(<a href="#L160" title="access/transam/xlogprefetcher.c:160">XLogPrefetcherFilter</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; link,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;prefetcher-&gt;filter_queue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (filter-&gt;filter_until_replayed &gt;= replaying_lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;filter-&gt;link);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(prefetcher-&gt;filter_table, filter, HASH_REMOVE, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if a given block should be skipped due to a filter.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L916">&#x200c;</a></span><span class="linkable">XLogPrefetcherIsFiltered</span>(<a href="#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> *prefetcher, RelFileLocator rlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber blockno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Test for empty queue first, because we expect it to be empty most of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the time and we can avoid the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table lookup in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(!dlist_is_empty(&amp;prefetcher-&gt;filter_queue)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/transam/xlogprefetcher.c:160">XLogPrefetcherFilter</a> *filter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if the block <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is filtered. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; filter = <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(prefetcher-&gt;filter_table, &amp;rlocator, HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (filter &amp;&amp; filter-&gt;filter_from_block &lt;= blockno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef XLOGPREFETCHER_DEBUG_LEVEL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(XLOGPREFETCHER_DEBUG_LEVEL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;prefetch of </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant"> block </span><span class="Special">%u</span><span class="Constant"> suppressed; filtering until LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> is replayed (blocks &gt;= </span><span class="Special">%u</span><span class="Constant"> filtered)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rlocator.spcOid, rlocator.dbOid, rlocator.relNumber, blockno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(filter-&gt;filter_until_replayed),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; filter-&gt;filter_from_block);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if the whole database is filtered. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rlocator.relNumber = InvalidRelFileNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rlocator.spcOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; filter = <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(prefetcher-&gt;filter_table, &amp;rlocator, HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (filter)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef XLOGPREFETCHER_DEBUG_LEVEL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(XLOGPREFETCHER_DEBUG_LEVEL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;prefetch of </span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant">/</span><span class="Special">%u</span><span class="Constant"> block </span><span class="Special">%u</span><span class="Constant"> suppressed; filtering until LSN </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> is replayed (whole database)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rlocator.spcOid, rlocator.dbOid, rlocator.relNumber, blockno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(filter-&gt;filter_until_replayed));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A wrapper for <a href="xlogreader.c.html#L231" title="access/transam/xlogreader.c:231">XLogBeginRead</a>() that also resets the prefetcher.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L964">&#x200c;</a></span><span class="linkable">XLogPrefetcherBeginRead</span>(<a href="#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> *prefetcher, XLogRecPtr recPtr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This will forget about <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> in-flight IO. */<br/></li>
<li></span>&nbsp; &nbsp; prefetcher-&gt;reconfigure_count--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Book-keeping to avoid readahead on first read. */<br/></li>
<li></span>&nbsp; &nbsp; prefetcher-&gt;begin_ptr = recPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; prefetcher-&gt;no_readahead_until = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This will forget about <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> queued up <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> in the decoder. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="xlogreader.c.html#L231" title="access/transam/xlogreader.c:231">XLogBeginRead</a>(prefetcher-&gt;reader, recPtr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A wrapper for <a href="xlogreader.c.html#L389" title="access/transam/xlogreader.c:389">XLogReadRecord</a>() that provides the same interface, but also<br/></li>
<li></span><span class="Comment"> * tries to initiate I/O for blocks referenced in future WAL <a href="twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecord *<br/></li>
<li><a id="L983">&#x200c;</a><span class="linkable">XLogPrefetcherReadRecord</span>(<a href="#L124" title="access/transam/xlogprefetcher.c:124">XLogPrefetcher</a> *prefetcher, <span class="Type">char</span> **<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DecodedXLogRecord *record;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; replayed_up_to;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if it's time to reset the prefetching machinery, because a relevant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * GUC was changed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(<a href="#L78" title="access/transam/xlogprefetcher.c:78">XLogPrefetchReconfigureCount</a> != prefetcher-&gt;reconfigure_count))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; max_distance;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; max_inflight;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prefetcher-&gt;streaming_read)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L227" title="access/transam/xlogprefetcher.c:227">lrq_free</a>(prefetcher-&gt;streaming_read);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L71" title="access/transam/xlogprefetcher.c:71">RecoveryPrefetchEnabled</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../storage/buffer/bufmgr.c.html#L157" title="storage/buffer/bufmgr.c:157">maintenance_io_concurrency</a> &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_inflight = <a href="../../storage/buffer/bufmgr.c.html#L157" title="storage/buffer/bufmgr.c:157">maintenance_io_concurrency</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_distance = max_inflight * <a href="#L62" title="access/transam/xlogprefetcher.c:62">XLOGPREFETCHER_DISTANCE_MULTIPLIER</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_inflight = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_distance = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prefetcher-&gt;streaming_read = <a href="#L202" title="access/transam/xlogprefetcher.c:202">lrq_alloc</a>(max_distance,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; max_inflight,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">uintptr_t</span>) prefetcher,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L461" title="access/transam/xlogprefetcher.c:461">XLogPrefetcherNextBlock</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prefetcher-&gt;reconfigure_count = <a href="#L78" title="access/transam/xlogprefetcher.c:78">XLogPrefetchReconfigureCount</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release last returned record, if there is one, as it's <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replayed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; replayed_up_to = <a href="xlogreader.c.html#L249" title="access/transam/xlogreader.c:249">XLogReleasePreviousRecord</a>(prefetcher-&gt;reader);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Can we drop <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> filters yet?&nbsp; If we were <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for a relation to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * created or extended, it is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> OK to access blocks in the covered<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L896" title="access/transam/xlogprefetcher.c:896">XLogPrefetcherCompleteFilters</a>(prefetcher, replayed_up_to);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All IO initiated by earlier WAL is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> completed.&nbsp; This might <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * further prefetching.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L272" title="access/transam/xlogprefetcher.c:272">lrq_complete_lsn</a>(prefetcher-&gt;streaming_read, replayed_up_to);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's nothing queued yet, then start prefetching to cause at least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one record to be queued.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogReaderHasQueuedRecordOrError(prefetcher-&gt;reader))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L233" title="access/transam/xlogprefetcher.c:233">lrq_inflight</a>(prefetcher-&gt;streaming_read) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L239" title="access/transam/xlogprefetcher.c:239">lrq_completed</a>(prefetcher-&gt;streaming_read) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L245" title="access/transam/xlogprefetcher.c:245">lrq_prefetch</a>(prefetcher-&gt;streaming_read);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Read the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> record. */<br/></li>
<li></span>&nbsp; &nbsp; record = <a href="xlogreader.c.html#L325" title="access/transam/xlogreader.c:325">XLogNextRecord</a>(prefetcher-&gt;reader, <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!record)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The record we just got is the &quot;current&quot; one, for the benefit of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLogRecXXX() macros.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(record == prefetcher-&gt;reader-&gt;record);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="../../storage/buffer/bufmgr.c.html#L157" title="storage/buffer/bufmgr.c:157">maintenance_io_concurrency</a> is set very low, we might have started<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prefetching some but not all of the blocks referenced in the record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're about to return.&nbsp; Forget about the rest of the blocks in this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record by dropping the prefetcher's reference to it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (record == prefetcher-&gt;record)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prefetcher-&gt;record = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if it's time to compute some statistics, because enough WAL has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been processed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(record-&gt;lsn &gt;= prefetcher-&gt;next_stats_shm_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L412" title="access/transam/xlogprefetcher.c:412">XLogPrefetcherComputeStats</a>(prefetcher);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(record == prefetcher-&gt;reader-&gt;record);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;record-&gt;header;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1083">&#x200c;</a></span><span class="linkable">check_recovery_prefetch</span>(<span class="Type">int</span> *new_value, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifndef USE_PREFETCH<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*new_value == RECOVERY_PREFETCH_ON)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;<a href="#L68" title="access/transam/xlogprefetcher.c:68">recovery_prefetch</a> is not supported on platforms that lack posix_fadvise().&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1097">&#x200c;</a></span><span class="linkable">assign_recovery_prefetch</span>(<span class="Type">int</span> new_value, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reconfigure prefetching, because a setting it depends on changed. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L68" title="access/transam/xlogprefetcher.c:68">recovery_prefetch</a> = new_value;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (AmStartupProcess())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L340" title="access/transam/xlogprefetcher.c:340">XLogPrefetchReconfigure</a>();<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
